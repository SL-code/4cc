# 0 "4coder_fleury.cpp"
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_ls//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "4coder_fleury.cpp"
# 394 "4coder_fleury.cpp"
# 1 "/usr/include/c++/12.2.1/stdlib.h" 1 3
# 36 "/usr/include/c++/12.2.1/stdlib.h" 3
# 1 "/usr/include/c++/12.2.1/cstdlib" 1 3
# 39 "/usr/include/c++/12.2.1/cstdlib" 3
       
# 40 "/usr/include/c++/12.2.1/cstdlib" 3

# 1 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 296 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 296 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__));
    terminate();
  }
#pragma GCC visibility pop
}
# 329 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
#pragma GCC visibility pop
}
# 655 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 393 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 394 "/usr/include/features.h" 2 3 4
# 491 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 559 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 560 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 561 "/usr/include/sys/cdefs.h" 2 3 4
# 492 "/usr/include/features.h" 2 3 4
# 515 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 516 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 656 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 659 "/usr/include/c++/12.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 42 "/usr/include/c++/12.2.1/cstdlib" 2 3
# 75 "/usr/include/c++/12.2.1/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 56 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/floatn.h" 1 3 4
# 74 "/usr/include/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 86 "/usr/include/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 57 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 273 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 274 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 142 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/time64.h" 1 3 4
# 143 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 30 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 35 "/usr/include/bits/endian.h" 3 4
# 1 "/usr/include/bits/endianness.h" 1 3 4
# 36 "/usr/include/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/sys/types.h" 2 3 4


}
# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     noexcept (true) ;


extern void arc4random_buf (void *__buf, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     noexcept (true) ;




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 588 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 630 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 695 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 708 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 718 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 730 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 740 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 751 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 772 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 782 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 794 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 804 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 821 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 893 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 980 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1036 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 1037 "/usr/include/stdlib.h" 2 3 4
# 1048 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/12.2.1/cstdlib" 2 3

# 1 "/usr/include/c++/12.2.1/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/12.2.1/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/12.2.1/bits/std_abs.h" 3
# 46 "/usr/include/c++/12.2.1/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/12.2.1/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/usr/include/c++/12.2.1/bits/std_abs.h" 3

}
}
# 78 "/usr/include/c++/12.2.1/cstdlib" 2 3
# 121 "/usr/include/c++/12.2.1/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/12.2.1/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/12.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/12.2.1/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 395 "4coder_fleury.cpp" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 434 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf")

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 605 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 909 "/usr/include/stdio.h" 3 4
}
# 396 "4coder_fleury.cpp" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/string.h" 3 4
}
# 397 "4coder_fleury.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp"
# 1 "/usr/include/c++/12.2.1/stdlib.h" 1 3
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h" 1
# 199 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdint.h" 2 3 4
# 200 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h" 2


# 201 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h"
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;


typedef i8 b8;
typedef i32 b32;
typedef i64 b64;

typedef float f32;
typedef double f64;

typedef void Void_Func(void);

typedef i32 Generated_Group;
enum{
  GeneratedGroup_Core,
  GeneratedGroup_Custom
};
# 334 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h"
static const u8 max_u8 = 0xFF;
static const u16 max_u16 = 0xFFFF;
static const u32 max_u32 = 0xFFFFFFFF;
static const u64 max_u64 = 0xFFFFFFFFFFFFFFFF;

static const i8 max_i8 = 127;
static const i16 max_i16 = 32767;
static const i32 max_i32 = 2147483647;
static const i64 max_i64 = 9223372036854775807;

static const i8 min_i8 = -127 - 1;
static const i16 min_i16 = -32767 - 1;
static const i32 min_i32 = -2147483647 - 1;
static const i64 min_i64 = -9223372036854775807 - 1;

static const f32 max_f32 = 3.402823466e+38f;
static const f32 min_f32 = -max_f32;
static const f32 smallest_positive_f32 = 1.1754943508e-38f;
static const f32 epsilon_f32 = 5.96046448e-8f;

static const f32 pi_f32 = 3.14159265359f;
static const f32 half_pi_f32 = 1.5707963267f;

static const f64 max_f64 = 1.79769313486231e+308;
static const f64 min_f64 = -max_f64;
static const f64 smallest_positive_f64 = 4.94065645841247e-324;
static const f64 epsilon_f64 = 1.11022302462515650e-16;
# 386 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h"
static const u32 bit_1 = 0x00000001;
static const u32 bit_2 = 0x00000002;
static const u32 bit_3 = 0x00000004;
static const u32 bit_4 = 0x00000008;
static const u32 bit_5 = 0x00000010;
static const u32 bit_6 = 0x00000020;
static const u32 bit_7 = 0x00000040;
static const u32 bit_8 = 0x00000080;
static const u32 bit_9 = 0x00000100;
static const u32 bit_10 = 0x00000200;
static const u32 bit_11 = 0x00000400;
static const u32 bit_12 = 0x00000800;
static const u32 bit_13 = 0x00001000;
static const u32 bit_14 = 0x00002000;
static const u32 bit_15 = 0x00004000;
static const u32 bit_16 = 0x00008000;
static const u32 bit_17 = 0x00010000;
static const u32 bit_18 = 0x00020000;
static const u32 bit_19 = 0x00040000;
static const u32 bit_20 = 0x00080000;
static const u32 bit_21 = 0x00100000;
static const u32 bit_22 = 0x00200000;
static const u32 bit_23 = 0x00400000;
static const u32 bit_24 = 0x00800000;
static const u32 bit_25 = 0x01000000;
static const u32 bit_26 = 0x02000000;
static const u32 bit_27 = 0x04000000;
static const u32 bit_28 = 0x08000000;
static const u32 bit_29 = 0x10000000;
static const u32 bit_30 = 0x20000000;
static const u32 bit_31 = 0x40000000;
static const u32 bit_32 = 0x80000000;

static const u64 bit_33 = 0x0000000100000000;
static const u64 bit_34 = 0x0000000200000000;
static const u64 bit_35 = 0x0000000400000000;
static const u64 bit_36 = 0x0000000800000000;
static const u64 bit_37 = 0x0000001000000000;
static const u64 bit_38 = 0x0000002000000000;
static const u64 bit_39 = 0x0000004000000000;
static const u64 bit_40 = 0x0000008000000000;
static const u64 bit_41 = 0x0000010000000000;
static const u64 bit_42 = 0x0000020000000000;
static const u64 bit_43 = 0x0000040000000000;
static const u64 bit_44 = 0x0000080000000000;
static const u64 bit_45 = 0x0000100000000000;
static const u64 bit_46 = 0x0000200000000000;
static const u64 bit_47 = 0x0000400000000000;
static const u64 bit_48 = 0x0000800000000000;
static const u64 bit_49 = 0x0001000000000000;
static const u64 bit_50 = 0x0002000000000000;
static const u64 bit_51 = 0x0004000000000000;
static const u64 bit_52 = 0x0008000000000000;
static const u64 bit_53 = 0x0010000000000000;
static const u64 bit_54 = 0x0020000000000000;
static const u64 bit_55 = 0x0040000000000000;
static const u64 bit_56 = 0x0080000000000000;
static const u64 bit_57 = 0x0100000000000000;
static const u64 bit_58 = 0x0200000000000000;
static const u64 bit_59 = 0x0400000000000000;
static const u64 bit_60 = 0x0800000000000000;
static const u64 bit_61 = 0x1000000000000000;
static const u64 bit_62 = 0x2000000000000000;
static const u64 bit_63 = 0x4000000000000000;
static const u64 bit_64 = 0x8000000000000000;

static const u32 bitmask_1 = 0x00000001;
static const u32 bitmask_2 = 0x00000003;
static const u32 bitmask_3 = 0x00000007;
static const u32 bitmask_4 = 0x0000000f;
static const u32 bitmask_5 = 0x0000001f;
static const u32 bitmask_6 = 0x0000003f;
static const u32 bitmask_7 = 0x0000007f;
static const u32 bitmask_8 = 0x000000ff;
static const u32 bitmask_9 = 0x000001ff;
static const u32 bitmask_10 = 0x000003ff;
static const u32 bitmask_11 = 0x000007ff;
static const u32 bitmask_12 = 0x00000fff;
static const u32 bitmask_13 = 0x00001fff;
static const u32 bitmask_14 = 0x00003fff;
static const u32 bitmask_15 = 0x00007fff;
static const u32 bitmask_16 = 0x0000ffff;
static const u32 bitmask_17 = 0x0001ffff;
static const u32 bitmask_18 = 0x0003ffff;
static const u32 bitmask_19 = 0x0007ffff;
static const u32 bitmask_20 = 0x000fffff;
static const u32 bitmask_21 = 0x001fffff;
static const u32 bitmask_22 = 0x003fffff;
static const u32 bitmask_23 = 0x007fffff;
static const u32 bitmask_24 = 0x00ffffff;
static const u32 bitmask_25 = 0x01ffffff;
static const u32 bitmask_26 = 0x03ffffff;
static const u32 bitmask_27 = 0x07ffffff;
static const u32 bitmask_28 = 0x0fffffff;
static const u32 bitmask_29 = 0x1fffffff;
static const u32 bitmask_30 = 0x3fffffff;
static const u32 bitmask_31 = 0x7fffffff;

static const u64 bitmask_32 = 0x00000000ffffffff;
static const u64 bitmask_33 = 0x00000001ffffffff;
static const u64 bitmask_34 = 0x00000003ffffffff;
static const u64 bitmask_35 = 0x00000007ffffffff;
static const u64 bitmask_36 = 0x0000000fffffffff;
static const u64 bitmask_37 = 0x0000001fffffffff;
static const u64 bitmask_38 = 0x0000003fffffffff;
static const u64 bitmask_39 = 0x0000007fffffffff;
static const u64 bitmask_40 = 0x000000ffffffffff;
static const u64 bitmask_41 = 0x000001ffffffffff;
static const u64 bitmask_42 = 0x000003ffffffffff;
static const u64 bitmask_43 = 0x000007ffffffffff;
static const u64 bitmask_44 = 0x00000fffffffffff;
static const u64 bitmask_45 = 0x00001fffffffffff;
static const u64 bitmask_46 = 0x00003fffffffffff;
static const u64 bitmask_47 = 0x00007fffffffffff;
static const u64 bitmask_48 = 0x0000ffffffffffff;
static const u64 bitmask_49 = 0x0001ffffffffffff;
static const u64 bitmask_50 = 0x0003ffffffffffff;
static const u64 bitmask_51 = 0x0007ffffffffffff;
static const u64 bitmask_52 = 0x000fffffffffffff;
static const u64 bitmask_53 = 0x001fffffffffffff;
static const u64 bitmask_54 = 0x003fffffffffffff;
static const u64 bitmask_55 = 0x007fffffffffffff;
static const u64 bitmask_56 = 0x00ffffffffffffff;
static const u64 bitmask_57 = 0x01ffffffffffffff;
static const u64 bitmask_58 = 0x03ffffffffffffff;
static const u64 bitmask_59 = 0x07ffffffffffffff;
static const u64 bitmask_60 = 0x0fffffffffffffff;
static const u64 bitmask_61 = 0x1fffffffffffffff;
static const u64 bitmask_62 = 0x3fffffffffffffff;
static const u64 bitmask_63 = 0x7fffffffffffffff;



struct Node{
  Node *next;
  Node *prev;
};
union SNode{
  SNode *next;
  SNode *prev;
};
# 578 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.h"
union Vec2_i8{
  struct{
    i8 x;
    i8 y;
  };
  i8 v[2];
};
union Vec3_i8{
  struct{
    i8 x;
    i8 y;
    i8 z;
  };
  struct{
    i8 r;
    i8 g;
    i8 b;
  };
  i8 v[3];
};
union Vec4_i8{
  struct{
    i8 x;
    i8 y;
    i8 z;
    i8 w;
  };
  struct{
    i8 r;
    i8 g;
    i8 b;
    i8 a;
  };
  i8 v[4];
};
union Vec2_i16{
  struct{
    i16 x;
    i16 y;
  };
  i16 v[2];
};
union Vec3_i16{
  struct{
    i16 x;
    i16 y;
    i16 z;
  };
  struct{
    i16 r;
    i16 g;
    i16 b;
  };
  i16 v[3];
};
union Vec4_i16{
  struct{
    i16 x;
    i16 y;
    i16 z;
    i16 w;
  };
  struct{
    i16 r;
    i16 g;
    i16 b;
    i16 a;
  };
  i16 v[4];
};
union Vec2_i32{
  struct{
    i32 x;
    i32 y;
  };
  i32 v[2];
};
union Vec3_i32{
  struct{
    i32 x;
    i32 y;
    i32 z;
  };
  struct{
    i32 r;
    i32 g;
    i32 b;
  };
  i32 v[3];
};
union Vec4_i32{
  struct{
    i32 x;
    i32 y;
    i32 z;
    i32 w;
  };
  struct{
    i32 r;
    i32 g;
    i32 b;
    i32 a;
  };
  i32 v[4];
};
union Vec2_f32{
  struct{
    f32 x;
    f32 y;
  };
  f32 v[2];
};
union Vec3_f32{
  struct{
    f32 x;
    f32 y;
    f32 z;
  };
  struct{
    f32 r;
    f32 g;
    f32 b;
  };
  f32 v[3];
};
union Vec4_f32{
  struct{
    f32 x;
    f32 y;
    f32 z;
    f32 w;
  };
  struct{
    f32 r;
    f32 g;
    f32 b;
    f32 a;
  };
  struct{
    f32 h;
    f32 s;
    f32 l;
    f32 __a;
  };
  f32 v[4];
};

union Range_i32{
  struct{
    i32 min;
    i32 max;
  };
  struct{
    i32 start;
    i32 end;
  };
  struct{
    i32 first;
    i32 one_past_last;
  };
};
union Range_i64{
  struct{
    i64 min;
    i64 max;
  };
  struct{
    i64 start;
    i64 end;
  };
  struct{
    i64 first;
    i64 one_past_last;
  };
};
union Range_u64{
  struct{
    u64 min;
    u64 max;
  };
  struct{
    u64 start;
    u64 end;
  };
  struct{
    u64 first;
    u64 one_past_last;
  };
};
union Range_f32{
  struct{
    f32 min;
    f32 max;
  };
  struct{
    f32 start;
    f32 end;
  };
  struct{
    f32 first;
    f32 one_past_last;
  };
};

struct Range_i32_Array{
  Range_i32 *ranges;
  i32 count;
};
struct Range_i64_Array{
  Range_i64 *ranges;
  i32 count;
};
struct Range_u64_Array{
  Range_u64 *ranges;
  i32 count;
};
struct Range_f32_Array{
  Range_f32 *ranges;
  i32 count;
};

union Rect_i32{
  struct{
    i32 x0;
    i32 y0;
    i32 x1;
    i32 y1;
  };
  struct{
    Vec2_i32 p0;
    Vec2_i32 p1;
  };
  Vec2_i32 p[2];
};
union Rect_f32{
  struct{
    f32 x0;
    f32 y0;
    f32 x1;
    f32 y1;
  };
  struct{
    Vec2_f32 p0;
    Vec2_f32 p1;
  };
  Vec2_f32 p[2];
};

union Rect_f32_Pair{
  struct{
    Rect_f32 a;
    Rect_f32 b;
  };
  struct{
    Rect_f32 min;
    Rect_f32 max;
  };
  struct{
    Rect_f32 e[2];
  };
};

typedef u32 ARGB_Color;



struct i8_Array{
  i8 *vals;
  i32 count;
};
struct i16_Array{
  i16 *vals;
  i32 count;
};
struct i32_Array{
  i32 *vals;
  i32 count;
};
struct i64_Array{
  i64 *vals;
  i32 count;
};

struct u8_Array{
  u8 *vals;
  i32 count;
};
struct u16_Array{
  u16 *vals;
  i32 count;
};
struct u32_Array{
  u32 *vals;
  i32 count;
};
struct u64_Array{
  u64 *vals;
  i32 count;
};



typedef i32 String_Fill_Terminate_Rule;
enum{
  StringFill_NoTerminate = 0,
  StringFill_NullTerminate = 1,
};
typedef u32 String_Separator_Flag;
enum{
  StringSeparator_NoFlags = 0,
};
enum{
  StringSeparator_BeforeFirst = 1,
  StringSeparator_AfterLast = 2,
};
typedef i32 String_Match_Rule;
enum{
  StringMatch_Exact = 0,
  StringMatch_CaseInsensitive = 1,
};

struct String_Const_char{
  char *str;
  u64 size;
};
struct String_Const_u8{
  u8 *str;
  u64 size;
};
struct String_Const_u16{
  u16 *str;
  u64 size;
};
struct String_Const_u32{
  u32 *str;
  u64 size;
};

typedef String_Const_u8 String8;

struct String_Const_char_Array{
  union{
    String_Const_char *strings;
    String_Const_char *vals;
  };
  i32 count;
};
struct String_Const_u8_Array{
  union{
    String_Const_u8 *strings;
    String_Const_u8 *vals;
  };
  i32 count;
};
struct String_Const_u16_Array{
  union{
    String_Const_u16 *strings;
    String_Const_u16 *vals;
  };
  i32 count;
};
struct String_Const_u32_Array{
  union{
    String_Const_u32 *strings;
    String_Const_u32 *vals;
  };
  i32 count;
};

typedef String_Const_u8_Array String8Array;

typedef i32 String_Encoding;
enum{
  StringEncoding_ASCII = 0,
  StringEncoding_UTF8 = 1,
  StringEncoding_UTF16 = 2,
  StringEncoding_UTF32 = 3,
};

struct String_Const_Any{
  String_Encoding encoding;
  union{
    struct{
      void *str;
      u64 size;
    };
    String_Const_char s_char;
    String_Const_u8 s_u8;
    String_Const_u16 s_u16;
    String_Const_u32 s_u32;
  };
};





struct Node_String_Const_char{
  Node_String_Const_char *next;
  String_Const_char string;
};
struct Node_String_Const_u8{
  Node_String_Const_u8 *next;
  String_Const_u8 string;
};
struct Node_String_Const_u16{
  Node_String_Const_u16 *next;
  String_Const_u16 string;
};
struct Node_String_Const_u32{
  Node_String_Const_u32 *next;
  String_Const_u32 string;
};
struct List_String_Const_char{
  Node_String_Const_char *first;
  Node_String_Const_char *last;
  u64 total_size;
  i32 node_count;
};
struct List_String_Const_u8{
  Node_String_Const_u8 *first;
  Node_String_Const_u8 *last;
  u64 total_size;
  i32 node_count;
};
struct List_String_Const_u16{
  Node_String_Const_u16 *first;
  Node_String_Const_u16 *last;
  u64 total_size;
  i32 node_count;
};
struct List_String_Const_u32{
  Node_String_Const_u32 *first;
  Node_String_Const_u32 *last;
  u64 total_size;
  i32 node_count;
};

typedef Node_String_Const_u8 String8Node;
typedef List_String_Const_u8 String8List;

struct Node_String_Const_Any{
  Node_String_Const_Any *next;
  String_Const_Any string;
};
struct List_String_Const_Any{
  Node_String_Const_Any *first;
  Node_String_Const_Any *last;
  u64 total_size;
  i32 node_count;
};

struct String_char{
  union{
    String_Const_char string;
    struct{
      char *str;
      u64 size;
    };
  };
  u64 cap;
};
struct String_u8{
  union{
    String_Const_u8 string;
    struct{
      u8 *str;
      u64 size;
    };
  };
  u64 cap;
};
struct String_u16{
  union{
    String_Const_u16 string;
    struct{
      u16 *str;
      u64 size;
    };
  };
  u64 cap;
};
struct String_u32{
  union{
    String_Const_u32 string;
    struct{
      u32 *str;
      u64 size;
    };
  };
  u64 cap;
};

struct String_Any{
  String_Encoding encoding;
  union{
    struct{
      void *str;
      u64 size;
      u64 cap;
    };
    String_char s_char;
    String_u8 s_u8;
    String_u16 s_u16;
    String_u32 s_u32;
  };
};

typedef i32 Line_Ending_Kind;
enum{
  LineEndingKind_Binary,
  LineEndingKind_LF,
  LineEndingKind_CRLF,
};

struct Character_Consume_Result{
  u32 inc;
  u32 codepoint;
};

static u32 surrogate_min = 0xD800;
static u32 surrogate_max = 0xDFFF;

static u32 nonchar_min = 0xFDD0;
static u32 nonchar_max = 0xFDEF;



typedef u32 Access_Flag;
enum{
  AccessFlag_Read = 1,
  AccessFlag_Write = 2,
  AccessFlag_Exec = 4,
};

typedef i32 Dimension;
enum{
  Dimension_X = 0,
  Dimension_Y = 1,
  Dimension_Z = 2,
  Dimension_W = 3,
};

typedef i32 Coordinate;
enum{
  Coordinate_X = 0,
  Coordinate_Y = 1,
  Coordinate_Z = 2,
  Coordinate_W = 3,
};

typedef i32 Side;
enum{
  Side_Min = 0,
  Side_Max = 1,
};

typedef i32 Scan_Direction;
enum{
  Scan_Backward = -1,
  Scan_Forward = 1,
};



struct Date_Time{
  u32 year;
  u8 mon;
  u8 day;
  u8 hour;
  u8 min;
  u8 sec;
  u16 msec;
};

static String_Const_u8 month_full_name[] = {
  {(u8*)("January"), sizeof("January") - 1},
  {(u8*)("February"), sizeof("February") - 1},
  {(u8*)("March"), sizeof("March") - 1},
  {(u8*)("April"), sizeof("April") - 1},
  {(u8*)("May"), sizeof("May") - 1},
  {(u8*)("June"), sizeof("June") - 1},
  {(u8*)("July"), sizeof("July") - 1},
  {(u8*)("August"), sizeof("August") - 1},
  {(u8*)("September"), sizeof("September") - 1},
  {(u8*)("October"), sizeof("October") - 1},
  {(u8*)("November"), sizeof("November") - 1},
  {(u8*)("December"), sizeof("December") - 1},
};

static String_Const_u8 month_abrev_name[] = {
  {(u8*)("Jan"), sizeof("Jan") - 1},
  {(u8*)("Feb"), sizeof("Feb") - 1},
  {(u8*)("Mar"), sizeof("Mar") - 1},
  {(u8*)("Apr"), sizeof("Apr") - 1},
  {(u8*)("May"), sizeof("May") - 1},
  {(u8*)("Jun"), sizeof("Jun") - 1},
  {(u8*)("Jul"), sizeof("Jul") - 1},
  {(u8*)("Aug"), sizeof("Aug") - 1},
  {(u8*)("Sep"), sizeof("Sep") - 1},
  {(u8*)("Oct"), sizeof("Oct") - 1},
  {(u8*)("Nov"), sizeof("Nov") - 1},
  {(u8*)("Dec"), sizeof("Dec") - 1},
};

static String_Const_u8 ordinal_numeric_name[] = {
  {(u8*)("1st"), sizeof("1st") - 1},
  {(u8*)("2nd"), sizeof("2nd") - 1},
  {(u8*)("3rd"), sizeof("3rd") - 1},
  {(u8*)("4th"), sizeof("4th") - 1},
  {(u8*)("5th"), sizeof("5th") - 1},
  {(u8*)("6th"), sizeof("6th") - 1},
  {(u8*)("7th"), sizeof("7th") - 1},
  {(u8*)("8th"), sizeof("8th") - 1},
  {(u8*)("9th"), sizeof("9th") - 1},
  {(u8*)("10th"), sizeof("10th") - 1},
  {(u8*)("11th"), sizeof("11th") - 1},
  {(u8*)("12th"), sizeof("12th") - 1},
  {(u8*)("13th"), sizeof("13th") - 1},
  {(u8*)("14th"), sizeof("14th") - 1},
  {(u8*)("15th"), sizeof("15th") - 1},
  {(u8*)("16th"), sizeof("16th") - 1},
  {(u8*)("17th"), sizeof("17th") - 1},
  {(u8*)("18th"), sizeof("18th") - 1},
  {(u8*)("19th"), sizeof("19th") - 1},
  {(u8*)("20th"), sizeof("20th") - 1},
  {(u8*)("21st"), sizeof("21st") - 1},
  {(u8*)("22nd"), sizeof("22nd") - 1},
  {(u8*)("23rd"), sizeof("23rd") - 1},
  {(u8*)("24th"), sizeof("24th") - 1},
  {(u8*)("25th"), sizeof("25th") - 1},
  {(u8*)("26th"), sizeof("26th") - 1},
  {(u8*)("27th"), sizeof("27th") - 1},
  {(u8*)("28th"), sizeof("28th") - 1},
  {(u8*)("29th"), sizeof("29th") - 1},
  {(u8*)("30th"), sizeof("30th") - 1},
  {(u8*)("31st"), sizeof("31st") - 1},
  {(u8*)("32nd"), sizeof("32nd") - 1},
  {(u8*)("33rd"), sizeof("33rd") - 1},
  {(u8*)("34th"), sizeof("34th") - 1},
  {(u8*)("35th"), sizeof("35th") - 1},
  {(u8*)("36th"), sizeof("36th") - 1},
  {(u8*)("37th"), sizeof("37th") - 1},
  {(u8*)("38th"), sizeof("38th") - 1},
  {(u8*)("39th"), sizeof("39th") - 1},
  {(u8*)("40th"), sizeof("40th") - 1},
  {(u8*)("41st"), sizeof("41st") - 1},
  {(u8*)("42nd"), sizeof("42nd") - 1},
  {(u8*)("43rd"), sizeof("43rd") - 1},
  {(u8*)("44th"), sizeof("44th") - 1},
  {(u8*)("45th"), sizeof("45th") - 1},
  {(u8*)("46th"), sizeof("46th") - 1},
  {(u8*)("47th"), sizeof("47th") - 1},
  {(u8*)("48th"), sizeof("48th") - 1},
  {(u8*)("49th"), sizeof("49th") - 1},
  {(u8*)("50th"), sizeof("50th") - 1},
  {(u8*)("51st"), sizeof("51st") - 1},
  {(u8*)("52nd"), sizeof("52nd") - 1},
  {(u8*)("53rd"), sizeof("53rd") - 1},
  {(u8*)("54th"), sizeof("54th") - 1},
  {(u8*)("55th"), sizeof("55th") - 1},
  {(u8*)("56th"), sizeof("56th") - 1},
  {(u8*)("57th"), sizeof("57th") - 1},
  {(u8*)("58th"), sizeof("58th") - 1},
  {(u8*)("59th"), sizeof("59th") - 1},
  {(u8*)("60th"), sizeof("60th") - 1},
  {(u8*)("61st"), sizeof("61st") - 1},
  {(u8*)("62nd"), sizeof("62nd") - 1},
  {(u8*)("63rd"), sizeof("63rd") - 1},
  {(u8*)("64th"), sizeof("64th") - 1},
  {(u8*)("65th"), sizeof("65th") - 1},
  {(u8*)("66th"), sizeof("66th") - 1},
  {(u8*)("67th"), sizeof("67th") - 1},
  {(u8*)("68th"), sizeof("68th") - 1},
  {(u8*)("69th"), sizeof("69th") - 1},
  {(u8*)("70th"), sizeof("70th") - 1},
  {(u8*)("71st"), sizeof("71st") - 1},
  {(u8*)("72nd"), sizeof("72nd") - 1},
  {(u8*)("73rd"), sizeof("73rd") - 1},
  {(u8*)("74th"), sizeof("74th") - 1},
  {(u8*)("75th"), sizeof("75th") - 1},
  {(u8*)("76th"), sizeof("76th") - 1},
  {(u8*)("77th"), sizeof("77th") - 1},
  {(u8*)("78th"), sizeof("78th") - 1},
  {(u8*)("79th"), sizeof("79th") - 1},
  {(u8*)("80th"), sizeof("80th") - 1},
  {(u8*)("81st"), sizeof("81st") - 1},
  {(u8*)("82nd"), sizeof("82nd") - 1},
  {(u8*)("83rd"), sizeof("83rd") - 1},
  {(u8*)("84th"), sizeof("84th") - 1},
  {(u8*)("85th"), sizeof("85th") - 1},
  {(u8*)("86th"), sizeof("86th") - 1},
  {(u8*)("87th"), sizeof("87th") - 1},
  {(u8*)("88th"), sizeof("88th") - 1},
  {(u8*)("89th"), sizeof("89th") - 1},
  {(u8*)("90th"), sizeof("90th") - 1},
  {(u8*)("91st"), sizeof("91st") - 1},
  {(u8*)("92nd"), sizeof("92nd") - 1},
  {(u8*)("93rd"), sizeof("93rd") - 1},
  {(u8*)("94th"), sizeof("94th") - 1},
  {(u8*)("95th"), sizeof("95th") - 1},
  {(u8*)("96th"), sizeof("96th") - 1},
  {(u8*)("97th"), sizeof("97th") - 1},
  {(u8*)("98th"), sizeof("98th") - 1},
  {(u8*)("99th"), sizeof("99th") - 1},
  {(u8*)("100th"), sizeof("100th") - 1},
};



typedef void *Base_Allocator_Reserve_Signature(void *user_data, u64 size, u64 *size_out, String_Const_u8 location);
typedef void Base_Allocator_Commit_Signature(void *user_data, void *ptr, u64 size);
typedef void Base_Allocator_Uncommit_Signature(void *user_data, void *ptr, u64 size);
typedef void Base_Allocator_Free_Signature(void *user_data, void *ptr);
typedef void Base_Allocator_Set_Access_Signature(void *user_data, void *ptr, u64 size, Access_Flag flags);
struct Base_Allocator{
  Base_Allocator_Reserve_Signature *reserve;
  Base_Allocator_Commit_Signature *commit;
  Base_Allocator_Uncommit_Signature *uncommit;
  Base_Allocator_Free_Signature *free;
  Base_Allocator_Set_Access_Signature *set_access;
  void *user_data;
};

struct Cursor{
  u8 *base;
  u64 pos;
  u64 cap;
};
struct Temp_Memory_Cursor{
  Cursor *cursor;
  u64 pos;
};
struct Cursor_Node{
  union{
    Cursor_Node *next;
    Cursor_Node *prev;
  };
  Cursor cursor;
};
struct Arena{
  Base_Allocator *base_allocator;
  Cursor_Node *cursor_node;
  u64 chunk_size;
  u64 alignment;
};
struct Temp_Memory_Arena{
  Arena *arena;
  Cursor_Node *cursor_node;
  u64 pos;
};
typedef i32 Linear_Allocator_Kind;
enum{
  LinearAllocatorKind_Cursor,
  LinearAllocatorKind_Arena,
};
struct Temp_Memory{
  Linear_Allocator_Kind kind;
  union{
    Temp_Memory_Cursor temp_memory_cursor;
    Temp_Memory_Arena temp_memory_arena;
  };
};



typedef u64 Profile_ID;
struct Profile_Record{
  Profile_Record *next;
  Profile_ID id;
  u64 time;
  String_Const_u8 location;
  String_Const_u8 name;
};

struct Profile_Thread{
  Profile_Thread *next;
  Profile_Record *first_record;
  Profile_Record *last_record;
  i32 record_count;
  i32 thread_id;
  String_Const_u8 name;
};

typedef u32 Profile_Enable_Flag;
enum{
  ProfileEnable_UserBit = 0x1,
  ProfileEnable_InspectBit = 0x2,
};


struct Profile_Global_List;



typedef i32 Thread_Kind;
enum{
  ThreadKind_Main,
  ThreadKind_MainCoroutine,
  ThreadKind_AsyncTasks,
};

struct Arena_Node{
  Arena_Node *next;
  Arena_Node *prev;
  Arena arena;
  i32 ref_counter;
};

struct Thread_Context{
  Thread_Kind kind;
  Base_Allocator *allocator;
  Arena node_arena;
  Arena_Node *used_first;
  Arena_Node *used_last;
  Arena_Node *free_arenas;

  Base_Allocator *prof_allocator;
  Profile_ID prof_id_counter;
  Arena prof_arena;
  Profile_Record *prof_first;
  Profile_Record *prof_last;
  i32 prof_record_count;

  void *user_data;
};

struct Scratch_Block{
  Thread_Context *tctx;
  Arena *arena;
  Temp_Memory temp;

  Scratch_Block(struct Thread_Context *tctx);
  Scratch_Block(struct Thread_Context *tctx, Arena *a1);
  Scratch_Block(struct Thread_Context *tctx, Arena *a1, Arena *a2);
  Scratch_Block(struct Thread_Context *tctx, Arena *a1, Arena *a2, Arena *a3);
  Scratch_Block(struct Application_Links *app);
  Scratch_Block(struct Application_Links *app, Arena *a1);
  Scratch_Block(struct Application_Links *app, Arena *a1, Arena *a2);
  Scratch_Block(struct Application_Links *app, Arena *a1, Arena *a2, Arena *a3);
  ~Scratch_Block();
  operator Arena*();
  void restore(void);
};

struct Temp_Memory_Block{
  Temp_Memory temp;
  Temp_Memory_Block(Temp_Memory temp);
  Temp_Memory_Block(Arena *arena);
  ~Temp_Memory_Block();
  void restore(void);
};



struct Heap_Basic_Node{
  Heap_Basic_Node *next;
  Heap_Basic_Node *prev;
};

struct Heap_Node{
  union{
    struct{
      Heap_Basic_Node order;
      Heap_Basic_Node alloc;
      u64 size;
    };
    u8 force_size__[64];
  };
};

struct Heap{
  Arena arena_;
  Arena *arena;
  Heap_Basic_Node in_order;
  Heap_Basic_Node free_nodes;
  u64 used_space;
  u64 total_space;
};
# 18 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_version.h" 1
# 19 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_table.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_table.h"
struct Table_Lookup{
    u64 hash;
    u32 index;
    b8 found_match;
    b8 found_empty_slot;
    b8 found_erased_slot;
};

struct Table_u64_u64{
    Base_Allocator *allocator;
    void *memory;
    u64 *keys;
    u64 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_u32_u16{
    Base_Allocator *allocator;
    void *memory;
    u32 *keys;
    u16 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_Data_u64{
    Base_Allocator *allocator;
    void *memory;
    u64 *hashes;
    String_Const_u8 *keys;
    u64 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_u64_Data{
    Base_Allocator *allocator;
    void *memory;
    u64 *keys;
    String_Const_u8 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_Data_Data{
    Base_Allocator *allocator;
    void *memory;
    u64 *hashes;
    String_Const_u8 *keys;
    String_Const_u8 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};
# 20 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_events.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_events.h"
typedef void Custom_Command_Function(struct Application_Links *app);

typedef u32 Key_Code;
typedef u32 Mouse_Code;
typedef u32 Core_Code;
# 1 "/home/tabletel/dev/4cc/code/custom/generated/4coder_event_codes.h" 1
enum{
    KeyCode_A = 1,
    KeyCode_B = 2,
    KeyCode_C = 3,
    KeyCode_D = 4,
    KeyCode_E = 5,
    KeyCode_F = 6,
    KeyCode_G = 7,
    KeyCode_H = 8,
    KeyCode_I = 9,
    KeyCode_J = 10,
    KeyCode_K = 11,
    KeyCode_L = 12,
    KeyCode_M = 13,
    KeyCode_N = 14,
    KeyCode_O = 15,
    KeyCode_P = 16,
    KeyCode_Q = 17,
    KeyCode_R = 18,
    KeyCode_S = 19,
    KeyCode_T = 20,
    KeyCode_U = 21,
    KeyCode_V = 22,
    KeyCode_W = 23,
    KeyCode_X = 24,
    KeyCode_Y = 25,
    KeyCode_Z = 26,
    KeyCode_0 = 27,
    KeyCode_1 = 28,
    KeyCode_2 = 29,
    KeyCode_3 = 30,
    KeyCode_4 = 31,
    KeyCode_5 = 32,
    KeyCode_6 = 33,
    KeyCode_7 = 34,
    KeyCode_8 = 35,
    KeyCode_9 = 36,
    KeyCode_Space = 37,
    KeyCode_Tick = 38,
    KeyCode_Minus = 39,
    KeyCode_Equal = 40,
    KeyCode_LeftBracket = 41,
    KeyCode_RightBracket = 42,
    KeyCode_Semicolon = 43,
    KeyCode_Quote = 44,
    KeyCode_Comma = 45,
    KeyCode_Period = 46,
    KeyCode_ForwardSlash = 47,
    KeyCode_BackwardSlash = 48,
    KeyCode_Tab = 49,
    KeyCode_Escape = 50,
    KeyCode_Pause = 51,
    KeyCode_Up = 52,
    KeyCode_Down = 53,
    KeyCode_Left = 54,
    KeyCode_Right = 55,
    KeyCode_Backspace = 56,
    KeyCode_Return = 57,
    KeyCode_Delete = 58,
    KeyCode_Insert = 59,
    KeyCode_Home = 60,
    KeyCode_End = 61,
    KeyCode_PageUp = 62,
    KeyCode_PageDown = 63,
    KeyCode_CapsLock = 64,
    KeyCode_NumLock = 65,
    KeyCode_ScrollLock = 66,
    KeyCode_Menu = 67,
    KeyCode_Shift = 68,
    KeyCode_Control = 69,
    KeyCode_Alt = 70,
    KeyCode_Command = 71,
    KeyCode_F1 = 72,
    KeyCode_F2 = 73,
    KeyCode_F3 = 74,
    KeyCode_F4 = 75,
    KeyCode_F5 = 76,
    KeyCode_F6 = 77,
    KeyCode_F7 = 78,
    KeyCode_F8 = 79,
    KeyCode_F9 = 80,
    KeyCode_F10 = 81,
    KeyCode_F11 = 82,
    KeyCode_F12 = 83,
    KeyCode_F13 = 84,
    KeyCode_F14 = 85,
    KeyCode_F15 = 86,
    KeyCode_F16 = 87,
    KeyCode_F17 = 88,
    KeyCode_F18 = 89,
    KeyCode_F19 = 90,
    KeyCode_F20 = 91,
    KeyCode_F21 = 92,
    KeyCode_F22 = 93,
    KeyCode_F23 = 94,
    KeyCode_F24 = 95,
    KeyCode_NumPad0 = 96,
    KeyCode_NumPad1 = 97,
    KeyCode_NumPad2 = 98,
    KeyCode_NumPad3 = 99,
    KeyCode_NumPad4 = 100,
    KeyCode_NumPad5 = 101,
    KeyCode_NumPad6 = 102,
    KeyCode_NumPad7 = 103,
    KeyCode_NumPad8 = 104,
    KeyCode_NumPad9 = 105,
    KeyCode_NumPadStar = 106,
    KeyCode_NumPadPlus = 107,
    KeyCode_NumPadMinus = 108,
    KeyCode_NumPadDot = 109,
    KeyCode_NumPadSlash = 110,
    KeyCode_Ex0 = 111,
    KeyCode_Ex1 = 112,
    KeyCode_Ex2 = 113,
    KeyCode_Ex3 = 114,
    KeyCode_Ex4 = 115,
    KeyCode_Ex5 = 116,
    KeyCode_Ex6 = 117,
    KeyCode_Ex7 = 118,
    KeyCode_Ex8 = 119,
    KeyCode_Ex9 = 120,
    KeyCode_Ex10 = 121,
    KeyCode_Ex11 = 122,
    KeyCode_Ex12 = 123,
    KeyCode_Ex13 = 124,
    KeyCode_Ex14 = 125,
    KeyCode_Ex15 = 126,
    KeyCode_Ex16 = 127,
    KeyCode_Ex17 = 128,
    KeyCode_Ex18 = 129,
    KeyCode_Ex19 = 130,
    KeyCode_Ex20 = 131,
    KeyCode_Ex21 = 132,
    KeyCode_Ex22 = 133,
    KeyCode_Ex23 = 134,
    KeyCode_Ex24 = 135,
    KeyCode_Ex25 = 136,
    KeyCode_Ex26 = 137,
    KeyCode_Ex27 = 138,
    KeyCode_Ex28 = 139,
    KeyCode_Ex29 = 140,
    KeyCode_COUNT = 141,
};
static char* key_code_name[KeyCode_COUNT] = {
    "None",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "Space",
    "Tick",
    "Minus",
    "Equal",
    "LeftBracket",
    "RightBracket",
    "Semicolon",
    "Quote",
    "Comma",
    "Period",
    "ForwardSlash",
    "BackwardSlash",
    "Tab",
    "Escape",
    "Pause",
    "Up",
    "Down",
    "Left",
    "Right",
    "Backspace",
    "Return",
    "Delete",
    "Insert",
    "Home",
    "End",
    "PageUp",
    "PageDown",
    "CapsLock",
    "NumLock",
    "ScrollLock",
    "Menu",
    "Shift",
    "Control",
    "Alt",
    "Command",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "F13",
    "F14",
    "F15",
    "F16",
    "F17",
    "F18",
    "F19",
    "F20",
    "F21",
    "F22",
    "F23",
    "F24",
    "NumPad0",
    "NumPad1",
    "NumPad2",
    "NumPad3",
    "NumPad4",
    "NumPad5",
    "NumPad6",
    "NumPad7",
    "NumPad8",
    "NumPad9",
    "NumPadStar",
    "NumPadPlus",
    "NumPadMinus",
    "NumPadDot",
    "NumPadSlash",
    "Ex0",
    "Ex1",
    "Ex2",
    "Ex3",
    "Ex4",
    "Ex5",
    "Ex6",
    "Ex7",
    "Ex8",
    "Ex9",
    "Ex10",
    "Ex11",
    "Ex12",
    "Ex13",
    "Ex14",
    "Ex15",
    "Ex16",
    "Ex17",
    "Ex18",
    "Ex19",
    "Ex20",
    "Ex21",
    "Ex22",
    "Ex23",
    "Ex24",
    "Ex25",
    "Ex26",
    "Ex27",
    "Ex28",
    "Ex29",
};
enum{
    MouseCode_Left = 1,
    MouseCode_Middle = 2,
    MouseCode_Right = 3,
    MouseCode_COUNT = 4,
};
static char* mouse_code_name[MouseCode_COUNT] = {
    "None",
    "Left",
    "Middle",
    "Right",
};
enum{
    CoreCode_Startup = 1,
    CoreCode_Animate = 2,
    CoreCode_ClickActivateView = 3,
    CoreCode_ClickDeactivateView = 4,
    CoreCode_TryExit = 5,
    CoreCode_FileExternallyModified = 6,
    CoreCode_NewClipboardContents = 7,
    CoreCode_COUNT = 8,
};
static char* core_code_name[CoreCode_COUNT] = {
    "None",
    "Startup",
    "Animate",
    "ClickActivateView",
    "ClickDeactivateView",
    "TryExit",
    "FileExternallyModified",
    "NewClipboardContents",
};
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_events.h" 2

typedef u32 Input_Event_Kind;
enum{
    InputEventKind_None,
    InputEventKind_TextInsert,
    InputEventKind_KeyStroke,
    InputEventKind_KeyRelease,
    InputEventKind_MouseButton,
    InputEventKind_MouseButtonRelease,
    InputEventKind_MouseWheel,
    InputEventKind_MouseMove,
    InputEventKind_Core,
    InputEventKind_CustomFunction,

    InputEventKind_COUNT,
};

typedef u32 Key_Flags;
enum{
    KeyFlag_IsDeadKey = (1 << 0),
};

static const i32 Input_MaxModifierCount = 8;

struct Input_Modifier_Set{
    Key_Code *mods;
    i32 count;
};

struct Input_Modifier_Set_Fixed{
    Key_Code mods[Input_MaxModifierCount];
    i32 count;
};

struct Input_Event{
    Input_Event_Kind kind;
    b32 virtual_event;
    union{
        struct{
            String_Const_u8 string;


            Input_Event *next_text;
            b32 blocked;
        } text;
        struct{
            Key_Code code;
            Key_Flags flags;
            Input_Modifier_Set modifiers;


            Input_Event *first_dependent_text;
        } key;
        struct{
            Mouse_Code code;
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse;
        struct{
            f32 value;
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse_wheel;
        struct{
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse_move;
        struct{
            Core_Code code;
            union{
                String_Const_u8 string;
                i32 id;
                struct{
                    String_Const_u8_Array flag_strings;
                    String_Const_u8_Array file_names;
                };
            };
        } core;
        Custom_Command_Function *custom_func;
    };
};

struct Input_Event_Node{
    Input_Event_Node *next;
    Input_Event event;
};

struct Input_List{
    Input_Event_Node *first;
    Input_Event_Node *last;
    i32 count;
};

typedef u32 Event_Property;
enum{
    EventProperty_AnyKey = 0x0001,
    EventProperty_Escape = 0x0002,
    EventProperty_AnyKeyRelease = 0x0004,
    EventProperty_MouseButton = 0x0008,
    EventProperty_MouseRelease = 0x0010,
    EventProperty_MouseWheel = 0x0020,
    EventProperty_MouseMove = 0x0040,
    EventProperty_Animate = 0x0080,
    EventProperty_ViewActivation = 0x0100,
    EventProperty_TextInsert = 0x0200,
    EventProperty_AnyFile = 0x0400,
    EventProperty_Startup = 0x0800,
    EventProperty_Exit = 0x1000,
    EventProperty_Clipboard = 0x2000,
    EventProperty_CustomFunction = 0x4000,
};
enum{
    EventPropertyGroup_AnyKeyboardEvent =
        EventProperty_AnyKey|
        EventProperty_Escape|
        EventProperty_AnyKeyRelease|
        EventProperty_TextInsert,
    EventPropertyGroup_AnyMouseEvent =
        EventProperty_MouseButton|
        EventProperty_MouseRelease|
        EventProperty_MouseWheel|
        EventProperty_MouseMove,
    EventPropertyGroup_AnyUserInput =
        EventPropertyGroup_AnyKeyboardEvent|
        EventPropertyGroup_AnyMouseEvent,
    EventPropertyGroup_AnyCore =
        EventProperty_Animate|
        EventProperty_ViewActivation|
        EventProperty_AnyFile|
        EventProperty_Startup|
        EventProperty_Exit|
        EventProperty_Clipboard|
        EventProperty_Animate,
    EventPropertyGroup_Any =
        EventPropertyGroup_AnyUserInput|
        EventPropertyGroup_AnyCore|
        EventProperty_CustomFunction,
};
# 21 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_types.h" 1




struct Thread_Context_Extra_Info{
    void *coroutine;
    void *async_thread;
};

struct Application_Links{
    Thread_Context *tctx;
    void *cmd_context;
};

typedef void Custom_Layer_Init_Type(Application_Links *app);
void custom_layer_init(Application_Links *app);


typedef b32 _Get_Version_Type(i32 maj, i32 min, i32 patch);

typedef Custom_Layer_Init_Type *_Init_APIs_Type(struct API_VTable_custom *custom_vtable,
                                                struct API_VTable_system *system_vtable);




typedef u16 ID_Color;


union FColor{
    struct{
        u8 padding__[3];
        u8 a_byte;
    };
    ARGB_Color argb;
    struct{
        ID_Color id;
        u8 sub_index;
        u8 padding_;
    };
};


struct Theme_Color{
    ID_Color tag;
    ARGB_Color color;
};


struct Color_Array{
    ARGB_Color *vals;
    i32 count;
};


struct Color_Table{
    Color_Array *arrays;
    i32 count;
};


struct Color_Picker{
    String_Const_u8 title;
    ARGB_Color *dest;
    b32 *finished;
};




typedef u32 Face_ID;


struct Fancy_String{
    Fancy_String *next;
    String_Const_u8 value;
    Face_ID face;
    FColor fore;
    f32 pre_margin;
    f32 post_margin;
};


struct Fancy_Line{
    Fancy_Line *next;
    Face_ID face;
    FColor fore;
    Fancy_String *first;
    Fancy_String *last;
};


struct Fancy_Block{
    Fancy_Line *first;
    Fancy_Line *last;
    i32 line_count;
};




typedef i32 Buffer_ID;


typedef i32 View_ID;


typedef i32 Panel_ID;


typedef u32 Text_Layout_ID;


typedef u32 Child_Process_ID;


typedef i32 UI_Highlight_Level;
enum{
    UIHighlight_None,
    UIHighlight_Hover,
    UIHighlight_Active,
};


struct Buffer_Point{
    i64 line_number;
    Vec2_f32 pixel_shift;
};


struct Line_Shift_Vertical{
    i64 line;
    f32 y_delta;
};


struct Line_Shift_Character{
    i64 line;
    i64 character_delta;
};


typedef u32 Child_Process_Set_Target_Flags;
enum{
    ChildProcessSet_FailIfBufferAlreadyAttachedToAProcess = 1,
    ChildProcessSet_FailIfProcessAlreadyAttachedToABuffer = 2,
    ChildProcessSet_NeverOverrideExistingAttachment = 3,
    ChildProcessSet_CursorAtEnd = 4,
};


typedef u32 Memory_Protect_Flags;
enum{
    MemProtect_Read = 0x1,
    MemProtect_Write = 0x2,
    MemProtect_Execute = 0x4,
};


typedef i32 Wrap_Indicator_Mode;
enum{
    WrapIndicator_Hide,
    WrapIndicator_Show_After_Line,
    WrapIndicator_Show_At_Wrap_Edge,
};


typedef i32 Global_Setting_ID;
enum{
    GlobalSetting_Null,
    GlobalSetting_LAltLCtrlIsAltGr,
};


typedef i32 Buffer_Setting_ID;
enum{
    BufferSetting_Null,
    BufferSetting_Unimportant,
    BufferSetting_ReadOnly,
    BufferSetting_RecordsHistory,
    BufferSetting_Unkillable,
};


struct Character_Predicate{
    u8 b[32];
};


struct Frame_Info{
    i32 index;
    f32 literal_dt;
    f32 animation_dt;
};


typedef i32 View_Setting_ID;
enum{
    ViewSetting_Null,
    ViewSetting_ShowWhitespace,
    ViewSetting_ShowScrollbar,
    ViewSetting_ShowFileBar,
};


typedef u32 Buffer_Create_Flag;
enum{
    BufferCreate_Background = 0x1,
    BufferCreate_AlwaysNew = 0x2,
    BufferCreate_NeverNew = 0x4,
    BufferCreate_JustChangedFile = 0x8,
    BufferCreate_MustAttachToFile = 0x10,
    BufferCreate_NeverAttachToFile = 0x20,
    BufferCreate_SuppressNewFileHook = 0x40,
};


typedef u32 Buffer_Save_Flag;
enum{
    BufferSave_IgnoreDirtyFlag = 0x1,
};


typedef u32 Buffer_Kill_Flag;
enum{
    BufferKill_AlwaysKill = 0x2,
};


typedef u32 Buffer_Reopen_Flag;
enum{};


typedef u32 Buffer_Kill_Result;
enum{
    BufferKillResult_Killed = 0,
    BufferKillResult_Dirty = 1,
    BufferKillResult_Unkillable = 2,
    BufferKillResult_DoesNotExist = 3,
};


typedef u32 Buffer_Reopen_Result;
enum{
    BufferReopenResult_Reopened = 0,
    BufferReopenResult_Failed = 1,
};


typedef u32 Access_Flag;
enum{
    Access_Write = 0x1,
    Access_Read = 0x2,
    Access_Visible = 0x4,
};
enum{
    Access_Always = 0,
    Access_ReadWrite = Access_Write|Access_Read,
    Access_ReadVisible = Access_Read|Access_Visible,
    Access_ReadWriteVisible = Access_Write|Access_Read|Access_Visible,
};


typedef i32 Dirty_State;
enum{
    DirtyState_UpToDate = 0,
    DirtyState_UnsavedChanges = 1,
    DirtyState_UnloadedChanges = 2,
    DirtyState_UnsavedChangesAndUnloadedChanges = 3,
};


typedef u32 Command_Line_Interface_Flag;
enum{
    CLI_OverlapWithConflict = 0x1,
    CLI_AlwaysBindToView = 0x2,
    CLI_CursorAtEnd = 0x4,
    CLI_SendEndSignal = 0x8,
};


typedef u32 Set_Buffer_Flag;
enum{
    SetBuffer_KeepOriginalGUI = 0x1
};


typedef i32 Mouse_Cursor_Show_Type;
enum{
    MouseCursorShow_Never,
    MouseCursorShow_Always,
};


typedef i32 View_Split_Position;
enum{
    ViewSplit_Top,
    ViewSplit_Bottom,
    ViewSplit_Left,
    ViewSplit_Right,
};


typedef i32 Panel_Split_Kind;
enum{
    PanelSplitKind_Ratio_Min = 0,
    PanelSplitKind_Ratio_Max = 1,
    PanelSplitKind_FixedPixels_Min = 2,
    PanelSplitKind_FixedPixels_Max = 3,
};


typedef u8 Key_Modifier;


struct Mouse_State{
    b8 l;
    b8 r;
    b8 press_l;
    b8 press_r;
    b8 release_l;
    b8 release_r;
    b8 out_of_window;
    i32 wheel;
    union{
        struct{
            i32 x;
            i32 y;
        };
        Vec2_i32 p;
    };
};


struct Parser_String_And_Type{
    char *str;
    u32 length;
    u32 type;
};


typedef u32 File_Attribute_Flag;
enum{
    FileAttribute_IsDirectory = 1,
};


struct File_Attributes{
    u64 size;
    u64 last_write_time;
    File_Attribute_Flag flags;
};


struct File_Info{
    File_Info *next;
    String_Const_u8 file_name;
    File_Attributes attributes;
};


struct File_List{
    File_Info **infos;
    u32 count;
};


struct Buffer_Identifier{
    char *name;
    i32 name_len;
    Buffer_ID id;
};


typedef i32 Set_Buffer_Scroll_Rule;
enum{
    SetBufferScroll_NoCursorChange,
    SetBufferScroll_SnapCursorIntoView,
};


struct Buffer_Scroll{
    Buffer_Point position;
    Buffer_Point target;
};


struct Basic_Scroll{
    Vec2_f32 position;
    Vec2_f32 target;
};


typedef i32 Buffer_Seek_Type;
enum{
    buffer_seek_pos,
    buffer_seek_line_col,
};


struct Buffer_Seek{
    Buffer_Seek_Type type;
    union{
        struct{
            i64 pos;
        };
        struct{
            i64 line;
            i64 col;
        };
    };
};


struct Buffer_Cursor{
    i64 pos;
    i64 line;
    i64 col;
};


union Range_Cursor{
    struct{
        Buffer_Cursor min;
        Buffer_Cursor max;
    };
    struct{
        Buffer_Cursor start;
        Buffer_Cursor end;
    };
    struct{
        Buffer_Cursor first;
        Buffer_Cursor one_past_last;
    };
};


struct Marker{
    i64 pos;
    b32 lean_right;
};


typedef i32 Managed_Object_Type;
enum{
    ManagedObjectType_Error = 0,
    ManagedObjectType_Memory = 1,
    ManagedObjectType_Markers = 2,

    ManagedObjectType_COUNT = 4,
};


typedef u64 Managed_ID;


typedef u64 Managed_Scope;

typedef u64 Managed_Object;


struct Marker_Visual{
    Managed_Scope scope;
    u32 slot_id;
    u32 gen_id;
};


typedef u32 Glyph_Flag;
enum{
    GlyphFlag_None = 0x0,
};


struct Query_Bar{
    String_Const_u8 prompt;
    String_Const_u8 string;
    u64 string_capacity;
};


struct Query_Bar_Ptr_Array{
    Query_Bar **ptrs;
    i32 count;
};


struct Query_Bar_Group{
    Application_Links *app;
    View_ID view;

    Query_Bar_Group(Application_Links *app);
    Query_Bar_Group(Application_Links *app, View_ID view);
    ~Query_Bar_Group();
};


struct Font_Load_Location{
    String_Const_u8 file_name;
};


typedef u32 Face_Antialiasing_Mode;
enum{
    FaceAntialiasingMode_8BitMono,
    FaceAntialiasingMode_1BitMono,
};


struct Face_Load_Parameters{
    u32 pt_size;
    Face_Antialiasing_Mode aa_mode;
    b8 bold;
    b8 italic;
    b8 underline;
    b8 hinting;
};


struct Face_Description{
    Font_Load_Location font;
    Face_Load_Parameters parameters;
};


struct Face_Metrics{
    f32 text_height;
    f32 line_height;
    f32 ascent;
    f32 descent;
    f32 line_skip;

    f32 underline_yoff1;
    f32 underline_yoff2;

    f32 max_advance;
    f32 space_advance;
    f32 decimal_digit_advance;
    f32 hex_digit_advance;
    f32 byte_advance;
    f32 byte_sub_advances[3];
    f32 normal_lowercase_advance;
    f32 normal_uppercase_advance;
    f32 normal_advance;
};


struct Codepoint_Index_Map{
    b32 has_zero_index;
    u16 zero_index;
    u16 max_index;
    Table_u32_u16 table;
};


struct Face_Advance_Map{
    Codepoint_Index_Map codepoint_to_index;
    f32 *advance;
    u16 index_count;
};


struct Edit{
    String_Const_u8 text;
    Range_i64 range;
};


struct Batch_Edit{
    Batch_Edit *next;
    Edit edit;
};


typedef i32 Record_Kind;
enum{
    RecordKind_Single,
    RecordKind_Group,
};


typedef i32 Record_Error;
enum{
    RecordError_NoError,
    RecordError_InvalidBuffer,
    RecordError_NoHistoryAttached,
    RecordError_IndexOutOfBounds,
    RecordError_SubIndexOutOfBounds,
    RecordError_InitialStateDummyRecord,
    RecordError_WrongRecordTypeAtIndex,
};


typedef u32 Record_Merge_Flag;
enum{
    RecordMergeFlag_StateInRange_MoveStateForward = 0x0,
    RecordMergeFlag_StateInRange_MoveStateBackward = 0x1,
    RecordMergeFlag_StateInRange_ErrorOut = 0x2,
};


typedef i32 History_Record_Index;


struct Record_Info{
    Record_Error error;
    Record_Kind kind;
    i64 pos_before_edit;
    i32 edit_number;
    union{
        struct{
            String_Const_u8 single_string_forward;
            String_Const_u8 single_string_backward;
            i64 single_first;
        };
        struct{
            i32 group_count;
        };
    };
};
# 638 "/home/tabletel/dev/4cc/code/custom/4coder_types.h"

struct User_Input{
    Input_Event event;
    b32 abort;
};


typedef i32 Hook_ID;
enum{
    HookID_Tick,
    HookID_RenderCaller,
    HookID_WholeScreenRenderCaller,
    HookID_DeltaRule,
    HookID_BufferViewerUpdate,
    HookID_ViewEventHandler,
    HookID_BufferNameResolver,
    HookID_BeginBuffer,
    HookID_EndBuffer,
    HookID_NewFile,
    HookID_SaveFile,
    HookID_BufferEditRange,
    HookID_BufferRegion,
    HookID_Layout,
    HookID_ViewChangeBuffer,
};


typedef i32 Hook_Function(Application_Links *app);



struct Buffer_Name_Conflict_Entry{
    Buffer_ID buffer_id;
    String_Const_u8 file_name;
    String_Const_u8 base_name;
    u8 *unique_name_in_out;
    u64 unique_name_len_in_out;
    u64 unique_name_capacity;
};


typedef void Buffer_Name_Resolver_Function(Application_Links *app, Buffer_Name_Conflict_Entry *conflicts, i32 conflict_count);



typedef i32 Buffer_Hook_Function(Application_Links *app, Buffer_ID buffer_id);



typedef i32 Buffer_Edit_Range_Function(Application_Links *app, Buffer_ID buffer_id,
                                       Range_i64 new_range, Range_Cursor old_range);



typedef Vec2_f32 Delta_Rule_Function(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data);



typedef Rect_f32 Buffer_Region_Function(Application_Links *app, View_ID view_id, Rect_f32 region);


typedef void New_Clipboard_Contents_Function(Application_Links *app, String_Const_u8 contents);



typedef void Tick_Function(Application_Links *app, Frame_Info frame_info);


typedef void Render_Caller_Function(Application_Links *app, Frame_Info frame_info, View_ID view);


typedef void Whole_Screen_Render_Caller_Function(Application_Links *app, Frame_Info frame_info);


typedef void View_Change_Buffer_Function(Application_Links *app, View_ID view_id,
                                         Buffer_ID old_buffer_id, Buffer_ID new_buffer_id);


typedef u32 Layout_Item_Flag;
enum{
    LayoutItemFlag_Special_Character = (1 << 0),
    LayoutItemFlag_Ghost_Character = (1 << 1)
};


struct Layout_Item{
    i64 index;
    u32 codepoint;
    Layout_Item_Flag flags;
    Rect_f32 rect;
    f32 padded_y1;
};


struct Layout_Item_Block{
    Layout_Item_Block *next;
    Layout_Item *items;
    i64 item_count;
    i64 character_count;
    Face_ID face;
};


struct Layout_Item_List{
    Layout_Item_Block *first;
    Layout_Item_Block *last;
    i64 item_count;
    i64 character_count;
    i32 node_count;
    f32 height;
    f32 bottom_padding;
    Range_i64 input_index_range;
    Range_i64 manifested_index_range;
};


typedef Layout_Item_List Layout_Function(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width);


struct View_Context{
    Render_Caller_Function *render_caller;
    Delta_Rule_Function *delta_rule;
    u64 delta_rule_memory_size;
    b32 hides_buffer;
    struct Mapping *mapping;
    i64 map_id;
};


typedef u32 String_Match_Flag;
enum{
    StringMatch_CaseSensitive = 1,
    StringMatch_LeftSideSloppy = 2,
    StringMatch_RightSideSloppy = 4,
    StringMatch_Straddled = 8,
};


struct String_Match{
    String_Match *next;
    Buffer_ID buffer;
    i32 string_id;
    String_Match_Flag flags;
    Range_i64 range;
};


struct String_Match_List{
    String_Match *first;
    String_Match *last;
    i32 count;
};


struct Process_State{
    b32 valid;
    b32 is_updating;
    i64 return_code;
};






typedef void Audio_Mix_Sources_Function(void *ctx, f32 *buffer, u32 sample_count);
typedef void Audio_Mix_Destination_Function(i16 *dst, f32 *src, u32 sample_count);
# 22 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.h"
typedef i32 Doc_Month;
enum{
    None,
     January,
     February,
     March,
     April,
     May,
     June,
     July,
     August,
     September,
     October,
     November,
     December,
};
char *doc_month_names[] = {
    "None",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
};
char *doc_day_names[] = {
    "0",
    "1st",
    "2nd",
    "3rd",
    "4th",
    "5th",
    "6th",
    "7th",
    "8th",
    "9th",
    "10th",
    "11th",
    "12th",
    "13th",
    "14th",
    "15th",
    "16th",
    "17th",
    "18th",
    "19th",
    "20th",
    "21st",
    "22nd",
    "23rd",
    "24th",
    "25th",
    "26th",
    "27th",
    "28th",
    "29th",
    "30th",
    "31st",
};

struct Doc_Date{
    i32 day;
    Doc_Month month;
    i32 year;
};

typedef i32 Doc_Content_Emphasis;
enum{
    DocContentEmphasis_Normal,
    DocContentEmphasis_SmallHeader,
    DocContentEmphasis_Heavy,
    DocContentEmphasis_Stylish,
    DocContentEmphasis_Code,
};
struct Doc_Content{
    Doc_Content *next;
    String_Const_u8 text;
    String_Const_u8 page_link;
    String_Const_u8 block_link;
    Doc_Content_Emphasis emphasis;
};
struct Doc_Content_List{
    Doc_Content *first;
    Doc_Content *last;
    u64 total_size;
    i32 node_count;
};

typedef i32 Doc_Code_Language;
enum{
    DocCodeLanguage_None,
    DocCodeLanguage_Cpp,
    DocCodeLanguage_Bat,
};
char *doc_language_name[] = {
    "none",
    "C++",
    "Batch",
};
struct Doc_Code_Sample{
    Doc_Code_Sample *next;
    String_Const_u8 contents;
    Doc_Code_Language language;
};
struct Doc_Code_Sample_List{
    Doc_Code_Sample *first;
    Doc_Code_Sample *last;
    i32 count;
};

typedef i32 Doc_Paragraph_Kind;
enum{
    DocParagraphKind_Text,
    DocParagraphKind_Code,
    DocParagraphKind_Table,
};
struct Doc_Paragraph{
    Doc_Paragraph *next;
    Doc_Paragraph_Kind kind;
    union{
        Doc_Content_List text;
        Doc_Code_Sample_List code;
        struct{
            Vec2_i32 dim;
            Doc_Content_List *vals;
        } table;
    };
};

struct Doc_Block{
    Doc_Block *next;

    struct Doc_Page *owner;

    String_Const_u8 name;

    Doc_Paragraph *first_par;
    Doc_Paragraph *last_par;
    i32 par_count;
};

struct Doc_Block_Ptr{
    Doc_Block_Ptr *next;
    Doc_Block *block;
};

struct Doc_Block_List{
    Doc_Block_Ptr *first;
    Doc_Block_Ptr *last;
    i32 count;
};

struct Doc_Page{
    Doc_Page *next;

    struct Doc_Cluster *owner;

    String_Const_u8 title;
    String_Const_u8 name;

    Doc_Block *first_block;
    Doc_Block *last_block;
    i32 block_count;

    Doc_Block_List quick_jumps;
};

struct Doc_Log{
    Doc_Log *next;
    String_Const_u8 content;
};

struct Doc_Cluster{
    String_Const_u8 title;
    String_Const_u8 name;
    Doc_Date gen_date;

    Doc_Page *first_page;
    Doc_Page *last_page;
    i32 page_count;

    Doc_Log *first_log;
    Doc_Log *last_log;
};
# 23 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_colors.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_default_colors.h"
CUSTOM_ID(colors, defcolor_bar);
CUSTOM_ID(colors, defcolor_base);
CUSTOM_ID(colors, defcolor_pop1);
CUSTOM_ID(colors, defcolor_pop2);
CUSTOM_ID(colors, defcolor_back);
CUSTOM_ID(colors, defcolor_margin);
CUSTOM_ID(colors, defcolor_margin_hover);
CUSTOM_ID(colors, defcolor_margin_active);
CUSTOM_ID(colors, defcolor_list_item);
CUSTOM_ID(colors, defcolor_list_item_hover);
CUSTOM_ID(colors, defcolor_list_item_active);
CUSTOM_ID(colors, defcolor_cursor);
CUSTOM_ID(colors, defcolor_at_cursor);
CUSTOM_ID(colors, defcolor_highlight_cursor_line);
CUSTOM_ID(colors, defcolor_highlight);
CUSTOM_ID(colors, defcolor_at_highlight);
CUSTOM_ID(colors, defcolor_mark);
CUSTOM_ID(colors, defcolor_text_default);
CUSTOM_ID(colors, defcolor_comment);
CUSTOM_ID(colors, defcolor_comment_pop);
CUSTOM_ID(colors, defcolor_keyword);
CUSTOM_ID(colors, defcolor_str_constant);
CUSTOM_ID(colors, defcolor_char_constant);
CUSTOM_ID(colors, defcolor_int_constant);
CUSTOM_ID(colors, defcolor_float_constant);
CUSTOM_ID(colors, defcolor_bool_constant);
CUSTOM_ID(colors, defcolor_preproc);
CUSTOM_ID(colors, defcolor_include);
CUSTOM_ID(colors, defcolor_special_character);
CUSTOM_ID(colors, defcolor_ghost_character);
CUSTOM_ID(colors, defcolor_highlight_junk);
CUSTOM_ID(colors, defcolor_highlight_white);
CUSTOM_ID(colors, defcolor_paste);
CUSTOM_ID(colors, defcolor_undo);
CUSTOM_ID(colors, defcolor_back_cycle);
CUSTOM_ID(colors, defcolor_text_cycle);
CUSTOM_ID(colors, defcolor_line_numbers_back);
CUSTOM_ID(colors, defcolor_line_numbers_text);

struct Color_Table_Node{
    Color_Table_Node *next;
    String_Const_u8 name;
    Color_Table table;
};

struct Color_Table_List{
    Color_Table_Node *first;
    Color_Table_Node *last;
    i32 count;
};

static Color_Table active_color_table = {};
static Color_Table default_color_table = {};

static Arena global_theme_arena = {};
static Color_Table_List global_theme_list = {};
# 24 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/generated/custom_api.h" 1
# 180 "/home/tabletel/dev/4cc/code/custom/generated/custom_api.h"
typedef b32 custom_global_set_setting_type(Application_Links* app, Global_Setting_ID setting, i64 value);
typedef Rect_f32 custom_global_get_screen_rectangle_type(Application_Links* app);
typedef Thread_Context* custom_get_thread_context_type(Application_Links* app);
typedef Child_Process_ID custom_create_child_process_type(Application_Links* app, String_Const_u8 path, String_Const_u8 command);
typedef b32 custom_child_process_set_target_buffer_type(Application_Links* app, Child_Process_ID child_process_id, Buffer_ID buffer_id, Child_Process_Set_Target_Flags flags);
typedef Child_Process_ID custom_buffer_get_attached_child_process_type(Application_Links* app, Buffer_ID buffer_id);
typedef Buffer_ID custom_child_process_get_attached_buffer_type(Application_Links* app, Child_Process_ID child_process_id);
typedef Process_State custom_child_process_get_state_type(Application_Links* app, Child_Process_ID child_process_id);
typedef b32 custom_enqueue_virtual_event_type(Application_Links* app, Input_Event* event);
typedef i32 custom_get_buffer_count_type(Application_Links* app);
typedef Buffer_ID custom_get_buffer_next_type(Application_Links* app, Buffer_ID buffer_id, Access_Flag access);
typedef Buffer_ID custom_get_buffer_by_name_type(Application_Links* app, String_Const_u8 name, Access_Flag access);
typedef Buffer_ID custom_get_buffer_by_file_name_type(Application_Links* app, String_Const_u8 file_name, Access_Flag access);
typedef b32 custom_buffer_read_range_type(Application_Links* app, Buffer_ID buffer_id, Range_i64 range, u8* out);
typedef b32 custom_buffer_replace_range_type(Application_Links* app, Buffer_ID buffer_id, Range_i64 range, String_Const_u8 string);
typedef b32 custom_buffer_batch_edit_type(Application_Links* app, Buffer_ID buffer_id, Batch_Edit* batch);
typedef String_Match custom_buffer_seek_string_type(Application_Links* app, Buffer_ID buffer, String_Const_u8 needle, Scan_Direction direction, i64 start_pos);
typedef String_Match custom_buffer_seek_character_class_type(Application_Links* app, Buffer_ID buffer, Character_Predicate* predicate, Scan_Direction direction, i64 start_pos);
typedef f32 custom_buffer_line_y_difference_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 line_a, i64 line_b);
typedef Line_Shift_Vertical custom_buffer_line_shift_y_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 line, f32 y_shift);
typedef i64 custom_buffer_pos_at_relative_xy_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, Vec2_f32 relative_xy);
typedef Rect_f32 custom_buffer_relative_box_of_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef Rect_f32 custom_buffer_padded_box_of_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef i64 custom_buffer_relative_character_from_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef i64 custom_buffer_pos_from_relative_character_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 relative_character);
typedef f32 custom_view_line_y_difference_type(Application_Links* app, View_ID view_id, i64 line_a, i64 line_b);
typedef Line_Shift_Vertical custom_view_line_shift_y_type(Application_Links* app, View_ID view_id, i64 line, f32 y_shift);
typedef i64 custom_view_pos_at_relative_xy_type(Application_Links* app, View_ID view_id, i64 base_line, Vec2_f32 relative_xy);
typedef Rect_f32 custom_view_relative_box_of_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef Rect_f32 custom_view_padded_box_of_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef i64 custom_view_relative_character_from_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef i64 custom_view_pos_from_relative_character_type(Application_Links* app, View_ID view_id, i64 base_line, i64 character);
typedef b32 custom_buffer_exists_type(Application_Links* app, Buffer_ID buffer_id);
typedef Access_Flag custom_buffer_get_access_flags_type(Application_Links* app, Buffer_ID buffer_id);
typedef i64 custom_buffer_get_size_type(Application_Links* app, Buffer_ID buffer_id);
typedef i64 custom_buffer_get_line_count_type(Application_Links* app, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_base_name_type(Application_Links* app, Arena* arena, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_unique_name_type(Application_Links* app, Arena* out, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_file_name_type(Application_Links* app, Arena* arena, Buffer_ID buffer_id);
typedef Dirty_State custom_buffer_get_dirty_state_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_set_dirty_state_type(Application_Links* app, Buffer_ID buffer_id, Dirty_State dirty_state);
typedef b32 custom_buffer_set_layout_type(Application_Links* app, Buffer_ID buffer_id, Layout_Function* layout_func);
typedef b32 custom_buffer_clear_layout_cache_type(Application_Links* app, Buffer_ID buffer_id);
typedef Layout_Function* custom_buffer_get_layout_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_get_setting_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64* value_out);
typedef b32 custom_buffer_set_setting_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64 value);
typedef Managed_Scope custom_buffer_get_managed_scope_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_send_end_signal_type(Application_Links* app, Buffer_ID buffer_id);
typedef Buffer_ID custom_create_buffer_type(Application_Links* app, String_Const_u8 file_name, Buffer_Create_Flag flags);
typedef b32 custom_buffer_save_type(Application_Links* app, Buffer_ID buffer_id, String_Const_u8 file_name, Buffer_Save_Flag flags);
typedef Buffer_Kill_Result custom_buffer_kill_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Kill_Flag flags);
typedef Buffer_Reopen_Result custom_buffer_reopen_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Reopen_Flag flags);
typedef File_Attributes custom_buffer_get_file_attributes_type(Application_Links* app, Buffer_ID buffer_id);
typedef View_ID custom_get_view_next_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef View_ID custom_get_view_prev_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef View_ID custom_get_this_ctx_view_type(Application_Links* app, Access_Flag access);
typedef View_ID custom_get_active_view_type(Application_Links* app, Access_Flag access);
typedef b32 custom_view_exists_type(Application_Links* app, View_ID view_id);
typedef Buffer_ID custom_view_get_buffer_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef i64 custom_view_get_cursor_pos_type(Application_Links* app, View_ID view_id);
typedef i64 custom_view_get_mark_pos_type(Application_Links* app, View_ID view_id);
typedef f32 custom_view_get_preferred_x_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_preferred_x_type(Application_Links* app, View_ID view_id, f32 x);
typedef Rect_f32 custom_view_get_screen_rect_type(Application_Links* app, View_ID view_id);
typedef Panel_ID custom_view_get_panel_type(Application_Links* app, View_ID view_id);
typedef View_ID custom_panel_get_view_type(Application_Links* app, Panel_ID panel_id, Access_Flag access);
typedef b32 custom_panel_is_split_type(Application_Links* app, Panel_ID panel_id);
typedef b32 custom_panel_is_leaf_type(Application_Links* app, Panel_ID panel_id);
typedef b32 custom_panel_split_type(Application_Links* app, Panel_ID panel_id, Dimension split_dim);
typedef b32 custom_panel_set_split_type(Application_Links* app, Panel_ID panel_id, Panel_Split_Kind kind, f32 t);
typedef b32 custom_panel_swap_children_type(Application_Links* app, Panel_ID panel_id);
typedef Panel_ID custom_panel_get_root_type(Application_Links* app);
typedef Panel_ID custom_panel_get_parent_type(Application_Links* app, Panel_ID panel_id);
typedef Panel_ID custom_panel_get_child_type(Application_Links* app, Panel_ID panel_id, Side which_child);
typedef b32 custom_view_close_type(Application_Links* app, View_ID view_id);
typedef Rect_f32 custom_view_get_buffer_region_type(Application_Links* app, View_ID view_id);
typedef Buffer_Scroll custom_view_get_buffer_scroll_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_active_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_enqueue_command_function_type(Application_Links* app, View_ID view_id, Custom_Command_Function* custom_func);
typedef b32 custom_view_get_setting_type(Application_Links* app, View_ID view_id, View_Setting_ID setting, i64* value_out);
typedef b32 custom_view_set_setting_type(Application_Links* app, View_ID view_id, View_Setting_ID setting, i64 value);
typedef Managed_Scope custom_view_get_managed_scope_type(Application_Links* app, View_ID view_id);
typedef Buffer_Cursor custom_buffer_compute_cursor_type(Application_Links* app, Buffer_ID buffer, Buffer_Seek seek);
typedef Buffer_Cursor custom_view_compute_cursor_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_set_camera_bounds_type(Application_Links* app, View_ID view_id, Vec2_f32 margin, Vec2_f32 push_in_multiplier);
typedef b32 custom_view_get_camera_bounds_type(Application_Links* app, View_ID view_id, Vec2_f32* margin, Vec2_f32* push_in_multiplier);
typedef b32 custom_view_set_cursor_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_set_buffer_scroll_type(Application_Links* app, View_ID view_id, Buffer_Scroll scroll, Set_Buffer_Scroll_Rule rule);
typedef b32 custom_view_set_mark_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_quit_ui_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_buffer_type(Application_Links* app, View_ID view_id, Buffer_ID buffer_id, Set_Buffer_Flag flags);
typedef b32 custom_view_push_context_type(Application_Links* app, View_ID view_id, View_Context* ctx);
typedef b32 custom_view_pop_context_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_alter_context_type(Application_Links* app, View_ID view_id, View_Context* ctx);
typedef View_Context custom_view_current_context_type(Application_Links* app, View_ID view_id);
typedef String_Const_u8 custom_view_current_context_hook_memory_type(Application_Links* app, View_ID view_id, Hook_ID hook_id);
typedef Managed_Scope custom_create_user_managed_scope_type(Application_Links* app);
typedef b32 custom_destroy_user_managed_scope_type(Application_Links* app, Managed_Scope scope);
typedef Managed_Scope custom_get_global_managed_scope_type(Application_Links* app);
typedef Managed_Scope custom_get_managed_scope_with_multiple_dependencies_type(Application_Links* app, Managed_Scope* scopes, i32 count);
typedef b32 custom_managed_scope_clear_contents_type(Application_Links* app, Managed_Scope scope);
typedef b32 custom_managed_scope_clear_self_all_dependent_scopes_type(Application_Links* app, Managed_Scope scope);
typedef Base_Allocator* custom_managed_scope_allocator_type(Application_Links* app, Managed_Scope scope);
typedef u64 custom_managed_id_group_highest_id_type(Application_Links* app, String_Const_u8 group);
typedef Managed_ID custom_managed_id_declare_type(Application_Links* app, String_Const_u8 group, String_Const_u8 name);
typedef Managed_ID custom_managed_id_get_type(Application_Links* app, String_Const_u8 group, String_Const_u8 name);
typedef void* custom_managed_scope_get_attachment_type(Application_Links* app, Managed_Scope scope, Managed_ID id, u64 size);
typedef b32 custom_managed_scope_attachment_erase_type(Application_Links* app, Managed_Scope scope, Managed_ID id);
typedef Managed_Object custom_alloc_managed_memory_in_scope_type(Application_Links* app, Managed_Scope scope, i32 item_size, i32 count);
typedef Managed_Object custom_alloc_buffer_markers_on_buffer_type(Application_Links* app, Buffer_ID buffer_id, i32 count, Managed_Scope* optional_extra_scope);
typedef u32 custom_managed_object_get_item_size_type(Application_Links* app, Managed_Object object);
typedef u32 custom_managed_object_get_item_count_type(Application_Links* app, Managed_Object object);
typedef void* custom_managed_object_get_pointer_type(Application_Links* app, Managed_Object object);
typedef Managed_Object_Type custom_managed_object_get_type_type(Application_Links* app, Managed_Object object);
typedef Managed_Scope custom_managed_object_get_containing_scope_type(Application_Links* app, Managed_Object object);
typedef b32 custom_managed_object_free_type(Application_Links* app, Managed_Object object);
typedef b32 custom_managed_object_store_data_type(Application_Links* app, Managed_Object object, u32 first_index, u32 count, void* mem);
typedef b32 custom_managed_object_load_data_type(Application_Links* app, Managed_Object object, u32 first_index, u32 count, void* mem_out);
typedef User_Input custom_get_next_input_raw_type(Application_Links* app);
typedef i64 custom_get_current_input_sequence_number_type(Application_Links* app);
typedef User_Input custom_get_current_input_type(Application_Links* app);
typedef void custom_set_current_input_type(Application_Links* app, User_Input* input);
typedef void custom_leave_current_input_unhandled_type(Application_Links* app);
typedef void custom_set_custom_hook_type(Application_Links* app, Hook_ID hook_id, Void_Func* func_ptr);
typedef Void_Func* custom_get_custom_hook_type(Application_Links* app, Hook_ID hook_id);
typedef b32 custom_set_custom_hook_memory_size_type(Application_Links* app, Hook_ID hook_id, u64 size);
typedef Mouse_State custom_get_mouse_state_type(Application_Links* app);
typedef b32 custom_get_active_query_bars_type(Application_Links* app, View_ID view_id, i32 max_result_count, Query_Bar_Ptr_Array* array_out);
typedef b32 custom_start_query_bar_type(Application_Links* app, Query_Bar* bar, u32 flags);
typedef void custom_end_query_bar_type(Application_Links* app, Query_Bar* bar, u32 flags);
typedef void custom_clear_all_query_bars_type(Application_Links* app, View_ID view_id);
typedef void custom_print_message_type(Application_Links* app, String_Const_u8 message);
typedef b32 custom_log_string_type(Application_Links* app, String_Const_u8 str);
typedef Face_ID custom_get_largest_face_id_type(Application_Links* app);
typedef b32 custom_set_global_face_type(Application_Links* app, Face_ID id);
typedef History_Record_Index custom_buffer_history_get_max_record_index_type(Application_Links* app, Buffer_ID buffer_id);
typedef Record_Info custom_buffer_history_get_record_info_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index);
typedef Record_Info custom_buffer_history_get_group_sub_record_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index, i32 sub_index);
typedef History_Record_Index custom_buffer_history_get_current_state_index_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_history_set_current_state_index_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index);
typedef b32 custom_buffer_history_merge_record_range_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index first_index, History_Record_Index last_index, Record_Merge_Flag flags);
typedef b32 custom_buffer_history_clear_after_current_state_type(Application_Links* app, Buffer_ID buffer_id);
typedef void custom_global_history_edit_group_begin_type(Application_Links* app);
typedef void custom_global_history_edit_group_end_type(Application_Links* app);
typedef b32 custom_buffer_set_face_type(Application_Links* app, Buffer_ID buffer_id, Face_ID id);
typedef Face_Description custom_get_face_description_type(Application_Links* app, Face_ID face_id);
typedef Face_Metrics custom_get_face_metrics_type(Application_Links* app, Face_ID face_id);
typedef Face_Advance_Map custom_get_face_advance_map_type(Application_Links* app, Face_ID face_id);
typedef Face_ID custom_get_face_id_type(Application_Links* app, Buffer_ID buffer_id);
typedef Face_ID custom_try_create_new_face_type(Application_Links* app, Face_Description* description);
typedef b32 custom_try_modify_face_type(Application_Links* app, Face_ID id, Face_Description* description);
typedef b32 custom_try_release_face_type(Application_Links* app, Face_ID id, Face_ID replacement_id);
typedef String_Const_u8 custom_push_hot_directory_type(Application_Links* app, Arena* arena);
typedef void custom_set_hot_directory_type(Application_Links* app, String_Const_u8 string);
typedef void custom_send_exit_signal_type(Application_Links* app);
typedef void custom_hard_exit_type(Application_Links* app);
typedef void custom_set_window_title_type(Application_Links* app, String_Const_u8 title);
typedef void custom_acquire_global_frame_mutex_type(Application_Links* app);
typedef void custom_release_global_frame_mutex_type(Application_Links* app);
typedef Vec2_f32 custom_draw_string_oriented_type(Application_Links* app, Face_ID font_id, ARGB_Color color, String_Const_u8 str, Vec2_f32 point, u32 flags, Vec2_f32 delta);
typedef f32 custom_get_string_advance_type(Application_Links* app, Face_ID font_id, String_Const_u8 str);
typedef void custom_draw_rectangle_type(Application_Links* app, Rect_f32 rect, f32 roundness, ARGB_Color color);
typedef void custom_draw_rectangle_outline_type(Application_Links* app, Rect_f32 rect, f32 roundness, f32 thickness, ARGB_Color color);
typedef Rect_f32 custom_draw_set_clip_type(Application_Links* app, Rect_f32 new_clip);
typedef Text_Layout_ID custom_text_layout_create_type(Application_Links* app, Buffer_ID buffer_id, Rect_f32 rect, Buffer_Point buffer_point);
typedef Rect_f32 custom_text_layout_region_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Buffer_ID custom_text_layout_get_buffer_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Range_i64 custom_text_layout_get_visible_range_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Range_f32 custom_text_layout_line_on_screen_type(Application_Links* app, Text_Layout_ID layout_id, i64 line_number);
typedef Rect_f32 custom_text_layout_character_on_screen_type(Application_Links* app, Text_Layout_ID layout_id, i64 pos);
typedef void custom_paint_text_color_type(Application_Links* app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color);
typedef void custom_paint_text_color_blend_type(Application_Links* app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color, f32 blend);
typedef b32 custom_text_layout_free_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef void custom_draw_text_layout_type(Application_Links* app, Text_Layout_ID layout_id, ARGB_Color special_color, ARGB_Color ghost_color);
typedef void custom_open_color_picker_type(Application_Links* app, Color_Picker* picker);
typedef void custom_animate_in_n_milliseconds_type(Application_Links* app, u32 n);
typedef String_Match_List custom_buffer_find_all_matches_type(Application_Links* app, Arena* arena, Buffer_ID buffer, i32 string_id, Range_i64 range, String_Const_u8 needle, Character_Predicate* predicate, Scan_Direction direction);
typedef Profile_Global_List* custom_get_core_profile_list_type(Application_Links* app);
typedef Doc_Cluster* custom_get_custom_layer_boundary_docs_type(Application_Links* app, Arena* arena);
struct API_VTable_custom{
custom_global_set_setting_type *global_set_setting;
custom_global_get_screen_rectangle_type *global_get_screen_rectangle;
custom_get_thread_context_type *get_thread_context;
custom_create_child_process_type *create_child_process;
custom_child_process_set_target_buffer_type *child_process_set_target_buffer;
custom_buffer_get_attached_child_process_type *buffer_get_attached_child_process;
custom_child_process_get_attached_buffer_type *child_process_get_attached_buffer;
custom_child_process_get_state_type *child_process_get_state;
custom_enqueue_virtual_event_type *enqueue_virtual_event;
custom_get_buffer_count_type *get_buffer_count;
custom_get_buffer_next_type *get_buffer_next;
custom_get_buffer_by_name_type *get_buffer_by_name;
custom_get_buffer_by_file_name_type *get_buffer_by_file_name;
custom_buffer_read_range_type *buffer_read_range;
custom_buffer_replace_range_type *buffer_replace_range;
custom_buffer_batch_edit_type *buffer_batch_edit;
custom_buffer_seek_string_type *buffer_seek_string;
custom_buffer_seek_character_class_type *buffer_seek_character_class;
custom_buffer_line_y_difference_type *buffer_line_y_difference;
custom_buffer_line_shift_y_type *buffer_line_shift_y;
custom_buffer_pos_at_relative_xy_type *buffer_pos_at_relative_xy;
custom_buffer_relative_box_of_pos_type *buffer_relative_box_of_pos;
custom_buffer_padded_box_of_pos_type *buffer_padded_box_of_pos;
custom_buffer_relative_character_from_pos_type *buffer_relative_character_from_pos;
custom_buffer_pos_from_relative_character_type *buffer_pos_from_relative_character;
custom_view_line_y_difference_type *view_line_y_difference;
custom_view_line_shift_y_type *view_line_shift_y;
custom_view_pos_at_relative_xy_type *view_pos_at_relative_xy;
custom_view_relative_box_of_pos_type *view_relative_box_of_pos;
custom_view_padded_box_of_pos_type *view_padded_box_of_pos;
custom_view_relative_character_from_pos_type *view_relative_character_from_pos;
custom_view_pos_from_relative_character_type *view_pos_from_relative_character;
custom_buffer_exists_type *buffer_exists;
custom_buffer_get_access_flags_type *buffer_get_access_flags;
custom_buffer_get_size_type *buffer_get_size;
custom_buffer_get_line_count_type *buffer_get_line_count;
custom_push_buffer_base_name_type *push_buffer_base_name;
custom_push_buffer_unique_name_type *push_buffer_unique_name;
custom_push_buffer_file_name_type *push_buffer_file_name;
custom_buffer_get_dirty_state_type *buffer_get_dirty_state;
custom_buffer_set_dirty_state_type *buffer_set_dirty_state;
custom_buffer_set_layout_type *buffer_set_layout;
custom_buffer_clear_layout_cache_type *buffer_clear_layout_cache;
custom_buffer_get_layout_type *buffer_get_layout;
custom_buffer_get_setting_type *buffer_get_setting;
custom_buffer_set_setting_type *buffer_set_setting;
custom_buffer_get_managed_scope_type *buffer_get_managed_scope;
custom_buffer_send_end_signal_type *buffer_send_end_signal;
custom_create_buffer_type *create_buffer;
custom_buffer_save_type *buffer_save;
custom_buffer_kill_type *buffer_kill;
custom_buffer_reopen_type *buffer_reopen;
custom_buffer_get_file_attributes_type *buffer_get_file_attributes;
custom_get_view_next_type *get_view_next;
custom_get_view_prev_type *get_view_prev;
custom_get_this_ctx_view_type *get_this_ctx_view;
custom_get_active_view_type *get_active_view;
custom_view_exists_type *view_exists;
custom_view_get_buffer_type *view_get_buffer;
custom_view_get_cursor_pos_type *view_get_cursor_pos;
custom_view_get_mark_pos_type *view_get_mark_pos;
custom_view_get_preferred_x_type *view_get_preferred_x;
custom_view_set_preferred_x_type *view_set_preferred_x;
custom_view_get_screen_rect_type *view_get_screen_rect;
custom_view_get_panel_type *view_get_panel;
custom_panel_get_view_type *panel_get_view;
custom_panel_is_split_type *panel_is_split;
custom_panel_is_leaf_type *panel_is_leaf;
custom_panel_split_type *panel_split;
custom_panel_set_split_type *panel_set_split;
custom_panel_swap_children_type *panel_swap_children;
custom_panel_get_root_type *panel_get_root;
custom_panel_get_parent_type *panel_get_parent;
custom_panel_get_child_type *panel_get_child;
custom_view_close_type *view_close;
custom_view_get_buffer_region_type *view_get_buffer_region;
custom_view_get_buffer_scroll_type *view_get_buffer_scroll;
custom_view_set_active_type *view_set_active;
custom_view_enqueue_command_function_type *view_enqueue_command_function;
custom_view_get_setting_type *view_get_setting;
custom_view_set_setting_type *view_set_setting;
custom_view_get_managed_scope_type *view_get_managed_scope;
custom_buffer_compute_cursor_type *buffer_compute_cursor;
custom_view_compute_cursor_type *view_compute_cursor;
custom_view_set_camera_bounds_type *view_set_camera_bounds;
custom_view_get_camera_bounds_type *view_get_camera_bounds;
custom_view_set_cursor_type *view_set_cursor;
custom_view_set_buffer_scroll_type *view_set_buffer_scroll;
custom_view_set_mark_type *view_set_mark;
custom_view_quit_ui_type *view_quit_ui;
custom_view_set_buffer_type *view_set_buffer;
custom_view_push_context_type *view_push_context;
custom_view_pop_context_type *view_pop_context;
custom_view_alter_context_type *view_alter_context;
custom_view_current_context_type *view_current_context;
custom_view_current_context_hook_memory_type *view_current_context_hook_memory;
custom_create_user_managed_scope_type *create_user_managed_scope;
custom_destroy_user_managed_scope_type *destroy_user_managed_scope;
custom_get_global_managed_scope_type *get_global_managed_scope;
custom_get_managed_scope_with_multiple_dependencies_type *get_managed_scope_with_multiple_dependencies;
custom_managed_scope_clear_contents_type *managed_scope_clear_contents;
custom_managed_scope_clear_self_all_dependent_scopes_type *managed_scope_clear_self_all_dependent_scopes;
custom_managed_scope_allocator_type *managed_scope_allocator;
custom_managed_id_group_highest_id_type *managed_id_group_highest_id;
custom_managed_id_declare_type *managed_id_declare;
custom_managed_id_get_type *managed_id_get;
custom_managed_scope_get_attachment_type *managed_scope_get_attachment;
custom_managed_scope_attachment_erase_type *managed_scope_attachment_erase;
custom_alloc_managed_memory_in_scope_type *alloc_managed_memory_in_scope;
custom_alloc_buffer_markers_on_buffer_type *alloc_buffer_markers_on_buffer;
custom_managed_object_get_item_size_type *managed_object_get_item_size;
custom_managed_object_get_item_count_type *managed_object_get_item_count;
custom_managed_object_get_pointer_type *managed_object_get_pointer;
custom_managed_object_get_type_type *managed_object_get_type;
custom_managed_object_get_containing_scope_type *managed_object_get_containing_scope;
custom_managed_object_free_type *managed_object_free;
custom_managed_object_store_data_type *managed_object_store_data;
custom_managed_object_load_data_type *managed_object_load_data;
custom_get_next_input_raw_type *get_next_input_raw;
custom_get_current_input_sequence_number_type *get_current_input_sequence_number;
custom_get_current_input_type *get_current_input;
custom_set_current_input_type *set_current_input;
custom_leave_current_input_unhandled_type *leave_current_input_unhandled;
custom_set_custom_hook_type *set_custom_hook;
custom_get_custom_hook_type *get_custom_hook;
custom_set_custom_hook_memory_size_type *set_custom_hook_memory_size;
custom_get_mouse_state_type *get_mouse_state;
custom_get_active_query_bars_type *get_active_query_bars;
custom_start_query_bar_type *start_query_bar;
custom_end_query_bar_type *end_query_bar;
custom_clear_all_query_bars_type *clear_all_query_bars;
custom_print_message_type *print_message;
custom_log_string_type *log_string;
custom_get_largest_face_id_type *get_largest_face_id;
custom_set_global_face_type *set_global_face;
custom_buffer_history_get_max_record_index_type *buffer_history_get_max_record_index;
custom_buffer_history_get_record_info_type *buffer_history_get_record_info;
custom_buffer_history_get_group_sub_record_type *buffer_history_get_group_sub_record;
custom_buffer_history_get_current_state_index_type *buffer_history_get_current_state_index;
custom_buffer_history_set_current_state_index_type *buffer_history_set_current_state_index;
custom_buffer_history_merge_record_range_type *buffer_history_merge_record_range;
custom_buffer_history_clear_after_current_state_type *buffer_history_clear_after_current_state;
custom_global_history_edit_group_begin_type *global_history_edit_group_begin;
custom_global_history_edit_group_end_type *global_history_edit_group_end;
custom_buffer_set_face_type *buffer_set_face;
custom_get_face_description_type *get_face_description;
custom_get_face_metrics_type *get_face_metrics;
custom_get_face_advance_map_type *get_face_advance_map;
custom_get_face_id_type *get_face_id;
custom_try_create_new_face_type *try_create_new_face;
custom_try_modify_face_type *try_modify_face;
custom_try_release_face_type *try_release_face;
custom_push_hot_directory_type *push_hot_directory;
custom_set_hot_directory_type *set_hot_directory;
custom_send_exit_signal_type *send_exit_signal;
custom_hard_exit_type *hard_exit;
custom_set_window_title_type *set_window_title;
custom_acquire_global_frame_mutex_type *acquire_global_frame_mutex;
custom_release_global_frame_mutex_type *release_global_frame_mutex;
custom_draw_string_oriented_type *draw_string_oriented;
custom_get_string_advance_type *get_string_advance;
custom_draw_rectangle_type *draw_rectangle;
custom_draw_rectangle_outline_type *draw_rectangle_outline;
custom_draw_set_clip_type *draw_set_clip;
custom_text_layout_create_type *text_layout_create;
custom_text_layout_region_type *text_layout_region;
custom_text_layout_get_buffer_type *text_layout_get_buffer;
custom_text_layout_get_visible_range_type *text_layout_get_visible_range;
custom_text_layout_line_on_screen_type *text_layout_line_on_screen;
custom_text_layout_character_on_screen_type *text_layout_character_on_screen;
custom_paint_text_color_type *paint_text_color;
custom_paint_text_color_blend_type *paint_text_color_blend;
custom_text_layout_free_type *text_layout_free;
custom_draw_text_layout_type *draw_text_layout;
custom_open_color_picker_type *open_color_picker;
custom_animate_in_n_milliseconds_type *animate_in_n_milliseconds;
custom_buffer_find_all_matches_type *buffer_find_all_matches;
custom_get_core_profile_list_type *get_core_profile_list;
custom_get_custom_layer_boundary_docs_type *get_custom_layer_boundary_docs;
};
# 722 "/home/tabletel/dev/4cc/code/custom/generated/custom_api.h"
static custom_global_set_setting_type *global_set_setting = 0;
static custom_global_get_screen_rectangle_type *global_get_screen_rectangle = 0;
static custom_get_thread_context_type *get_thread_context = 0;
static custom_create_child_process_type *create_child_process = 0;
static custom_child_process_set_target_buffer_type *child_process_set_target_buffer = 0;
static custom_buffer_get_attached_child_process_type *buffer_get_attached_child_process = 0;
static custom_child_process_get_attached_buffer_type *child_process_get_attached_buffer = 0;
static custom_child_process_get_state_type *child_process_get_state = 0;
static custom_enqueue_virtual_event_type *enqueue_virtual_event = 0;
static custom_get_buffer_count_type *get_buffer_count = 0;
static custom_get_buffer_next_type *get_buffer_next = 0;
static custom_get_buffer_by_name_type *get_buffer_by_name = 0;
static custom_get_buffer_by_file_name_type *get_buffer_by_file_name = 0;
static custom_buffer_read_range_type *buffer_read_range = 0;
static custom_buffer_replace_range_type *buffer_replace_range = 0;
static custom_buffer_batch_edit_type *buffer_batch_edit = 0;
static custom_buffer_seek_string_type *buffer_seek_string = 0;
static custom_buffer_seek_character_class_type *buffer_seek_character_class = 0;
static custom_buffer_line_y_difference_type *buffer_line_y_difference = 0;
static custom_buffer_line_shift_y_type *buffer_line_shift_y = 0;
static custom_buffer_pos_at_relative_xy_type *buffer_pos_at_relative_xy = 0;
static custom_buffer_relative_box_of_pos_type *buffer_relative_box_of_pos = 0;
static custom_buffer_padded_box_of_pos_type *buffer_padded_box_of_pos = 0;
static custom_buffer_relative_character_from_pos_type *buffer_relative_character_from_pos = 0;
static custom_buffer_pos_from_relative_character_type *buffer_pos_from_relative_character = 0;
static custom_view_line_y_difference_type *view_line_y_difference = 0;
static custom_view_line_shift_y_type *view_line_shift_y = 0;
static custom_view_pos_at_relative_xy_type *view_pos_at_relative_xy = 0;
static custom_view_relative_box_of_pos_type *view_relative_box_of_pos = 0;
static custom_view_padded_box_of_pos_type *view_padded_box_of_pos = 0;
static custom_view_relative_character_from_pos_type *view_relative_character_from_pos = 0;
static custom_view_pos_from_relative_character_type *view_pos_from_relative_character = 0;
static custom_buffer_exists_type *buffer_exists = 0;
static custom_buffer_get_access_flags_type *buffer_get_access_flags = 0;
static custom_buffer_get_size_type *buffer_get_size = 0;
static custom_buffer_get_line_count_type *buffer_get_line_count = 0;
static custom_push_buffer_base_name_type *push_buffer_base_name = 0;
static custom_push_buffer_unique_name_type *push_buffer_unique_name = 0;
static custom_push_buffer_file_name_type *push_buffer_file_name = 0;
static custom_buffer_get_dirty_state_type *buffer_get_dirty_state = 0;
static custom_buffer_set_dirty_state_type *buffer_set_dirty_state = 0;
static custom_buffer_set_layout_type *buffer_set_layout = 0;
static custom_buffer_clear_layout_cache_type *buffer_clear_layout_cache = 0;
static custom_buffer_get_layout_type *buffer_get_layout = 0;
static custom_buffer_get_setting_type *buffer_get_setting = 0;
static custom_buffer_set_setting_type *buffer_set_setting = 0;
static custom_buffer_get_managed_scope_type *buffer_get_managed_scope = 0;
static custom_buffer_send_end_signal_type *buffer_send_end_signal = 0;
static custom_create_buffer_type *create_buffer = 0;
static custom_buffer_save_type *buffer_save = 0;
static custom_buffer_kill_type *buffer_kill = 0;
static custom_buffer_reopen_type *buffer_reopen = 0;
static custom_buffer_get_file_attributes_type *buffer_get_file_attributes = 0;
static custom_get_view_next_type *get_view_next = 0;
static custom_get_view_prev_type *get_view_prev = 0;
static custom_get_this_ctx_view_type *get_this_ctx_view = 0;
static custom_get_active_view_type *get_active_view = 0;
static custom_view_exists_type *view_exists = 0;
static custom_view_get_buffer_type *view_get_buffer = 0;
static custom_view_get_cursor_pos_type *view_get_cursor_pos = 0;
static custom_view_get_mark_pos_type *view_get_mark_pos = 0;
static custom_view_get_preferred_x_type *view_get_preferred_x = 0;
static custom_view_set_preferred_x_type *view_set_preferred_x = 0;
static custom_view_get_screen_rect_type *view_get_screen_rect = 0;
static custom_view_get_panel_type *view_get_panel = 0;
static custom_panel_get_view_type *panel_get_view = 0;
static custom_panel_is_split_type *panel_is_split = 0;
static custom_panel_is_leaf_type *panel_is_leaf = 0;
static custom_panel_split_type *panel_split = 0;
static custom_panel_set_split_type *panel_set_split = 0;
static custom_panel_swap_children_type *panel_swap_children = 0;
static custom_panel_get_root_type *panel_get_root = 0;
static custom_panel_get_parent_type *panel_get_parent = 0;
static custom_panel_get_child_type *panel_get_child = 0;
static custom_view_close_type *view_close = 0;
static custom_view_get_buffer_region_type *view_get_buffer_region = 0;
static custom_view_get_buffer_scroll_type *view_get_buffer_scroll = 0;
static custom_view_set_active_type *view_set_active = 0;
static custom_view_enqueue_command_function_type *view_enqueue_command_function = 0;
static custom_view_get_setting_type *view_get_setting = 0;
static custom_view_set_setting_type *view_set_setting = 0;
static custom_view_get_managed_scope_type *view_get_managed_scope = 0;
static custom_buffer_compute_cursor_type *buffer_compute_cursor = 0;
static custom_view_compute_cursor_type *view_compute_cursor = 0;
static custom_view_set_camera_bounds_type *view_set_camera_bounds = 0;
static custom_view_get_camera_bounds_type *view_get_camera_bounds = 0;
static custom_view_set_cursor_type *view_set_cursor = 0;
static custom_view_set_buffer_scroll_type *view_set_buffer_scroll = 0;
static custom_view_set_mark_type *view_set_mark = 0;
static custom_view_quit_ui_type *view_quit_ui = 0;
static custom_view_set_buffer_type *view_set_buffer = 0;
static custom_view_push_context_type *view_push_context = 0;
static custom_view_pop_context_type *view_pop_context = 0;
static custom_view_alter_context_type *view_alter_context = 0;
static custom_view_current_context_type *view_current_context = 0;
static custom_view_current_context_hook_memory_type *view_current_context_hook_memory = 0;
static custom_create_user_managed_scope_type *create_user_managed_scope = 0;
static custom_destroy_user_managed_scope_type *destroy_user_managed_scope = 0;
static custom_get_global_managed_scope_type *get_global_managed_scope = 0;
static custom_get_managed_scope_with_multiple_dependencies_type *get_managed_scope_with_multiple_dependencies = 0;
static custom_managed_scope_clear_contents_type *managed_scope_clear_contents = 0;
static custom_managed_scope_clear_self_all_dependent_scopes_type *managed_scope_clear_self_all_dependent_scopes = 0;
static custom_managed_scope_allocator_type *managed_scope_allocator = 0;
static custom_managed_id_group_highest_id_type *managed_id_group_highest_id = 0;
static custom_managed_id_declare_type *managed_id_declare = 0;
static custom_managed_id_get_type *managed_id_get = 0;
static custom_managed_scope_get_attachment_type *managed_scope_get_attachment = 0;
static custom_managed_scope_attachment_erase_type *managed_scope_attachment_erase = 0;
static custom_alloc_managed_memory_in_scope_type *alloc_managed_memory_in_scope = 0;
static custom_alloc_buffer_markers_on_buffer_type *alloc_buffer_markers_on_buffer = 0;
static custom_managed_object_get_item_size_type *managed_object_get_item_size = 0;
static custom_managed_object_get_item_count_type *managed_object_get_item_count = 0;
static custom_managed_object_get_pointer_type *managed_object_get_pointer = 0;
static custom_managed_object_get_type_type *managed_object_get_type = 0;
static custom_managed_object_get_containing_scope_type *managed_object_get_containing_scope = 0;
static custom_managed_object_free_type *managed_object_free = 0;
static custom_managed_object_store_data_type *managed_object_store_data = 0;
static custom_managed_object_load_data_type *managed_object_load_data = 0;
static custom_get_next_input_raw_type *get_next_input_raw = 0;
static custom_get_current_input_sequence_number_type *get_current_input_sequence_number = 0;
static custom_get_current_input_type *get_current_input = 0;
static custom_set_current_input_type *set_current_input = 0;
static custom_leave_current_input_unhandled_type *leave_current_input_unhandled = 0;
static custom_set_custom_hook_type *set_custom_hook = 0;
static custom_get_custom_hook_type *get_custom_hook = 0;
static custom_set_custom_hook_memory_size_type *set_custom_hook_memory_size = 0;
static custom_get_mouse_state_type *get_mouse_state = 0;
static custom_get_active_query_bars_type *get_active_query_bars = 0;
static custom_start_query_bar_type *start_query_bar = 0;
static custom_end_query_bar_type *end_query_bar = 0;
static custom_clear_all_query_bars_type *clear_all_query_bars = 0;
static custom_print_message_type *print_message = 0;
static custom_log_string_type *log_string = 0;
static custom_get_largest_face_id_type *get_largest_face_id = 0;
static custom_set_global_face_type *set_global_face = 0;
static custom_buffer_history_get_max_record_index_type *buffer_history_get_max_record_index = 0;
static custom_buffer_history_get_record_info_type *buffer_history_get_record_info = 0;
static custom_buffer_history_get_group_sub_record_type *buffer_history_get_group_sub_record = 0;
static custom_buffer_history_get_current_state_index_type *buffer_history_get_current_state_index = 0;
static custom_buffer_history_set_current_state_index_type *buffer_history_set_current_state_index = 0;
static custom_buffer_history_merge_record_range_type *buffer_history_merge_record_range = 0;
static custom_buffer_history_clear_after_current_state_type *buffer_history_clear_after_current_state = 0;
static custom_global_history_edit_group_begin_type *global_history_edit_group_begin = 0;
static custom_global_history_edit_group_end_type *global_history_edit_group_end = 0;
static custom_buffer_set_face_type *buffer_set_face = 0;
static custom_get_face_description_type *get_face_description = 0;
static custom_get_face_metrics_type *get_face_metrics = 0;
static custom_get_face_advance_map_type *get_face_advance_map = 0;
static custom_get_face_id_type *get_face_id = 0;
static custom_try_create_new_face_type *try_create_new_face = 0;
static custom_try_modify_face_type *try_modify_face = 0;
static custom_try_release_face_type *try_release_face = 0;
static custom_push_hot_directory_type *push_hot_directory = 0;
static custom_set_hot_directory_type *set_hot_directory = 0;
static custom_send_exit_signal_type *send_exit_signal = 0;
static custom_hard_exit_type *hard_exit = 0;
static custom_set_window_title_type *set_window_title = 0;
static custom_acquire_global_frame_mutex_type *acquire_global_frame_mutex = 0;
static custom_release_global_frame_mutex_type *release_global_frame_mutex = 0;
static custom_draw_string_oriented_type *draw_string_oriented = 0;
static custom_get_string_advance_type *get_string_advance = 0;
static custom_draw_rectangle_type *draw_rectangle = 0;
static custom_draw_rectangle_outline_type *draw_rectangle_outline = 0;
static custom_draw_set_clip_type *draw_set_clip = 0;
static custom_text_layout_create_type *text_layout_create = 0;
static custom_text_layout_region_type *text_layout_region = 0;
static custom_text_layout_get_buffer_type *text_layout_get_buffer = 0;
static custom_text_layout_get_visible_range_type *text_layout_get_visible_range = 0;
static custom_text_layout_line_on_screen_type *text_layout_line_on_screen = 0;
static custom_text_layout_character_on_screen_type *text_layout_character_on_screen = 0;
static custom_paint_text_color_type *paint_text_color = 0;
static custom_paint_text_color_blend_type *paint_text_color_blend = 0;
static custom_text_layout_free_type *text_layout_free = 0;
static custom_draw_text_layout_type *draw_text_layout = 0;
static custom_open_color_picker_type *open_color_picker = 0;
static custom_animate_in_n_milliseconds_type *animate_in_n_milliseconds = 0;
static custom_buffer_find_all_matches_type *buffer_find_all_matches = 0;
static custom_get_core_profile_list_type *get_core_profile_list = 0;
static custom_get_custom_layer_boundary_docs_type *get_custom_layer_boundary_docs = 0;
# 26 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_system_types.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_system_types.h"
typedef i32 Key_Mode;
enum{
    KeyMode_LanguageArranged,
    KeyMode_Physical,
};

struct Plat_Handle{
    u32 d[4];
};
typedef Plat_Handle System_Library;
typedef Plat_Handle System_Thread;
typedef Plat_Handle System_Mutex;
typedef Plat_Handle System_Condition_Variable;
typedef void Thread_Function(void *ptr);
struct CLI_Handles{
    Plat_Handle proc;
    Plat_Handle out_read;
    Plat_Handle out_write;
    Plat_Handle in_read;
    Plat_Handle in_write;
    u32 scratch_space[4];
    i32 exit;
};

typedef i32 System_Path_Code;
enum{
    SystemPath_CurrentDirectory,
    SystemPath_Binary,
    SystemPath_UserDirectory,
};

struct Memory_Annotation_Node{
    Memory_Annotation_Node *next;
    String_Const_u8 location;
    void *address;
    u64 size;
};

struct Memory_Annotation{
    Memory_Annotation_Node *first;
    Memory_Annotation_Node *last;
    i32 count;
};

struct Mutex_Lock{
    Mutex_Lock(System_Mutex mutex);
    ~Mutex_Lock();
    operator System_Mutex();
    System_Mutex mutex;
};
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/generated/system_api.h" 1
# 58 "/home/tabletel/dev/4cc/code/custom/generated/system_api.h"
typedef void system_error_box_type(char* msg);
typedef String_Const_u8 system_get_path_type(Arena* arena, System_Path_Code path_code);
typedef String_Const_u8 system_get_canonical_type(Arena* arena, String_Const_u8 name);
typedef File_List system_get_file_list_type(Arena* arena, String_Const_u8 directory);
typedef File_Attributes system_quick_file_attributes_type(Arena* scratch, String_Const_u8 file_name);
typedef b32 system_load_handle_type(Arena* scratch, char* file_name, Plat_Handle* out);
typedef File_Attributes system_load_attributes_type(Plat_Handle handle);
typedef b32 system_load_file_type(Plat_Handle handle, char* buffer, u32 size);
typedef b32 system_load_close_type(Plat_Handle handle);
typedef File_Attributes system_save_file_type(Arena* scratch, char* file_name, String_Const_u8 data);
typedef b32 system_load_library_type(Arena* scratch, String_Const_u8 file_name, System_Library* out);
typedef b32 system_release_library_type(System_Library handle);
typedef Void_Func* system_get_proc_type(System_Library handle, char* proc_name);
typedef u64 system_now_time_type(void);
typedef Date_Time system_now_date_time_universal_type(void);
typedef Date_Time system_local_date_time_from_universal_type(Date_Time* date_time);
typedef Date_Time system_universal_date_time_from_local_type(Date_Time* date_time);
typedef Plat_Handle system_wake_up_timer_create_type(void);
typedef void system_wake_up_timer_release_type(Plat_Handle handle);
typedef void system_wake_up_timer_set_type(Plat_Handle handle, u32 time_milliseconds);
typedef void system_signal_step_type(u32 code);
typedef void system_sleep_type(u64 microseconds);
typedef String_Const_u8 system_get_clipboard_type(Arena* arena, i32 index);
typedef void system_post_clipboard_type(String_Const_u8 str, i32 index);
typedef void system_set_clipboard_catch_all_type(b32 enabled);
typedef b32 system_get_clipboard_catch_all_type(void);
typedef b32 system_cli_call_type(Arena* scratch, char* path, char* script, CLI_Handles* cli_out);
typedef void system_cli_begin_update_type(CLI_Handles* cli);
typedef b32 system_cli_update_step_type(CLI_Handles* cli, char* dest, u32 max, u32* amount);
typedef b32 system_cli_end_update_type(CLI_Handles* cli);
typedef void system_open_color_picker_type(Color_Picker* picker);
typedef f32 system_get_screen_scale_factor_type(void);
typedef System_Thread system_thread_launch_type(Thread_Function* proc, void* ptr);
typedef void system_thread_join_type(System_Thread thread);
typedef void system_thread_free_type(System_Thread thread);
typedef i32 system_thread_get_id_type(void);
typedef void system_acquire_global_frame_mutex_type(Thread_Context* tctx);
typedef void system_release_global_frame_mutex_type(Thread_Context* tctx);
typedef System_Mutex system_mutex_make_type(void);
typedef void system_mutex_acquire_type(System_Mutex mutex);
typedef void system_mutex_release_type(System_Mutex mutex);
typedef void system_mutex_free_type(System_Mutex mutex);
typedef System_Condition_Variable system_condition_variable_make_type(void);
typedef void system_condition_variable_wait_type(System_Condition_Variable cv, System_Mutex mutex);
typedef void system_condition_variable_signal_type(System_Condition_Variable cv);
typedef void system_condition_variable_free_type(System_Condition_Variable cv);
typedef void* system_memory_allocate_type(u64 size, String_Const_u8 location);
typedef b32 system_memory_set_protection_type(void* ptr, u64 size, u32 flags);
typedef void system_memory_free_type(void* ptr, u64 size);
typedef Memory_Annotation system_memory_annotation_type(Arena* arena);
typedef void system_show_mouse_cursor_type(i32 show);
typedef b32 system_set_fullscreen_type(b32 full_screen);
typedef b32 system_is_fullscreen_type(void);
typedef Input_Modifier_Set system_get_keyboard_modifiers_type(Arena* arena);
typedef void system_set_key_mode_type(Key_Mode mode);
typedef void system_set_source_mixer_type(void* ctx, Audio_Mix_Sources_Function* mix_func);
typedef void system_set_destination_mixer_type(Audio_Mix_Destination_Function* mix_func);
struct API_VTable_system{
system_error_box_type *error_box;
system_get_path_type *get_path;
system_get_canonical_type *get_canonical;
system_get_file_list_type *get_file_list;
system_quick_file_attributes_type *quick_file_attributes;
system_load_handle_type *load_handle;
system_load_attributes_type *load_attributes;
system_load_file_type *load_file;
system_load_close_type *load_close;
system_save_file_type *save_file;
system_load_library_type *load_library;
system_release_library_type *release_library;
system_get_proc_type *get_proc;
system_now_time_type *now_time;
system_now_date_time_universal_type *now_date_time_universal;
system_local_date_time_from_universal_type *local_date_time_from_universal;
system_universal_date_time_from_local_type *universal_date_time_from_local;
system_wake_up_timer_create_type *wake_up_timer_create;
system_wake_up_timer_release_type *wake_up_timer_release;
system_wake_up_timer_set_type *wake_up_timer_set;
system_signal_step_type *signal_step;
system_sleep_type *sleep;
system_get_clipboard_type *get_clipboard;
system_post_clipboard_type *post_clipboard;
system_set_clipboard_catch_all_type *set_clipboard_catch_all;
system_get_clipboard_catch_all_type *get_clipboard_catch_all;
system_cli_call_type *cli_call;
system_cli_begin_update_type *cli_begin_update;
system_cli_update_step_type *cli_update_step;
system_cli_end_update_type *cli_end_update;
system_open_color_picker_type *open_color_picker;
system_get_screen_scale_factor_type *get_screen_scale_factor;
system_thread_launch_type *thread_launch;
system_thread_join_type *thread_join;
system_thread_free_type *thread_free;
system_thread_get_id_type *thread_get_id;
system_acquire_global_frame_mutex_type *acquire_global_frame_mutex;
system_release_global_frame_mutex_type *release_global_frame_mutex;
system_mutex_make_type *mutex_make;
system_mutex_acquire_type *mutex_acquire;
system_mutex_release_type *mutex_release;
system_mutex_free_type *mutex_free;
system_condition_variable_make_type *condition_variable_make;
system_condition_variable_wait_type *condition_variable_wait;
system_condition_variable_signal_type *condition_variable_signal;
system_condition_variable_free_type *condition_variable_free;
system_memory_allocate_type *memory_allocate;
system_memory_set_protection_type *memory_set_protection;
system_memory_free_type *memory_free;
system_memory_annotation_type *memory_annotation;
system_show_mouse_cursor_type *show_mouse_cursor;
system_set_fullscreen_type *set_fullscreen;
system_is_fullscreen_type *is_fullscreen;
system_get_keyboard_modifiers_type *get_keyboard_modifiers;
system_set_key_mode_type *set_key_mode;
system_set_source_mixer_type *set_source_mixer;
system_set_destination_mixer_type *set_destination_mixer;
};
# 234 "/home/tabletel/dev/4cc/code/custom/generated/system_api.h"
static system_error_box_type *system_error_box = 0;
static system_get_path_type *system_get_path = 0;
static system_get_canonical_type *system_get_canonical = 0;
static system_get_file_list_type *system_get_file_list = 0;
static system_quick_file_attributes_type *system_quick_file_attributes = 0;
static system_load_handle_type *system_load_handle = 0;
static system_load_attributes_type *system_load_attributes = 0;
static system_load_file_type *system_load_file = 0;
static system_load_close_type *system_load_close = 0;
static system_save_file_type *system_save_file = 0;
static system_load_library_type *system_load_library = 0;
static system_release_library_type *system_release_library = 0;
static system_get_proc_type *system_get_proc = 0;
static system_now_time_type *system_now_time = 0;
static system_now_date_time_universal_type *system_now_date_time_universal = 0;
static system_local_date_time_from_universal_type *system_local_date_time_from_universal = 0;
static system_universal_date_time_from_local_type *system_universal_date_time_from_local = 0;
static system_wake_up_timer_create_type *system_wake_up_timer_create = 0;
static system_wake_up_timer_release_type *system_wake_up_timer_release = 0;
static system_wake_up_timer_set_type *system_wake_up_timer_set = 0;
static system_signal_step_type *system_signal_step = 0;
static system_sleep_type *system_sleep = 0;
static system_get_clipboard_type *system_get_clipboard = 0;
static system_post_clipboard_type *system_post_clipboard = 0;
static system_set_clipboard_catch_all_type *system_set_clipboard_catch_all = 0;
static system_get_clipboard_catch_all_type *system_get_clipboard_catch_all = 0;
static system_cli_call_type *system_cli_call = 0;
static system_cli_begin_update_type *system_cli_begin_update = 0;
static system_cli_update_step_type *system_cli_update_step = 0;
static system_cli_end_update_type *system_cli_end_update = 0;
static system_open_color_picker_type *system_open_color_picker = 0;
static system_get_screen_scale_factor_type *system_get_screen_scale_factor = 0;
static system_thread_launch_type *system_thread_launch = 0;
static system_thread_join_type *system_thread_join = 0;
static system_thread_free_type *system_thread_free = 0;
static system_thread_get_id_type *system_thread_get_id = 0;
static system_acquire_global_frame_mutex_type *system_acquire_global_frame_mutex = 0;
static system_release_global_frame_mutex_type *system_release_global_frame_mutex = 0;
static system_mutex_make_type *system_mutex_make = 0;
static system_mutex_acquire_type *system_mutex_acquire = 0;
static system_mutex_release_type *system_mutex_release = 0;
static system_mutex_free_type *system_mutex_free = 0;
static system_condition_variable_make_type *system_condition_variable_make = 0;
static system_condition_variable_wait_type *system_condition_variable_wait = 0;
static system_condition_variable_signal_type *system_condition_variable_signal = 0;
static system_condition_variable_free_type *system_condition_variable_free = 0;
static system_memory_allocate_type *system_memory_allocate = 0;
static system_memory_set_protection_type *system_memory_set_protection = 0;
static system_memory_free_type *system_memory_free = 0;
static system_memory_annotation_type *system_memory_annotation = 0;
static system_show_mouse_cursor_type *system_show_mouse_cursor = 0;
static system_set_fullscreen_type *system_set_fullscreen = 0;
static system_is_fullscreen_type *system_is_fullscreen = 0;
static system_get_keyboard_modifiers_type *system_get_keyboard_modifiers = 0;
static system_set_key_mode_type *system_set_key_mode = 0;
static system_set_source_mixer_type *system_set_source_mixer = 0;
static system_set_destination_mixer_type *system_set_destination_mixer = 0;
# 29 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2




# 1 "/home/tabletel/dev/4cc/code/custom/4coder_token.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_token.h"
typedef i16 Token_Base_Kind;
enum{
    TokenBaseKind_EOF = 0,
    TokenBaseKind_Whitespace = 1,
    TokenBaseKind_LexError = 2,
    TokenBaseKind_Comment = 3,
    TokenBaseKind_Keyword = 4,
    TokenBaseKind_Preprocessor = 5,
    TokenBaseKind_Identifier = 6,
    TokenBaseKind_Operator = 7,
    TokenBaseKind_LiteralInteger = 8,
    TokenBaseKind_LiteralFloat = 9,
    TokenBaseKind_LiteralString = 10,
    TokenBaseKind_ScopeOpen = 11,
    TokenBaseKind_ScopeClose = 12,
    TokenBaseKind_ParentheticalOpen = 13,
    TokenBaseKind_ParentheticalClose = 14,
    TokenBaseKind_StatementClose = 15,

    TokenBaseKind_COUNT = 16,
};

char *token_base_kind_names[] ={
    "EOF",
    "Whitespace",
    "LexError",
    "Comment",
    "Keyword",
    "Preprocessor",
    "Identifier",
    "Operator",
    "LiteralInteger",
    "LiteralFloat",
    "LiteralString",
    "ScopeOpen",
    "ScopeClose",
    "ParentheticalOpen",
    "ParentheticalClose",
};

typedef u16 Token_Base_Flag;
enum{
    TokenBaseFlag_PreprocessorBody = 1,
};

struct Token{
    i64 pos;
    i64 size;
    Token_Base_Kind kind;
    Token_Base_Flag flags;
    i16 sub_kind;
    u16 sub_flags;
};

struct Token_Pair{
    Token a;
    Token b;
};

struct Token_Array{
    Token *tokens;
    i64 count;
    i64 max;
};

struct Token_Block{
    Token_Block *next;
    Token_Block *prev;
    Token *tokens;
    i64 count;
    i64 max;
};

struct Token_List{
    Token_Block *first;
    Token_Block *last;
    i64 node_count;
    i64 total_count;
};

struct Token_Relex{
    b32 successful_resync;
    i64 first_resync_index;
};

struct Token_Iterator_Array{
    u64 user_id;
    Token *ptr;
    Token *tokens;
    i64 count;
};

struct Token_Iterator_List{
    u64 user_id;
    i64 index;
    Token *ptr;
    Token_Block *block;
    Token_Block *first;
    Token_Block *last;
    i64 node_count;
    i64 total_count;
};

typedef i32 Token_Iterator_Kind;
enum{
    TokenIterator_Array,
    TokenIterator_List,
};

struct Token_Iterator{
    Token_Iterator_Kind kind;
    union{
        Token_Iterator_Array array;
        Token_Iterator_List list;
    };
};
# 34 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/generated/lexer_cpp.h" 1



struct Lexeme_Table_Value{
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

struct Lexeme_Table_Lookup{
    b32 found_match;
    Token_Base_Kind base_kind;
    u16 sub_kind;
};


typedef u16 Token_Cpp_Kind;
enum{
TokenCppKind_EOF = 0,
TokenCppKind_Whitespace = 1,
TokenCppKind_LexError = 2,
TokenCppKind_BlockComment = 3,
TokenCppKind_LineComment = 4,
TokenCppKind_Backslash = 5,
TokenCppKind_LiteralInteger = 6,
TokenCppKind_LiteralIntegerU = 7,
TokenCppKind_LiteralIntegerL = 8,
TokenCppKind_LiteralIntegerUL = 9,
TokenCppKind_LiteralIntegerLL = 10,
TokenCppKind_LiteralIntegerULL = 11,
TokenCppKind_LiteralIntegerHex = 12,
TokenCppKind_LiteralIntegerHexU = 13,
TokenCppKind_LiteralIntegerHexL = 14,
TokenCppKind_LiteralIntegerHexUL = 15,
TokenCppKind_LiteralIntegerHexLL = 16,
TokenCppKind_LiteralIntegerHexULL = 17,
TokenCppKind_LiteralIntegerOct = 18,
TokenCppKind_LiteralIntegerOctU = 19,
TokenCppKind_LiteralIntegerOctL = 20,
TokenCppKind_LiteralIntegerOctUL = 21,
TokenCppKind_LiteralIntegerOctLL = 22,
TokenCppKind_LiteralIntegerOctULL = 23,
TokenCppKind_LiteralFloat32 = 24,
TokenCppKind_LiteralFloat64 = 25,
TokenCppKind_LiteralString = 26,
TokenCppKind_LiteralStringWide = 27,
TokenCppKind_LiteralStringUTF8 = 28,
TokenCppKind_LiteralStringUTF16 = 29,
TokenCppKind_LiteralStringUTF32 = 30,
TokenCppKind_LiteralStringRaw = 31,
TokenCppKind_LiteralStringWideRaw = 32,
TokenCppKind_LiteralStringUTF8Raw = 33,
TokenCppKind_LiteralStringUTF16Raw = 34,
TokenCppKind_LiteralStringUTF32Raw = 35,
TokenCppKind_LiteralCharacter = 36,
TokenCppKind_LiteralCharacterWide = 37,
TokenCppKind_LiteralCharacterUTF8 = 38,
TokenCppKind_LiteralCharacterUTF16 = 39,
TokenCppKind_LiteralCharacterUTF32 = 40,
TokenCppKind_PPIncludeFile = 41,
TokenCppKind_PPErrorMessage = 42,
TokenCppKind_KeywordGeneric = 43,
TokenCppKind_BraceOp = 44,
TokenCppKind_BraceCl = 45,
TokenCppKind_ParenOp = 46,
TokenCppKind_BrackOp = 47,
TokenCppKind_ParenCl = 48,
TokenCppKind_BrackCl = 49,
TokenCppKind_Semicolon = 50,
TokenCppKind_Colon = 51,
TokenCppKind_DotDotDot = 52,
TokenCppKind_ColonColon = 53,
TokenCppKind_PlusPlus = 54,
TokenCppKind_MinusMinus = 55,
TokenCppKind_Dot = 56,
TokenCppKind_Arrow = 57,
TokenCppKind_Plus = 58,
TokenCppKind_Minus = 59,
TokenCppKind_Not = 60,
TokenCppKind_Tilde = 61,
TokenCppKind_Star = 62,
TokenCppKind_And = 63,
TokenCppKind_DotStar = 64,
TokenCppKind_ArrowStar = 65,
TokenCppKind_Div = 66,
TokenCppKind_Mod = 67,
TokenCppKind_LeftLeft = 68,
TokenCppKind_RightRight = 69,
TokenCppKind_Compare = 70,
TokenCppKind_Less = 71,
TokenCppKind_LessEq = 72,
TokenCppKind_Grtr = 73,
TokenCppKind_GrtrEq = 74,
TokenCppKind_EqEq = 75,
TokenCppKind_NotEq = 76,
TokenCppKind_Xor = 77,
TokenCppKind_Or = 78,
TokenCppKind_AndAnd = 79,
TokenCppKind_OrOr = 80,
TokenCppKind_Ternary = 81,
TokenCppKind_Eq = 82,
TokenCppKind_PlusEq = 83,
TokenCppKind_MinusEq = 84,
TokenCppKind_StarEq = 85,
TokenCppKind_DivEq = 86,
TokenCppKind_ModEq = 87,
TokenCppKind_LeftLeftEq = 88,
TokenCppKind_RightRightEq = 89,
TokenCppKind_Comma = 90,
TokenCppKind_PPStringify = 91,
TokenCppKind_PPConcat = 92,
TokenCppKind_Void = 93,
TokenCppKind_Bool = 94,
TokenCppKind_Char = 95,
TokenCppKind_Int = 96,
TokenCppKind_Float = 97,
TokenCppKind_Double = 98,
TokenCppKind_Long = 99,
TokenCppKind_Short = 100,
TokenCppKind_Unsigned = 101,
TokenCppKind_Signed = 102,
TokenCppKind_Const = 103,
TokenCppKind_Volatile = 104,
TokenCppKind_Asm = 105,
TokenCppKind_Break = 106,
TokenCppKind_Case = 107,
TokenCppKind_Catch = 108,
TokenCppKind_Continue = 109,
TokenCppKind_Default = 110,
TokenCppKind_Do = 111,
TokenCppKind_Else = 112,
TokenCppKind_For = 113,
TokenCppKind_Goto = 114,
TokenCppKind_If = 115,
TokenCppKind_Return = 116,
TokenCppKind_Switch = 117,
TokenCppKind_Try = 118,
TokenCppKind_While = 119,
TokenCppKind_StaticAssert = 120,
TokenCppKind_ConstCast = 121,
TokenCppKind_DynamicCast = 122,
TokenCppKind_ReinterpretCast = 123,
TokenCppKind_StaticCast = 124,
TokenCppKind_Class = 125,
TokenCppKind_Enum = 126,
TokenCppKind_Struct = 127,
TokenCppKind_Typedef = 128,
TokenCppKind_Union = 129,
TokenCppKind_Template = 130,
TokenCppKind_Typename = 131,
TokenCppKind_Friend = 132,
TokenCppKind_Namespace = 133,
TokenCppKind_Private = 134,
TokenCppKind_Protected = 135,
TokenCppKind_Public = 136,
TokenCppKind_Using = 137,
TokenCppKind_Extern = 138,
TokenCppKind_Export = 139,
TokenCppKind_Inline = 140,
TokenCppKind_Static = 141,
TokenCppKind_Virtual = 142,
TokenCppKind_AlignAs = 143,
TokenCppKind_Explicit = 144,
TokenCppKind_NoExcept = 145,
TokenCppKind_NullPtr = 146,
TokenCppKind_Operator = 147,
TokenCppKind_Register = 148,
TokenCppKind_This = 149,
TokenCppKind_ThreadLocal = 150,
TokenCppKind_SizeOf = 151,
TokenCppKind_AlignOf = 152,
TokenCppKind_DeclType = 153,
TokenCppKind_TypeID = 154,
TokenCppKind_New = 155,
TokenCppKind_Delete = 156,
TokenCppKind_LiteralTrue = 157,
TokenCppKind_LiteralFalse = 158,
TokenCppKind_Identifier = 159,
TokenCppKind_PPInclude = 160,
TokenCppKind_PPVersion = 161,
TokenCppKind_PPDefine = 162,
TokenCppKind_PPUndef = 163,
TokenCppKind_PPIf = 164,
TokenCppKind_PPIfDef = 165,
TokenCppKind_PPIfNDef = 166,
TokenCppKind_PPElse = 167,
TokenCppKind_PPElIf = 168,
TokenCppKind_PPEndIf = 169,
TokenCppKind_PPError = 170,
TokenCppKind_PPImport = 171,
TokenCppKind_PPUsing = 172,
TokenCppKind_PPLine = 173,
TokenCppKind_PPPragma = 174,
TokenCppKind_PPUnknown = 175,
TokenCppKind_PPDefined = 176,
TokenCppKind_COUNT = 177,
};
char *token_cpp_kind_names[] = {
"EOF",
"Whitespace",
"LexError",
"BlockComment",
"LineComment",
"Backslash",
"LiteralInteger",
"LiteralIntegerU",
"LiteralIntegerL",
"LiteralIntegerUL",
"LiteralIntegerLL",
"LiteralIntegerULL",
"LiteralIntegerHex",
"LiteralIntegerHexU",
"LiteralIntegerHexL",
"LiteralIntegerHexUL",
"LiteralIntegerHexLL",
"LiteralIntegerHexULL",
"LiteralIntegerOct",
"LiteralIntegerOctU",
"LiteralIntegerOctL",
"LiteralIntegerOctUL",
"LiteralIntegerOctLL",
"LiteralIntegerOctULL",
"LiteralFloat32",
"LiteralFloat64",
"LiteralString",
"LiteralStringWide",
"LiteralStringUTF8",
"LiteralStringUTF16",
"LiteralStringUTF32",
"LiteralStringRaw",
"LiteralStringWideRaw",
"LiteralStringUTF8Raw",
"LiteralStringUTF16Raw",
"LiteralStringUTF32Raw",
"LiteralCharacter",
"LiteralCharacterWide",
"LiteralCharacterUTF8",
"LiteralCharacterUTF16",
"LiteralCharacterUTF32",
"PPIncludeFile",
"PPErrorMessage",
"KeywordGeneric",
"BraceOp",
"BraceCl",
"ParenOp",
"BrackOp",
"ParenCl",
"BrackCl",
"Semicolon",
"Colon",
"DotDotDot",
"ColonColon",
"PlusPlus",
"MinusMinus",
"Dot",
"Arrow",
"Plus",
"Minus",
"Not",
"Tilde",
"Star",
"And",
"DotStar",
"ArrowStar",
"Div",
"Mod",
"LeftLeft",
"RightRight",
"Compare",
"Less",
"LessEq",
"Grtr",
"GrtrEq",
"EqEq",
"NotEq",
"Xor",
"Or",
"AndAnd",
"OrOr",
"Ternary",
"Eq",
"PlusEq",
"MinusEq",
"StarEq",
"DivEq",
"ModEq",
"LeftLeftEq",
"RightRightEq",
"Comma",
"PPStringify",
"PPConcat",
"Void",
"Bool",
"Char",
"Int",
"Float",
"Double",
"Long",
"Short",
"Unsigned",
"Signed",
"Const",
"Volatile",
"Asm",
"Break",
"Case",
"Catch",
"Continue",
"Default",
"Do",
"Else",
"For",
"Goto",
"If",
"Return",
"Switch",
"Try",
"While",
"StaticAssert",
"ConstCast",
"DynamicCast",
"ReinterpretCast",
"StaticCast",
"Class",
"Enum",
"Struct",
"Typedef",
"Union",
"Template",
"Typename",
"Friend",
"Namespace",
"Private",
"Protected",
"Public",
"Using",
"Extern",
"Export",
"Inline",
"Static",
"Virtual",
"AlignAs",
"Explicit",
"NoExcept",
"NullPtr",
"Operator",
"Register",
"This",
"ThreadLocal",
"SizeOf",
"AlignOf",
"DeclType",
"TypeID",
"New",
"Delete",
"LiteralTrue",
"LiteralFalse",
"Identifier",
"PPInclude",
"PPVersion",
"PPDefine",
"PPUndef",
"PPIf",
"PPIfDef",
"PPIfNDef",
"PPElse",
"PPElIf",
"PPEndIf",
"PPError",
"PPImport",
"PPUsing",
"PPLine",
"PPPragma",
"PPUnknown",
"PPDefined",
};
# 35 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_variables.h" 1
# 13 "/home/tabletel/dev/4cc/code/custom/4coder_variables.h"
typedef u64 String_ID;

struct Variable{
    Variable *parent;
    Variable *next;
    String_ID key;
    String_ID string;
    Variable *first;
    Variable *last;
};

struct Variable_Handle{
    Variable *ptr;
};
# 36 "/home/tabletel/dev/4cc/code/custom/4coder_variables.h"
static String_ID vars_save_string(String_Const_u8 string);

static String8 vars_read_string(Arena *arena, String_ID id);

static Variable_Handle vars_get_root(void);
static Variable_Handle vars_get_nil(void);
static b32 vars_is_nil(Variable_Handle var);
static b32 vars_is_nil(Variable *var);
static b32 vars_match(Variable_Handle a, Variable_Handle b);

static Variable_Handle vars_first_child(Variable_Handle var);
static Variable_Handle vars_next_sibling(Variable_Handle var);
static Variable_Handle vars_parent(Variable_Handle var);



static Variable_Handle vars_read_key(Variable_Handle var, String_ID key);
static String_ID vars_key_id_from_var(Variable_Handle var);
static String8 vars_key_from_var(Arena *arena, Variable_Handle var);

static String_ID vars_string_id_from_var(Variable_Handle var);
static String8 vars_string_from_var(Arena *arena, Variable_Handle var);
static b32 vars_b32_from_var(Variable_Handle var);
static u64 vars_u64_from_var(Application_Links *app, Variable_Handle var);

static void vars_set_string(Variable_Handle var, String_ID string);
static void vars_erase(Variable_Handle var, String_ID key);
static Variable_Handle vars_new_variable(Variable_Handle var, String_ID key);
static Variable_Handle vars_new_variable(Variable_Handle var, String_ID key, String_ID string);
static void vars_clear_keys(Variable_Handle var);

static void vars_print_indented(Application_Links *app, Variable_Handle var, i32 indent);
static void vars_print(Application_Links *app, Variable_Handle var);
# 37 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_audio.h" 1
# 9 "/home/tabletel/dev/4cc/code/custom/4coder_audio.h"
struct Audio_Control{
    volatile f32 channel_volume[2];
 volatile u32 generation;
 volatile u32 last_played_sample_index;
    volatile b32 loop;
};

struct Audio_Clip{
    i16 *samples;
    Audio_Control *control;
    f32 channel_volume[2];

    u32 sample_count;
    u32 at_sample_index;
};

struct Audio_System{
    volatile u32 quit;
    volatile u32 ticket;
    volatile u32 serving;
 volatile u32 generation;

    Audio_Clip playing_clips[64];


    volatile u32 pending_clip_count;
    Audio_Clip pending_clips[64];
};




static void def_audio_init(void);
static void def_audio_play_clip(Audio_Clip clip, Audio_Control *control);
static b32 def_audio_is_playing(Audio_Control *control);
static void def_audio_stop(Audio_Control *control);

static void def_audio_mix_sources(void *ctx, f32 *mix_buffer, u32 sample_count);
static void def_audio_mix_destination(i16 *dst, f32 *src, u32 sample_count);




static Audio_Clip audio_clip_from_wav_data(String_Const_u8 data);
static Audio_Clip audio_clip_from_wav_FILE(Arena *arena, FILE *file);
static Audio_Clip audio_clip_from_wav_file_name(Arena *arena, char *file_name);
# 38 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_profile.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_profile.h"
struct Profile_Global_List{
    System_Mutex mutex;
    Arena node_arena;
    Arena_Node *first_arena;
    Arena_Node *last_arena;
    Profile_Thread *first_thread;
    Profile_Thread *last_thread;
    i32 thread_count;
    Profile_Enable_Flag disable_bits;
};

struct Profile_Block{
    Thread_Context *tctx;
    Profile_Global_List *list;
    b32 is_closed;
    Profile_ID id;

    Profile_Block(Thread_Context *tctx, Profile_Global_List *list,
                  String_Const_u8 name, String_Const_u8 location);
    Profile_Block(Application_Links *app, String_Const_u8 name, String_Const_u8 location);
    ~Profile_Block();
    void close_now();
};

struct Profile_Scope_Block{
    Thread_Context *tctx;
    Profile_Global_List *list;
    b32 is_closed;
    Profile_ID id;

    Profile_Scope_Block(Thread_Context *tctx, Profile_Global_List *list,
                        String_Const_u8 name, String_Const_u8 location);
    Profile_Scope_Block(Application_Links *app, String_Const_u8 name, String_Const_u8 location);
    ~Profile_Scope_Block();
    void close_now();
};
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.h"
typedef void Async_Task_Function_Type(struct Async_Context *actx, String_Const_u8 data);
typedef u64 Async_Task;

struct Async_Thread{
    struct Async_System *async_system;
    System_Thread thread;
    struct Async_Node *node;
    Async_Task task;
    b32 cancel_signal;
};

struct Async_Node{
    union{
        Async_Node *next;
        Node node;
    };
    Async_Task task;
    Async_Thread *thread;
    Async_Task_Function_Type *func;
    String_Const_u8 data;
};

struct Async_System{
    void *cmd_context;

    Heap node_heap;
    Arena node_arena;
    System_Mutex mutex;
    System_Condition_Variable cv;
    System_Condition_Variable join_cv;
    Async_Task task_id_counter;
    Async_Node *free_nodes;
    Node task_sent;
    i32 task_count;

    Async_Thread thread;
};

struct Async_Context{
    Application_Links *app;
    Async_Thread *thread;
};
# 40 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_string_match.h" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_string_match.h"
typedef b32 Buffer_Predicate(Application_Links *app, Buffer_ID buffer);
# 41 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_helper.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_helper.h"
struct File_Name_Data{
    String_Const_u8 file_name;
    String_Const_u8 data;
};

struct View_Context_Block{
    Application_Links *app;
    View_ID view;

    View_Context_Block(Application_Links *app, View_ID view, View_Context *ctx);
    ~View_Context_Block();
};



typedef i32 Position_Within_Line;
enum{
    PositionWithinLine_Start,
    PositionWithinLine_SkipLeadingWhitespace,
    PositionWithinLine_End,
};

typedef u32 Buffer_Seek_String_Flags;
enum{
    BufferSeekString_Backward = 1,
    BufferSeekString_CaseInsensitive = 2,
};



typedef b8 Character_Predicate_Function(u8 c);

static Character_Predicate character_predicate_alpha = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        254, 255, 255, 7, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_alpha_numeric = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 7, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_alpha_numeric_underscore = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 135, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_uppercase = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        254, 255, 255, 7, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_lowercase = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_base10 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_base16 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        126, 0, 0, 0, 126, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_whitespace = { {
        0, 62, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_non_whitespace = { {
        255, 193, 255, 255, 254, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

static Character_Predicate character_predicate_utf8_byte = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

static Character_Predicate character_predicate_alpha_numeric_utf8 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 7, 254, 255, 255, 7,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

static Character_Predicate character_predicate_alpha_numeric_underscore_utf8 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 135, 254, 255, 255, 7,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

typedef i64 Boundary_Function(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos);

struct Boundary_Function_Node{
    Boundary_Function_Node *next;
    Boundary_Function *func;
};
struct Boundary_Function_List{
    Boundary_Function_Node *first;
    Boundary_Function_Node *last;
    i32 count;
};

typedef Range_i64 Enclose_Function(Application_Links *app, Buffer_ID buffer, Range_i64 range);

struct Indent_Info{
    i64 first_char_pos;
    i32 indent_pos;
    b32 is_blank;
    b32 all_space;
};



struct Sort_Pair_i32{
    i32 index;
    i32 key;
};



struct History_Group{
    Application_Links *app;
    Buffer_ID buffer;
    History_Record_Index first;
};



typedef i32 View_Split_Kind;
enum{
    ViewSplitKind_Ratio,
    ViewSplitKind_FixedPixels,
};



typedef i32 Nest_Delimiter_Kind;
enum{
    NestDelim_None = 0,
    NestDelim_Open = 1,
    NestDelim_Close = 2,
};

typedef u32 Find_Nest_Flag;
enum{
    FindNest_Scope = 1,
    FindNest_Paren = 2,
    FindNest_EndOfToken = 4,
    FindNest_Balanced = 8,
};
# 42 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_delta_rule.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_delta_rule.h"
union Delta_Context_Header{
    Buffer_Point point;
    Vec2_f32 p;
};
struct Buffer_Point_Delta_Result{
    Buffer_Point point;
    b32 still_animating;
};
struct Vec2_f32_Delta_Result{
    Vec2_f32 p;
    b32 still_animating;
};

struct Smooth_Step{
    f32 p;
    f32 v;
};
# 43 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.h"
struct Newline_Layout_Vars{
    i64 newline_character_index;
    b32 consuming_newline_characters;
    b32 prev_did_emit_newline;
};

struct LefRig_TopBot_Layout_Vars{
    Face_Advance_Map *advance_map;
    Face_Metrics *metrics;
    f32 tab_width;
    f32 line_to_text_shift;

    Vec2_f32 blank_dim;

    Vec2_f32 p;
    f32 line_y;
    f32 text_y;
    f32 width;
};

struct Layout_Reflex{
    Layout_Item_List *list;
    Buffer_ID buffer;
    f32 width;
    Face_ID face;
};

typedef i32 Layout_Wrap_Kind;
enum{
    Layout_Unwrapped,
    Layout_Wrapped,
};

typedef i32 Layout_Virtual_Indent;
enum{
    LayoutVirtualIndent_Off,
    LayoutVirtualIndent_On,
};
# 44 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_code_index.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_code_index.h"
struct Code_Index_Nest_List{
    struct Code_Index_Nest *first;
    struct Code_Index_Nest *last;
    i32 count;
};

struct Code_Index_Nest_Ptr_Array{
    struct Code_Index_Nest **ptrs;
    i32 count;
};

typedef i32 Code_Index_Nest_Kind;
enum{
    CodeIndexNest_Scope,
    CodeIndexNest_Paren,
    CodeIndexNest_Preprocessor,
    CodeIndexNest_Statement,
};

struct Code_Index_Nest{
    Code_Index_Nest *next;

    Code_Index_Nest_Kind kind;
    b32 is_closed;
    Range_i64 open;
    Range_i64 close;

    struct Code_Index_File *file;
    Code_Index_Nest *parent;

    Code_Index_Nest_List nest_list;
    Code_Index_Nest_Ptr_Array nest_array;
};

typedef i64 Code_Index_Note_Kind;
enum{
    CodeIndexNote_Type,
    CodeIndexNote_Function,
    CodeIndexNote_Macro,
    CodeIndexNote_4coderCommand,
};

struct Code_Index_Note{
    Code_Index_Note *next;
    Code_Index_Note_Kind note_kind;
    Range_i64 pos;
    String_Const_u8 text;
    struct Code_Index_File *file;
    Code_Index_Nest *parent;

    Code_Index_Note *prev_in_hash;
    Code_Index_Note *next_in_hash;
};

struct Code_Index_Note_List{
    Code_Index_Note *first;
    Code_Index_Note *last;
    i32 count;
};

struct Code_Index_Note_Ptr_Array{
    Code_Index_Note **ptrs;
    i32 count;
};

struct Code_Index_File{
    Code_Index_Nest_List nest_list;
    Code_Index_Nest_Ptr_Array nest_array;
    Code_Index_Note_List note_list;
    Code_Index_Note_Ptr_Array note_array;
    Buffer_ID buffer;
};

struct Code_Index_File_Storage{
    Code_Index_File_Storage *next;
    Code_Index_File_Storage *prev;
    Arena arena;
    Code_Index_File *file;
};

struct Code_Index{
    System_Mutex mutex;
    Arena node_arena;
    Table_u64_u64 buffer_to_index_file;
    Code_Index_File_Storage *free_storage;
    Code_Index_File_Storage *storage_first;
    Code_Index_File_Storage *storage_last;
    i32 storage_count;

    Code_Index_Note_List name_hash[4099];
};



typedef void Generic_Parse_Comment_Function(Application_Links *app, Arena *arena, Code_Index_File *index,
                                            Token *token, String_Const_u8 contents);

struct Generic_Parse_State{
    Application_Links *app;
    Arena *arena;
    String_Const_u8 contents;
    Token_Iterator_Array it;
    Generic_Parse_Comment_Function *handle_comment;
    u8 *prev_line_start;
    b32 finished;

    i32 scope_counter;
    i32 paren_counter;
    b32 in_preprocessor;
    b32 in_statement;

    b32 do_cpp_parse;
};
# 45 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_draw.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_draw.h"
struct Comment_Highlight_Pair{
    String_Const_u8 needle;
     ARGB_Color color;
};

typedef i32 Range_Highlight_Kind;
enum{
    RangeHighlightKind_LineHighlight,
    RangeHighlightKind_CharacterHighlight,
};
# 46 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.h"
struct Buffer_Insertion{
    Application_Links *app;
    Buffer_ID buffer;
    i64 at;
    b32 buffering;
    Cursor *cursor;
    Temp_Memory temp;
};
# 47 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.h"
typedef i64 Command_Map_ID;

struct Command_Trigger{
    Command_Trigger *next;
    Input_Event_Kind kind;
    u32 sub_code;
    Input_Modifier_Set mods;
};

struct Command_Trigger_List{
    Command_Trigger *first;
    Command_Trigger *last;
};

struct Command_Binding{
    union{
        Custom_Command_Function *custom;
        char *name;
    };

    Command_Binding();
    Command_Binding(Custom_Command_Function *c);
    Command_Binding(char *n);

    operator Custom_Command_Function*();
    operator char*();
};

struct Command_Modified_Binding{
    Command_Modified_Binding *next;
    SNode order_node;
    Input_Modifier_Set mods;
    Command_Binding binding;
};

struct Command_Binding_List{
    Command_Binding_List *next;
    SNode *first;
    SNode *last;
    i32 count;
};

struct Command_Map{
    Command_Map *next;
    Command_Map *prev;
    Command_Map_ID id;
    Command_Map_ID parent;
    Command_Binding text_input_command;
    Arena node_arena;
    Table_u64_u64 event_code_to_binding_list;
    Table_u64_u64 cmd_to_binding_trigger;
    Command_Modified_Binding *binding_first;
    Command_Modified_Binding *binding_last;
    Command_Binding_List *list_first;
    Command_Binding_List *list_last;

    struct Binding_Unit *real_beginning;
};

struct Mapping{
    Arena node_arena;
    Heap heap;
    Base_Allocator heap_wrapper;
    Table_u64_u64 id_to_map;
    Command_Map_ID id_counter;
    Command_Map *first_map;
    Command_Map *last_map;
    Command_Map *free_maps;
    Command_Modified_Binding *free_bindings;
    Command_Binding_List *free_lists;
};

typedef i32 Binding_Match_Rule;
enum{
    BindingMatchRule_Strict,
    BindingMatchRule_Loose,
};

struct Map_Event_Breakdown{
    Input_Modifier_Set *mod_set;
    u64 key;
    Key_Code skip_self_mod;
};
# 48 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_lister_base.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_lister_base.h"
typedef i32 Lister_Activation_Code;
enum{
    ListerActivation_Finished = 0,
    ListerActivation_Continue = 1,
    ListerActivation_ContinueAndRefresh = 2,
};

typedef void Lister_Regenerate_List_Function_Type(Application_Links *app, struct Lister *lister);

struct Lister_Node{
    Lister_Node *next;
    Lister_Node *prev;
    String_Const_u8 string;
    union{
        String_Const_u8 status;
        i32 index;
    };
    void *user_data;
    i32 raw_index;
};

struct Lister_Node_List{
    Lister_Node *first;
    Lister_Node *last;
    i32 count;
};

struct Lister_Node_Ptr_Array{
    Lister_Node **node_ptrs;
    i32 count;
};

typedef Lister_Activation_Code Lister_Write_Character_Function(Application_Links *app);
typedef Lister_Activation_Code Lister_Key_Stroke_Function(Application_Links *app);
typedef void Lister_Navigate_Function(Application_Links *app,
                                      View_ID view, struct Lister *lister,
                                      i32 index_delta);

struct Lister_Handlers{
    Lister_Regenerate_List_Function_Type *refresh;
    Lister_Write_Character_Function *write_character;
    Custom_Command_Function *backspace;
    Lister_Navigate_Function *navigate;
    Lister_Key_Stroke_Function *key_stroke;
};

struct Lister_Result{
    b32 canceled;
    b32 activated_by_click;
    String_Const_u8 text_field;
    void *user_data;
};

struct Lister{
    Arena *arena;
    Temp_Memory restore_all_point;

    Lister_Handlers handlers;

    Mapping *mapping;
    Command_Map *map;

    u8 query_space[256];
    u8 text_field_space[256];
    u8 key_string_space[256];
    String_u8 query;
    String_u8 text_field;
    String_u8 key_string;

    Lister_Node_List options;
    Temp_Memory filter_restore_point;
    Lister_Node_Ptr_Array filtered;

    b32 set_vertical_focus_to_item;
    Lister_Node *highlighted_node;
    void *hot_user_data;
    i32 item_index;
    i32 raw_item_index;

    Basic_Scroll scroll;
    i32 visible_count;

    Lister_Result out;
};

struct Lister_Prev_Current{
    Lister *prev;
    Lister *current;
};

struct Lister_Block{
    Application_Links *app;
    Lister_Prev_Current lister;
    Lister_Block(Application_Links *app, Arena *arena);
    ~Lister_Block();
    operator Lister *();
};

struct Lister_Prealloced_String{
    String_Const_u8 string;
};

struct Lister_Filtered{
    Lister_Node_Ptr_Array exact_matches;
    Lister_Node_Ptr_Array before_extension_matches;
    Lister_Node_Ptr_Array substring_matches;
};



struct Lister_Choice{
    Lister_Choice *next;
    String_Const_u8 string;
    String_Const_u8 status;
    Key_Code key_code;
    union{
        u64 user_data;
        void *user_data_ptr;
    };
};

struct Lister_Choice_List{
    Lister_Choice *first;
    Lister_Choice *last;
};
# 49 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.h"
struct Clipboard{
    Arena arena;
    Heap heap;
    String_Const_u8 *clips;
    u32 clip_index;
    u32 clip_capacity;
};
# 50 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.h" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.h"
typedef i64 Rewrite_Type;
enum{
    Rewrite_None,
    Rewrite_NoChange,
    Rewrite_Paste,
    Rewrite_WordComplete
};



struct ID_Line_Column_Jump_Location{
    Buffer_ID buffer_id;
    i32 line;
    i32 column;
};
typedef ID_Line_Column_Jump_Location ID_Based_Jump_Location;

struct ID_Pos_Jump_Location{
    Buffer_ID buffer_id;
    i64 pos;
};

struct Name_Line_Column_Location{
    String_Const_u8 file;
    i32 line;
    i32 column;
};

struct Parsed_Jump{
    b32 success;
    Name_Line_Column_Location location;
    i32 colon_position;
    b32 is_sub_jump;
    b32 sub_jump_indented;
    b32 sub_jump_note;
    b32 is_ms_style;
    b32 has_rust_arrow;
};

struct ID_Pos_Jump_Location_Array{
    struct ID_Pos_Jump_Location *jumps;
    i32 count;
};





struct Point_Stack_Slot{
    Buffer_ID buffer;
    Managed_Object object;
};

struct Point_Stack{
    Point_Stack_Slot markers[100 + 1];
    i32 top;
    i32 bot;
};



typedef i32 Fallback_Dispatch_Result_Code;
enum{
    FallbackDispatch_Unhandled,
    FallbackDispatch_DidCall,
    FallbackDispatch_DelayedUICall,
};

struct Fallback_Dispatch_Result{
    Fallback_Dispatch_Result_Code code;
    Custom_Command_Function *func;
};



typedef void View_Render_Hook(Application_Links *app, View_ID view, Frame_Info frame_info, Rect_f32 inner);



static b32
do_buffer_kill_user_check(Application_Links *app, Buffer_ID buffer, View_ID view);

static b32
do_4coder_close_user_check(Application_Links *app, View_ID view);



struct Buffer_Modified_Node{
    Buffer_Modified_Node *next;
    Buffer_Modified_Node *prev;
    Buffer_ID buffer;
};

struct Buffer_Modified_Set{
    Arena arena;
    Buffer_Modified_Node *free;
    Buffer_Modified_Node *first;
    Buffer_Modified_Node *last;
    Table_u64_u64 id_to_node;
};



struct Fade_Range{
    Fade_Range *next;
    Buffer_ID buffer_id;
    f32 t;
    f32 full_t;
    ARGB_Color color;
    b32 negate_fade_direction;
    Range_i64 range;

    void (*finish_call)(Application_Links *app, struct Fade_Range *range);
    void *opaque[4];
};

struct Fade_Range_List{
    Fade_Range *first;
    Fade_Range *last;
    i32 count;
};





struct Implicit_Map_Result{
    String_ID map;
    Custom_Command_Function *command;
};

typedef Implicit_Map_Result Implicit_Map_Function(Application_Links *app,
                                                  String_ID buffer_language,
                                                  String_ID global_mode,
                                                  Input_Event *event);

static Implicit_Map_Function *implicit_map_function = 0;
# 51 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_config.h" 1
# 13 "/home/tabletel/dev/4cc/code/custom/4coder_config.h"
struct Error_Location{
    i32 line_number;
    i32 column_number;
};

struct Config_Error{
    Config_Error *next;
    Config_Error *prev;
    String_Const_u8 file_name;
    u8 *pos;
    String_Const_u8 text;
};

struct Config_Error_List{
    Config_Error *first;
    Config_Error *last;
    i32 count;
};

struct Config_Parser{
    Token *token;
    Token *opl;

    String_Const_u8 file_name;
    String_Const_u8 data;

    Arena *arena;

    Config_Error_List errors;
};

struct Config_LValue{
    String_Const_u8 identifier;
    i32 index;
};

typedef i32 Config_RValue_Type;
enum{
    ConfigRValueType_Null,
    ConfigRValueType_LValue,
    ConfigRValueType_Boolean,
    ConfigRValueType_Integer,
    ConfigRValueType_String,
    ConfigRValueType_Compound,
    ConfigRValueType_COUNT
};

struct Config_Compound{
    struct Config_Compound_Element *first;
    struct Config_Compound_Element *last;
    i32 count;
};

struct Config_RValue{
    Config_RValue_Type type;
    union{
        Config_LValue *lvalue;
        b32 boolean;
        i32 integer;
        u32 uinteger;
        String_Const_u8 string;
        char character;
        Config_Compound *compound;
    };
};

struct Config_Integer{
    b32 is_signed;
    union{
        i32 integer;
        u32 uinteger;
    };
};

typedef i32 Config_Layout_Type;
enum{
    ConfigLayoutType_Unset,
    ConfigLayoutType_Identifier,
    ConfigLayoutType_Integer,
    ConfigLayoutType_COUNT,
};
struct Config_Layout{
    Config_Layout_Type type;
    u8 *pos;
    union{
        String_Const_u8 identifier;
        i32 integer;
    };
};

struct Config_Compound_Element{
    Config_Compound_Element *next;
    Config_Compound_Element *prev;

    Config_Layout l;
    Config_RValue *r;
};

struct Config_Assignment{
    Config_Assignment *next;
    Config_Assignment *prev;

    u8 *pos;
    Config_LValue *l;
    Config_RValue *r;

    b32 visited;
};

struct Config{
    i32 *version;
    Config_Assignment *first;
    Config_Assignment *last;
    i32 count;

    Config_Error_List errors;

    String_Const_u8 file_name;
    String_Const_u8 data;
};




typedef i32 Iteration_Step_Result;
enum{
    Iteration_Good = 0,
    Iteration_Skip = 1,
    Iteration_Quit = 2,
};

struct Config_Get_Result{
    b32 success;
    Config_RValue_Type type;
    u8 *pos;
    union{
        b32 boolean;
        i32 integer;
        u32 uinteger;
        String_Const_u8 string;
        char character;
        Config_Compound *compound;
    };
};

struct Config_Iteration_Step_Result{
    Iteration_Step_Result step;
    Config_Get_Result get;
};

struct Config_Get_Result_Node{
    Config_Get_Result_Node *next;
    Config_Get_Result_Node *prev;
    Config_Get_Result result;
};

struct Config_Get_Result_List{
    Config_Get_Result_Node *first;
    Config_Get_Result_Node *last;
    i32 count;
};




static void def_search_normal_load_list(Arena *arena, String8List *list);

static String8 def_search_normal_full_path(Arena *arena, String8 relative);
static FILE *def_search_normal_fopen(Arena *arena, char *file_name, char *opt);




static Config_Parser def_config_parser_init(Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Token_Array array);

static void def_config_parser_inc(Config_Parser *ctx);
static u8* def_config_parser_get_pos(Config_Parser *ctx);

static b32 def_config_parser_recognize_base_kind(Config_Parser *ctx, Token_Base_Kind kind);
static b32 def_config_parser_recognize_cpp_kind(Config_Parser *ctx, Token_Cpp_Kind kind);
static b32 def_config_parser_recognize_boolean(Config_Parser *ctx);
static b32 def_config_parser_recognize_text(Config_Parser *ctx, String_Const_u8 text);

static b32 def_config_parser_match_cpp_kind(Config_Parser *ctx, Token_Cpp_Kind kind);
static b32 def_config_parser_match_text(Config_Parser *ctx, String_Const_u8 text);

static String_Const_u8 def_config_parser_get_lexeme(Config_Parser *ctx);
static Config_Integer def_config_parser_get_int(Config_Parser *ctx);
static b32 def_config_parser_get_boolean(Config_Parser *ctx);

static void def_config_parser_recover(Config_Parser *ctx);

static Config* def_config_parser_top (Config_Parser *ctx);
static i32* def_config_parser_version (Config_Parser *ctx);
static Config_Assignment* def_config_parser_assignment(Config_Parser *ctx);
static Config_LValue* def_config_parser_lvalue (Config_Parser *ctx);
static Config_RValue* def_config_parser_rvalue (Config_Parser *ctx);
static Config_Compound* def_config_parser_compound (Config_Parser *ctx);
static Config_Compound_Element* def_config_parser_element (Config_Parser *ctx);

static Config* def_config_parse(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Token_Array array);
static Config* def_config_from_text(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data);

static Config_Error* def_config_push_error(Arena *arena, Config_Error_List *list, String_Const_u8 file_name, u8 *pos, char *error_text);
static Config_Error* def_config_push_error(Arena *arena, Config *config, u8 *pos, char *error_text);

static void def_config_parser_push_error(Config_Parser *ctx, u8 *pos, char *error_text);
static void def_config_parser_push_error_here(Config_Parser *ctx, char *error_text);

static void def_config_parser_recover(Config_Parser *ctx);




static Variable_Handle def_fill_var_from_config(Application_Links *app, Variable_Handle parent, String_ID key, Config *config);




static Variable_Handle def_get_config_var(String_ID key);
static void def_set_config_var(String_ID key, String_ID val);

static b32 def_get_config_b32(String_ID key);
static void def_set_config_b32(String_ID key, b32 val);

static String_Const_u8 def_get_config_string(Arena *arena, String_ID key);
static void def_set_config_string(String_ID key, String_Const_u8 val);

static u64 def_get_config_u64(Application_Links *app, String_ID key);
static void def_set_config_u64(Application_Links *app, String_ID key, u64 val);
# 52 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.h"
typedef u32 Indent_Flag;
enum{
    Indent_ClearLine = 0x1,
    Indent_UseTab = 0x2,
    Indent_FullTokens = 0x4,
};

struct Nest{
    Nest *next;
    Token_Base_Kind kind;
    i64 indent;
};

struct Nest_Alloc{
    Nest *free_nest;
};

struct Indent_Line_Cache{
    i64 where_token_starts;
    i64 line_number_for_cached_indent;
    i64 start_pos;
    i64 one_past_last_pos;
    Indent_Info indent_info;
};
# 53 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_search.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_search.h"
typedef u32 List_All_Locations_Flag;
enum{
    ListAllLocationsFlag_CaseSensitive = 1,
    ListAllLocationsFlag_MatchSubstring = 2,
};

struct Word_Complete_Iterator{
    Application_Links *app;
    Arena *arena;

    Temp_Memory arena_restore;
    Buffer_ID first_buffer;
    Buffer_ID current_buffer;
    b32 scan_all_buffers;
    String_Const_u8 needle;

    List_String_Const_u8 list;
    Node_String_Const_u8 *node;
    Table_Data_u64 already_used_table;
};

struct Word_Complete_Menu{
    Render_Caller_Function *prev_render_caller;
    Word_Complete_Iterator *it;
    String_Const_u8 options[8];
    i32 count;
};
# 54 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.h" 1
# 55 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jumping.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_jumping.h"
typedef u32 Jump_Flag;
enum{
    JumpFlag_SkipSubs = 1,
};
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.h"
struct Sticky_Jump{
    i64 list_line;
    i64 list_colon_index;
    b32 is_sub_error;
    Buffer_ID jump_buffer_id;
    i64 jump_pos;
};

struct Sticky_Jump_Stored{
    i64 list_line;
    i64 list_colon_index;
    b32 is_sub_error;
    Buffer_ID jump_buffer_id;
    i32 index_into_marker_array;
};

struct Sticky_Jump_Node{
    Sticky_Jump_Node *next;
    Sticky_Jump jump;
};

struct Sticky_Jump_Array{
    Sticky_Jump *jumps;
    i32 count;
};

struct Sticky_Jump_Node_Header{
    Managed_Object memory;
    Managed_Object markers;
    i32 first_index;
    i32 count;
};

enum Jump_Location_Flag{
    JumpFlag_IsSubJump = 0x1,
};

struct Marker_List{
    Managed_Object jump_array;
    i32 jump_count;
    i32 previous_size;
    Buffer_ID buffer_id;
};

struct Marker_List_Node{
    Marker_List_Node *next;
    Marker_List_Node *prev;
    Marker_List list;
    Buffer_ID buffer_id;
};

struct Locked_Jump_State{
    View_ID view;
    Marker_List *list;
    i32 list_index;
};
# 57 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jump_lister.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_jump_lister.h"
typedef i32 Jump_Lister_Activation_Rule;
enum{
    JumpListerActivation_OpenInUIView = 0,
    JumpListerActivation_OpenInTargetViewKeepUI = 1,
    JumpListerActivation_OpenInTargetViewCloseUI = 2,
    JumpListerActivation_OpenInNextViewKeepUI = 3,
    JumpListerActivation_OpenInNextViewCloseUI = 4,
};

struct Jump_Lister_Parameters{
    Buffer_ID list_buffer_id;
    Jump_Lister_Activation_Rule activation_rule;
    View_ID target_view_id;
};

struct Jump_Lister_Result{
    b32 success;
    i32 index;
};
# 58 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.h" 1
# 13 "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.h"
struct Prj_Pattern{
    String8List absolutes;
};

struct Prj_Pattern_Node{
    Prj_Pattern_Node *next;
    Prj_Pattern pattern;
};

struct Prj_Pattern_List{
    Prj_Pattern_Node *first;
    Prj_Pattern_Node *last;
    i32 count;
};

typedef u32 Prj_Open_File_Flags;
enum{
    PrjOpenFileFlag_Recursive = 1,
};




struct Prj_Setup_Status{
    b32 bat_exists;
    b32 sh_exists;
    b32 project_exists;
    b32 everything_exists;
};

struct Prj_Key_Strings{
    b32 success;
    String8 script_file;
    String8 code_file;
    String8 output_dir;
    String8 binary_file;
};

typedef u32 Prj_Setup_Script_Flags;
enum{
    PrjSetupScriptFlag_Project = 0x1,
    PrjSetupScriptFlag_Bat = 0x2,
    PrjSetupScriptFlag_Sh = 0x4,
};




static Prj_Pattern_List prj_pattern_list_from_extension_array(Arena *arena, String8Array list);
static Prj_Pattern_List prj_pattern_list_from_var(Arena *arena, Variable_Handle var);
static Prj_Pattern_List prj_get_standard_blacklist(Arena *arena);

static b32 prj_match_in_pattern_list(String8 string, Prj_Pattern_List list);

static void prj_close_files_with_ext(Application_Links *app, String8Array extension_array);
static void prj_open_files_pattern_filter(Application_Links *app, String8 dir, Prj_Pattern_List whitelist, Prj_Pattern_List blacklist, Prj_Open_File_Flags flags);
static void prj_open_all_files_with_ext_in_hot(Application_Links *app, String8Array array, Prj_Open_File_Flags flags);




static void prj_stringize_project(Application_Links *app, Arena *arena, Variable_Handle project, String8List *out);

static Prj_Setup_Status prj_file_is_setup(Application_Links *app, String8 script_path, String8 script_file);
static b32 prj_generate_bat(Arena *scratch, String8 opts, String8 compiler, String8 script_path, String8 script_file, String8 code_file, String8 output_dir, String8 binary_file);
static b32 prj_generate_sh(Arena *scratch, String8 opts, String8 compiler, String8 script_path, String8 script_file, String8 code_file, String8 output_dir, String8 binary_file);
static b32 prj_generate_project(Arena *scratch, String8 script_path, String8 script_file, String8 output_dir, String8 binary_file);

static void prj_setup_scripts(Application_Links *app, Prj_Setup_Script_Flags flags);




static void prj_exec_command(Application_Links *app, Variable_Handle cmd_var);
static Variable_Handle prj_command_from_name(Application_Links *app, String8 cmd_name);
static void prj_exec_command_name(Application_Links *app, String8 cmd_name);
static void prj_exec_command_fkey_index(Application_Links *app, i32 fkey_index);

static String8 prj_full_file_path_from_project(Arena *arena, Variable_Handle project);
static String8 prj_path_from_project(Arena *arena, Variable_Handle project);
static Variable_Handle prj_cmd_from_user(Application_Links *app, Variable_Handle prj_var, String8 query);
# 59 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.h" 1
# 13 "/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.h"
struct Prj_V1_File_Load_Path{
    String8 path;
    b32 recursive;
    b32 relative;
};

struct Prj_V1_File_Load_Path_Array{
    Prj_V1_File_Load_Path *paths;
    i32 count;
};

struct Prj_V1_Command{
    String8 name;
    String8 cmd;
    String8 out;
    b32 footer_panel;
    b32 save_dirty_files;
    b32 cursor_at_end;
};

struct Prj_V1_Command_Array{
    Prj_V1_Command *commands;
    i32 count;
};

struct Prj_V1{
    b32 loaded;

    String8 dir;
    String8 name;

    Prj_Pattern_List pattern_list;
    Prj_Pattern_List blacklist_pattern_list;
    Prj_V1_File_Load_Path_Array load_path_array;
    Prj_V1_Command_Array command_array;

    i32 fkey_commands[16];
};

enum Prj_V1_OS_Match_Level{
    PrjV1OSMatchLevel_NoMatch = 0,
    PrjV1OSMatchLevel_PassiveMatch = 1,
    PrjV1OSMatchLevel_ActiveMatch = 2,
};





static Variable_Handle prj_v1_to_v2(Application_Links *app, String8 dir, Config *parsed);
# 60 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_function_list.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_function_list.h"
struct Function_Positions{
    i64 sig_start_index;
    i64 sig_end_index;
    i64 open_paren_pos;
};

struct Get_Positions_Results{
    i64 positions_count;
    i64 next_token_index;
    b32 still_looping;
};
# 61 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.h" 1
# 62 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.h" 1






struct Snippet{
    char *name;
    char *text;
    i32 cursor_offset;
    i32 mark_offset;
};

struct Snippet_Array{
    Snippet *snippets;
    i32 count;
};
# 63 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_log_parser.h" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_log_parser.h"
typedef i64 Log_Tag_Kind;
enum{
    LogTagKind_Null,
    LogTagKind_Integer,
    LogTagKind_String,
};

typedef i32 Log_String_Source;
enum{
    LogParse_ExternalString,
    LogParse_PreAllocatedString,
};

struct Log_Tag_Value{
    Log_Tag_Kind kind;
    union{
        u64 value;
        i64 value_s;
    };
};

struct Log_Sort_Key{
    Log_Tag_Value value;
    i32 number;
};

struct Log_Tag_Name_Value{
    u64 name;
    Log_Tag_Value value;
};

struct Log_Tag{
    Log_Tag *next;
    u64 name;
    Log_Tag_Value value;
};

struct Log_Event{
    Log_Event *next;
    u64 src_file_name;
    u64 event_name;
    u64 line_number;

    Log_Tag *first_tag;
    Log_Tag *last_tag;
    i32 tag_count;

    i32 event_number;

    Table_u64_u64 tag_name_to_tag_ptr_table;
};

struct Log_Event_Ptr_Node{
    Log_Event_Ptr_Node *next;
    Log_Event *event;
};

struct Log_Event_List{
    Log_Event_Ptr_Node *first;
    Log_Event_Ptr_Node *last;
    i32 count;
};

struct Log_Event_Ptr_Array{
    Log_Event **events;
    i32 count;
};

struct Log_Tag_Value_Array{
    Log_Tag_Value *vals;
    i32 count;
};

struct Log_Parse{
    Arena *arena;

    Log_Event *first_event;
    Log_Event *last_event;
    i32 event_count;

    u64 string_id_counter;
    Table_Data_u64 string_to_id_table;
    Table_u64_Data id_to_string_table;

    Table_Data_u64 tag_value_to_event_list_table;
    Table_u64_u64 tag_name_to_event_list_table;
};



struct Log_Graph_Thread_Bucket{
    Log_Graph_Thread_Bucket *next;
    Range_i32 range;
    b32 had_a_tag;
    u64 thread_id_value;
};

struct Log_Graph_Box{
    Log_Graph_Box *next;
    Rect_f32 rect;
    Log_Event *event;
};

typedef i32 Log_Filter_Kind;
enum{
    LogFilter_ERROR,
    LogFilter_TagValue,
    LogFilter_Tag,
};

struct Log_Filter{
    Log_Filter *next;
    Log_Filter *prev;
    Log_Filter_Kind kind;
    u64 tag_name_code;
    Log_Tag_Value tag_value;
};

struct Log_Filter_Set{
    Log_Filter filters_memory[20];
    Log_Filter *free_filters;
    Log_Filter *first;
    Log_Filter *last;
    i32 count;
    i32 alter_counter;
};

typedef i32 Log_Graph_List_Tab;
enum{
    LogTab_ERROR,
    LogTab_Filters,
    LogTab_Previews,
    LogTab_COUNT,
};

struct Log_Graph{
    b32 holding_temp;
    Temp_Memory temp;
    Rect_f32 layout_region;
    Face_ID face_id;
    i32 filter_alter_counter;
    i32 preview_alter_counter;
    Log_Graph_List_Tab tab;
    Rect_f32 details_region;
    Log_Event_List filtered_list;
    Log_Event_Ptr_Array event_array;
    Log_Graph_Thread_Bucket *first_bucket;
    Log_Graph_Thread_Bucket *last_bucket;
    i32 bucket_count;
    Log_Graph_Box *first_box;
    Log_Graph_Box *last_box;
    i32 box_count;
    f32 y_scroll;
    f32 max_y_scroll;
    Log_Event *selected_event;
    b32 has_unused_click;
    Vec2_f32 unused_click;
};
# 64 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.h"
struct Profile_Node_Ptr{
    Profile_Node_Ptr *next;
    struct Profile_Node *ptr;
};

struct Profile_Slot{
    Profile_Slot *next;
    String_Const_u8 location;
    String_Const_u8 name;

    u64 total_time;
    b32 corrupted_time;

    i32 hit_count;
    Profile_Node_Ptr *first_hit;
    Profile_Node_Ptr *last_hit;
};

struct Profile_Node{
    Profile_Node *next;
    Profile_Node *parent;
    Profile_Slot *slot;
    struct Profile_Inspection_Thread *thread;
    Range_u64 time;
    Profile_ID id;
    u64 unique_counter;

    Profile_Node *first_child;
    Profile_Node *last_child;
    i32 child_count;

    b32 closed;
};

struct Profile_Inspection_Thread{
    i32 thread_id;
    String_Const_u8 name;
    Profile_Node root;
    u64 active_time;
};

struct Profile_Error{
    Profile_Error *next;
    String_Const_u8 message;
    String_Const_u8 location;
};

typedef i32 Profile_Inspection_Tab;
enum{
    ProfileInspectTab_None,
    ProfileInspectTab_Threads,
    ProfileInspectTab_Blocks,
    ProfileInspectTab_Errors,
    ProfileInspectTab_Memory,
    ProfileInspectTab_Selection,
};

struct Profile_Inspection{
    Profile_Slot *first_slot;
    Profile_Slot *last_slot;
    Profile_Error *first_error;
    Profile_Error *last_error;
    Profile_Inspection_Thread *threads;
    i32 slot_count;
    i32 thread_count;
    i32 error_count;

    Profile_Inspection_Tab tab_id;
    Profile_Inspection_Thread *selected_thread;
    Profile_Slot *selected_slot;
    Profile_Node *selected_node;

    Profile_Inspection_Tab tab_id_hovered;
    String_Const_u8 full_name_hovered;
    u64 unique_counter_hovered;
    String_Const_u8 location_jump_hovered;
    Profile_Inspection_Thread *hover_thread;
    Profile_Slot *hover_slot;
    Profile_Node *hover_node;
};

static Profile_Inspection global_profile_inspection = {};

struct Memory_Bucket{
    Memory_Bucket *next;
    Memory_Annotation annotation;
    String_Const_u8 location;
    u64 total_memory;
};
# 65 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.h" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.h"
typedef i32 Tutorial_Action;
enum{
    TutorialAction_None,
    TutorialAction_Minimize,
    TutorialAction_Maximize,
    TutorialAction_Prev,
    TutorialAction_Next,
    TutorialAction_Exit,
    TutorialAction_Restart,
};

struct Tutorial_Slide{
    Fancy_Block long_details;
    Fancy_Line short_details;
};

typedef Tutorial_Slide Tutorial_Slide_Function(Application_Links *app, Arena *arena);

struct Tutorial_State{
    b32 in_tutorial;
    View_ID view;
    Face_ID face;
    b32 is_active;
    Tutorial_Action hover_action;
    Tutorial_Action depressed_action;

    i32 slide_index;
    Tutorial_Slide_Function **slide_func_ptrs;
    i32 slide_count;
};
# 66 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_search_list.h" 1
# 18 "/home/tabletel/dev/4cc/code/custom/4coder_search_list.h"
static void def_search_add_path(Arena *arena, List_String_Const_u8 *list, String_Const_u8 path);
static void def_search_list_add_system_path(Arena *arena, List_String_Const_u8 *list, System_Path_Code path);




static String_Const_u8 def_search_get_full_path(Arena *arena, List_String_Const_u8 *list, String_Const_u8 file_name);
static FILE *def_search_fopen(Arena *arena, List_String_Const_u8 *list, char *file_name, char *opt);
# 67 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2



# 1 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp"
static i32
i32_ceil32(f32 v){
    return(((v)>0)?( (v == (i32)(v))?((i32)(v)):((i32)((v)+1.f)) ):( ((i32)(v)) ));
}

static i32
i32_floor32(f32 v){
    return(((v)<0)?( (v == (i32)(v))?((i32)(v)):((i32)((v)-1.f)) ):( ((i32)(v)) ));
}

static i32
i32_round32(f32 v){
    return(i32_floor32(v + 0.5f));
}

static f32
f32_ceil32(f32 v){
    return((f32)i32_ceil32(v));
}

static f32
f32_floor32(f32 v){
    return((f32)i32_floor32(v));
}

static f32
f32_round32(f32 v){
    return((f32)i32_round32(v));
}

static i8
round_up_i8(i8 x, i8 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u8
round_up_u8(u8 x, u8 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i16
round_up_i16(i16 x, i16 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u16
round_up_u16(u16 x, u16 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i32
round_up_i32(i32 x, i32 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u32
round_up_u32(u32 x, u32 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i64
round_up_i64(i64 x, i64 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u64
round_up_u64(u64 x, u64 b){
    x += b - 1;
    x -= x%b;
    return(x);
}

static i8
round_down_i8(i8 x, i8 b){
    x -= x%b;
    return(x);
}
static u8
round_down_u8(u8 x, u8 b){
    x -= x%b;
    return(x);
}
static i16
round_down_i16(i16 x, i16 b){
    x -= x%b;
    return(x);
}
static u16
round_down_u16(u16 x, u16 b){
    x -= x%b;
    return(x);
}
static i32
round_down_i32(i32 x, i32 b){
    x -= x%b;
    return(x);
}
static u32
round_down_u32(u32 x, u32 b){
    x -= x%b;
    return(x);
}
static i64
round_down_i64(i64 x, i64 b){
    x -= x%b;
    return(x);
}
static u64
round_down_u64(u64 x, u64 b){
    x -= x%b;
    return(x);
}

static f32
f32_integer(f32 x){
    return((f32)((i32)x));
}

static u32
round_up_pot_u32(u32 x){
    --x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    ++x;
    return(x);
}



static String_Const_u8
make_data(void *memory, u64 size){
    String_Const_u8 data = {(u8*)memory, size};
    return(data);
}



static const String_Const_u8 zero_data = {};
# 168 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp"
static void
block_zero(void *mem, u64 size){
    for (u8 *p = (u8*)mem, *e = p + size; p < e; p += 1){
        *p = 0;
    }
}
static void
block_zero(String_Const_u8 data){
    block_zero(data.str, data.size);
}
static void
block_fill_ones(void *mem, u64 size){
    for (u8 *p = (u8*)mem, *e = p + size; p < e; p += 1){
        *p = 0xFF;
    }
}
static void
block_fill_ones(String_Const_u8 data){
    block_fill_ones(data.str, data.size);
}
static void
block_copy(void *dst, const void *src, u64 size){
    u8 *d = (u8*)dst;
    u8 *s = (u8*)src;
    if (d < s){
        u8 *e = d + size;
        for (; d < e; d += 1, s += 1){
            *d = *s;
        }
    }
    else if (d > s){
        u8 *e = d;
        d += size - 1;
        s += size - 1;
        for (; d >= e; d -= 1, s -= 1){
            *d = *s;
        }
    }
}
static b32
block_match(void *a, void *b, u64 size){
    b32 result = true;
    for (u8 *pa = (u8*)a, *pb = (u8*)b, *ea = pa + size; pa < ea; pa += 1, pb += 1){
        if (*pa != *pb){
            result = false;
            break;
        }
    }
    return(result);
}
static i32
block_compare(void *a, void *b, u64 size){
    i32 result = 0;
    for (u8 *pa = (u8*)a, *pb = (u8*)b, *ea = pa + size; pa < ea; pa += 1, pb += 1){
        i32 dif = (i32)*pa - (i32)*pb;
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static void
block_fill_u8(void *a, u64 size, u8 val){
    for (u8 *ptr = (u8*)a, *e = ptr + size; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u16(void *a, u64 size, u16 val){
    do{ if (!(size%sizeof(u16) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u16);
    for (u16 *ptr = (u16*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u32(void *a, u64 size, u32 val){
    do{ if (!(size%sizeof(u32) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u32);
    for (u32 *ptr = (u32*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u64(void *a, u64 size, u64 val){
    do{ if (!(size%sizeof(u64) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u64);
    for (u64 *ptr = (u64*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
# 272 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp"
static void
block_range_copy__inner(void *dst, void *src, Range_u64 range, i64 shift){
    block_copy((u8*)dst + range.first + shift, (u8*)src + range.first, range.max - range.min);
}

static void
block_range_copy__inner(void *dst, void *src, Range_u64 range, i64 shift, u64 item_size){
    range.first *= item_size;
    range.one_past_last *= item_size;
    shift *= item_size;
    block_range_copy__inner(dst, src, range, shift);
}





static void
block_copy_array_shift__inner(void *dst, void *src, u64 it_size, Range_i64 range, i64 shift){
    u8 *dptr = (u8*)dst;
    u8 *sptr = (u8*)src;
    dptr += it_size*(range.first + shift);
    sptr += it_size*range.first;
    block_copy(dptr, sptr, (u64)(it_size*(range.one_past_last - range.first)));
}
static void
block_copy_array_shift__inner(void *dst, void *src, u64 it_size, Range_i32 range, i64 shift){
    u8 *dptr = (u8*)dst;
    u8 *sptr = (u8*)src;
    dptr += it_size*(range.first + shift);
    sptr += it_size*range.first;
    block_copy(dptr, sptr, (u64)(it_size*(range.one_past_last - range.first)));
}





static f32
abs_f32(f32 x){
    if (x < 0){
        x = -x;
    }
    return(x);
}


# 1 "/usr/include/c++/12.2.1/math.h" 1 3
# 36 "/usr/include/c++/12.2.1/math.h" 3
# 1 "/usr/include/c++/12.2.1/cmath" 1 3
# 39 "/usr/include/c++/12.2.1/cmath" 3
       
# 40 "/usr/include/c++/12.2.1/cmath" 3


# 1 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3

# 67 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 289 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 425 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 550 "/usr/include/c++/12.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/12.2.1/cmath" 2 3
# 1 "/usr/include/c++/12.2.1/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/12.2.1/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/12.2.1/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };
# 211 "/usr/include/c++/12.2.1/ext/type_traits.h" 3
  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };



}
}
# 44 "/usr/include/c++/12.2.1/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 481 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 482 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1055 "/usr/include/math.h" 2 3 4
# 1066 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1097 "/usr/include/math.h" 3 4
extern "C++" {
# 1128 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1363 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1417 "/usr/include/math.h" 3 4
template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {

    return __iseqsigf128 (__x, __y);



  }
};
# 1454 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/12.2.1/cmath" 2 3
# 77 "/usr/include/c++/12.2.1/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/12.2.1/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/12.2.1/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/12.2.1/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1931 "/usr/include/c++/12.2.1/cmath" 3

}





}
# 37 "/usr/include/c++/12.2.1/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 320 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" 2


# 321 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp"
static f32
mod_f32(f32 x, i32 m){
    f32 whole;
    f32 frac = modff(x, &whole);
    f32 r = ((i32)(whole) % m) + frac;
    return(r);
}

static f32
sin_f32(f32 x){
    return(sinf(x));
}

static f32
cos_f32(f32 x){
    return(cosf(x));
}




static Vec2_i8
V2i8(i8 x, i8 y){
    Vec2_i8 v = {x, y};
    return(v);
}
static Vec3_i8
V3i8(i8 x, i8 y, i8 z){
    Vec3_i8 v = {x, y, z};
    return(v);
}
static Vec4_i8
V4i8(i8 x, i8 y, i8 z, i8 w){
    Vec4_i8 v = {x, y, z, w};
    return(v);
}
static Vec2_i16
V2i16(i16 x, i16 y){
    Vec2_i16 v = {x, y};
    return(v);
}
static Vec3_i16
V3i16(i16 x, i16 y, i16 z){
    Vec3_i16 v = {x, y, z};
    return(v);
}
static Vec4_i16
V4i16(i16 x, i16 y, i16 z, i16 w){
    Vec4_i16 v = {x, y, z, w};
    return(v);
}
static Vec2_i32
V2i32(i32 x, i32 y){
    Vec2_i32 v = {x, y};
    return(v);
}
static Vec3_i32
V3i32(i32 x, i32 y, i32 z){
    Vec3_i32 v = {x, y, z};
    return(v);
}
static Vec4_i32
V4i32(i32 x, i32 y, i32 z, i32 w){
    Vec4_i32 v = {x, y, z, w};
    return(v);
}
static Vec2_f32
V2f32(f32 x, f32 y){
    Vec2_f32 v = {x, y};
    return(v);
}
static Vec3_f32
V3f32(f32 x, f32 y, f32 z){
    Vec3_f32 v = {x, y, z};
    return(v);
}
static Vec4_f32
V4f32(f32 x, f32 y, f32 z, f32 w){
    Vec4_f32 v = {x, y, z, w};
    return(v);
}

static Vec2_i8
V2i8(Vec2_i8 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_i16 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_i32 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_f32 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec3_i8
V3i8(Vec3_i8 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_i16 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_i32 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_f32 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec4_i8
V4i8(Vec4_i8 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_i16 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_i32 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_f32 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec2_i16
V2i16(Vec2_i8 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_i16 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_i32 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_f32 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec3_i16
V3i16(Vec3_i8 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_i16 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_i32 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_f32 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec4_i16
V4i16(Vec4_i8 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_i16 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_i32 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_f32 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec2_i32
V2i32(Vec2_i8 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_i16 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_i32 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_f32 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec3_i32
V3i32(Vec3_i8 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_i16 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_i32 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_f32 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec4_i32
V4i32(Vec4_i8 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_i16 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_i32 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_f32 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec2_f32
V2f32(Vec2_i8 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_i16 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_i32 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_f32 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec3_f32
V3f32(Vec3_i8 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_i16 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_i32 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_f32 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec4_f32
V4f32(Vec4_i8 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_i16 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_i32 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_f32 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}

static Vec2_i8
operator+(Vec2_i8 a, Vec2_i8 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i8
operator+(Vec3_i8 a, Vec3_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i8
operator+(Vec4_i8 a, Vec4_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i16
operator+(Vec2_i16 a, Vec2_i16 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i16
operator+(Vec3_i16 a, Vec3_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i16
operator+(Vec4_i16 a, Vec4_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i32
operator+(Vec2_i32 a, Vec2_i32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i32
operator+(Vec3_i32 a, Vec3_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i32
operator+(Vec4_i32 a, Vec4_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_f32
operator+(Vec2_f32 a, Vec2_f32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_f32
operator+(Vec3_f32 a, Vec3_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_f32
operator+(Vec4_f32 a, Vec4_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}

static Vec2_i8&
operator+=(Vec2_i8 &a, Vec2_i8 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i8&
operator+=(Vec3_i8 &a, Vec3_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i8&
operator+=(Vec4_i8 &a, Vec4_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i16&
operator+=(Vec2_i16 &a, Vec2_i16 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i16&
operator+=(Vec3_i16 &a, Vec3_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i16&
operator+=(Vec4_i16 &a, Vec4_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i32&
operator+=(Vec2_i32 &a, Vec2_i32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i32&
operator+=(Vec3_i32 &a, Vec3_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i32&
operator+=(Vec4_i32 &a, Vec4_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_f32&
operator+=(Vec2_f32 &a, Vec2_f32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_f32&
operator+=(Vec3_f32 &a, Vec3_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_f32&
operator+=(Vec4_f32 &a, Vec4_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}

static Vec2_i8
operator-(Vec2_i8 a, Vec2_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i8
operator-(Vec3_i8 a, Vec3_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i8
operator-(Vec4_i8 a, Vec4_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i16
operator-(Vec2_i16 a, Vec2_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i16
operator-(Vec3_i16 a, Vec3_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i16
operator-(Vec4_i16 a, Vec4_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i32
operator-(Vec2_i32 a, Vec2_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i32
operator-(Vec3_i32 a, Vec3_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i32
operator-(Vec4_i32 a, Vec4_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_f32
operator-(Vec2_f32 a, Vec2_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_f32
operator-(Vec3_f32 a, Vec3_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_f32
operator-(Vec4_f32 a, Vec4_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}

static Vec2_i8&
operator-=(Vec2_i8 &a, Vec2_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i8&
operator-=(Vec3_i8 &a, Vec3_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i8&
operator-=(Vec4_i8 &a, Vec4_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i16&
operator-=(Vec2_i16 &a, Vec2_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i16&
operator-=(Vec3_i16 &a, Vec3_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i16&
operator-=(Vec4_i16 &a, Vec4_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i32&
operator-=(Vec2_i32 &a, Vec2_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i32&
operator-=(Vec3_i32 &a, Vec3_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i32&
operator-=(Vec4_i32 &a, Vec4_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_f32&
operator-=(Vec2_f32 &a, Vec2_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_f32&
operator-=(Vec3_f32 &a, Vec3_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_f32&
operator-=(Vec4_f32 &a, Vec4_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}

static Vec2_i8
operator*(i8 s, Vec2_i8 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i8
operator*(Vec2_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i8
operator*(i8 s, Vec3_i8 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i8
operator*(Vec3_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i8
operator*(i8 s, Vec4_i8 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i8
operator*(Vec4_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i16
operator*(i16 s, Vec2_i16 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i16
operator*(Vec2_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i16
operator*(i16 s, Vec3_i16 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i16
operator*(Vec3_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i16
operator*(i16 s, Vec4_i16 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i16
operator*(Vec4_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i32
operator*(i32 s, Vec2_i32 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i32
operator*(Vec2_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i32
operator*(i32 s, Vec3_i32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i32
operator*(Vec3_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i32
operator*(i32 s, Vec4_i32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i32
operator*(Vec4_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_f32
operator*(f32 s, Vec2_f32 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_f32
operator*(Vec2_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_f32
operator*(f32 s, Vec3_f32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_f32
operator*(Vec3_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_f32
operator*(f32 s, Vec4_f32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_f32
operator*(Vec4_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}

static Vec2_i8&
operator*=(Vec2_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i8&
operator*=(Vec3_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i8&
operator*=(Vec4_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i16&
operator*=(Vec2_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i16&
operator*=(Vec3_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i16&
operator*=(Vec4_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i32&
operator*=(Vec2_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i32&
operator*=(Vec3_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i32&
operator*=(Vec4_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_f32&
operator*=(Vec2_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_f32&
operator*=(Vec3_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_f32&
operator*=(Vec4_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}

static Vec2_i8
operator/(Vec2_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i8
operator/(Vec3_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i8
operator/(Vec4_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i16
operator/(Vec2_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i16
operator/(Vec3_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i16
operator/(Vec4_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i32
operator/(Vec2_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i32
operator/(Vec3_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i32
operator/(Vec4_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_f32
operator/(Vec2_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_f32
operator/(Vec3_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_f32
operator/(Vec4_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}

static Vec2_i8&
operator/=(Vec2_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i8&
operator/=(Vec3_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i8&
operator/=(Vec4_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i16&
operator/=(Vec2_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i16&
operator/=(Vec3_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i16&
operator/=(Vec4_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i32&
operator/=(Vec2_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i32&
operator/=(Vec3_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i32&
operator/=(Vec4_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_f32&
operator/=(Vec2_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_f32&
operator/=(Vec3_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_f32&
operator/=(Vec4_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}

static b32
operator==(Vec2_i8 a, Vec2_i8 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i8 a, Vec3_i8 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i8 a, Vec4_i8 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_i16 a, Vec2_i16 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i16 a, Vec3_i16 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i16 a, Vec4_i16 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_i32 a, Vec2_i32 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i32 a, Vec3_i32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i32 a, Vec4_i32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_f32 a, Vec2_f32 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_f32 a, Vec3_f32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_f32 a, Vec4_f32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}

static b32
operator!=(Vec2_i8 a, Vec2_i8 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i8 a, Vec3_i8 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i8 a, Vec4_i8 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_i16 a, Vec2_i16 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i16 a, Vec3_i16 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i16 a, Vec4_i16 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_i32 a, Vec2_i32 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i32 a, Vec3_i32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i32 a, Vec4_i32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_f32 a, Vec2_f32 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_f32 a, Vec3_f32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_f32 a, Vec4_f32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}



static b32
near_zero(f32 p, f32 epsilon){
    return(-epsilon <= p && p <= epsilon);
}
static b32
near_zero(Vec2_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon);
}
static b32
near_zero(Vec3_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon &&
           -epsilon <= p.z && p.z <= epsilon);
}
static b32
near_zero(Vec4_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon &&
           -epsilon <= p.z && p.z <= epsilon &&
           -epsilon <= p.w && p.w <= epsilon);
}

static b32
near_zero(f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec2_f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec3_f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec4_f32 p){ return(near_zero(p, epsilon_f32)); }

static Vec2_f32
hadamard(Vec2_f32 a, Vec2_f32 b){
    return(V2f32(a.x*b.x, a.y*b.y));
}
static Vec3_f32
hadamard(Vec3_f32 a, Vec3_f32 b){
    return(V3f32(a.x*b.x, a.y*b.y, a.z*b.z));
}
static Vec4_f32
hadamard(Vec4_f32 a, Vec4_f32 b){
    return(V4f32(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w));
}



static f32
lerp(f32 a, f32 t, f32 b){
    return(a + (b-a)*t);
}

static f32
lerp(f32 t, Range_f32 x){
    return(x.min + (x.max - x.min)*t);
}

static i32
lerp(i32 a, f32 t, i32 b){
    return((i32)(lerp((f32)a, t, (f32)b)));
}

static Vec2_f32
lerp(Vec2_f32 a, f32 t, Vec2_f32 b){
    return(a + (b-a)*t);
}

static Vec3_f32
lerp(Vec3_f32 a, f32 t, Vec3_f32 b){
    return(a + (b-a)*t);
}

static Vec4_f32
lerp(Vec4_f32 a, f32 t, Vec4_f32 b){
    return(a + (b-a)*t);
}

static f32
unlerp(f32 a, f32 x, f32 b){
    f32 r = x;
    if (b != a){
        r = (x - a)/(b - a);
    }
    return(r);
}

static f32
unlerp(u64 a, u64 x, u64 b){
    f32 r = 0.f;
    if (b <= x){
        r = 1.f;
    }
    else if (a < x){
        u64 n = x - a;
        u64 d = b - a;
        r = (f32)(((f64)n)/((f64)d));
    }
    return(r);
}

static Range_f32
unlerp(f32 a, Range_f32 x, f32 b){
    x.min = unlerp(a, x.min, b);
    x.max = unlerp(a, x.max, b);
    return(x);
}

static Range_f32
lerp(f32 a, Range_f32 x, f32 b){
    x.min = lerp(a, x.min, b);
    x.max = lerp(a, x.max, b);
    return(x);
}

static f32
lerp(Range_f32 range, f32 t){
    return(lerp(range.min, t, range.max));
}

static f32
clamp_range(Range_f32 range, f32 x){
    return((((range.min)>(x))?(range.min):(((range.max)<(x))?(range.max):(x))));
}



static b32
operator==(Rect_i32 a, Rect_i32 b){
    return(a.p0 == b.p0 && a.p1 == b.p1);
}
static b32
operator==(Rect_f32 a, Rect_f32 b){
    return(a.p0 == b.p0 && a.p1 == b.p1);
}

static b32
operator!=(Rect_i32 a, Rect_i32 b){
    return(!(a == b));
}
static b32
operator!=(Rect_f32 a, Rect_f32 b){
    return(!(a == b));
}



static Vec4_f32
unpack_color(ARGB_Color color){
    Vec4_f32 result;
    result.a = ((color >> 24) & 0xFF)/255.f;
    result.r = ((color >> 16) & 0xFF)/255.f;
    result.g = ((color >> 8) & 0xFF)/255.f;
    result.b = ((color >> 0) & 0xFF)/255.f;
    return(result);
}

static ARGB_Color
pack_color(Vec4_f32 color){
    ARGB_Color result =
        ((u8)(color.a*255) << 24) |
        ((u8)(color.r*255) << 16) |
        ((u8)(color.g*255) << 8) |
        ((u8)(color.b*255) << 0);
    return(result);
}

static ARGB_Color
color_blend(ARGB_Color a, f32 t, ARGB_Color b){
    Vec4_f32 av = unpack_color(a);
    Vec4_f32 bv = unpack_color(b);
    Vec4_f32 v = lerp(av, t, bv);
    return(pack_color(v));
}

static Vec4_f32
rgba_to_hsla(Vec4_f32 rgba){
    Vec4_f32 hsla = {};
    f32 max, min, delta;
    i32 maxc;
    hsla.a = rgba.a;
    max = rgba.r; min = rgba.r;
    maxc = 0;
    if (rgba.r < rgba.g){
        max = rgba.g;
        maxc = 1;
    }
    if (rgba.b > max){
        max = rgba.b;
        maxc = 2;
    }
    if (rgba.r > rgba.g){
        min = rgba.g;
    }
    if (rgba.b < min){
        min = rgba.b;
    }
    delta = max - min;

    hsla.z = (max + min)*.5f;
    if (delta == 0){
        hsla.x = 0.f;
        hsla.y = 0.f;
    }
    else{
        switch (maxc){
            case 0:
            {
                hsla.x = (rgba.g - rgba.b) / delta;
                hsla.x += (rgba.g < rgba.b)*6.f;
            }break;

            case 1:
            {
                hsla.x = (rgba.b - rgba.r) / delta;
                hsla.x += 2.f;
            }break;

            case 2:
            {
                hsla.x = (rgba.r - rgba.g) / delta;
                hsla.x += 4.f;
            }break;
        }
        hsla.x *= (1/6.f);
        hsla.y = delta / (1.f - abs_f32(2.f*hsla.z - 1.f));
    }

    return(hsla);
}

static Vec4_f32
hsla_to_rgba(Vec4_f32 hsla){
    if (hsla.h >= 1.f){
        hsla.h = 0.f;
    }
    f32 C = (1.f - abs_f32(2*hsla.z - 1.f))*hsla.y;
    f32 X = C*(1.f-abs_f32(mod_f32(hsla.x*6.f, 2)-1.f));
    f32 m = hsla.z - C*.5f;
    i32 H = i32_floor32(hsla.x*6.f);
    Vec4_f32 rgba = {};
    rgba.a = hsla.a;
    switch (H){
        case 0: rgba.r = C; rgba.g = X; rgba.b = 0; break;
        case 1: rgba.r = X; rgba.g = C; rgba.b = 0; break;
        case 2: rgba.r = 0; rgba.g = C; rgba.b = X; break;
        case 3: rgba.r = 0; rgba.g = X; rgba.b = C; break;
        case 4: rgba.r = X; rgba.g = 0; rgba.b = C; break;
        case 5: rgba.r = C; rgba.g = 0; rgba.b = X; break;
    }
    rgba.r += m;
    rgba.g += m;
    rgba.b += m;
    return(rgba);
}



static Range_i32
Ii32(i32 a, i32 b){
    Range_i32 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_i64
Ii64(i64 a, i64 b){
    Range_i64 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_u64
Iu64(u64 a, u64 b){
    Range_u64 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_f32
If32(f32 a, f32 b){
    Range_f32 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}

static Range_i32
Ii32_size(i32 pos, i32 size){
    return(Ii32(pos, pos + size));
}
static Range_i64
Ii64_size(i64 pos, i64 size){
    return(Ii64(pos, pos + size));
}
static Range_u64
Iu64_size(u64 pos, u64 size){
    return(Iu64(pos, pos + size));
}
static Range_f32
If32_size(f32 pos, f32 size){
    return(If32(pos, pos + size));
}

static Range_i32
Ii32(i32 a){
    Range_i32 interval = {a, a};
    return(interval);
}
static Range_i64
Ii64(i64 a){
    Range_i64 interval = {a, a};
    return(interval);
}
static Range_u64
Iu64(u64 a){
    Range_u64 interval = {a, a};
    return(interval);
}
static Range_f32
If32(f32 a){
    Range_f32 interval = {a, a};
    return(interval);
}

static Range_i32
Ii32(){
    Range_i32 interval = {};
    return(interval);
}
static Range_i64
Ii64(){
    Range_i64 interval = {};
    return(interval);
}
static Range_u64
Iu64(){
    Range_u64 interval = {};
    return(interval);
}
static Range_f32
If32(){
    Range_f32 interval = {};
    return(interval);
}

static Range_u64
Iu64(Range_i32 r){
    return(Iu64(r.min, r.max));
}

static Range_i32 Ii32_neg_inf = {max_i32, min_i32};
static Range_i64 Ii64_neg_inf = {max_i64, min_i64};
static Range_u64 Iu64_neg_inf = {max_u64, 0};
static Range_f32 If32_neg_inf = {max_f32, -max_f32};

static b32
operator==(Range_i32 a, Range_i32 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_i64 a, Range_i64 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_u64 a, Range_u64 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_f32 a, Range_f32 b){
    return(a.min == b.min && a.max == b.max);
}

static Range_i32
operator+(Range_i32 r, i32 s){
    return(Ii32(r.min + s, r.max + s));
}
static Range_i64
operator+(Range_i64 r, i64 s){
    return(Ii64(r.min + s, r.max + s));
}
static Range_u64
operator+(Range_u64 r, u64 s){
    return(Iu64(r.min + s, r.max + s));
}
static Range_f32
operator+(Range_f32 r, f32 s){
    return(If32(r.min + s, r.max + s));
}

static Range_i32
operator-(Range_i32 r, i32 s){
    return(Ii32(r.min - s, r.max - s));
}
static Range_i64
operator-(Range_i64 r, i64 s){
    return(Ii64(r.min - s, r.max - s));
}
static Range_u64
operator-(Range_u64 r, u64 s){
    return(Iu64(r.min - s, r.max - s));
}
static Range_f32
operator-(Range_f32 r, f32 s){
    return(If32(r.min - s, r.max - s));
}

static Range_i32&
operator+=(Range_i32 &r, i32 s){
    r = r + s;
    return(r);
}
static Range_i64&
operator+=(Range_i64 &r, i64 s){
    r = r + s;
    return(r);
}
static Range_u64&
operator+=(Range_u64 &r, u64 s){
    r = r + s;
    return(r);
}
static Range_f32&
operator+=(Range_f32 &r, f32 s){
    r = r + s;
    return(r);
}

static Range_i32&
operator-=(Range_i32 &r, i32 s){
    r = r - s;
    return(r);
}
static Range_i64&
operator-=(Range_i64 &r, i64 s){
    r = r - s;
    return(r);
}
static Range_u64&
operator-=(Range_u64 &r, u64 s){
    r = r - s;
    return(r);
}
static Range_f32&
operator-=(Range_f32 &r, f32 s){
    r = r - s;
    return(r);
}

static Range_i32
range_margin(Range_i32 range, i32 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_i64
range_margin(Range_i64 range, i64 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_u64
range_margin(Range_u64 range, u64 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_f32
range_margin(Range_f32 range, f32 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}

static b32
range_overlap(Range_i32 a, Range_i32 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_i64 a, Range_i64 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_u64 a, Range_u64 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_f32 a, Range_f32 b){
    return(a.min < b.max && b.min < a.max);
}

static Range_i32
range_intersect(Range_i32 a, Range_i32 b){
    Range_i32 result = {};
    if (range_overlap(a, b)){
        result = Ii32((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_i64
range_intersect(Range_i64 a, Range_i64 b){
    Range_i64 result = {};
    if (range_overlap(a, b)){
        result = Ii64((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_u64
range_intersect(Range_u64 a, Range_u64 b){
    Range_u64 result = {};
    if (range_overlap(a, b)){
        result = Iu64((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_f32
range_intersect(Range_f32 a, Range_f32 b){
    Range_f32 result = {};
    if (range_overlap(a, b)){
        result = If32((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}

static Range_i32
range_union(Range_i32 a, Range_i32 b){
    return(Ii32((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_i64
range_union(Range_i64 a, Range_i64 b){
    return(Ii64((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_u64
range_union(Range_u64 a, Range_u64 b){
    return(Iu64((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_f32
range_union(Range_f32 a, Range_f32 b){
    return(If32((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}

static b32
range_contains_inclusive(Range_i32 a, i32 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_contains_inclusive(Range_i64 a, i64 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_contains_inclusive(Range_u64 a, u64 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_inclusive_contains(Range_f32 a, f32 p){
    return(a.min <= p && p <= a.max);
}

static b32
range_contains(Range_i32 a, i32 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_i64 a, i64 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_u64 a, u64 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_f32 a, f32 p){
    return(a.min <= p && p < a.max);
}

static i32
range_size(Range_i32 a){
    i32 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static i64
range_size(Range_i64 a){
    i64 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static u64
range_size(Range_u64 a){
    u64 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static f32
range_size(Range_f32 a){
    f32 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}

static i32
range_size_inclusive(Range_i32 a){
    i32 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static i64
range_size_inclusive(Range_i64 a){
    i64 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static u64
range_size_inclusive(Range_u64 a){
    u64 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static f32
range_size_inclusive(Range_f32 a){
    f32 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}

static Range_i32
rectify(Range_i32 a){
    return(Ii32(a.min, a.max));
}
static Range_i64
rectify(Range_i64 a){
    return(Ii64(a.min, a.max));
}
static Range_u64
rectify(Range_u64 a){
    return(Iu64(a.min, a.max));
}
static Range_f32
rectify(Range_f32 a){
    return(If32(a.min, a.max));
}

static Range_i32
range_clamp_size(Range_i32 a, i32 max_size){
    i32 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_i64
range_clamp_size(Range_i64 a, i64 max_size){
    i64 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_u64
range_clamp_size(Range_u64 a, u64 max_size){
    u64 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_f32
range_clamp_size(Range_f32 a, f32 max_size){
    f32 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}

static b32
range_is_valid(Range_i32 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_i64 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_u64 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_f32 a){
    return(a.min <= a.max);
}

static i32
range_side(Range_i32 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static i64
range_side(Range_i64 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static u64
range_side(Range_u64 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static f32
range_side(Range_f32 a, Side side){
    return(side == Side_Min?a.min:a.max);
}

static i32
range_distance(Range_i32 a, Range_i32 b){
    i32 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static i64
range_distance(Range_i64 a, Range_i64 b){
    i64 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static u64
range_distance(Range_u64 a, Range_u64 b){
    u64 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static f32
range_distance(Range_f32 a, Range_f32 b){
    f32 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}



static i32
replace_range_shift(i32 replace_length, i32 insert_length){
    return(insert_length - replace_length);
}
static i32
replace_range_shift(i32 start, i32 end, i32 insert_length){
    return(insert_length - (end - start));
}
static i32
replace_range_shift(Range_i32 range, i32 insert_length){
    return(insert_length - (range.end - range.start));
}
static i64
replace_range_shift(i64 replace_length, i64 insert_length){
    return(insert_length - replace_length);
}
static i64
replace_range_shift(i64 start, i64 end, i64 insert_length){
    return(insert_length - (end - start));
}
static i64
replace_range_shift(Range_i64 range, i64 insert_length){
    return(insert_length - (range.end - range.start));
}
static i64
replace_range_shift(u64 replace_length, u64 insert_length){
    return((i64)insert_length - replace_length);
}
static i64
replace_range_shift(i64 start, i64 end, u64 insert_length){
    return((i64)insert_length - (end - start));
}
static i64
replace_range_shift(Range_i64 range, u64 insert_length){
    return((i64)insert_length - (range.end - range.start));
}



static Rect_i32
Ri32(i32 x0, i32 y0, i32 x1, i32 y1){
    Rect_i32 rect = {x0, y0, x1, y1};
    return(rect);
}
static Rect_f32
Rf32(f32 x0, f32 y0, f32 x1, f32 y1){
    Rect_f32 rect = {x0, y0, x1, y1};
    return(rect);
}

static Rect_i32
Ri32(Vec2_i32 p0, Vec2_i32 p1){
    Rect_i32 rect = {p0.x, p0.y, p1.x, p1.y};
    return(rect);
}
static Rect_f32
Rf32(Vec2_f32 p0, Vec2_f32 p1){
    Rect_f32 rect = {p0.x, p0.y, p1.x, p1.y};
    return(rect);
}

static Rect_i32
Ri32(Rect_f32 o){
    Rect_i32 rect = {(i32)(o.x0), (i32)(o.y0), (i32)(o.x1), (i32)(o.y1)};
    return(rect);
}
static Rect_f32
Rf32(Rect_i32 o){
    Rect_f32 rect = {(f32)(o.x0), (f32)(o.y0), (f32)(o.x1), (f32)(o.y1)};
    return(rect);
}

static Rect_i32
Ri32_xy_wh(i32 x0, i32 y0, i32 w, i32 h){
    Rect_i32 rect = {x0, y0, x0 + w, y0 + h};
    return(rect);
}
static Rect_f32
Rf32_xy_wh(f32 x0, f32 y0, f32 w, f32 h){
    Rect_f32 rect = {x0, y0, x0 + w, y0 + h};
    return(rect);
}

static Rect_i32
Ri32_xy_wh(Vec2_i32 p0, Vec2_i32 d){
    Rect_i32 rect = {p0.x, p0.y, p0.x + d.x, p0.y + d.y};
    return(rect);
}
static Rect_f32
Rf32_xy_wh(Vec2_f32 p0, Vec2_f32 d){
    Rect_f32 rect = {p0.x, p0.y, p0.x + d.x, p0.y + d.y};
    return(rect);
}

static Rect_i32
Ri32(Range_i32 x, Range_i32 y){
    return(Ri32(x.min, y.min, x.max, y.max));
}
static Rect_f32
Rf32(Range_f32 x, Range_f32 y){
    return(Rf32(x.min, y.min, x.max, y.max));
}

static const Rect_f32 Rf32_infinity = {-max_f32, -max_f32, max_f32, max_f32};
static const Rect_f32 Rf32_negative_infinity = { max_f32, max_f32, -max_f32, -max_f32};

static const Rect_i32 Ri32_infinity = {-max_i32, -max_i32, max_i32, max_i32};
static const Rect_i32 Ri32_negative_infinity = { max_i32, max_i32, -max_i32, -max_i32};

static b32
rect_equals(Rect_i32 a, Rect_i32 b){
    return(a.x0 == b.x0 && a.y0 == b.y0 && a.x1 == b.x1 && a.y1 == b.y1);
}
static b32
rect_equals(Rect_f32 a, Rect_f32 b){
    return(a.x0 == b.x0 && a.y0 == b.y0 && a.x1 == b.x1 && a.y1 == b.y1);
}

static b32
rect_contains_point(Rect_i32 a, Vec2_i32 b){
    return(a.x0 <= b.x && b.x < a.x1 && a.y0 <= b.y && b.y < a.y1);
}
static b32
rect_contains_point(Rect_f32 a, Vec2_f32 b){
    return(a.x0 <= b.x && b.x < a.x1 && a.y0 <= b.y && b.y < a.y1);
}

static Rect_i32
rect_inner(Rect_i32 r, i32 m){
    r.x0 += m;
    r.y0 += m;
    r.x1 -= m;
    r.y1 -= m;
    return(r);
}
static Rect_f32
rect_inner(Rect_f32 r, f32 m){
    r.x0 += m;
    r.y0 += m;
    r.x1 -= m;
    r.y1 -= m;
    return(r);
}

static Vec2_i32
rect_dim(Rect_i32 r){
    Vec2_i32 v = {r.x1 - r.x0, r.y1 - r.y0};
    return(v);
}
static Range_i32
rect_x(Rect_i32 r){
    return(Ii32(r.x0, r.x1));
}
static Range_i32
rect_y(Rect_i32 r){
    return(Ii32(r.y0, r.y1));
}
static i32
rect_width(Rect_i32 r){
    return(r.x1 - r.x0);
}
static i32
rect_height(Rect_i32 r){
    return(r.y1 - r.y0);
}
static Vec2_f32
rect_dim(Rect_f32 r){
    Vec2_f32 v = {r.x1 - r.x0, r.y1 - r.y0};
    return(v);
}
static Range_f32
rect_x(Rect_f32 r){
    return(If32(r.x0, r.x1));
}
static Range_f32
rect_y(Rect_f32 r){
    return(If32(r.y0, r.y1));
}
static f32
rect_width(Rect_f32 r){
    return(r.x1 - r.x0);
}
static f32
rect_height(Rect_f32 r){
    return(r.y1 - r.y0);
}

static Vec2_i32
rect_center(Rect_i32 r){
    return((r.p0 + r.p1)/2);
}
static Vec2_f32
rect_center(Rect_f32 r){
    return((r.p0 + r.p1)*0.5f);
}

static Range_i32
rect_range_x(Rect_i32 r){
    return(Ii32(r.x0, r.x1));
}
static Range_i32
rect_range_y(Rect_i32 r){
    return(Ii32(r.y0, r.y1));
}
static Range_f32
rect_range_x(Rect_f32 r){
    return(If32(r.x0, r.x1));
}
static Range_f32
rect_range_y(Rect_f32 r){
    return(If32(r.y0, r.y1));
}

static i32
rect_area(Rect_i32 r){
    return((r.x1 - r.x0)*(r.y1 - r.y0));
}
static f32
rect_area(Rect_f32 r){
    return((r.x1 - r.x0)*(r.y1 - r.y0));
}

static b32
rect_overlap(Rect_i32 a, Rect_i32 b){
    return(range_overlap(rect_range_x(a), rect_range_x(b)) &&
           range_overlap(rect_range_y(a), rect_range_y(b)));
}
static b32
rect_overlap(Rect_f32 a, Rect_f32 b){
    return(range_overlap(rect_range_x(a), rect_range_x(b)) &&
           range_overlap(rect_range_y(a), rect_range_y(b)));
}

static Vec2_i32
rect_half_dim(Rect_i32 r){
    return(rect_dim(r)/2);
}
static Vec2_f32
rect_half_dim(Rect_f32 r){
    return(rect_dim(r)*0.5f);
}

static Rect_i32
rect_intersect(Rect_i32 a, Rect_i32 b){
    a.x0 = (((a.x0)>(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)>(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)<(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)<(b.y1))?(a.y1):(b.y1));
    a.x0 = (((a.x0)<(a.x1))?(a.x0):(a.x1));
    a.y0 = (((a.y0)<(a.y1))?(a.y0):(a.y1));
    return(a);
}
static Rect_i32
rect_union(Rect_i32 a, Rect_i32 b){
    a.x0 = (((a.x0)<(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)<(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)>(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)>(b.y1))?(a.y1):(b.y1));
    return(a);
}
static Rect_f32
rect_intersect(Rect_f32 a, Rect_f32 b){
    a.x0 = (((a.x0)>(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)>(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)<(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)<(b.y1))?(a.y1):(b.y1));
    a.x0 = (((a.x0)<(a.x1))?(a.x0):(a.x1));
    a.y0 = (((a.y0)<(a.y1))?(a.y0):(a.y1));
    return(a);
}
static Rect_f32
rect_union(Rect_f32 a, Rect_f32 b){
    a.x0 = (((a.x0)<(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)<(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)>(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)>(b.y1))?(a.y1):(b.y1));
    return(a);
}



static Rect_f32_Pair
rect_split_top_bottom__inner(Rect_f32 rect, f32 y){
    y = (((rect.y0)>(y))?(rect.y0):(((rect.y1)<(y))?(rect.y1):(y)));
    Rect_f32_Pair pair = {};
    pair.a = Rf32(rect.x0, rect.y0, rect.x1, y );
    pair.b = Rf32(rect.x0, y , rect.x1, rect.y1);
    return(pair);
}

static Rect_f32_Pair
rect_split_left_right__inner(Rect_f32 rect, f32 x){
    x = (((rect.x0)>(x))?(rect.x0):(((rect.x1)<(x))?(rect.x1):(x)));
    Rect_f32_Pair pair = {};
    pair.a = Rf32(rect.x0, rect.y0, x , rect.y1);
    pair.b = Rf32(x , rect.y0, rect.x1, rect.y1);
    return(pair);
}

static Rect_f32_Pair
rect_split_top_bottom(Rect_f32 rect, f32 y){
    return(rect_split_top_bottom__inner(rect, rect.y0 + y));
}

static Rect_f32_Pair
rect_split_left_right(Rect_f32 rect, f32 x){
    return(rect_split_left_right__inner(rect, rect.x0 + x));
}

static Rect_f32_Pair
rect_split_top_bottom_neg(Rect_f32 rect, f32 y){
    return(rect_split_top_bottom__inner(rect, rect.y1 - y));
}

static Rect_f32_Pair
rect_split_left_right_neg(Rect_f32 rect, f32 x){
    return(rect_split_left_right__inner(rect, rect.x1 - x));
}

static Rect_f32_Pair
rect_split_top_bottom_lerp(Rect_f32 rect, f32 t){
    return(rect_split_top_bottom__inner(rect, lerp(rect.y0, t, rect.y1)));
}

static Rect_f32_Pair
rect_split_left_right_lerp(Rect_f32 rect, f32 t){
    return(rect_split_left_right__inner(rect, lerp(rect.x0, t, rect.x1)));
}



static Scan_Direction
flip_direction(Scan_Direction direction){
    switch (direction){
        case Scan_Forward:
        {
            direction = Scan_Backward;
        }break;
        case Scan_Backward:
        {
            direction = Scan_Forward;
        }break;
    }
    return(direction);
}

static Side
flip_side(Side side){
    switch (side){
        case Side_Min:
        {
            side = Side_Max;
        }break;
        case Side_Max:
        {
            side = Side_Min;
        }break;
    }
    return(side);
}



static u64
cstring_length(char *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u8 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u16 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u32 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}

static String_char
Schar(char *str, u64 size, u64 cap){
    String_char string = {str, size, cap};
    return(string);
}
static String_u8
Su8(u8 *str, u64 size, u64 cap){
    String_u8 string = {str, size, cap};
    return(string);
}
static String_u16
Su16(u16 *str, u64 size, u64 cap){
    String_u16 string = {str, size, cap};
    return(string);
}
static String_u32
Su32(u32 *str, u64 size, u64 cap){
    String_u32 string = {str, size, cap};
    return(string);
}

static String_Any
Sany(void *str, u64 size, u64 cap, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, size, cap); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, size, cap); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, size, cap); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, size, cap); break;
    }
    return(string);
}

static String_char
Schar(char *str, u64 size){
    String_char string = {str, size, size + 1};
    return(string);
}
static String_u8
Su8(u8 *str, u64 size){
    String_u8 string = {str, size, size + 1};
    return(string);
}
static String_u16
Su16(u16 *str, u64 size){
    String_u16 string = {str, size, size + 1};
    return(string);
}
static String_u32
Su32(u32 *str, u64 size){
    String_u32 string = {str, size, size + 1};
    return(string);
}

static String_Any
Sany(void *str, u64 size, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, size); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, size); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, size); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, size); break;
    }
    return(string);
}

static String_char
Schar(char *str, char *one_past_last){
    return(Schar(str, (u64)(one_past_last - str)));
}
static String_u8
Su8(u8 *str, u8 *one_past_last){
    return(Su8(str, (u64)(one_past_last - str)));
}
static String_u16
Su16(u16 *str, u16 *one_past_last){
    return(Su16(str, (u64)(one_past_last - str)));
}
static String_u32
Su32(u32 *str, u32 *one_past_last){
    return(Su32(str, (u64)(one_past_last - str)));
}

static String_Any
Sany(void *str, void *one_past_last, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, (char*)one_past_last); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, (u8*)one_past_last); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, (u16*)one_past_last); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, (u32*)one_past_last); break;
    }
    return(string);
}

static String_char
Schar(char *str){
    u64 size = cstring_length(str);
    String_char string = {str, size, size + 1};
    return(string);
}
static String_u8
Su8(u8 *str){
    u64 size = cstring_length(str);
    String_u8 string = {str, size, size + 1};
    return(string);
}
static String_u16
Su16(u16 *str){
    u64 size = cstring_length(str);
    String_u16 string = {str, size, size + 1};
    return(string);
}
static String_u32
Su32(u32 *str){
    u64 size = cstring_length(str);
    String_u32 string = {str, size, size + 1};
    return(string);
}

static String_Any
Sany(void *str, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str); break;
    }
    return(string);
}

static String_char
Schar(String_Const_char str, u64 cap){
    String_char string = {str.str, str.size, cap};
    return(string);
}
static String_u8
Su8(String_Const_u8 str, u64 cap){
    String_u8 string = {str.str, str.size, cap};
    return(string);
}
static String_u16
Su16(String_Const_u16 str, u64 cap){
    String_u16 string = {str.str, str.size, cap};
    return(string);
}
static String_u32
Su32(String_Const_u32 str, u64 cap){
    String_u32 string = {str.str, str.size, cap};
    return(string);
}

static String_Any
SCany(String_char str){
    String_Any string = {StringEncoding_ASCII};
    string.s_char = str;
    return(string);
}
static String_Any
SCany(String_u8 str){
    String_Any string = {StringEncoding_UTF8};
    string.s_u8 = str;
    return(string);
}
static String_Any
SCany(String_u16 str){
    String_Any string = {StringEncoding_UTF16};
    string.s_u16 = str;
    return(string);
}
static String_Any
SCany(String_u32 str){
    String_Any string = {StringEncoding_UTF32};
    string.s_u32 = str;
    return(string);
}

static String_Const_char
SCchar(char *str, u64 size){
    String_Const_char string = {str, size};
    return(string);
}
static String_Const_u8
SCu8(u8 *str, u64 size){
    String_Const_u8 string = {str, size};
    return(string);
}
static String_Const_u16
SCu16(u16 *str, u64 size){
    String_Const_u16 string = {str, size};
    return(string);
}
static String_Const_u32
SCu32(u32 *str, u64 size){
    String_Const_u32 string = {str, size};
    return(string);
}

static String_Const_Any
SCany(void *str, u64 size, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str, size); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str, size); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str, size); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str, size); break;
    }
    return(string);
}

static String_Const_char
SCchar(void){
    String_Const_char string = {};
    return(string);
}
static String_Const_u8
SCu8(void){
    String_Const_u8 string = {};
    return(string);
}
static String_Const_u16
SCu16(void){
    String_Const_u16 string = {};
    return(string);
}
static String_Const_u32
SCu32(void){
    String_Const_u32 string = {};
    return(string);
}

static String_Const_char
SCchar(char *str, char *one_past_last){
    return(SCchar(str, (u64)(one_past_last - str)));
}
static String_Const_u8
SCu8(u8 *str, u8 *one_past_last){
    return(SCu8(str, (u64)(one_past_last - str)));
}
static String_Const_u16
SCu16(u16 *str, u16 *one_past_last){
    return(SCu16(str, (u64)(one_past_last - str)));
}
static String_Const_u32
SCu32(u32 *str, u32 *one_past_last){
    return(SCu32(str, (u64)(one_past_last - str)));
}

static String_Const_Any
SCany(void *str, void *one_past_last, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str, (char*)one_past_last); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str, (u8*)one_past_last); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str, (u16*)one_past_last); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str, (u32*)one_past_last); break;
    }
    return(string);
}

static String_Const_char
SCchar(char *str){
    u64 size = cstring_length(str);
    String_Const_char string = {str, size};
    return(string);
}
static String_Const_u8
SCu8(u8 *str){
    u64 size = cstring_length(str);
    String_Const_u8 string = {str, size};
    return(string);
}
static String_Const_u16
SCu16(u16 *str){
    u64 size = cstring_length(str);
    String_Const_u16 string = {str, size};
    return(string);
}
static String_Const_u32
SCu32(u32 *str){
    u64 size = cstring_length(str);
    String_Const_u32 string = {str, size};
    return(string);
}

static String_Const_char
SCchar(String_char string){
    return(string.string);
}
static String_Const_u8
SCu8(String_u8 string){
    return(string.string);
}
static String_Const_u16
SCu16(String_u16 string){
    return(string.string);
}
static String_Const_u32
SCu32(String_u32 string){
    return(string.string);
}

static String_Const_char
SCchar(String_Const_u8 str){
    return(SCchar((char*)str.str, str.size));
}
static String_Const_u8
SCu8(String_Const_char str){
    return(SCu8((u8*)str.str, str.size));
}

static String_Const_u8
SCu8(char *str, u64 length){
    return(SCu8((u8*)str, length));
}
static String_Const_u8
SCu8(char *first, char *one_past_last){
    return(SCu8((u8*)first, (u8*)one_past_last));
}
static String_Const_u8
SCu8(char *str){
    return(SCu8((u8*)str));
}

static String_Const_u16
SCu16(wchar_t *str, u64 size){
    return(SCu16((u16*)str, size));
}
static String_Const_u16
SCu16(wchar_t *str){
    return(SCu16((u16*)str));
}

static String_Const_Any
SCany(void *str, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str); break;
    }
    return(string);
}

static String_Const_Any
SCany(String_Const_char str){
    String_Const_Any string = {StringEncoding_ASCII};
    string.s_char = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u8 str){
    String_Const_Any string = {StringEncoding_UTF8};
    string.s_u8 = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u16 str){
    String_Const_Any string = {StringEncoding_UTF16};
    string.s_u16 = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u32 str){
    String_Const_Any string = {StringEncoding_UTF32};
    string.s_u32 = str;
    return(string);
}







static String_Const_char string_empty = {"", 0};
static String_Const_u8 string_u8_empty = {(u8*)"", 0};





static void*
base_reserve__noop(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    *size_out = 0;
    return(0);
}
static void
base_commit__noop(void *user_data, void *ptr, u64 size){}
static void
base_uncommit__noop(void *user_data, void *ptr, u64 size){}
static void
base_free__noop(void *user_data, void *ptr){}
static void
base_set_access__noop(void *user_data, void *ptr, u64 size, Access_Flag flags){}

static Base_Allocator
make_base_allocator(Base_Allocator_Reserve_Signature *func_reserve,
                    Base_Allocator_Commit_Signature *func_commit,
                    Base_Allocator_Uncommit_Signature *func_uncommit,
                    Base_Allocator_Free_Signature *func_free,
                    Base_Allocator_Set_Access_Signature *func_set_access,
                    void *user_data){
    if (func_reserve == 0){
        func_reserve = base_reserve__noop;
    }
    if (func_commit == 0){
        func_commit = base_commit__noop;
    }
    if (func_uncommit == 0){
        func_uncommit = base_uncommit__noop;
    }
    if (func_free == 0){
        func_free = base_free__noop;
    }
    if (func_set_access == 0){
        func_set_access = base_set_access__noop;
    }
    Base_Allocator base_allocator = {
        func_reserve,
        func_commit,
        func_uncommit,
        func_free,
        func_set_access,
        user_data,
    };
    return(base_allocator);
}
static String_Const_u8
base_allocate__inner(Base_Allocator *allocator, u64 size, String_Const_u8 location){
    u64 full_size = 0;
    void *memory = allocator->reserve(allocator->user_data, size, &full_size, location);
    allocator->commit(allocator->user_data, memory, full_size);
    return(make_data(memory, (u64)full_size));
}
static void
base_free(Base_Allocator *allocator, void *ptr){
    if (ptr != 0){
        allocator->free(allocator->user_data, ptr);
    }
}







static Cursor
make_cursor(void *base, u64 size){
    Cursor cursor = {(u8*)base, 0, size};
    return(cursor);
}
static Cursor
make_cursor(String_Const_u8 data){
    return(make_cursor(data.str, data.size));
}
static Cursor
make_cursor(Base_Allocator *allocator, u64 size){
    String_Const_u8 memory = base_allocate__inner((allocator), (size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3072" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3072" ":") - 1)));
    return(make_cursor(memory));
}
static String_Const_u8
linalloc_push(Cursor *cursor, u64 size, String_Const_u8 location){
    String_Const_u8 result = {};
    if (cursor->pos + size <= cursor->cap){
        result.str = cursor->base + cursor->pos;
        result.size = size;
        cursor->pos += size;
    }
    return(result);
}
static void
linalloc_pop(Cursor *cursor, u64 size){
    if (cursor->pos > size){
        cursor->pos -= size;
    }
    else{
        cursor->pos = 0;
    }
}
static String_Const_u8
linalloc_align(Cursor *cursor, u64 alignment){
    u64 pos = round_up_u64(cursor->pos, alignment);
    u64 new_size = pos - cursor->pos;
    return(linalloc_push(cursor, new_size, SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3098" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3098" ":") - 1))));
}
static Temp_Memory_Cursor
linalloc_begin_temp(Cursor *cursor){
    Temp_Memory_Cursor temp = {cursor, cursor->pos};
    return(temp);
}
static void
linalloc_end_temp(Temp_Memory_Cursor temp){
    temp.cursor->pos = temp.pos;
}
static void
linalloc_clear(Cursor *cursor){
    cursor->pos = 0;
}
static Arena
make_arena(Base_Allocator *allocator, u64 chunk_size, u64 alignment){
    Arena arena = {allocator, 0, chunk_size, alignment};
    return(arena);
}
static Arena
make_arena(Base_Allocator *allocator, u64 chunk_size){
    return(make_arena(allocator, chunk_size, 8));
}
static Arena
make_arena(Base_Allocator *allocator){
    return(make_arena(allocator, ((64) << 10), 8));
}
static Cursor_Node*
arena__new_node(Arena *arena, u64 min_size, String_Const_u8 location){
    min_size = (((min_size)>(arena->chunk_size))?(min_size):(arena->chunk_size));
    String_Const_u8 memory = base_allocate__inner(arena->base_allocator, min_size + sizeof(Cursor_Node), location);
    Cursor_Node *cursor_node = (Cursor_Node*)memory.str;
    cursor_node->cursor = make_cursor(cursor_node + 1, memory.size - sizeof(Cursor_Node));
    ((cursor_node)->next=(arena->cursor_node),(arena->cursor_node)=(cursor_node));
    return(cursor_node);
}
static String_Const_u8
linalloc_push(Arena *arena, u64 size, String_Const_u8 location){
    String_Const_u8 result = {};
    if (size > 0){
        Cursor_Node *cursor_node = arena->cursor_node;
        if (cursor_node == 0){
            cursor_node = arena__new_node(arena, size, location);
        }
        result = linalloc_push(&cursor_node->cursor, size, location);
        if (result.str == 0){
            cursor_node = arena__new_node(arena, size, location);
            result = linalloc_push(&cursor_node->cursor, size, location);
        }
        String_Const_u8 alignment_data = linalloc_align(&cursor_node->cursor, arena->alignment);
        result.size += alignment_data.size;
    }
    return(result);
}
static void
linalloc_pop(Arena *arena, u64 size){
    Base_Allocator *allocator = arena->base_allocator;
    Cursor_Node *cursor_node = arena->cursor_node;
    for (Cursor_Node *prev = 0;
         cursor_node != 0 && size != 0;
         cursor_node = prev){
        prev = cursor_node->prev;
        if (size >= cursor_node->cursor.pos){
            size -= cursor_node->cursor.pos;
            base_free(allocator, cursor_node);
        }
        else{
            linalloc_pop(&cursor_node->cursor, size);
            break;
        }
    }
    arena->cursor_node = cursor_node;
}
static String_Const_u8
linalloc_align(Arena *arena, u64 alignment){
    arena->alignment = alignment;
    String_Const_u8 data = {};
    Cursor_Node *cursor_node = arena->cursor_node;
    if (cursor_node != 0){
        data = linalloc_align(&cursor_node->cursor, arena->alignment);
    }
    return(data);
}
static Temp_Memory_Arena
linalloc_begin_temp(Arena *arena){
    Cursor_Node *cursor_node = arena->cursor_node;
    Temp_Memory_Arena temp = {arena, cursor_node,
        cursor_node == 0?0:cursor_node->cursor.pos};
    return(temp);
}
static void
linalloc_end_temp(Temp_Memory_Arena temp){
    Base_Allocator *allocator = temp.arena->base_allocator;
    Cursor_Node *cursor_node = temp.arena->cursor_node;
    for (Cursor_Node *prev = 0;
         cursor_node != temp.cursor_node && cursor_node != 0;
         cursor_node = prev){
        prev = cursor_node->prev;
        base_free(allocator, cursor_node);
    }
    temp.arena->cursor_node = cursor_node;
    if (cursor_node != 0){
        if (temp.pos > 0){
            cursor_node->cursor.pos = temp.pos;
        }
        else{
            temp.arena->cursor_node = cursor_node->prev;
            base_free(allocator, cursor_node);
        }
    }
}
static void
linalloc_clear(Arena *arena){
    Temp_Memory_Arena temp = {arena, 0, 0};
    linalloc_end_temp(temp);
}
static void*
linalloc_wrap_unintialized(String_Const_u8 data){
    return(data.str);
}
static void*
linalloc_wrap_zero(String_Const_u8 data){
    block_zero(data.str, data.size);
    return(data.str);
}
static void*
linalloc_wrap_write(String_Const_u8 data, u64 size, void *src){
    block_copy(data.str, src, (((data.size)<(size))?(data.size):(size)));
    return(data.str);
}






static Temp_Memory
begin_temp(Cursor *cursor){
    Temp_Memory temp = {LinearAllocatorKind_Cursor};
    temp.temp_memory_cursor = linalloc_begin_temp(cursor);
    return(temp);
}
static Temp_Memory
begin_temp(Arena *arena){
    Temp_Memory temp = {LinearAllocatorKind_Arena};
    temp.temp_memory_arena = linalloc_begin_temp(arena);
    return(temp);
}
static void
end_temp(Temp_Memory temp){
    switch (temp.kind){
        case LinearAllocatorKind_Cursor:
        {
            linalloc_end_temp(temp.temp_memory_cursor);
        }break;
        case LinearAllocatorKind_Arena:
        {
            linalloc_end_temp(temp.temp_memory_arena);
        }break;
    }
}



static void
thread_ctx_init(Thread_Context *tctx, Thread_Kind kind, Base_Allocator *allocator,
                Base_Allocator *prof_allocator){
    block_zero((tctx), sizeof(*(tctx)));
    tctx->kind = kind;
    tctx->allocator = allocator;
    tctx->node_arena = make_arena(allocator, ((4) << 10), 8);

    tctx->prof_allocator = prof_allocator;
    tctx->prof_id_counter = 1;
    tctx->prof_arena = make_arena(prof_allocator, ((16) << 10));
}

static void
thread_ctx_release(Thread_Context *tctx){
    for (Arena_Node *node = tctx->free_arenas;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    for (Arena_Node *node = tctx->used_first;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    linalloc_clear(&tctx->node_arena);
    block_zero((tctx), sizeof(*(tctx)));
}

static Arena_Node*
tctx__alloc_arena_node(Thread_Context *tctx){
    Arena_Node *result = tctx->free_arenas;
    if (result != 0){
        ((tctx->free_arenas)=(tctx->free_arenas)=(tctx->free_arenas)->next);
    }
    else{
        result = ((Arena_Node*)linalloc_wrap_zero(linalloc_push((&tctx->node_arena), sizeof(Arena_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3299" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3299" ":") - 1)))));
        result->arena = make_arena(tctx->allocator, ((16) << 10), 8);
    }
    return(result);
}

static void
tctx__free_arena_node(Thread_Context *tctx, Arena_Node *node){
    ((node)->next=(tctx->free_arenas),(tctx->free_arenas)=(node));
}

static Arena*
tctx_reserve(Thread_Context *tctx){
    Arena_Node *node = tctx->used_first;
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1, Arena *a2){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1 && na != a2){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1, Arena *a2, Arena *a3){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1 && na != a2 && na != a3){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static void
tctx_release(Thread_Context *tctx, Arena *arena){
    Arena_Node *node = (Arena_Node*)( (u8*)(arena) - ((u8*)(&(((Arena_Node*)0)->arena)) - (u8*)(0)) );
    node->ref_counter -= 1;
    if (node->ref_counter == 0){


        linalloc_clear(&node->arena);
        (((tctx->used_last)==(node))?((((tctx->used_first)==(tctx->used_last))?((tctx->used_first)=(tctx->used_last)=0):((tctx->used_last)->prev->next=0,(tctx->used_last)=(tctx->used_last)->prev))) :((tctx->used_first)==(node))?((((tctx->used_last)==(tctx->used_first))?((tctx->used_last)=(tctx->used_first)=0):((tctx->used_first)->next->prev=0,(tctx->used_first)=(tctx->used_first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
        ((node)->next=(tctx->free_arenas),(tctx->free_arenas)=(node));
    }
}



Scratch_Block::Scratch_Block(Thread_Context *t){
    this->tctx = t;
    this->arena = tctx_reserve(t);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1, Arena *a2){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1, a2);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1, Arena *a2, Arena *a3){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1, a2, a3);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::~Scratch_Block(){
    end_temp(this->temp);
    tctx_release(this->tctx, this->arena);
}

Scratch_Block::operator Arena*(){
    return(this->arena);
}

void
Scratch_Block::restore(void){
    end_temp(this->temp);
}

Temp_Memory_Block::Temp_Memory_Block(Temp_Memory t){
    this->temp = t;
}

Temp_Memory_Block::Temp_Memory_Block(Arena *arena){
    this->temp = begin_temp(arena);
}

Temp_Memory_Block::~Temp_Memory_Block(){
    end_temp(this->temp);
}

void
Temp_Memory_Block::restore(void){
    end_temp(this->temp);
}
# 3478 "/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp"
static void
heap_init(Heap *heap, Base_Allocator *allocator){
    heap->arena_ = make_arena(allocator);
    heap->arena = &heap->arena_;
    (&heap->in_order)->next=(&heap->in_order)->prev=(&heap->in_order);
    (&heap->free_nodes)->next=(&heap->free_nodes)->prev=(&heap->free_nodes);
    heap->used_space = 0;
    heap->total_space = 0;
}

static void
heap_init(Heap *heap, Arena *arena){
    heap->arena = arena;
    (&heap->in_order)->next=(&heap->in_order)->prev=(&heap->in_order);
    (&heap->free_nodes)->next=(&heap->free_nodes)->prev=(&heap->free_nodes);
    heap->used_space = 0;
    heap->total_space = 0;
}

static Base_Allocator*
heap_get_base_allocator(Heap *heap){
    return(heap->arena->base_allocator);
}

static void
heap_free_all(Heap *heap){
    if (heap->arena == &heap->arena_){
        linalloc_clear(heap->arena);
    }
    block_zero((heap), sizeof(*(heap)));
}

static void
heap__extend(Heap *heap, void *memory, u64 size){
    ((void)(heap));
    if (size >= sizeof(Heap_Node)){
        Heap_Node *new_node = (Heap_Node*)memory;
        ((&new_node->order)->prev=(&heap->in_order)->prev,(&new_node->order)->next=(&heap->in_order),(&new_node->order)->prev->next=(&new_node->order),(&heap->in_order)->prev=(&new_node->order));
        ((&new_node->alloc)->next=(&heap->free_nodes)->next,(&new_node->alloc)->prev=(&heap->free_nodes),(&new_node->alloc)->next->prev=(&new_node->alloc),(&heap->free_nodes)->next=(&new_node->alloc));
        new_node->size = size - sizeof(*new_node);
        heap->total_space += size;
    }
    ((void)(heap));
}

static void
heap__extend_automatic(Heap *heap, u64 size){
    void *memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((heap->arena), sizeof(u8)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3525" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3525" ":") - 1)))));
    heap__extend(heap, memory, size);
}

static void*
heap__reserve_chunk(Heap *heap, Heap_Node *node, u64 size){
    u8 *ptr = (u8*)(node + 1);
    do{ if (!(node->size >= size)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 left_over_size = node->size - size;
    if (left_over_size > sizeof(*node)){
        u64 new_node_size = left_over_size - sizeof(*node);
        Heap_Node *new_node = (Heap_Node*)(ptr + size);
        ((&new_node->order)->next=(&node->order)->next,(&new_node->order)->prev=(&node->order),(&new_node->order)->next->prev=(&new_node->order),(&node->order)->next=(&new_node->order));
        ((&new_node->alloc)->next=(&node->alloc)->next,(&new_node->alloc)->prev=(&node->alloc),(&new_node->alloc)->next->prev=(&new_node->alloc),(&node->alloc)->next=(&new_node->alloc));
        new_node->size = new_node_size;
    }
    ((&node->alloc)->next->prev=(&node->alloc)->prev,(&node->alloc)->prev->next=(&node->alloc)->next);
    node->alloc.next = 0;
    node->alloc.prev = 0;
    node->size = size;
    heap->used_space += sizeof(*node) + size;
    return(ptr);
}

static void*
heap_allocate(Heap *heap, u64 size){
    b32 first_try = true;
    for (;;){
        if (heap->in_order.next != 0){
            ((void)(heap));
            u64 aligned_size = (size + sizeof(Heap_Node) - 1);
            aligned_size = aligned_size - (aligned_size%sizeof(Heap_Node));
            for (Heap_Basic_Node *n = heap->free_nodes.next;
                 n != &heap->free_nodes;
                 n = n->next){
                Heap_Node *node = (Heap_Node*)( (u8*)(n) - ((u8*)(&(((Heap_Node*)0)->alloc)) - (u8*)(0)) );
                if (node->size >= aligned_size){
                    void *ptr = heap__reserve_chunk(heap, node, aligned_size);
                    ((void)(heap));
                    return(ptr);
                }
            }
            ((void)(heap));
        }

        if (first_try){
            u64 extension_size = (((((64) << 10))>(size*2))?(((64) << 10)):(size*2));
            heap__extend_automatic(heap, extension_size);
            first_try = false;
        }
        else{
            break;
        }
    }
    return(0);
}

static void
heap__merge(Heap *heap, Heap_Node *l, Heap_Node *r){
    if (&l->order != &heap->in_order && &r->order != &heap->in_order &&
        l->alloc.next != 0 && l->alloc.prev != 0 &&
        r->alloc.next != 0 && r->alloc.prev != 0){
        u8 *ptr = (u8*)(l + 1) + l->size;
        if (((u8*)(ptr) - (u8*)(r)) == 0){
            ((&r->order)->next->prev=(&r->order)->prev,(&r->order)->prev->next=(&r->order)->next);
            ((&r->alloc)->next->prev=(&r->alloc)->prev,(&r->alloc)->prev->next=(&r->alloc)->next);
            ((&l->alloc)->next->prev=(&l->alloc)->prev,(&l->alloc)->prev->next=(&l->alloc)->next);
            l->size += r->size + sizeof(*r);
            ((&l->alloc)->next=(&heap->free_nodes)->next,(&l->alloc)->prev=(&heap->free_nodes),(&l->alloc)->next->prev=(&l->alloc),(&heap->free_nodes)->next=(&l->alloc));
        }
    }
}

static void
heap_free(Heap *heap, void *memory){
    if (heap->in_order.next != 0 && memory != 0){
        Heap_Node *node = ((Heap_Node*)memory) - 1;
        do{ if (!(node->alloc.next == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(node->alloc.prev == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        heap->used_space -= sizeof(*node) + node->size;
        ((void)(heap));
        ((&node->alloc)->next=(&heap->free_nodes)->next,(&node->alloc)->prev=(&heap->free_nodes),(&node->alloc)->next->prev=(&node->alloc),(&heap->free_nodes)->next=(&node->alloc));
        ((void)(heap));
        heap__merge(heap, node, (Heap_Node*)( (u8*)(node->order.next) - ((u8*)(&(((Heap_Node*)0)->order)) - (u8*)(0)) ));
        ((void)(heap));
        heap__merge(heap, (Heap_Node*)( (u8*)(node->order.prev) - ((u8*)(&(((Heap_Node*)0)->order)) - (u8*)(0)) ), node);
        ((void)(heap));
    }
}





static void*
base_reserve__heap(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    Heap *heap = (Heap*)user_data;
    void *memory = heap_allocate(heap, size);
    *size_out = size;
    return(memory);
}

static void
base_free__heap(void *user_data, void *ptr){
    Heap *heap = (Heap*)user_data;
    heap_free(heap, ptr);
}

static Base_Allocator
base_allocator_on_heap(Heap *heap){
    return(make_base_allocator(base_reserve__heap, 0, 0, base_free__heap, 0, heap));
}



static String_Const_u8
push_data(Arena *arena, u64 size){
    String_Const_u8 result = {};
    result.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3643" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3643" ":") - 1)))));
    result.size = size;
    return(result);
}

static String_Const_u8
push_data_copy(Arena *arena, String_Const_u8 data){
    String_Const_u8 result = {};
    result.str = ((u8*)linalloc_wrap_write(linalloc_push((arena), sizeof(u8)*(data.size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3651" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "3651" ":") - 1))), sizeof(u8)*(data.size), (data.str)));
    result.size = data.size;
    return(result);
}

static b32
data_match(String_Const_u8 a, String_Const_u8 b){
    return(a.size == b.size && block_match(a.str, b.str, a.size));
}



static b32
character_is_basic_ascii(char c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u8 c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u16 c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u32 c){
    return(' ' <= c && c <= '~');
}

static b32
character_is_slash(char c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u8 c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u16 c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u32 c){
    return((c == '/') || (c == '\\'));
}

static b32
character_is_upper(char c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u8 c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u16 c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u32 c){
    return(('A' <= c) && (c <= 'Z'));
}

static b32
character_is_lower(char c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u8 c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u16 c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u32 c){
    return(('a' <= c) && (c <= 'z'));
}

static b32
character_is_lower_unicode(u8 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}
static b32
character_is_lower_unicode(u16 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}
static b32
character_is_lower_unicode(u32 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}

static char
character_to_upper(char c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u8
character_to_upper(u8 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u16
character_to_upper(u16 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u32
character_to_upper(u32 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static char
character_to_lower(char c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u8
character_to_lower(u8 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u16
character_to_lower(u16 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u32
character_to_lower(u32 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}

static b32
character_is_whitespace(char c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u8 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u16 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u32 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}

static b32
character_is_base10(char c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u8 c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u16 c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u32 c){
    return('0' <= c && c <= '9');
}

static b32
character_is_base16(char c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u8 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u16 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u32 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}

static b32
character_is_base64(char c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u8 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u16 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u32 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}

static b32
character_is_alpha(char c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u8 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u16 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u32 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}

static b32
character_is_alpha_numeric(char c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u8 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u16 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u32 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}


static b32
character_is_alpha_unicode(u8 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_unicode(u16 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_unicode(u32 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}

static b32
character_is_alpha_numeric_unicode(u8 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_numeric_unicode(u16 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_numeric_unicode(u32 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}

static char
string_get_character(String_Const_char str, u64 i){
    char r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u8
string_get_character(String_Const_u8 str, u64 i){
    u8 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u16
string_get_character(String_Const_u16 str, u64 i){
    u16 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u32
string_get_character(String_Const_u32 str, u64 i){
    u32 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}

static String_Const_char
string_prefix(String_Const_char str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u8
string_prefix(String_Const_u8 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u16
string_prefix(String_Const_u16 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u32
string_prefix(String_Const_u32 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}

static String_Const_Any
string_prefix(String_Const_Any str, u64 size){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_prefix(str.s_char, size); break;
        case StringEncoding_UTF8: str.s_u8 = string_prefix(str.s_u8 , size); break;
        case StringEncoding_UTF16: str.s_u16 = string_prefix(str.s_u16 , size); break;
        case StringEncoding_UTF32: str.s_u32 = string_prefix(str.s_u32 , size); break;
    }
    return(str);
}

static String_Const_char
string_postfix(String_Const_char str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u8
string_postfix(String_Const_u8 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u16
string_postfix(String_Const_u16 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u32
string_postfix(String_Const_u32 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}

static String_Const_Any
string_postfix(String_Const_Any str, u64 size){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_postfix(str.s_char, size); break;
        case StringEncoding_UTF8: str.s_u8 = string_postfix(str.s_u8 , size); break;
        case StringEncoding_UTF16: str.s_u16 = string_postfix(str.s_u16 , size); break;
        case StringEncoding_UTF32: str.s_u32 = string_postfix(str.s_u32 , size); break;
    }
    return(str);
}

static String_Const_char
string_skip(String_Const_char str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u8
string_skip(String_Const_u8 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u16
string_skip(String_Const_u16 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u32
string_skip(String_Const_u32 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}

static String_Const_Any
string_skip(String_Const_Any str, u64 n){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_skip(str.s_char, n); break;
        case StringEncoding_UTF8: str.s_u8 = string_skip(str.s_u8 , n); break;
        case StringEncoding_UTF16: str.s_u16 = string_skip(str.s_u16 , n); break;
        case StringEncoding_UTF32: str.s_u32 = string_skip(str.s_u32 , n); break;
    }
    return(str);
}

static String_Const_char
string_chop(String_Const_char str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u8
string_chop(String_Const_u8 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u16
string_chop(String_Const_u16 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u32
string_chop(String_Const_u32 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}

static String_Const_Any
string_chop(String_Const_Any str, u64 n){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_chop(str.s_char, n); break;
        case StringEncoding_UTF8: str.s_u8 = string_chop(str.s_u8 , n); break;
        case StringEncoding_UTF16: str.s_u16 = string_chop(str.s_u16 , n); break;
        case StringEncoding_UTF32: str.s_u32 = string_chop(str.s_u32 , n); break;
    }
    return(str);
}

static String_Const_char
string_substring(String_Const_char str, Range_i64 range){
    return(SCchar(str.str + range.min, str.str + range.max));
}
static String_Const_u8
string_substring(String_Const_u8 str, Range_i64 range){
    return(SCu8(str.str + range.min, str.str + range.max));
}
static String_Const_u16
string_substring(String_Const_u16 str, Range_i64 range){
    return(SCu16(str.str + range.min, str.str + range.max));
}
static String_Const_u32
string_substring(String_Const_u32 str, Range_i64 range){
    return(SCu32(str.str + range.min, str.str + range.max));
}

static u64
string_find_first(String_Const_char str, u64 start_pos, char c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u8 str, u64 start_pos, u8 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u16 str, u64 start_pos, u16 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u32 str, u64 start_pos, u32 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}

static u64
string_find_first(String_Const_char str, char c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u8 str, u8 c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u16 str, u16 c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u32 str, u32 c){
    return(string_find_first(str, 0, c));
}

static i64
string_find_last(String_Const_char str, char c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u8 str, u8 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u16 str, u16 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u32 str, u32 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}

static u64
string_find_first_whitespace(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}

static u64
string_find_first_non_whitespace(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}

static u64
string_find_first_slash(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}

static String_Const_char
string_remove_last_folder(String_Const_char str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_remove_last_folder(String_Const_u8 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u16
string_remove_last_folder(String_Const_u16 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u32
string_remove_last_folder(String_Const_u32 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}

static b32
string_looks_like_drive_letter(String_Const_u8 string){
    b32 result = false;
    if (string.size == 3 &&
        character_is_alpha(string.str[0]) &&
        string.str[1] == ':' &&
        character_is_slash(string.str[2])){
        result = true;
    }
    return(result);
}

static String_Const_char
string_remove_front_of_path(String_Const_char str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_remove_front_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u16
string_remove_front_of_path(String_Const_u16 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u32
string_remove_front_of_path(String_Const_u32 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}

static String_Const_char
string_front_of_path(String_Const_char str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u8
string_front_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u16
string_front_of_path(String_Const_u16 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u32
string_front_of_path(String_Const_u32 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}

static String_Const_u8
string_remove_front_folder_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(string_chop(str, 1));
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_front_folder_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(string_chop(str, 1));
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}

static String_Const_char
string_file_extension(String_Const_char string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u8
string_file_extension(String_Const_u8 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u16
string_file_extension(String_Const_u16 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u32
string_file_extension(String_Const_u32 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}

static String_Const_char
string_file_without_extension(String_Const_char string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u8
string_file_without_extension(String_Const_u8 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u16
string_file_without_extension(String_Const_u16 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u32
string_file_without_extension(String_Const_u32 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}

static String_Const_char
string_skip_whitespace(String_Const_char str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u8
string_skip_whitespace(String_Const_u8 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u16
string_skip_whitespace(String_Const_u16 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u32
string_skip_whitespace(String_Const_u32 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}

static String_Const_char
string_chop_whitespace(String_Const_char str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u8
string_chop_whitespace(String_Const_u8 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u16
string_chop_whitespace(String_Const_u16 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u32
string_chop_whitespace(String_Const_u32 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}

static String_Const_char
string_skip_chop_whitespace(String_Const_char str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u8
string_skip_chop_whitespace(String_Const_u8 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u16
string_skip_chop_whitespace(String_Const_u16 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u32
string_skip_chop_whitespace(String_Const_u32 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}

static b32
string_match(String_Const_char a, String_Const_char b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u8 a, String_Const_u8 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u16 a, String_Const_u16 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u32 a, String_Const_u32 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}

static b32
string_match(String_Const_Any a, String_Const_Any b){
    b32 result = false;
    if (a.encoding == b.encoding){
        switch (a.encoding){
            case StringEncoding_ASCII: result = string_match(a.s_char, b.s_char); break;
            case StringEncoding_UTF8: result = string_match(a.s_u8 , b.s_u8 ); break;
            case StringEncoding_UTF16: result = string_match(a.s_u16 , b.s_u16 ); break;
            case StringEncoding_UTF32: result = string_match(a.s_u32 , b.s_u32 ); break;
        }
    }
    return(result);
}

static b32
string_match_insensitive(String_Const_char a, String_Const_char b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u8 a, String_Const_u8 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u16 a, String_Const_u16 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u32 a, String_Const_u32 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}

static b32
string_match(String_Const_char a, String_Const_char b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u8 a, String_Const_u8 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u16 a, String_Const_u16 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u32 a, String_Const_u32 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}

static u64
string_find_first(String_Const_char str, String_Const_char needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            char c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_char source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u8 str, String_Const_u8 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u8 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u8 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u16 str, String_Const_u16 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u16 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u16 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u32 str, String_Const_u32 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u32 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u32 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}

static u64
string_find_first(String_Const_char str, String_Const_char needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u16 str, String_Const_u16 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u32 str, String_Const_u32 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first_insensitive(String_Const_char str, String_Const_char needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u16 str, String_Const_u16 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u32 str, String_Const_u32 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}

static b32
string_has_substr(String_Const_u8 str, String_Const_u8 needle, String_Match_Rule rule){
    return(string_find_first(str, needle, rule) < str.size);
}

static b32
string_has_substr(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_Exact) < str.size);
}

static i32
string_compare(String_Const_char a, String_Const_char b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        char ca = (i < a.size)?a.str[i]:0;
        char cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u8 a, String_Const_u8 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u8 ca = (i < a.size)?a.str[i]:0;
        u8 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u16 a, String_Const_u16 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u16 ca = (i < a.size)?a.str[i]:0;
        u16 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u32 a, String_Const_u32 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u32 ca = (i < a.size)?a.str[i]:0;
        u32 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}

static i32
string_compare_insensitive(String_Const_char a, String_Const_char b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        char ca = (i <= a.size)?0:a.str[i];
        char cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u8 a, String_Const_u8 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u8 ca = (i <= a.size)?0:a.str[i];
        u8 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u16 a, String_Const_u16 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u16 ca = (i <= a.size)?0:a.str[i];
        u16 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u32 a, String_Const_u32 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u32 ca = (i <= a.size)?0:a.str[i];
        u32 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}

static String_Const_char
string_mod_upper(String_Const_char str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u8
string_mod_upper(String_Const_u8 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u16
string_mod_upper(String_Const_u16 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u32
string_mod_upper(String_Const_u32 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_char
string_mod_lower(String_Const_char str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u8
string_mod_lower(String_Const_u8 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u16
string_mod_lower(String_Const_u16 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u32
string_mod_lower(String_Const_u32 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}

static String_Const_char
string_mod_replace_character(String_Const_char str, char o, char n){
    for (u64 i = 0; i < str.size; i += 1){
        char c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u8
string_mod_replace_character(String_Const_u8 str, u8 o, u8 n){
    for (u64 i = 0; i < str.size; i += 1){
        u8 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u16
string_mod_replace_character(String_Const_u16 str, u16 o, u16 n){
    for (u64 i = 0; i < str.size; i += 1){
        u16 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u32
string_mod_replace_character(String_Const_u32 str, u32 o, u32 n){
    for (u64 i = 0; i < str.size; i += 1){
        u32 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}

static b32
string_append(String_char *dst, String_Const_char src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u8 *dst, String_Const_u8 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u16 *dst, String_Const_u16 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u32 *dst, String_Const_u32 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}

static b32
string_append_character(String_char *dst, char c){
    return(string_append(dst, SCchar(&c, 1)));
}
static b32
string_append_character(String_u8 *dst, u8 c){
    return(string_append(dst, SCu8(&c, 1)));
}
static b32
string_append_character(String_u16 *dst, u16 c){
    return(string_append(dst, SCu16(&c, 1)));
}
static b32
string_append_character(String_u32 *dst, u32 c){
    return(string_append(dst, SCu32(&c, 1)));
}

static b32
string_null_terminate(String_char *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u8 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u16 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u32 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}

static String_char
string_char_push(Arena *arena, u64 size){
    String_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5309" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5309" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u8
string_u8_push(Arena *arena, u64 size){
    String_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5316" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5316" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u16
string_u16_push(Arena *arena, u64 size){
    String_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5323" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5323" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u32
string_u32_push(Arena *arena, u64 size){
    String_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5330" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5330" ":") - 1)))));
    string.cap = size;
    return(string);
}

static String_Any
string_any_push(Arena *arena, u64 size, String_Encoding encoding){
    String_Any string = {};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = string_char_push(arena, size); break;
        case StringEncoding_UTF8: string.s_u8 = string_u8_push (arena, size); break;
        case StringEncoding_UTF16: string.s_u16 = string_u16_push (arena, size); break;
        case StringEncoding_UTF32: string.s_u32 = string_u32_push (arena, size); break;
    }
    return(string);
}






static String_Const_char
string_const_char_push(Arena *arena, u64 size){
    String_Const_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5355" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5355" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u8
string_const_u8_push(Arena *arena, u64 size){
    String_Const_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5362" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5362" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u16
string_const_u16_push(Arena *arena, u64 size){
    String_Const_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5369" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5369" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u32
string_const_u32_push(Arena *arena, u64 size){
    String_Const_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5376" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5376" ":") - 1)))));
    string.size = size;
    return(string);
}

static String_Const_Any
string_const_any_push(Arena *arena, u64 size, String_Encoding encoding){
    String_Const_Any string = {};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = string_const_char_push(arena, size); break;
        case StringEncoding_UTF8: string.s_u8 = string_const_u8_push (arena, size); break;
        case StringEncoding_UTF16: string.s_u16 = string_const_u16_push (arena, size); break;
        case StringEncoding_UTF32: string.s_u32 = string_const_u32_push (arena, size); break;
    }
    return(string);
}






static String_Const_char
push_string_copy(Arena *arena, String_Const_char src){
    String_Const_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(src.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5401" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5401" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u8
push_string_copy(Arena *arena, String_Const_u8 src){
    String_Const_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(src.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5410" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5410" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u16
push_string_copy(Arena *arena, String_Const_u16 src){
    String_Const_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(src.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5419" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5419" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u32
push_string_copy(Arena *arena, String_Const_u32 src){
    String_Const_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(src.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5428" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5428" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}

static String_Const_Any
push_string_copy(Arena *arena, u64 size, String_Const_Any src){
    String_Const_Any string = {};
    switch (src.encoding){
        case StringEncoding_ASCII: string.s_char = push_string_copy(arena, src.s_char); break;
        case StringEncoding_UTF8: string.s_u8 = push_string_copy(arena, src.s_u8 ); break;
        case StringEncoding_UTF16: string.s_u16 = push_string_copy(arena, src.s_u16 ); break;
        case StringEncoding_UTF32: string.s_u32 = push_string_copy(arena, src.s_u32 ); break;
    }
    return(string);
}

static String_Const_u8_Array
push_string_array_copy(Arena *arena, String_Const_u8_Array src){
    String_Const_u8_Array result = {};
    result.vals = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(src.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5450" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5450" ":") - 1)))));
    result.count = src.count;
    for (i32 i = 0; i < src.count; i += 1){
        result.vals[i] = push_string_copy(arena, src.vals[i]);
    }
    return(result);
}

static void
string_list_push(List_String_Const_char *list, Node_String_Const_char *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u8 *list, Node_String_Const_u8 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u16 *list, Node_String_Const_u16 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u32 *list, Node_String_Const_u32 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}

static void
string_list_push(Arena *arena, List_String_Const_char *list, String_Const_char string){
    Node_String_Const_char *node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5485" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5485" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u8 *list, String_Const_u8 string){
    Node_String_Const_u8 *node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5493" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5493" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u16 *list, String_Const_u16 string){
    Node_String_Const_u16 *node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5501" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5501" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u32 *list, String_Const_u32 string){
    Node_String_Const_u32 *node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5509" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5509" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}

static void
string_list_push(Arena *arena, List_String_Const_Any *list, String_Const_Any string){
    Node_String_Const_Any *node = ((Node_String_Const_Any*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_Any)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5518" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "5518" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}




static void
string_list_push(List_String_Const_char *list, List_String_Const_char *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u8 *list, List_String_Const_u8 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u16 *list, List_String_Const_u16 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u32 *list, List_String_Const_u32 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}

static void
string_list_push(List_String_Const_Any *list, List_String_Const_Any *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}

static void
string_list_push_overlap(Arena *arena, List_String_Const_char *list, char overlap, String_Const_char string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_char tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCchar(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u8 *list, u8 overlap, String_Const_u8 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u8 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu8(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u16 *list, u16 overlap, String_Const_u16 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u16 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu16(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u32 *list, u32 overlap, String_Const_u32 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u32 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu32(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}






typedef String_Const_char String_char_Mod_Function_Type(String_Const_char string);
typedef String_Const_u8 String_u8_Mod_Function_Type(String_Const_u8 string);
typedef String_Const_u16 String_u16_Mod_Function_Type(String_Const_u16 string);
typedef String_Const_u32 String_u32_Mod_Function_Type(String_Const_u32 string);

static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_char_Mod_Function_Type *mod, String_Const_char separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_char string = string_char_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_char *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCchar(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_u8_Mod_Function_Type *mod, String_Const_u8 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u8 string = string_u8_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u8 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu8(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_u16_Mod_Function_Type *mod, String_Const_u16 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u16 string = string_u16_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u16 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu16(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_u32_Mod_Function_Type *mod, String_Const_u32 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u32 string = string_u32_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u32 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu32(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_Const_char separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_Const_u8 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_Const_u16 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_Const_u32 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_char_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCchar(), 0, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_u8_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu8(), 0, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_u16_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu16(), 0, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_u32_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu32(), 0, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCchar(), 0, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu8(), 0, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu16(), 0, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu32(), 0, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char string){
    return(string_list_flatten(arena, string, 0, SCchar(), 0, StringFill_NoTerminate));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 string){
    return(string_list_flatten(arena, string, 0, SCu8(), 0, StringFill_NoTerminate));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 string){
    return(string_list_flatten(arena, string, 0, SCu16(), 0, StringFill_NoTerminate));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 string){
    return(string_list_flatten(arena, string, 0, SCu32(), 0, StringFill_NoTerminate));
}

static List_String_Const_char
string_split(Arena *arena, String_Const_char string, char *split_characters, i32 split_character_count){
    List_String_Const_char list = {};
    for (;;){
        u64 i = string.size;
        String_Const_char prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u8
string_split(Arena *arena, String_Const_u8 string, u8 *split_characters, i32 split_character_count){
    List_String_Const_u8 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u8 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u16
string_split(Arena *arena, String_Const_u16 string, u16 *split_characters, i32 split_character_count){
    List_String_Const_u16 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u16 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u32
string_split(Arena *arena, String_Const_u32 string, u32 *split_characters, i32 split_character_count){
    List_String_Const_u32 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u32 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}

static List_String_Const_char
string_split_needle(Arena *arena, String_Const_char string, String_Const_char needle){
    List_String_Const_char list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_char prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u8
string_split_needle(Arena *arena, String_Const_u8 string, String_Const_u8 needle){
    List_String_Const_u8 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u8 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u16
string_split_needle(Arena *arena, String_Const_u16 string, String_Const_u16 needle){
    List_String_Const_u16 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u16 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u32
string_split_needle(Arena *arena, String_Const_u32 string, String_Const_u32 needle){
    List_String_Const_u32 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u32 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}

static void
string_list_insert_separators(Arena *arena, List_String_Const_char *list, String_Const_char separator, String_Separator_Flag flags){
    Node_String_Const_char *last = list->last;
    for (Node_String_Const_char *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6006" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6006" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6014" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6014" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6022" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6022" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u8 *list, String_Const_u8 separator, String_Separator_Flag flags){
    Node_String_Const_u8 *last = list->last;
    for (Node_String_Const_u8 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6038" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6038" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6046" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6046" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6054" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6054" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u16 *list, String_Const_u16 separator, String_Separator_Flag flags){
    Node_String_Const_u16 *last = list->last;
    for (Node_String_Const_u16 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6070" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6070" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6078" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6078" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6086" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6086" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u32 *list, String_Const_u32 separator, String_Separator_Flag flags){
    Node_String_Const_u32 *last = list->last;
    for (Node_String_Const_u32 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6102" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6102" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6110" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6110" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6118" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6118" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}

static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_char *list, String_Const_char needle, String_Const_char new_value){
    for (Node_String_Const_char *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u8 *list, String_Const_u8 needle, String_Const_u8 new_value){
    for (Node_String_Const_u8 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u16 *list, String_Const_u16 needle, String_Const_u16 new_value){
    for (Node_String_Const_u16 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u32 *list, String_Const_u32 needle, String_Const_u32 new_value){
    for (Node_String_Const_u32 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}

static String_Const_char
string_condense_whitespace(Arena *arena, String_Const_char string){
    char split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_char list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCchar(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u8
string_condense_whitespace(Arena *arena, String_Const_u8 string){
    u8 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u8 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu8(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u16
string_condense_whitespace(Arena *arena, String_Const_u16 string){
    u16 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u16 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu16(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u32
string_condense_whitespace(Arena *arena, String_Const_u32 string){
    u32 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u32 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu32(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}

static List_String_Const_u8
string_split_wildcards(Arena *arena, String_Const_u8 string){
    List_String_Const_u8 list = {};
    if (string_get_character(string, 0) == '*'){
        string_list_push(arena, &list, SCu8());
    }
    {
        List_String_Const_u8 splits = string_split(arena, string, (u8*)"*", 1);
        string_list_push(&list, &splits);
    }
    if (string.size > 1 && string_get_character(string, string.size - 1) == '*'){
        string_list_push(arena, &list, SCu8());
    }
    return(list);
}

static b32
string_wildcard_match(List_String_Const_u8 list, String_Const_u8 string, String_Match_Rule rule){
    b32 success = true;
    if (list.node_count > 0){
        String_Const_u8 head = list.first->string;
        if (!string_match(head, string_prefix(string, head.size), rule)){
            success = false;
        }
        else if (list.node_count > 1){
            string = string_skip(string, head.size);
            String_Const_u8 tail = list.last->string;
            if (!string_match(tail, string_postfix(string, tail.size), rule)){
                success = false;
            }
            else if (list.node_count > 2){
                string = string_chop(string, tail.size);
                Node_String_Const_u8 *one_past_last = list.last;
                for (Node_String_Const_u8 *node = list.first->next;
                     node != one_past_last;
                     node = node->next){
                    u64 position = string_find_first(string, node->string, rule);
                    if (position < string.size){
                        string = string_skip(string, position + node->string.size);
                    }
                    else{
                        success = false;
                        break;
                    }
                }
            }
        }
    }
    return(success);
}

static b32
string_wildcard_match(List_String_Const_u8 list, String_Const_u8 string){
    return(string_wildcard_match(list, string, StringMatch_Exact));
}
static b32
string_wildcard_match_insensitive(List_String_Const_u8 list, String_Const_u8 string){
    return(string_wildcard_match(list, string, StringMatch_CaseInsensitive));
}

static void
string_list_reverse(List_String_Const_char *list){
    Node_String_Const_char *first = 0;
    Node_String_Const_char *last = list->first;
    for (Node_String_Const_char *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u8 *list){
    Node_String_Const_u8 *first = 0;
    Node_String_Const_u8 *last = list->first;
    for (Node_String_Const_u8 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u16 *list){
    Node_String_Const_u16 *first = 0;
    Node_String_Const_u16 *last = list->first;
    for (Node_String_Const_u16 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u32 *list){
    Node_String_Const_u32 *first = 0;
    Node_String_Const_u32 *last = list->first;
    for (Node_String_Const_u32 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}

static b32
string_list_match(List_String_Const_u8 a, List_String_Const_u8 b){
    b32 result = true;
    for (Node_String_Const_u8 *a_node = a.first, *b_node = b.first;
         a_node != 0 && b_node != 0;
         a_node = a_node->next, b_node = b_node->next){
        if (!string_match(a_node->string, b_node->string)){
            result = false;
            break;
        }
    }
    return(result);
}



static const u8 utf8_class[32] = {
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,3,3,4,5,
};

static Character_Consume_Result
utf8_consume(u8 *str, u64 max){
    Character_Consume_Result result = {1, max_u32};
    u8 byte = str[0];
    u8 byte_class = utf8_class[byte >> 3];
    switch (byte_class){
        case 1:
        {
            result.codepoint = byte;
        }break;
        case 2:
        {
            if (1 < max){
                u8 cont_byte = str[1];
                if (utf8_class[cont_byte >> 3] == 0){
                    result.codepoint = (byte & bitmask_5) << 6;
                    result.codepoint |= (cont_byte & bitmask_6);
                    result.inc = 2;
                }
            }
        }break;
        case 3:
        {
            if (2 < max){
                u8 cont_byte[2] = {str[1], str[2]};
                if (utf8_class[cont_byte[0] >> 3] == 0 &&
                    utf8_class[cont_byte[1] >> 3] == 0){
                    result.codepoint = (byte & bitmask_4) << 12;
                    result.codepoint |= ((cont_byte[0] & bitmask_6) << 6);
                    result.codepoint |= (cont_byte[1] & bitmask_6);
                    result.inc = 3;
                }
            }
        }break;
        case 4:
        {
            if (3 < max){
                u8 cont_byte[3] = {str[1], str[2], str[3]};
                if (utf8_class[cont_byte[0] >> 3] == 0 &&
                    utf8_class[cont_byte[1] >> 3] == 0 &&
                    utf8_class[cont_byte[2] >> 3] == 0){
                    result.codepoint = (byte & bitmask_3) << 18;
                    result.codepoint |= ((cont_byte[0] & bitmask_6) << 12);
                    result.codepoint |= ((cont_byte[1] & bitmask_6) << 6);
                    result.codepoint |= (cont_byte[2] & bitmask_6);
                    result.inc = 4;
                }
            }
        }break;
    }
    return(result);
}

static Character_Consume_Result
utf16_consume(u16 *str, u64 max){
    Character_Consume_Result result = {1, max_u32};
    result.codepoint = str[0];
    result.inc = 1;
    if (0xD800 <= str[0] && str[0] < 0xDC00 && max > 1 && 0xDC00 <= str[1] && str[1] < 0xE000){
        result.codepoint = ((str[0] - 0xD800) << 10) | (str[1] - 0xDC00);
        result.inc = 2;
    }
    return(result);
}

static u32
utf8_write(u8 *str, u32 codepoint){
    u32 inc = 0;
    if (codepoint <= 0x7F){
        str[0] = (u8)codepoint;
        inc = 1;
    }
    else if (codepoint <= 0x7FF){
        str[0] = (bitmask_2 << 6) | ((codepoint >> 6) & bitmask_5);
        str[1] = bit_8 | (codepoint & bitmask_6);
        inc = 2;
    }
    else if (codepoint <= 0xFFFF){
        str[0] = (bitmask_3 << 5) | ((codepoint >> 12) & bitmask_4);
        str[1] = bit_8 | ((codepoint >> 6) & bitmask_6);
        str[2] = bit_8 | ( codepoint & bitmask_6);
        inc = 3;
    }
    else if (codepoint <= 0x10FFFF){
        str[0] = (bitmask_4 << 3) | ((codepoint >> 18) & bitmask_3);
        str[1] = bit_8 | ((codepoint >> 12) & bitmask_6);
        str[2] = bit_8 | ((codepoint >> 6) & bitmask_6);
        str[3] = bit_8 | ( codepoint & bitmask_6);
        inc = 4;
    }
    else{
        str[0] = '?';
        inc = 1;
    }
    return(inc);
}

static u32
utf16_write(u16 *str, u32 codepoint){
    u32 inc = 1;
    if (codepoint == max_u32){
        str[0] = (u16)'?';
    }
    else if (codepoint < 0x10000){
        str[0] = (u16)codepoint;
    }
    else{
        u32 v = codepoint - 0x10000;
        str[0] = 0xD800 + (u16)(v >> 10);
        str[1] = 0xDC00 + (v & bitmask_10);
        inc = 2;
    }
    return(inc);
}



static String_u8
string_u8_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6463" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6463" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u8)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6481" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6481" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u16)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(string.size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6499" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6499" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u32)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6517" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6517" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint <= 127)?((char)consume.codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6539" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6539" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.size += utf16_write(out.str + out.size, consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6561" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6561" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint == max_u32)?(u64)'?':(consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6583" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6583" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint <= 127)?((char)consume.codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u8
string_u8_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size*3;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6605" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6605" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.size += utf8_write(out.str + out.size, consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6627" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6627" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.str[out.size++] = consume.codepoint;
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(string.size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6649" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6649" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        u32 codepoint = *ptr;
        out.str[out.size++] = (codepoint <= 127)?((char)codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u8
string_u8_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size*4;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6669" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6669" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        out.size += utf8_write(out.str + out.size, *ptr);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size*2;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6688" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "6688" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        out.size += utf16_write(out.str + out.size, *ptr);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}



static String_char
string_char_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_char_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_char
string_char_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_char_from_string_u16(arena, string, StringFill_NullTerminate));
}
static String_char
string_char_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_char_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_char(Arena *arena, String_Const_char string){
    return(string_u8_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_u8_from_string_u16(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_u8_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_char(Arena *arena, String_Const_char string){
    return(string_u16_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_u16_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_u16_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_char(Arena *arena, String_Const_char string){
    return(string_u32_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_u32_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_u32_from_string_u16(arena, string, StringFill_NullTerminate));
}



static String_Const_char
string_char_from_any(Arena *arena, String_Const_Any string){
    String_Const_char result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string.s_char; break;
        case StringEncoding_UTF8: result = string_char_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string_char_from_string_u16(arena, string.s_u16).string; break;
        case StringEncoding_UTF32: result = string_char_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u8
string_u8_from_any(Arena *arena, String_Const_Any string){
    String_Const_u8 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u8_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string.s_u8; break;
        case StringEncoding_UTF16: result = string_u8_from_string_u16(arena, string.s_u16).string; break;
        case StringEncoding_UTF32: result = string_u8_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u16
string_u16_from_any(Arena *arena, String_Const_Any string){
    String_Const_u16 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u16_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string_u16_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string.s_u16; break;
        case StringEncoding_UTF32: result = string_u16_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u32
string_u32_from_any(Arena *arena, String_Const_Any string){
    String_Const_u32 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u32_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string_u32_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string_u32_from_string_u16 (arena, string.s_u16 ).string; break;
        case StringEncoding_UTF32: result = string.s_u32; break;
    }
    return(result);
}

static String_Const_Any
string_any_from_any(Arena *arena, String_Encoding encoding, String_Const_Any string){
    String_Const_Any result = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: result.s_char = string_char_from_any(arena, string); break;
        case StringEncoding_UTF8: result.s_u8 = string_u8_from_any (arena, string); break;
        case StringEncoding_UTF16: result.s_u16 = string_u16_from_any (arena, string); break;
        case StringEncoding_UTF32: result.s_u32 = string_u32_from_any (arena, string); break;
    }
    return(result);
}

static List_String_Const_char
string_list_char_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_char result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_char_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u8
string_list_u8_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u8 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u8_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u16
string_list_u16_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u16 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u16_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u32
string_list_u32_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u32 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u32_from_any(arena, node->string));
    }
    return(result);
}



static Line_Ending_Kind
string_guess_line_ending_kind(String_Const_u8 string){
    b32 looks_like_binary = false;
    u64 crlf_count = 0;
    u64 lf_count = 0;
    for (u64 i = 0; i < string.size; i += 1){
        if (string.str[i] == 0){
            looks_like_binary = true;
            break;
        }
        if (string.str[i] == '\r' &&
            (i + 1 == string.size || string.str[i + 1] != '\n')){
            looks_like_binary = true;
            break;
        }
        if (string.str[i] == '\n'){
            if (i > 0 && string.str[i - 1] == '\r'){
                crlf_count += 1;
            }
            else{
                lf_count += 1;
            }
        }
    }
    Line_Ending_Kind kind = LineEndingKind_Binary;
    if (!looks_like_binary){
        if (crlf_count > lf_count){
            kind = LineEndingKind_CRLF;
        }
        else{
            kind = LineEndingKind_LF;
        }
    }
    return(kind);
}



static List_String_Const_char
string_replace_list(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement){
    List_String_Const_char list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u8
string_replace_list(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement){
    List_String_Const_u8 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u16
string_replace_list(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement){
    List_String_Const_u16 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u32
string_replace_list(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement){
    List_String_Const_u32 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}

static String_Const_char
string_replace(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_char list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u8
string_replace(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u8 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u16
string_replace(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u16 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u32
string_replace(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u32 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}

static String_Const_char
string_replace(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u8
string_replace(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u16
string_replace(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u32
string_replace(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}



static b32
byte_is_ascii(u8 byte){
    return(byte == '\r' || byte == '\n' || byte == '\t' || (' ' <= byte && byte <= '~'));
}

static b32
data_is_ascii(String_Const_u8 data){
    u8 *ptr = data.str;
    u8 *one_past_last = ptr + data.size;
    b32 result = true;
    for (;ptr < one_past_last; ptr += 1){
        if (!byte_is_ascii(*ptr) && !(*ptr == 0 && ptr + 1 == one_past_last)){
            result = false;
            break;
        }
    }
    return(result);
}



static String_Const_u8
string_escape(Arena *arena, String_Const_u8 string){
    List_String_Const_u8 list = string_replace_list(arena, string, SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)),
                                                    SCu8((u8*)("\\\\"), (u64)(sizeof("\\\\") - 1)));
    Node_String_Const_u8 **fixup_ptr = &list.first;
    for (Node_String_Const_u8 *node = list.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        List_String_Const_u8 relist = string_replace_list(arena, node->string, SCu8((u8*)("\""), (u64)(sizeof("\"") - 1)),
                                                          SCu8((u8*)("\\\""), (u64)(sizeof("\\\"") - 1)));
        if (relist.first != 0){
            *fixup_ptr = relist.first;
            relist.last->next = next;
            fixup_ptr = &relist.last->next;
            list.last = relist.last;
        }
        else{
            *fixup_ptr = next;
        }
    }
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}

static String_Const_char
string_interpret_escapes(Arena *arena, String_Const_char string){
    char *space = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(string.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "7043" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_types.cpp" ":" "7043" ":") - 1)))));
    String_char result = Schar(space, 0, string.size);
    for (;;){
        u64 back_slash_pos = string_find_first(string, '\\');
        string_append(&result, string_prefix(string, back_slash_pos));
        string = string_skip(string, back_slash_pos + 1);
        if (string.size == 0){
            break;
        }
        switch (string.str[0]){
            case '\\':
            {
                string_append_character(&result, '\\');
            }break;

            case 'n':
            {
                string_append_character(&result, '\n');
            }break;

            case 't':
            {
                string_append_character(&result, '\t');
            }break;

            case '"':
            {
                string_append_character(&result, '\"');
            }break;

            case '0':
            {
                string_append_character(&result, '\0');
            }break;

            default:
            {
                char c[2] = {'\\'};
                c[1] = string.str[0];
                string_append(&result, SCchar(c, 2));
            }break;
        }
        string = string_skip(string, 1);
    }
    result.str[result.size] = 0;
    (linalloc_pop((arena), sizeof(char)*(result.cap - result.size)));
    return(result.string);
}

static String_Const_u8
string_interpret_escapes(Arena *arena, String_Const_u8 string){
    return(SCu8(string_interpret_escapes(arena, SCchar(string))));
}

static const u8 integer_symbols[] = {
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
};

static const u8 integer_symbol_reverse[128] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};

static const u8 base64[64] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    '_', '$',
};

static const u8 base64_reverse[128] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
    0xFF,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,
    0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0xFF,0xFF,0xFF,0xFF,0x3E,
    0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
    0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0xFF,0xFF,0xFF,0xFF,0xFF,
};

static u64
digit_count_from_integer(u64 x, u32 radix){
    u64 result = 0;
    if (radix >= 2 && radix <= 16){
        if (x == 0){
            result = 1;
        }
        else{
            do{
                x /= radix;
                result += 1;
            } while(x > 0);
        }
    }
    return(result);
}

static String_Const_u8
string_from_integer(Arena *arena, u64 x, u32 radix){
    String_Const_u8 result = {};
    if (radix >= 2 && radix <= 16){
        if (x == 0){
            result = push_string_copy(arena, SCu8((u8*)("0"), (u64)(sizeof("0") - 1)));
        }
        else{
            u8 string_space[64];
            u64 length = 0;
            for (u64 X = x;
                 X > 0;
                 X /= radix, length += 1){
                string_space[length] = integer_symbols[X%radix];
            }
            for (u64 j = 0, i = length - 1;
                 j < i;
                 j += 1, i -= 1){
                do { u8 hidden_temp_7167 = string_space[i]; string_space[i] = string_space[j]; string_space[j] = hidden_temp_7167; } while(0);
            }
            result = push_string_copy(arena, SCu8(string_space, length));
        }
    }
    return(result);
}

static b32
string_is_integer(String_Const_u8 string, u32 radix){
    b32 is_integer = false;
    if (string.size > 0 && radix <= 16){
        is_integer = true;
        for (u64 i = 0; i < string.size; i += 1){
            if (string.str[i] < 128){
                u8 x = integer_symbol_reverse[character_to_upper(string.str[i])];
                if (x >= radix){
                    is_integer = false;
                    break;
                }
            }
            else{
                is_integer = false;
                break;
            }
        }
    }
    return(is_integer);
}

static u64
string_to_integer(String_Const_u8 string, u32 radix){
    u64 x = 0;
    if (radix <= 16){
        for (u64 i = 0; i < string.size; i += 1){
            x *= radix;
            if (string.str[i] < 128){
                x += integer_symbol_reverse[character_to_upper(string.str[i])];
            }
            else{
                x += 0xFF;
            }
        }
    }
    return(x);
}

static u64
string_to_integer(String_Const_char string, u32 radix){
    return(string_to_integer(SCu8((u8*)string.str, string.size), radix));
}

static String_Const_u8
string_base64_encode_from_binary(Arena *arena, void *data, u64 size){
    u64 char_count = (((size*8) + (6) - 1)/(6));
    char_count = round_up_u64(char_count, 4);
    String_Const_u8 string = string_const_u8_push(arena, char_count);
    u8 *s = string.str;
    u8 *d = (u8*)data;
    u8 *de = d + size;
    for (;d < de; d += 3, s += 4){
        i32 in_byte_count = (i32)(de - d);
        u8 *D = d;
        b32 partial_fill = (in_byte_count < 3);
        u8 D_space[3] = {};
        if (partial_fill){
            block_copy(D_space, d, (((sizeof(D_space))<(in_byte_count))?(sizeof(D_space)):(in_byte_count)));
            D = D_space;
        }
        s[0] = D[0] &bitmask_6;
        s[1] = ((D[0] >> 6)&bitmask_2) | ((D[1]&bitmask_4) << 2);
        s[2] = ((D[1] >> 4)&bitmask_4) | ((D[2]&bitmask_2) << 4);
        s[3] = (D[2] >> 2)&bitmask_6;
        for (i32 j = 0; j < 4; j += 1){
            s[j] = base64[s[j]];
        }
        switch (in_byte_count){
            case 1:
            {
                s[2] = '?';
                s[3] = '?';
            }break;
            case 2:
            {
                s[3] = '?';
            }break;
        }
    }
    return(string);
}

static String_Const_u8
data_decode_from_base64(Arena *arena, u8 *str, u64 size){
    String_Const_u8 data = {};
    if (size%4 == 0){
        u64 data_size = size*6/8;
        if (str[size - 2] == '?'){
            data_size -= 2;
        }
        else if (str[size - 1] == '?'){
            data_size -= 1;
        }
        data = push_data(arena, data_size);
        u8 *s = str;
        u8 *se = s + size;
        u8 *d = data.str;
        u8 *de = d + data_size;
        for (;s < se; d += 3, s += 4){
            u8 *D = d;
            i32 out_byte_count = (i32)(de - d);
            b32 partial_fill = (out_byte_count < 3);
            u8 D_space[2];
            if (partial_fill){
                D = D_space;
            }
            u8 S[4];
            for (i32 j = 0; j < 4; j += 1){
                if (s[j] < 128){
                    S[j] = base64_reverse[s[j]];
                }
                else{
                    S[j] = 0xFF;
                }
            }
            D[0] = ( S[0] &bitmask_6) | ((S[1]&bitmask_2) << 6);
            D[1] = ((S[1] >> 2)&bitmask_4) | ((S[2]&bitmask_4) << 4);
            D[2] = ((S[2] >> 4)&bitmask_2) | ((S[3]&bitmask_6) << 2);
            if (partial_fill){
                do{ if (!(out_byte_count <= sizeof(D_space))) { (*((i32*)0) = 0xA11E); } }while(0);
                block_copy(D, D_space, out_byte_count);
            }
        }
    }
    return(data);
}



static u64
time_stamp_from_date_time(Date_Time *date_time){
    u64 result = 0;
    result += date_time->year;
    result *= 12;
    result += date_time->mon;
    result *= 30;
    result += date_time->day;
    result *= 24;
    result += date_time->hour;
    result *= 60;
    result += date_time->min;
    result *= 61;
    result += date_time->sec;
    result *= 1000;
    result += date_time->msec;
    return(result);
}

static Date_Time
date_time_from_time_stamp(u64 time_stamp){
    Date_Time result = {};
    result.msec = time_stamp%1000;
    time_stamp /= 1000;
    result.sec = time_stamp%61;
    time_stamp /= 61;
    result.min = time_stamp%60;
    time_stamp /= 60;
    result.hour = time_stamp%24;
    time_stamp /= 24;
    result.day = time_stamp%30;
    time_stamp /= 30;
    result.mon = time_stamp%12;
    time_stamp /= 12;
    result.year = (u32)time_stamp;
    return(result);
}
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stdarg.h" 1 3 4
# 11 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 2


static String_Const_u8
push_stringfv(Arena *arena, char *format, va_list args){
    va_list args2;
    
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_copy(
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args2
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   ,
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 16 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
                       ;
    i32 size = vsnprintf(0, 0, format, args);
    String_Const_u8 result = string_const_u8_push(arena, size + 1);
    vsnprintf((char*)result.str, (size_t)result.size, format, args2);
    result.size -= 1;
    result.str[result.size] = 0;
    return(result);
}
static String_Const_u8
push_stringf(Arena *arena, char *format, ...){
    va_list args;
    
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   ,
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   format
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 27 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
                         ;
    String_Const_u8 result = push_stringfv(arena, format, args);
    
# 29 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 29 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 29 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 29 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
               ;
    return(result);
}
static String_Const_u8
push_u8_stringfv(Arena *arena, char *format, va_list args){
    return(push_stringfv(arena, format, args));
}
static String_Const_u8
push_u8_stringf(Arena *arena, char *format, ...){
    va_list args;
    
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   ,
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   format
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
                         ;
    String_Const_u8 result = push_stringfv(arena, format, args);
    
# 41 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 41 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 41 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 41 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
               ;
    return(result);
}

static void
string_list_pushfv(Arena *arena, List_String_Const_char *list, char *format, va_list args){
    String_Const_u8 string = push_stringfv(arena, format, args);
    if (arena->alignment < sizeof(u64)){
        (linalloc_align((arena), (sizeof(u64))));
    }
    string_list_push(arena, list, SCchar(string));
}
static void
string_list_pushf(Arena *arena, List_String_Const_char *list, char *format, ...){
    va_list args;
    
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   ,
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   format
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 56 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
                         ;
    string_list_pushfv(arena, list, format, args);
    
# 58 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 58 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 58 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 58 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
               ;
}
static void
string_list_pushfv(Arena *arena, List_String_Const_u8 *list, char *format, va_list args){
    String_Const_u8 string = push_u8_stringfv(arena, format, args);
    if (arena->alignment < sizeof(u64)){
        (linalloc_align((arena), (sizeof(u64))));
    }
    string_list_push(arena, list, string);
}
static void
string_list_pushf(Arena *arena, List_String_Const_u8 *list, char *format, ...){
    va_list args;
    
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   ,
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   format
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 71 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
                         ;
    string_list_pushfv(arena, list, format, args);
    
# 73 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 73 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
   args
# 73 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp" 3 4
   )
# 73 "/home/tabletel/dev/4cc/code/custom/4coder_stringf.cpp"
               ;
}




static void
push_year_full(Arena *arena, List_String_Const_u8 *list, u32 year){
    string_list_pushf(arena, list, "%u", year);
}

static void
push_year_abrev(Arena *arena, List_String_Const_u8 *list, u32 year){
    string_list_pushf(arena, list, "%u", year % 100);
}


static void
push_month_num(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_pushf(arena, list, "%u", mon + 1);
}

static void
push_month_num_zeros(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_pushf(arena, list, "%02u", mon + 1);
}

static void
push_month_name(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_push(arena, list, month_full_name[mon%12]);
}

static void
push_month_abrev(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_push(arena, list, month_abrev_name[mon%12]);
}


static void
push_day_num(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_pushf(arena, list, "%u", day + 1);
}

static void
push_day_num_zeroes(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_pushf(arena, list, "%02u", day + 1);
}

static void
push_day_ord(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_push(arena, list, ordinal_numeric_name[day%100]);
}


static void
push_hour_24(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%u", hour);
}

static void
push_hour_24_zeroes(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%02u", hour);
}

static void
push_hour_12(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%u", hour%12);
}

static void
push_hour_12_zeroes(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%02u", hour%12);
}

static void
push_hour_am_pm(Arena *arena, List_String_Const_u8 *list, u8 hour){
    if (hour >= 12){
        string_list_push(arena, list, SCu8((u8*)("pm"), (u64)(sizeof("pm") - 1)));
    }
    else{
        string_list_push(arena, list, SCu8((u8*)("am"), (u64)(sizeof("am") - 1)));
    }
}


static void
push_minute(Arena *arena, List_String_Const_u8 *list, u8 min){
    string_list_pushf(arena, list, "%u", min);
}

static void
push_minute_zeroes(Arena *arena, List_String_Const_u8 *list, u8 min){
    string_list_pushf(arena, list, "%02u", min);
}


static void
push_second(Arena *arena, List_String_Const_u8 *list, u8 sec){
    string_list_pushf(arena, list, "%u", sec);
}

static void
push_second_zeroes(Arena *arena, List_String_Const_u8 *list, u8 sec){
    string_list_pushf(arena, list, "%02u", sec);
}


static void
push_millisecond_zeroes(Arena *arena, List_String_Const_u8 *list, u16 msec){
    string_list_pushf(arena, list, "%03u", msec);
}

static void
date_time_format(Arena *arena, List_String_Const_u8 *list, String_Const_u8 format, Date_Time *date_time){
    u8 *ptr = format.str;
    u8 *end = format.str + format.size;
    for (;ptr < end;){
        if (character_is_alpha_numeric(*ptr)){
            u8 *start = ptr;
            for (;ptr < end; ptr += 1){
                if (!character_is_alpha_numeric(*ptr)){
                    break;
                }
            }

            String_Const_u8 field = SCu8(start, ptr);
            for (; field.size > 0;){
                if (string_match(string_prefix(field, 5), SCu8((u8*)("month"), (u64)(sizeof("month") - 1)))){
                    field = string_skip(field, 5);
                    push_month_name(arena, list, date_time->mon);
                }

                else if (string_match(string_prefix(field, 4), SCu8((u8*)("yyyy"), (u64)(sizeof("yyyy") - 1)))){
                    field = string_skip(field, 4);
                    push_year_full(arena, list, date_time->year);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("hh24"), (u64)(sizeof("hh24") - 1)))){
                    field = string_skip(field, 4);
                    push_hour_24_zeroes(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("ampm"), (u64)(sizeof("ampm") - 1)))){
                    field = string_skip(field, 4);
                    push_hour_am_pm(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("mimi"), (u64)(sizeof("mimi") - 1)))){
                    field = string_skip(field, 4);
                    push_minute_zeroes(arena, list, date_time->min);
                }

                else if (string_match(string_prefix(field, 3), SCu8((u8*)("mon"), (u64)(sizeof("mon") - 1)))){
                    field = string_skip(field, 3);
                    push_month_abrev(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 3), SCu8((u8*)("day"), (u64)(sizeof("day") - 1)))){
                    field = string_skip(field, 3);
                    push_day_ord(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 3), SCu8((u8*)("h24"), (u64)(sizeof("h24") - 1)))){
                    field = string_skip(field, 3);
                    push_hour_24(arena, list, date_time->hour);
                }

                else if (string_match(string_prefix(field, 2), SCu8((u8*)("yy"), (u64)(sizeof("yy") - 1)))){
                    field = string_skip(field, 2);
                    push_year_abrev(arena, list, date_time->year);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("mm"), (u64)(sizeof("mm") - 1)))){
                    field = string_skip(field, 2);
                    push_month_num_zeros(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("dd"), (u64)(sizeof("dd") - 1)))){
                    field = string_skip(field, 2);
                    push_day_num_zeroes(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("hh"), (u64)(sizeof("hh") - 1)))){
                    field = string_skip(field, 2);
                    push_hour_12_zeroes(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("mi"), (u64)(sizeof("mi") - 1)))){
                    field = string_skip(field, 2);
                    push_minute(arena, list, date_time->min);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("ss"), (u64)(sizeof("ss") - 1)))){
                    field = string_skip(field, 2);
                    push_second_zeroes(arena, list, date_time->sec);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("ms"), (u64)(sizeof("ms") - 1)))){
                    field = string_skip(field, 2);
                    push_millisecond_zeroes(arena, list, date_time->msec);
                }

                else if (string_match(string_prefix(field, 1), SCu8((u8*)("m"), (u64)(sizeof("m") - 1)))){
                    field = string_skip(field, 1);
                    push_month_num(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("d"), (u64)(sizeof("d") - 1)))){
                    field = string_skip(field, 1);
                    push_day_num(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("h"), (u64)(sizeof("h") - 1)))){
                    field = string_skip(field, 1);
                    push_hour_12(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("s"), (u64)(sizeof("s") - 1)))){
                    field = string_skip(field, 1);
                    push_second(arena, list, date_time->sec);
                }

                else{
                    string_list_push(arena, list, SCu8(start, ptr));
                    break;
                }
            }
        }
        else{
            u8 *start = ptr;
            for (;ptr < end; ptr += 1){
                if (character_is_alpha_numeric(*ptr)){
                    break;
                }
            }
            string_list_push(arena, list, SCu8(start, ptr));
        }
    }
}
static void
date_time_format(Arena *arena, List_String_Const_u8 *list, char *format, Date_Time *date_time){
    date_time_format(arena, list, SCu8(format), date_time);
}

static String_Const_u8
date_time_format(Arena *arena, String_Const_u8 format, Date_Time *date_time){
    List_String_Const_u8 list = {};
    date_time_format(arena, &list, format, date_time);
    return(string_list_flatten(arena, list));
}
static String_Const_u8
date_time_format(Arena *arena, char *format, Date_Time *date_time){
    return(date_time_format(arena, SCu8(format), date_time));
}
# 72 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_app_links_allocator.cpp" 1






Scratch_Block::Scratch_Block(Application_Links *app){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1, Arena *a2){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1, a2);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1, Arena *a2, Arena *a3){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1, a2, a3);
    this->temp = begin_temp(this->arena);
}
# 73 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_system_allocator.cpp" 1






static void*
base_reserve__system(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    u64 extra_size = 128;
    u64 increased_size = size + extra_size;
    size = round_up_u64(increased_size, ((4) << 10));
    *size_out = size - extra_size;
    void *ptr = system_memory_allocate(size, location);
    *(u64*)ptr = size;
    ptr = (u8*)ptr + extra_size;
    return(ptr);
}

static void
base_free__system(void *user_data, void *ptr){
    u64 extra_size = 128;
    ptr = (u8*)ptr - extra_size;
    u64 size = *(u64*)ptr;
    system_memory_free(ptr, size);
}

static Base_Allocator
make_base_allocator_system(void){
    return(make_base_allocator(base_reserve__system, 0, 0, base_free__system, 0, 0));
}

static Base_Allocator base_allocator_system = {};

static Base_Allocator*
get_base_allocator_system(void){
    if (base_allocator_system.reserve == 0){
        base_allocator_system = make_base_allocator_system();
    }
    return(&base_allocator_system);
}

static Arena
make_arena_system(u64 chunk_size, u64 align){
    return(make_arena(get_base_allocator_system(), chunk_size, align));
}

static Arena
make_arena_system(u64 chunk_size){
    return(make_arena_system(chunk_size, 8));
}

static Arena
make_arena_system(void){
    return(make_arena_system(((16) << 10), 8));
}
# 74 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp" 1
# 14 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp"
static String_Const_u8
data_from_file(Arena *arena, FILE *file){
    String_Const_u8 result = {};
    if (file != 0){
        fseek(file, 0, 
# 18 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp" 3 4
                      2
# 18 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp"
                              );
        result.size = ftell(file);
        fseek(file, 0, 
# 20 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp" 3 4
                      0
# 20 "/home/tabletel/dev/4cc/code/custom/4coder_file.cpp"
                              );
        result.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(result.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_file.cpp" ":" "21" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_file.cpp" ":" "21" ":") - 1)))));
        fread(result.str, 1, (size_t)result.size, file);
        result.str[result.size] = 0;
    }
    return(result);
}
# 76 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2


# 1 "/home/tabletel/dev/4cc/code/custom/generated/custom_api.cpp" 1
static void
custom_api_fill_vtable(API_VTable_custom *vtable){
vtable->global_set_setting = global_set_setting;
vtable->global_get_screen_rectangle = global_get_screen_rectangle;
vtable->get_thread_context = get_thread_context;
vtable->create_child_process = create_child_process;
vtable->child_process_set_target_buffer = child_process_set_target_buffer;
vtable->buffer_get_attached_child_process = buffer_get_attached_child_process;
vtable->child_process_get_attached_buffer = child_process_get_attached_buffer;
vtable->child_process_get_state = child_process_get_state;
vtable->enqueue_virtual_event = enqueue_virtual_event;
vtable->get_buffer_count = get_buffer_count;
vtable->get_buffer_next = get_buffer_next;
vtable->get_buffer_by_name = get_buffer_by_name;
vtable->get_buffer_by_file_name = get_buffer_by_file_name;
vtable->buffer_read_range = buffer_read_range;
vtable->buffer_replace_range = buffer_replace_range;
vtable->buffer_batch_edit = buffer_batch_edit;
vtable->buffer_seek_string = buffer_seek_string;
vtable->buffer_seek_character_class = buffer_seek_character_class;
vtable->buffer_line_y_difference = buffer_line_y_difference;
vtable->buffer_line_shift_y = buffer_line_shift_y;
vtable->buffer_pos_at_relative_xy = buffer_pos_at_relative_xy;
vtable->buffer_relative_box_of_pos = buffer_relative_box_of_pos;
vtable->buffer_padded_box_of_pos = buffer_padded_box_of_pos;
vtable->buffer_relative_character_from_pos = buffer_relative_character_from_pos;
vtable->buffer_pos_from_relative_character = buffer_pos_from_relative_character;
vtable->view_line_y_difference = view_line_y_difference;
vtable->view_line_shift_y = view_line_shift_y;
vtable->view_pos_at_relative_xy = view_pos_at_relative_xy;
vtable->view_relative_box_of_pos = view_relative_box_of_pos;
vtable->view_padded_box_of_pos = view_padded_box_of_pos;
vtable->view_relative_character_from_pos = view_relative_character_from_pos;
vtable->view_pos_from_relative_character = view_pos_from_relative_character;
vtable->buffer_exists = buffer_exists;
vtable->buffer_get_access_flags = buffer_get_access_flags;
vtable->buffer_get_size = buffer_get_size;
vtable->buffer_get_line_count = buffer_get_line_count;
vtable->push_buffer_base_name = push_buffer_base_name;
vtable->push_buffer_unique_name = push_buffer_unique_name;
vtable->push_buffer_file_name = push_buffer_file_name;
vtable->buffer_get_dirty_state = buffer_get_dirty_state;
vtable->buffer_set_dirty_state = buffer_set_dirty_state;
vtable->buffer_set_layout = buffer_set_layout;
vtable->buffer_clear_layout_cache = buffer_clear_layout_cache;
vtable->buffer_get_layout = buffer_get_layout;
vtable->buffer_get_setting = buffer_get_setting;
vtable->buffer_set_setting = buffer_set_setting;
vtable->buffer_get_managed_scope = buffer_get_managed_scope;
vtable->buffer_send_end_signal = buffer_send_end_signal;
vtable->create_buffer = create_buffer;
vtable->buffer_save = buffer_save;
vtable->buffer_kill = buffer_kill;
vtable->buffer_reopen = buffer_reopen;
vtable->buffer_get_file_attributes = buffer_get_file_attributes;
vtable->get_view_next = get_view_next;
vtable->get_view_prev = get_view_prev;
vtable->get_this_ctx_view = get_this_ctx_view;
vtable->get_active_view = get_active_view;
vtable->view_exists = view_exists;
vtable->view_get_buffer = view_get_buffer;
vtable->view_get_cursor_pos = view_get_cursor_pos;
vtable->view_get_mark_pos = view_get_mark_pos;
vtable->view_get_preferred_x = view_get_preferred_x;
vtable->view_set_preferred_x = view_set_preferred_x;
vtable->view_get_screen_rect = view_get_screen_rect;
vtable->view_get_panel = view_get_panel;
vtable->panel_get_view = panel_get_view;
vtable->panel_is_split = panel_is_split;
vtable->panel_is_leaf = panel_is_leaf;
vtable->panel_split = panel_split;
vtable->panel_set_split = panel_set_split;
vtable->panel_swap_children = panel_swap_children;
vtable->panel_get_root = panel_get_root;
vtable->panel_get_parent = panel_get_parent;
vtable->panel_get_child = panel_get_child;
vtable->view_close = view_close;
vtable->view_get_buffer_region = view_get_buffer_region;
vtable->view_get_buffer_scroll = view_get_buffer_scroll;
vtable->view_set_active = view_set_active;
vtable->view_enqueue_command_function = view_enqueue_command_function;
vtable->view_get_setting = view_get_setting;
vtable->view_set_setting = view_set_setting;
vtable->view_get_managed_scope = view_get_managed_scope;
vtable->buffer_compute_cursor = buffer_compute_cursor;
vtable->view_compute_cursor = view_compute_cursor;
vtable->view_set_camera_bounds = view_set_camera_bounds;
vtable->view_get_camera_bounds = view_get_camera_bounds;
vtable->view_set_cursor = view_set_cursor;
vtable->view_set_buffer_scroll = view_set_buffer_scroll;
vtable->view_set_mark = view_set_mark;
vtable->view_quit_ui = view_quit_ui;
vtable->view_set_buffer = view_set_buffer;
vtable->view_push_context = view_push_context;
vtable->view_pop_context = view_pop_context;
vtable->view_alter_context = view_alter_context;
vtable->view_current_context = view_current_context;
vtable->view_current_context_hook_memory = view_current_context_hook_memory;
vtable->create_user_managed_scope = create_user_managed_scope;
vtable->destroy_user_managed_scope = destroy_user_managed_scope;
vtable->get_global_managed_scope = get_global_managed_scope;
vtable->get_managed_scope_with_multiple_dependencies = get_managed_scope_with_multiple_dependencies;
vtable->managed_scope_clear_contents = managed_scope_clear_contents;
vtable->managed_scope_clear_self_all_dependent_scopes = managed_scope_clear_self_all_dependent_scopes;
vtable->managed_scope_allocator = managed_scope_allocator;
vtable->managed_id_group_highest_id = managed_id_group_highest_id;
vtable->managed_id_declare = managed_id_declare;
vtable->managed_id_get = managed_id_get;
vtable->managed_scope_get_attachment = managed_scope_get_attachment;
vtable->managed_scope_attachment_erase = managed_scope_attachment_erase;
vtable->alloc_managed_memory_in_scope = alloc_managed_memory_in_scope;
vtable->alloc_buffer_markers_on_buffer = alloc_buffer_markers_on_buffer;
vtable->managed_object_get_item_size = managed_object_get_item_size;
vtable->managed_object_get_item_count = managed_object_get_item_count;
vtable->managed_object_get_pointer = managed_object_get_pointer;
vtable->managed_object_get_type = managed_object_get_type;
vtable->managed_object_get_containing_scope = managed_object_get_containing_scope;
vtable->managed_object_free = managed_object_free;
vtable->managed_object_store_data = managed_object_store_data;
vtable->managed_object_load_data = managed_object_load_data;
vtable->get_next_input_raw = get_next_input_raw;
vtable->get_current_input_sequence_number = get_current_input_sequence_number;
vtable->get_current_input = get_current_input;
vtable->set_current_input = set_current_input;
vtable->leave_current_input_unhandled = leave_current_input_unhandled;
vtable->set_custom_hook = set_custom_hook;
vtable->get_custom_hook = get_custom_hook;
vtable->set_custom_hook_memory_size = set_custom_hook_memory_size;
vtable->get_mouse_state = get_mouse_state;
vtable->get_active_query_bars = get_active_query_bars;
vtable->start_query_bar = start_query_bar;
vtable->end_query_bar = end_query_bar;
vtable->clear_all_query_bars = clear_all_query_bars;
vtable->print_message = print_message;
vtable->log_string = log_string;
vtable->get_largest_face_id = get_largest_face_id;
vtable->set_global_face = set_global_face;
vtable->buffer_history_get_max_record_index = buffer_history_get_max_record_index;
vtable->buffer_history_get_record_info = buffer_history_get_record_info;
vtable->buffer_history_get_group_sub_record = buffer_history_get_group_sub_record;
vtable->buffer_history_get_current_state_index = buffer_history_get_current_state_index;
vtable->buffer_history_set_current_state_index = buffer_history_set_current_state_index;
vtable->buffer_history_merge_record_range = buffer_history_merge_record_range;
vtable->buffer_history_clear_after_current_state = buffer_history_clear_after_current_state;
vtable->global_history_edit_group_begin = global_history_edit_group_begin;
vtable->global_history_edit_group_end = global_history_edit_group_end;
vtable->buffer_set_face = buffer_set_face;
vtable->get_face_description = get_face_description;
vtable->get_face_metrics = get_face_metrics;
vtable->get_face_advance_map = get_face_advance_map;
vtable->get_face_id = get_face_id;
vtable->try_create_new_face = try_create_new_face;
vtable->try_modify_face = try_modify_face;
vtable->try_release_face = try_release_face;
vtable->push_hot_directory = push_hot_directory;
vtable->set_hot_directory = set_hot_directory;
vtable->send_exit_signal = send_exit_signal;
vtable->hard_exit = hard_exit;
vtable->set_window_title = set_window_title;
vtable->acquire_global_frame_mutex = acquire_global_frame_mutex;
vtable->release_global_frame_mutex = release_global_frame_mutex;
vtable->draw_string_oriented = draw_string_oriented;
vtable->get_string_advance = get_string_advance;
vtable->draw_rectangle = draw_rectangle;
vtable->draw_rectangle_outline = draw_rectangle_outline;
vtable->draw_set_clip = draw_set_clip;
vtable->text_layout_create = text_layout_create;
vtable->text_layout_region = text_layout_region;
vtable->text_layout_get_buffer = text_layout_get_buffer;
vtable->text_layout_get_visible_range = text_layout_get_visible_range;
vtable->text_layout_line_on_screen = text_layout_line_on_screen;
vtable->text_layout_character_on_screen = text_layout_character_on_screen;
vtable->paint_text_color = paint_text_color;
vtable->paint_text_color_blend = paint_text_color_blend;
vtable->text_layout_free = text_layout_free;
vtable->draw_text_layout = draw_text_layout;
vtable->open_color_picker = open_color_picker;
vtable->animate_in_n_milliseconds = animate_in_n_milliseconds;
vtable->buffer_find_all_matches = buffer_find_all_matches;
vtable->get_core_profile_list = get_core_profile_list;
vtable->get_custom_layer_boundary_docs = get_custom_layer_boundary_docs;
}

static void
custom_api_read_vtable(API_VTable_custom *vtable){
global_set_setting = vtable->global_set_setting;
global_get_screen_rectangle = vtable->global_get_screen_rectangle;
get_thread_context = vtable->get_thread_context;
create_child_process = vtable->create_child_process;
child_process_set_target_buffer = vtable->child_process_set_target_buffer;
buffer_get_attached_child_process = vtable->buffer_get_attached_child_process;
child_process_get_attached_buffer = vtable->child_process_get_attached_buffer;
child_process_get_state = vtable->child_process_get_state;
enqueue_virtual_event = vtable->enqueue_virtual_event;
get_buffer_count = vtable->get_buffer_count;
get_buffer_next = vtable->get_buffer_next;
get_buffer_by_name = vtable->get_buffer_by_name;
get_buffer_by_file_name = vtable->get_buffer_by_file_name;
buffer_read_range = vtable->buffer_read_range;
buffer_replace_range = vtable->buffer_replace_range;
buffer_batch_edit = vtable->buffer_batch_edit;
buffer_seek_string = vtable->buffer_seek_string;
buffer_seek_character_class = vtable->buffer_seek_character_class;
buffer_line_y_difference = vtable->buffer_line_y_difference;
buffer_line_shift_y = vtable->buffer_line_shift_y;
buffer_pos_at_relative_xy = vtable->buffer_pos_at_relative_xy;
buffer_relative_box_of_pos = vtable->buffer_relative_box_of_pos;
buffer_padded_box_of_pos = vtable->buffer_padded_box_of_pos;
buffer_relative_character_from_pos = vtable->buffer_relative_character_from_pos;
buffer_pos_from_relative_character = vtable->buffer_pos_from_relative_character;
view_line_y_difference = vtable->view_line_y_difference;
view_line_shift_y = vtable->view_line_shift_y;
view_pos_at_relative_xy = vtable->view_pos_at_relative_xy;
view_relative_box_of_pos = vtable->view_relative_box_of_pos;
view_padded_box_of_pos = vtable->view_padded_box_of_pos;
view_relative_character_from_pos = vtable->view_relative_character_from_pos;
view_pos_from_relative_character = vtable->view_pos_from_relative_character;
buffer_exists = vtable->buffer_exists;
buffer_get_access_flags = vtable->buffer_get_access_flags;
buffer_get_size = vtable->buffer_get_size;
buffer_get_line_count = vtable->buffer_get_line_count;
push_buffer_base_name = vtable->push_buffer_base_name;
push_buffer_unique_name = vtable->push_buffer_unique_name;
push_buffer_file_name = vtable->push_buffer_file_name;
buffer_get_dirty_state = vtable->buffer_get_dirty_state;
buffer_set_dirty_state = vtable->buffer_set_dirty_state;
buffer_set_layout = vtable->buffer_set_layout;
buffer_clear_layout_cache = vtable->buffer_clear_layout_cache;
buffer_get_layout = vtable->buffer_get_layout;
buffer_get_setting = vtable->buffer_get_setting;
buffer_set_setting = vtable->buffer_set_setting;
buffer_get_managed_scope = vtable->buffer_get_managed_scope;
buffer_send_end_signal = vtable->buffer_send_end_signal;
create_buffer = vtable->create_buffer;
buffer_save = vtable->buffer_save;
buffer_kill = vtable->buffer_kill;
buffer_reopen = vtable->buffer_reopen;
buffer_get_file_attributes = vtable->buffer_get_file_attributes;
get_view_next = vtable->get_view_next;
get_view_prev = vtable->get_view_prev;
get_this_ctx_view = vtable->get_this_ctx_view;
get_active_view = vtable->get_active_view;
view_exists = vtable->view_exists;
view_get_buffer = vtable->view_get_buffer;
view_get_cursor_pos = vtable->view_get_cursor_pos;
view_get_mark_pos = vtable->view_get_mark_pos;
view_get_preferred_x = vtable->view_get_preferred_x;
view_set_preferred_x = vtable->view_set_preferred_x;
view_get_screen_rect = vtable->view_get_screen_rect;
view_get_panel = vtable->view_get_panel;
panel_get_view = vtable->panel_get_view;
panel_is_split = vtable->panel_is_split;
panel_is_leaf = vtable->panel_is_leaf;
panel_split = vtable->panel_split;
panel_set_split = vtable->panel_set_split;
panel_swap_children = vtable->panel_swap_children;
panel_get_root = vtable->panel_get_root;
panel_get_parent = vtable->panel_get_parent;
panel_get_child = vtable->panel_get_child;
view_close = vtable->view_close;
view_get_buffer_region = vtable->view_get_buffer_region;
view_get_buffer_scroll = vtable->view_get_buffer_scroll;
view_set_active = vtable->view_set_active;
view_enqueue_command_function = vtable->view_enqueue_command_function;
view_get_setting = vtable->view_get_setting;
view_set_setting = vtable->view_set_setting;
view_get_managed_scope = vtable->view_get_managed_scope;
buffer_compute_cursor = vtable->buffer_compute_cursor;
view_compute_cursor = vtable->view_compute_cursor;
view_set_camera_bounds = vtable->view_set_camera_bounds;
view_get_camera_bounds = vtable->view_get_camera_bounds;
view_set_cursor = vtable->view_set_cursor;
view_set_buffer_scroll = vtable->view_set_buffer_scroll;
view_set_mark = vtable->view_set_mark;
view_quit_ui = vtable->view_quit_ui;
view_set_buffer = vtable->view_set_buffer;
view_push_context = vtable->view_push_context;
view_pop_context = vtable->view_pop_context;
view_alter_context = vtable->view_alter_context;
view_current_context = vtable->view_current_context;
view_current_context_hook_memory = vtable->view_current_context_hook_memory;
create_user_managed_scope = vtable->create_user_managed_scope;
destroy_user_managed_scope = vtable->destroy_user_managed_scope;
get_global_managed_scope = vtable->get_global_managed_scope;
get_managed_scope_with_multiple_dependencies = vtable->get_managed_scope_with_multiple_dependencies;
managed_scope_clear_contents = vtable->managed_scope_clear_contents;
managed_scope_clear_self_all_dependent_scopes = vtable->managed_scope_clear_self_all_dependent_scopes;
managed_scope_allocator = vtable->managed_scope_allocator;
managed_id_group_highest_id = vtable->managed_id_group_highest_id;
managed_id_declare = vtable->managed_id_declare;
managed_id_get = vtable->managed_id_get;
managed_scope_get_attachment = vtable->managed_scope_get_attachment;
managed_scope_attachment_erase = vtable->managed_scope_attachment_erase;
alloc_managed_memory_in_scope = vtable->alloc_managed_memory_in_scope;
alloc_buffer_markers_on_buffer = vtable->alloc_buffer_markers_on_buffer;
managed_object_get_item_size = vtable->managed_object_get_item_size;
managed_object_get_item_count = vtable->managed_object_get_item_count;
managed_object_get_pointer = vtable->managed_object_get_pointer;
managed_object_get_type = vtable->managed_object_get_type;
managed_object_get_containing_scope = vtable->managed_object_get_containing_scope;
managed_object_free = vtable->managed_object_free;
managed_object_store_data = vtable->managed_object_store_data;
managed_object_load_data = vtable->managed_object_load_data;
get_next_input_raw = vtable->get_next_input_raw;
get_current_input_sequence_number = vtable->get_current_input_sequence_number;
get_current_input = vtable->get_current_input;
set_current_input = vtable->set_current_input;
leave_current_input_unhandled = vtable->leave_current_input_unhandled;
set_custom_hook = vtable->set_custom_hook;
get_custom_hook = vtable->get_custom_hook;
set_custom_hook_memory_size = vtable->set_custom_hook_memory_size;
get_mouse_state = vtable->get_mouse_state;
get_active_query_bars = vtable->get_active_query_bars;
start_query_bar = vtable->start_query_bar;
end_query_bar = vtable->end_query_bar;
clear_all_query_bars = vtable->clear_all_query_bars;
print_message = vtable->print_message;
log_string = vtable->log_string;
get_largest_face_id = vtable->get_largest_face_id;
set_global_face = vtable->set_global_face;
buffer_history_get_max_record_index = vtable->buffer_history_get_max_record_index;
buffer_history_get_record_info = vtable->buffer_history_get_record_info;
buffer_history_get_group_sub_record = vtable->buffer_history_get_group_sub_record;
buffer_history_get_current_state_index = vtable->buffer_history_get_current_state_index;
buffer_history_set_current_state_index = vtable->buffer_history_set_current_state_index;
buffer_history_merge_record_range = vtable->buffer_history_merge_record_range;
buffer_history_clear_after_current_state = vtable->buffer_history_clear_after_current_state;
global_history_edit_group_begin = vtable->global_history_edit_group_begin;
global_history_edit_group_end = vtable->global_history_edit_group_end;
buffer_set_face = vtable->buffer_set_face;
get_face_description = vtable->get_face_description;
get_face_metrics = vtable->get_face_metrics;
get_face_advance_map = vtable->get_face_advance_map;
get_face_id = vtable->get_face_id;
try_create_new_face = vtable->try_create_new_face;
try_modify_face = vtable->try_modify_face;
try_release_face = vtable->try_release_face;
push_hot_directory = vtable->push_hot_directory;
set_hot_directory = vtable->set_hot_directory;
send_exit_signal = vtable->send_exit_signal;
hard_exit = vtable->hard_exit;
set_window_title = vtable->set_window_title;
acquire_global_frame_mutex = vtable->acquire_global_frame_mutex;
release_global_frame_mutex = vtable->release_global_frame_mutex;
draw_string_oriented = vtable->draw_string_oriented;
get_string_advance = vtable->get_string_advance;
draw_rectangle = vtable->draw_rectangle;
draw_rectangle_outline = vtable->draw_rectangle_outline;
draw_set_clip = vtable->draw_set_clip;
text_layout_create = vtable->text_layout_create;
text_layout_region = vtable->text_layout_region;
text_layout_get_buffer = vtable->text_layout_get_buffer;
text_layout_get_visible_range = vtable->text_layout_get_visible_range;
text_layout_line_on_screen = vtable->text_layout_line_on_screen;
text_layout_character_on_screen = vtable->text_layout_character_on_screen;
paint_text_color = vtable->paint_text_color;
paint_text_color_blend = vtable->paint_text_color_blend;
text_layout_free = vtable->text_layout_free;
draw_text_layout = vtable->draw_text_layout;
open_color_picker = vtable->open_color_picker;
animate_in_n_milliseconds = vtable->animate_in_n_milliseconds;
buffer_find_all_matches = vtable->buffer_find_all_matches;
get_core_profile_list = vtable->get_core_profile_list;
get_custom_layer_boundary_docs = vtable->get_custom_layer_boundary_docs;
}
# 79 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/generated/system_api.cpp" 1
static void
system_api_fill_vtable(API_VTable_system *vtable){
vtable->error_box = system_error_box;
vtable->get_path = system_get_path;
vtable->get_canonical = system_get_canonical;
vtable->get_file_list = system_get_file_list;
vtable->quick_file_attributes = system_quick_file_attributes;
vtable->load_handle = system_load_handle;
vtable->load_attributes = system_load_attributes;
vtable->load_file = system_load_file;
vtable->load_close = system_load_close;
vtable->save_file = system_save_file;
vtable->load_library = system_load_library;
vtable->release_library = system_release_library;
vtable->get_proc = system_get_proc;
vtable->now_time = system_now_time;
vtable->now_date_time_universal = system_now_date_time_universal;
vtable->local_date_time_from_universal = system_local_date_time_from_universal;
vtable->universal_date_time_from_local = system_universal_date_time_from_local;
vtable->wake_up_timer_create = system_wake_up_timer_create;
vtable->wake_up_timer_release = system_wake_up_timer_release;
vtable->wake_up_timer_set = system_wake_up_timer_set;
vtable->signal_step = system_signal_step;
vtable->sleep = system_sleep;
vtable->get_clipboard = system_get_clipboard;
vtable->post_clipboard = system_post_clipboard;
vtable->set_clipboard_catch_all = system_set_clipboard_catch_all;
vtable->get_clipboard_catch_all = system_get_clipboard_catch_all;
vtable->cli_call = system_cli_call;
vtable->cli_begin_update = system_cli_begin_update;
vtable->cli_update_step = system_cli_update_step;
vtable->cli_end_update = system_cli_end_update;
vtable->open_color_picker = system_open_color_picker;
vtable->get_screen_scale_factor = system_get_screen_scale_factor;
vtable->thread_launch = system_thread_launch;
vtable->thread_join = system_thread_join;
vtable->thread_free = system_thread_free;
vtable->thread_get_id = system_thread_get_id;
vtable->acquire_global_frame_mutex = system_acquire_global_frame_mutex;
vtable->release_global_frame_mutex = system_release_global_frame_mutex;
vtable->mutex_make = system_mutex_make;
vtable->mutex_acquire = system_mutex_acquire;
vtable->mutex_release = system_mutex_release;
vtable->mutex_free = system_mutex_free;
vtable->condition_variable_make = system_condition_variable_make;
vtable->condition_variable_wait = system_condition_variable_wait;
vtable->condition_variable_signal = system_condition_variable_signal;
vtable->condition_variable_free = system_condition_variable_free;
vtable->memory_allocate = system_memory_allocate;
vtable->memory_set_protection = system_memory_set_protection;
vtable->memory_free = system_memory_free;
vtable->memory_annotation = system_memory_annotation;
vtable->show_mouse_cursor = system_show_mouse_cursor;
vtable->set_fullscreen = system_set_fullscreen;
vtable->is_fullscreen = system_is_fullscreen;
vtable->get_keyboard_modifiers = system_get_keyboard_modifiers;
vtable->set_key_mode = system_set_key_mode;
vtable->set_source_mixer = system_set_source_mixer;
vtable->set_destination_mixer = system_set_destination_mixer;
}

static void
system_api_read_vtable(API_VTable_system *vtable){
system_error_box = vtable->error_box;
system_get_path = vtable->get_path;
system_get_canonical = vtable->get_canonical;
system_get_file_list = vtable->get_file_list;
system_quick_file_attributes = vtable->quick_file_attributes;
system_load_handle = vtable->load_handle;
system_load_attributes = vtable->load_attributes;
system_load_file = vtable->load_file;
system_load_close = vtable->load_close;
system_save_file = vtable->save_file;
system_load_library = vtable->load_library;
system_release_library = vtable->release_library;
system_get_proc = vtable->get_proc;
system_now_time = vtable->now_time;
system_now_date_time_universal = vtable->now_date_time_universal;
system_local_date_time_from_universal = vtable->local_date_time_from_universal;
system_universal_date_time_from_local = vtable->universal_date_time_from_local;
system_wake_up_timer_create = vtable->wake_up_timer_create;
system_wake_up_timer_release = vtable->wake_up_timer_release;
system_wake_up_timer_set = vtable->wake_up_timer_set;
system_signal_step = vtable->signal_step;
system_sleep = vtable->sleep;
system_get_clipboard = vtable->get_clipboard;
system_post_clipboard = vtable->post_clipboard;
system_set_clipboard_catch_all = vtable->set_clipboard_catch_all;
system_get_clipboard_catch_all = vtable->get_clipboard_catch_all;
system_cli_call = vtable->cli_call;
system_cli_begin_update = vtable->cli_begin_update;
system_cli_update_step = vtable->cli_update_step;
system_cli_end_update = vtable->cli_end_update;
system_open_color_picker = vtable->open_color_picker;
system_get_screen_scale_factor = vtable->get_screen_scale_factor;
system_thread_launch = vtable->thread_launch;
system_thread_join = vtable->thread_join;
system_thread_free = vtable->thread_free;
system_thread_get_id = vtable->thread_get_id;
system_acquire_global_frame_mutex = vtable->acquire_global_frame_mutex;
system_release_global_frame_mutex = vtable->release_global_frame_mutex;
system_mutex_make = vtable->mutex_make;
system_mutex_acquire = vtable->mutex_acquire;
system_mutex_release = vtable->mutex_release;
system_mutex_free = vtable->mutex_free;
system_condition_variable_make = vtable->condition_variable_make;
system_condition_variable_wait = vtable->condition_variable_wait;
system_condition_variable_signal = vtable->condition_variable_signal;
system_condition_variable_free = vtable->condition_variable_free;
system_memory_allocate = vtable->memory_allocate;
system_memory_set_protection = vtable->memory_set_protection;
system_memory_free = vtable->memory_free;
system_memory_annotation = vtable->memory_annotation;
system_show_mouse_cursor = vtable->show_mouse_cursor;
system_set_fullscreen = vtable->set_fullscreen;
system_is_fullscreen = vtable->is_fullscreen;
system_get_keyboard_modifiers = vtable->get_keyboard_modifiers;
system_set_key_mode = vtable->set_key_mode;
system_set_source_mixer = vtable->set_source_mixer;
system_set_destination_mixer = vtable->set_destination_mixer;
}
# 81 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_system_helpers.cpp" 1






Mutex_Lock::Mutex_Lock(System_Mutex m){
    system_mutex_acquire(m);
    this->mutex = m;
}

Mutex_Lock::~Mutex_Lock(){
    system_mutex_release(this->mutex);
}

Mutex_Lock::operator System_Mutex(){
    return(this->mutex);
}
# 82 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_layout.cpp" 1






static i64
layout_nearest_pos_to_xy(Layout_Item_List list, Vec2_f32 p){
    i64 closest_match = 0;
    if (p.y < 0.f){
        closest_match = list.manifested_index_range.min;
    }
    else if (p.y >= list.height){
        closest_match = list.manifested_index_range.max;
    }
    else{
        if (0.f < p.x && p.x < max_f32){
            f32 closest_x = -max_f32;
            for (Layout_Item_Block *block = list.first;
                 block != 0;
                 block = block->next){
                i64 count = block->item_count;
                Layout_Item *item = block->items;
                for (i32 i = 0; i < count; i += 1, item += 1){
                    if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                        continue;
                    }

                    if (p.y < item->rect.y0){
                        goto double_break;
                    }
                    if (item->padded_y1 <= p.y){
                        continue;
                    }
                    f32 dist0 = p.x - item->rect.x0;
                    f32 dist1 = item->rect.x1 - p.x;
                    if (dist0 >= 0.f && dist1 > 0.f){
                        closest_match = item->index;
                        goto double_break;
                    }



                    f32 neg_dist = (((dist0)<(dist1))?(dist0):(dist1));
                    if (closest_x < neg_dist){
                        closest_x = neg_dist;
                        closest_match = item->index;
                    }
                }
            }
            double_break:;
        }
        else{

            if (p.x == max_f32){
                Layout_Item *prev_item = 0;
                for (Layout_Item_Block *block = list.first;
                     block != 0;
                     block = block->next){
                    i64 count = block->item_count;
                    Layout_Item *item = block->items;
                    for (i32 i = 0; i < count; i += 1, item += 1){
                        if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                            continue;
                        }
                        if (p.y < item->rect.y0){
                            goto double_break_2;
                        }
                        prev_item = item;
                        if (item->padded_y1 <= p.y){
                            continue;
                        }
                    }
                }

                double_break_2:;
                if (prev_item != 0){
                    closest_match = prev_item->index;
                }
                else{
                    closest_match = list.manifested_index_range.max;
                }
            }
            else{
                Layout_Item *closest_item = 0;
                for (Layout_Item_Block *block = list.first;
                     block != 0;
                     block = block->next){
                    i64 count = block->item_count;
                    Layout_Item *item = block->items;
                    for (i32 i = 0; i < count; i += 1, item += 1){
                        if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                            continue;
                        }

                        if (p.y < item->rect.y0){
                            goto double_break_3;
                        }
                        if (item->padded_y1 <= p.y){
                            continue;
                        }
                        closest_item = item;
                        goto double_break_3;
                    }
                }

                double_break_3:;
                if (closest_item != 0){
                    closest_match = closest_item->index;
                }
                else{
                    closest_match = list.manifested_index_range.min;
                }
            }

        }
    }
    return(closest_match);
}

static Layout_Item*
layout_get_first_with_index(Layout_Item_List list, i64 index){
    Layout_Item *result = 0;
    Layout_Item *prev = 0;
    for (Layout_Item_Block *block = list.first;
         block != 0;
         block = block->next){
        i64 count = block->item_count;
        Layout_Item *item = block->items;
        for (i32 i = 0; i < count; i += 1, item += 1){
            if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                continue;
            }
            if (item->index > index){
                result = prev;
                goto done;
            }
            if (item->index == index){
                result = item;
                goto done;
            }
            prev = item;
        }
    }
    if (result == 0){
        result = prev;
    }
    done:;
    return(result);
}

static Rect_f32
layout_box_of_pos(Layout_Item_List list, i64 index){
    Rect_f32 result = {};
    Layout_Item *item = layout_get_first_with_index(list, index);
    if (item != 0){
        result = item->rect;
    }
    return(result);
}

static Rect_f32
layout_padded_box_of_pos(Layout_Item_List list, i64 index){
    Rect_f32 result = {};
    Layout_Item *item = layout_get_first_with_index(list, index);
    if (item != 0){
        result.x0 = item->rect.x0;
        result.y0 = item->rect.y0;
        result.x1 = item->rect.x1;
        result.y1 = item->padded_y1;
    }
    return(result);
}

static i64
layout_get_pos_at_character(Layout_Item_List list, i64 character){
    i64 result = 0;
    if (character <= 0){
        result = list.manifested_index_range.min;
    }
    else if (character >= list.character_count){
        result = list.manifested_index_range.max;
    }
    else{
        i64 counter = 0;
        i64 next_counter = 0;
        for (Layout_Item_Block *node = list.first;
             node != 0;
             node = node->next, counter = next_counter){
            next_counter = counter + node->character_count;
            if (character >= next_counter){
                continue;
            }

            i64 count = node->item_count;
            i64 relative_character = character - counter;
            i64 relative_character_counter = 0;

            Layout_Item *item = node->items;
            for (i64 i = 0; i < count; i += 1, item += 1){
                if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                    continue;
                }
                if (relative_character_counter == relative_character){
                    result = item->index;
                    break;
                }
                relative_character_counter += 1;
            }

            break;
        }
    }
    return(result);
}

static i64
layout_character_from_pos(Layout_Item_List list, i64 index){
    i64 result = 0;
    i64 prev_index = -1;
    if (index <= list.manifested_index_range.first){
        result = 0;
    }
    else if (index > list.manifested_index_range.one_past_last){
        result = list.character_count - 1;
    }
    else{
        for (Layout_Item_Block *node = list.first;
             node != 0;
             node = node->next){
            Layout_Item *item = node->items;
            i64 count = node->item_count;
            for (i64 i = 0; i < count; i += 1, item += 1){
                if (item->index >= index){
                    goto double_break;
                }
                if (item->index > prev_index){
                    prev_index = item->index;
                    result += 1;
                }
            }
        }
    }
    double_break:;
    return(result);
}
# 83 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" 1






static void
profile_init(Profile_Global_List *list){
    list->mutex = system_mutex_make();
    list->node_arena = make_arena_system(((4) << 10));
    list->disable_bits = ProfileEnable_UserBit;
}

static Profile_Thread*
prof__get_thread(Profile_Global_List *list, i32 thread_id){
    Profile_Thread *result = 0;
    for (Profile_Thread *node = list->first_thread;
         node != 0;
         node = node->next){
        if (thread_id == node->thread_id){
            result = node;
            break;
        }
    }
    if (result == 0){
        result = ((Profile_Thread*)linalloc_wrap_zero(linalloc_push((&list->node_arena), sizeof(Profile_Thread)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "26" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "26" ":") - 1)))));
        do{ if((result)){if((list->first_thread)){(list->last_thread)->next=(result);}else{(list->first_thread)=(result);}(list->last_thread)=(result);(list->last_thread)->next=0;} }while(0);
        list->thread_count += 1;
        result->thread_id = thread_id;
    }
    return(result);
}

static void
profile_clear(Profile_Global_List *list){
    Mutex_Lock lock(list->mutex);
    for (Arena_Node *node = list->first_arena;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    list->first_arena = 0;
    list->last_arena = 0;

    linalloc_clear(&list->node_arena);
    list->first_thread = 0;
    list->last_thread = 0;
    list->thread_count = 0;
}

static void
profile_thread_flush(Thread_Context *tctx, Profile_Global_List *list){
    if (tctx->prof_record_count > 0){
        Mutex_Lock lock(list->mutex);
        if (list->disable_bits == 0){
            Profile_Thread* thread = prof__get_thread(list, system_thread_get_id());

            Arena_Node* node = ((Arena_Node*)linalloc_wrap_unintialized(linalloc_push((&list->node_arena), sizeof(Arena_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "58" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "58" ":") - 1)))));
            do{ if((node)){if((list->first_arena)){(list->last_arena)->next=(node);}else{(list->first_arena)=(node);}(list->last_arena)=(node);(list->last_arena)->next=0;} }while(0);
            node->arena = tctx->prof_arena;
            tctx->prof_arena = make_arena_system(((16) << 10));

            if (tctx->prof_first != 0){
            if (thread->first_record == 0){
                thread->first_record = tctx->prof_first;
                thread->last_record = tctx->prof_last;
            }
            else{
                thread->last_record->next = tctx->prof_first;
                thread->last_record = tctx->prof_last;
            }
            thread->record_count += tctx->prof_record_count;
            }
        }
        else{
            linalloc_clear(&tctx->prof_arena);
        }
        tctx->prof_record_count = 0;
        tctx->prof_first = 0;
        tctx->prof_last = 0;
    }
}

static void
profile_thread_set_name(Thread_Context *tctx, Profile_Global_List *list, String_Const_u8 name){
    Mutex_Lock lock(list->mutex);
    Profile_Thread* thread = prof__get_thread(list, system_thread_get_id());
    thread->name = name;
}



static void
profile_set_enabled(Profile_Global_List *list, b32 value, Profile_Enable_Flag flag){
    Mutex_Lock lock(list->mutex);
    if (value){
        ((list->disable_bits)&=(~(flag)));
    }
    else{
        ((list->disable_bits)|=(flag));
    }
}

static void
thread_profile_record__inner(Thread_Context *tctx, Profile_ID id, u64 time,
                             String_Const_u8 name, String_Const_u8 location){
    Profile_Record *record = ((Profile_Record*)linalloc_wrap_zero(linalloc_push((&tctx->prof_arena), sizeof(Profile_Record)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "107" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp" ":" "107" ":") - 1)))));
    do{ if((record)){if((tctx->prof_first)){(tctx->prof_last)->next=(record);}else{(tctx->prof_first)=(record);}(tctx->prof_last)=(record);(tctx->prof_last)->next=0;} }while(0);
    tctx->prof_record_count += 1;
    record->id = id;
    record->time = time;
    record->location = location;
    record->name = name;
}

static Profile_ID
thread_profile_record_push(Thread_Context *tctx, u64 time,
                           String_Const_u8 name, String_Const_u8 location){
    Profile_ID id = tctx->prof_id_counter;
    tctx->prof_id_counter += 1;
    thread_profile_record__inner(tctx, id, time, name, location);
    return(id);
}
static void
thread_profile_record_pop(Thread_Context *tctx, u64 time, Profile_ID id){
    do{ if (!(tctx->prof_id_counter > 1)) { (*((i32*)0) = 0xA11E); } }while(0);
    tctx->prof_id_counter = id;
    thread_profile_record__inner(tctx, id, time, SCu8(""), SCu8(""));
}

static Profile_ID
thread_profile_record_push(Application_Links *app, u64 time,
                           String_Const_u8 name, String_Const_u8 location){
    Thread_Context *tctx = get_thread_context(app);
    return(thread_profile_record_push(tctx, time, name, location));
}
static void
thread_profile_record_pop(Application_Links *app, u64 time, Profile_ID id){
    Thread_Context *tctx = get_thread_context(app);
    thread_profile_record_pop(tctx, time, id);
}



static void
profile_block__init(Thread_Context *tctx, Profile_Global_List *list,
                    String_Const_u8 name, String_Const_u8 location, Profile_Block *block){
    block->tctx = tctx;
    block->list = list;
    block->is_closed = false;
    block->id = thread_profile_record_push(tctx, system_now_time(), name, location);
}
static void
profile_block__init(Thread_Context *tctx, Profile_Global_List *list,
                    String_Const_u8 name, String_Const_u8 location,
                    Profile_Scope_Block *block){
    block->tctx = tctx;
    block->list = list;
    block->is_closed = false;
    block->id = thread_profile_record_push(tctx, system_now_time(), name, location);
}



Profile_Block::Profile_Block(Thread_Context *tctx, Profile_Global_List *list,
                             String_Const_u8 name, String_Const_u8 location){
    profile_block__init(tctx, list, name, location, this);
}
Profile_Block::Profile_Block(Application_Links *app, String_Const_u8 name,
                             String_Const_u8 location){
    Thread_Context *v_tctx = get_thread_context(app);
    Profile_Global_List *v_list = get_core_profile_list(app);
    profile_block__init(v_tctx, v_list, name, location, this);
}
Profile_Block::~Profile_Block(){
    this->close_now();
}
void
Profile_Block::close_now(){
    if (!this->is_closed){
        thread_profile_record_pop(this->tctx, system_now_time(), this->id);
        this->is_closed = true;
    }
}



Profile_Scope_Block::Profile_Scope_Block(Thread_Context *tctx, Profile_Global_List *list,
                                         String_Const_u8 name, String_Const_u8 location){
    profile_block__init(tctx, list, name, location, this);
}
Profile_Scope_Block::Profile_Scope_Block(Application_Links *app, String_Const_u8 name,
                                         String_Const_u8 location){
    Thread_Context *v_tctx = get_thread_context(app);
    Profile_Global_List *v_list = get_core_profile_list(app);
    profile_block__init(v_tctx, v_list, name, location, this);
}
Profile_Scope_Block::~Profile_Scope_Block(){
    this->close_now();
    profile_thread_flush(this->tctx, this->list);
}
void
Profile_Scope_Block::close_now(){
    if (!this->is_closed){
        thread_profile_record_pop(this->tctx, system_now_time(), this->id);
        this->is_closed = true;
    }
}



CUSTOM_COMMAND(profile_enable, "/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp", 212, Normal)
CUSTOM_DOC("Allow 4coder's self profiler to gather new profiling information.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_set_enabled(list, true, ProfileEnable_UserBit);
}

CUSTOM_COMMAND(profile_disable, "/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp", 219, Normal)
CUSTOM_DOC("Prevent 4coder's self profiler from gathering new profiling information.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_set_enabled(list, false, ProfileEnable_UserBit);
}

CUSTOM_COMMAND(profile_clear, "/home/tabletel/dev/4cc/code/custom/4coder_profile.cpp", 226, Normal)
CUSTOM_DOC("Clear all profiling information from 4coder's self profiler.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_clear(list);
}
# 84 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_profile_static_enable.cpp" 1
# 85 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" 1






static b32
has_modifier(Key_Code *mods, i32 count, Key_Code modifier){
    b32 result = false;
    for (i32 i = 0; i < count; i += 1){
        if (mods[i] == modifier){
            result = true;
            break;
        }
    }
    return(result);
}

static b32
has_modifier(Input_Modifier_Set_Fixed *set, Key_Code modifier){
    return(has_modifier(set->mods, set->count, modifier));
}

static b32
has_modifier(Input_Modifier_Set *set, Key_Code modifier){
    return(has_modifier(set->mods, set->count, modifier));
}

static Input_Modifier_Set
copy_modifier_set(Arena *arena, Input_Modifier_Set_Fixed *set){
    Input_Modifier_Set result = {};
    result.count = set->count;
    if (result.count > 0){
        result.mods = ((Key_Code*)linalloc_wrap_write(linalloc_push((arena), sizeof(Key_Code)*(result.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "34" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "34" ":") - 1))), sizeof(Key_Code)*(result.count), (set->mods)));
    }
    return(result);
}

static void
copy_modifier_set(Input_Modifier_Set_Fixed *dst, Input_Modifier_Set *set){
    i32 count = (((set->count)<(((sizeof(dst->mods))/(sizeof(*dst->mods)))))?(set->count):(((sizeof(dst->mods))/(sizeof(*dst->mods)))));
    dst->count = count;
    block_copy(dst->mods, set->mods, count*sizeof(*set->mods));
}

static void
add_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod){
    if (!has_modifier(set, mod)){
        if (set->count < ((sizeof(set->mods))/(sizeof(*set->mods)))){
            set->mods[set->count] = mod;
            set->count += 1;
        }
    }
}

static void
remove_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod){
    i32 count = set->count;
    Key_Code *mods = set->mods;
    for (i32 i = 0; i < count; i += 1){
        if (mods[i] == mod){
            i32 new_count = count - 1;
            mods[i] = mods[new_count];
            set->count = new_count;
            break;
        }
    }
}

static void
set_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod, b32 val){
    if (val){
        add_modifier(set, mod);
    }
    else{
        remove_modifier(set, mod);
    }
}

static Input_Modifier_Set
copy_modifier_set(Arena *arena, Input_Modifier_Set *set){
    Input_Modifier_Set result = {};
    result.count = set->count;
    if (result.count > 0){
        result.mods = ((Key_Code*)linalloc_wrap_write(linalloc_push((arena), sizeof(Key_Code)*(result.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "85" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "85" ":") - 1))), sizeof(Key_Code)*(result.count), (set->mods)));
    }
    return(result);
}

static Input_Modifier_Set*
get_modifiers(Input_Event *event){
    Input_Modifier_Set *result = 0;
    switch (event->kind){
        case InputEventKind_KeyStroke:
        {
            result = &event->key.modifiers;
        }break;
        case InputEventKind_MouseButton:
        {
            result = &event->mouse.modifiers;
        }break;
        case InputEventKind_MouseWheel:
        {
            result = &event->mouse_wheel.modifiers;
        }break;
        case InputEventKind_MouseMove:
        {
            result = &event->mouse_move.modifiers;
        }break;
    }
    return(result);
}

static b32
has_modifier(Input_Event *event, Key_Code modifier){
    Input_Modifier_Set *set = get_modifiers(event);
    return(has_modifier(set, modifier));
}

static b32
is_unmodified_key(Input_Event *event){
    b32 result = false;
    if (event->kind == InputEventKind_KeyStroke){
        Input_Modifier_Set *set = get_modifiers(event);
        result = (!has_modifier(set, KeyCode_Control) &&
                  !has_modifier(set, KeyCode_Alt) &&
                  !has_modifier(set, KeyCode_Shift) &&
                  !has_modifier(set, KeyCode_Command));
    }
    return(result);
}

static b32
is_modified(Input_Event *event){
    Input_Modifier_Set *mods = get_modifiers(event);
    b32 result = false;
    if (mods != 0){
        result = (mods->count > 0);
    }
    return(result);
}

static b32
event_is_dead_key(Input_Event *event){
    return(event->kind == InputEventKind_KeyStroke && (((event->key.flags)&(KeyFlag_IsDeadKey))!=0));
}

static Input_Event
event_next_text_event(Input_Event *event){
    Input_Event result = {};
    if (event != 0){
        if (event->kind == InputEventKind_KeyStroke &&
            event->key.first_dependent_text != 0){
            block_copy((&result), (event->key.first_dependent_text), sizeof(*(&result)));
        }
        else if (event->kind == InputEventKind_TextInsert &&
                 event->text.next_text != 0){
            block_copy((&result), (event->text.next_text), sizeof(*(&result)));
        }
    }
    return(result);
}

static String_Const_u8
to_writable(Input_Event *event){
    String_Const_u8 result = {};
    if (event->kind == InputEventKind_TextInsert){
        result = event->text.string;
    }
    return(result);
}

static b32
match_key_code(Input_Event *event, Key_Code code){
    return(event->kind == InputEventKind_KeyStroke && event->key.code == code);
}

static b32
match_mouse_code(Input_Event *event, Mouse_Code code){
    return(event->kind == InputEventKind_MouseButton && event->mouse.code == code);
}

static b32
match_mouse_code_release(Input_Event *event, Mouse_Code code){
    return(event->kind == InputEventKind_MouseButtonRelease && event->mouse.code == code);
}

static b32
match_core_code(Input_Event *event, Core_Code code){
    return(event->kind == InputEventKind_Core && event->core.code == code);
}

static Event_Property
get_event_properties(Input_Event *event){
    Event_Property flags = 0;

    switch (event->kind){
        case InputEventKind_TextInsert:
        {
            flags |= EventProperty_TextInsert;
        }break;

        case InputEventKind_KeyStroke:
        {
            if (event->key.code == KeyCode_Escape){
                flags |= EventProperty_Escape;
            }
            flags |= EventProperty_AnyKey;
        }break;

        case InputEventKind_KeyRelease:
        {
            flags |= EventProperty_AnyKeyRelease;
        }break;

        case InputEventKind_MouseButton:
        {
            flags |= EventProperty_MouseButton;
        }break;

        case InputEventKind_MouseButtonRelease:
        {
            flags |= EventProperty_MouseRelease;
        }break;

        case InputEventKind_MouseWheel:
        {
            flags |= EventProperty_MouseWheel;
        }break;

        case InputEventKind_MouseMove:
        {
            flags |= EventProperty_MouseMove;
        }break;

        case InputEventKind_Core:
        {
            switch (event->core.code){
                case CoreCode_Animate:
                {
                    flags |= EventProperty_Animate;
                }break;

                case CoreCode_ClickActivateView:
                case CoreCode_ClickDeactivateView:
                {
                    flags |= EventProperty_ViewActivation;
                }break;

                case CoreCode_FileExternallyModified:
                {
                    flags |= EventProperty_AnyFile;
                }break;

                case CoreCode_Startup:
                {
                    flags |= EventProperty_Startup;
                }break;

                case CoreCode_TryExit:
                {
                    flags |= EventProperty_Exit;
                }break;

                case CoreCode_NewClipboardContents:
                {
                    flags |= EventProperty_Clipboard;
                }break;
            }
        }break;

        case InputEventKind_CustomFunction:
        {
            flags |= EventProperty_CustomFunction;
        }break;
    }

    return(flags);
}

static Input_Event*
push_input_event(Arena *arena, Input_List *list){
    Input_Event_Node *node = ((Input_Event_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Input_Event_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "283" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "283" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    return(&node->event);
}

static Input_Event*
push_input_event(Arena *arena, Input_List *list, Input_Event *event){
    Input_Event_Node *node = ((Input_Event_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Input_Event_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "291" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "291" ":") - 1)))));
    block_copy((&node->event), (event), sizeof(*(&node->event)));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    return(&node->event);
}

static Input_Event
copy_input_event(Arena *arena, Input_Event *event){
    Input_Event result = *event;
    switch (result.kind){
        case InputEventKind_TextInsert:
        {
            result.text.string = push_string_copy(arena, event->text.string);
        }break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            result.key.modifiers = copy_modifier_set(arena, &event->key.modifiers);
        }break;

        case InputEventKind_MouseButton:
        case InputEventKind_MouseButtonRelease:
        {
            result.mouse.modifiers = copy_modifier_set(arena, &event->mouse.modifiers);
        }break;

        case InputEventKind_MouseWheel:
        {
            result.mouse_wheel.modifiers = copy_modifier_set(arena, &event->mouse_wheel.modifiers);
        }break;

        case InputEventKind_MouseMove:
        {
            result.mouse_move.modifiers = copy_modifier_set(arena, &event->mouse_move.modifiers);
        }break;

        case InputEventKind_Core:
        {
            switch (result.core.code){
                case CoreCode_Startup:
                {
                    result.core.flag_strings = push_string_array_copy(arena, event->core.flag_strings);
                    result.core.file_names = push_string_array_copy(arena, event->core.file_names);
                }break;

                case CoreCode_FileExternallyModified:
                case CoreCode_NewClipboardContents:
                {
                    result.core.string = push_string_copy(arena, event->core.string);
                }break;
            }
        }break;
    }
    return(result);
}



static String_Const_u8
stringize_keyboard_event(Arena *arena, Input_Event *event){
    List_String_Const_u8 list = {};

    switch (event->kind){
        case InputEventKind_TextInsert:
        {
            string_list_push(arena, &list, SCu8((u8*)("t"), (u64)(sizeof("t") - 1)));
            u64 size = event->text.string.size;
            u8 *ptr = event->text.string.str;
            for (u64 i = 0; i < size; i += 1, ptr += 1){
                string_list_pushf(arena, &list, "%02X", (i32)(*ptr));
            }
            string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            string_list_pushf(arena, &list, "k%X ", event->key.code);
            if (event->kind == InputEventKind_KeyRelease){
                string_list_push(arena, &list, SCu8((u8*)("^"), (u64)(sizeof("^") - 1)));
            }
            i32 count = event->key.modifiers.count;
            if (count > 0){
                Key_Code *m = event->key.modifiers.mods;
                string_list_push(arena, &list, SCu8((u8*)("m{"), (u64)(sizeof("m{") - 1)));
                for (i32 i = 0; i < count; i += 1, m += 1){
                    string_list_pushf(arena, &list, "%X ", *m);
                }
                string_list_push(arena, &list, SCu8((u8*)("}"), (u64)(sizeof("}") - 1)));
            }
            string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }break;
    }

    return(string_list_flatten(arena, list));
}

static Input_Event
parse_keyboard_event(Arena *arena, String_Const_u8 text){
    Input_Event result = {};
    u64 pos = 0;
    Range_i64 range = {};

    if (pos < text.size && text.str[pos] == 't'){
        pos += 1;
        result.kind = InputEventKind_TextInsert;

        u64 max_size = text.size/2;
        result.text.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(max_size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "401" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_events.cpp" ":" "401" ":") - 1)))));
        for (; pos + 1 < text.size; pos += 2){
            if (character_is_base16(text.str[pos]) &&
                character_is_base16(text.str[pos + 1])){
                String_Const_u8 byte_str = {text.str + pos, 2};
                result.text.string.str[result.text.string.size] = (u8)string_to_integer(byte_str, 16);
                result.text.string.size += 1;
            }
        }
    }
    else if (pos < text.size && text.str[pos] == 'k'){
        pos += 1;
        result.kind = InputEventKind_KeyStroke;

        range.first = pos;
        for (;pos < text.size && character_is_base16(text.str[pos]); pos += 1);
        range.one_past_last = pos;

        if (range.first == range.one_past_last){
            result.kind = InputEventKind_None;
        }
        else{
            String_Const_u8 code_str = string_substring(text, range);
            result.key.code = (u32)string_to_integer(code_str, 16);

            for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);

            if (pos < text.size && text.str[pos] == '^'){
                result.kind = InputEventKind_KeyRelease;
                pos += 1;
                for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);
            }

            if (pos < text.size && text.str[pos] == 'm'){
                pos += 1;
                if (pos < text.size && text.str[pos] == '{'){
                    pos += 1;

                    Input_Modifier_Set_Fixed mods = {};
                    for (;mods.count < ((sizeof(mods.mods))/(sizeof(*mods.mods)));){
                        for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);
                        range.first = pos;
                        for (;pos < text.size && character_is_base16(text.str[pos]); pos += 1);
                        range.one_past_last = pos;

                        if (range.first == range.one_past_last){
                            break;
                        }

                        code_str = string_substring(text, range);
                        mods.mods[mods.count] = (u32)string_to_integer(code_str, 16);
                        mods.count += 1;
                    }

                    result.key.modifiers = copy_modifier_set(arena, &mods);
                }
            }
        }
    }

    return(result);
}
# 86 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_custom.cpp" 1






extern "C" b32
get_version(i32 maj, i32 min, i32 patch){
    return(maj == 4 && min == 1 && patch == 8);
}

extern "C" Custom_Layer_Init_Type*
init_apis(API_VTable_custom *custom_vtable, API_VTable_system *system_vtable){
    custom_api_read_vtable(custom_vtable);
    system_api_read_vtable(system_vtable);
    return(custom_layer_init);
}
# 87 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_log.cpp" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_log.cpp"
static String_Const_u8
log_event(Arena *arena, String_Const_u8 event_name, String_Const_u8 src_name, i32 line_number, i32 buffer, i32 view, i32 thread_id){
    List_String_Const_u8 list = {};
    string_list_pushf(arena, &list, "%.*s:%d: %.*s",
                      (i32)(src_name).size, (char*)(src_name).str, line_number, (i32)(event_name).size, (char*)(event_name).str);
    if (thread_id != 0){
        string_list_pushf(arena, &list, " [thread=%d]", thread_id);
    }
    if (buffer != 0){
        string_list_pushf(arena, &list, " [buffer=%d]", buffer);
    }
    if (view != 0){
        string_list_pushf(arena, &list, " [view=%d]", view);
    }
    string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
    return(string_list_flatten(arena, list));
}
# 88 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_hash_functions.cpp" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_hash_functions.cpp"
static u64
table_hash_u8(u8 *v, u64 size){
    u64 hash = 0;
    for (u8 *p = v, *e = v + size; p < e; p += 1){
        u8 k = *p;
        k *= 81;
        k = ((u8)(k << 4)) | ((u8)(k >> 4));
        hash ^= k;
        hash *= 11;
        hash += 237;
    }
    return(hash);
}
static u64
table_hash_u16(u16 *v, u64 size){
    u64 hash = 0;
    for (u16 *p = v, *e = v + size; p < e; p += 1){
        u16 k = *p;
        k *= 11601;
        k = ((u16)(k << 8)) | ((u16)(k >> 8));
        hash ^= k;
        hash *= 11;
        hash += 12525;
    }
    return(hash);
}
static u64
table_hash_u32(u32 *v, u64 size){
    u64 hash = 0;
    for (u32 *p = v, *e = v + size; p < e; p += 1){
        u32 k = *p;
        k *= 3432918353U;
        k = ((u32)(k << 16)) | ((u32)(k >> 16));
        hash ^= k;
        hash *= 11;
        hash += 2041000173U;
    }
    return(hash);
}
static u64
table_hash_u64(u64 *v, u64 size){
    u64 hash = 0;
    for (u64 *p = v, *e = v + size; p < e; p += 1){
        u64 k = *p;
        k *= 14744272059406101841ULL;
        k = ((u64)(k << 32)) | ((u64)(k >> 32));
        hash ^= k;
        hash *= 11;
        hash += 8766028991911375085ULL;
    }
    return(hash);
}
static u64
table_hash(void *v, i32 it_size, u64 size){
    u64 hash = 0;
    switch (it_size){
        case 1:
        {
            hash = table_hash_u8((u8*)v, size);
        }break;
        case 2:
        {
            hash = table_hash_u16((u16*)v, size);
        }break;
        case 4:
        {
            hash = table_hash_u32((u32*)v, size);
        }break;
        case 8:
        {
            hash = table_hash_u64((u64*)v, size);
        }break;
        default:
        {
            hash = table_hash_u8((u8*)v, it_size*size);
        }break;
    }
    return(hash);
}
# 89 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" 1






static u64
table_hash(String_Const_u8 key){
    return(table_hash_u8((u8*)key.str, key.size) | bit_64);
}

static const u64 table_empty_slot = 0;
static const u64 table_erased_slot = 1;

static const u64 table_empty_key = 0;
static const u64 table_erased_key = max_u64;

static const u32 table_empty_u32_key = 0;
static const u32 table_erased_u32_key = max_u32;



static Table_u64_u64
make_table_u64_u64__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u64_u64 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    String_Const_u8 mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.str, mem.size);
    table.memory = mem.str;
    table.keys = (u64*)table.memory;
    table.vals = (u64*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u64_u64 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u64_u64 *table, u64 key){
    Table_Lookup result = {};

    if (key != table_empty_key && key != table_erased_key &&
        table->slot_count > 0){
        u64 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u64_u64 *table, Table_Lookup lookup, u64 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_u64_u64 *table, u64 key, u64 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_u64_u64 *table, Table_Lookup lookup, u64 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = lookup.hash;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u64_u64 *dst, Table_u64_u64 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u64 key = src_keys[i];
            if (key != table_empty_key &&
                key != table_erased_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u64_u64 *table, u64 key, u64 val){
    b32 result = false;
    if (key != table_empty_key && key != table_erased_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u64_u64 new_table = make_table_u64_u64__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "150" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "150" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u64_u64 *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = table_erased_key;
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u64_u64 *table, u64 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u64_u64 *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
}



static Table_u32_u16
make_table_u32_u16__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u32_u16 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    String_Const_u8 mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.str, mem.size);
    table.memory = mem.str;
    table.keys = (u32*)table.memory;
    table.vals = (u16*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u32_u16 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u32_u16 *table, u32 key){
    Table_Lookup result = {};

    if (key != table_empty_u32_key && key != table_erased_u32_key &&
        table->slot_count > 0){
        u32 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_u32_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_u32_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u32_u16 *table, u32 key, u16 *val_out){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static void
table_insert__inner(Table_u32_u16 *table, Table_Lookup lookup, u32 key, u16 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u32_u16 *dst, Table_u32_u16 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u32 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u32 key = src_keys[i];
            if (key != table_empty_u32_key && key != table_erased_u32_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u32_u16 *table, u32 key, u16 val){
    b32 result = false;
    if (key != table_empty_u32_key && key != table_erased_u32_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u32_u16 new_table = make_table_u32_u16__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "311" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "311" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u32_u16 *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = table_erased_u32_key;
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u32_u16 *table, u32 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u32_u16 *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_Data_u64
make_table_Data_u64__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_Data_u64 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    String_Const_u8 mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.hashes) + sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.str, mem.size);
    table.memory = mem.str;
    table.hashes = (u64*)table.memory;
    table.keys = (String_Const_u8*)(table.hashes + slot_count);
    table.vals = (u64*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_Data_u64 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_Data_u64 *table, String_Const_u8 key){
    Table_Lookup result = {};

    if (table->slot_count > 0){
        u64 *hashes = table->hashes;
        u32 slot_count = table->slot_count;

        u64 hash = table_hash(key);
        u32 first_index = hash % slot_count;
        u32 index = first_index;
        result.hash = hash;
        for (;;){
            if (hash == hashes[index]){
                if (data_match(key, table->keys[index])){
                    result.index = index;
                    result.found_match = true;
                    result.found_empty_slot = false;
                    result.found_erased_slot = false;
                    break;
                }
            }
            if (table_empty_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_Data_u64 *table, Table_Lookup lookup, u64 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read_key(Table_Data_u64 *table, Table_Lookup lookup, String_Const_u8 *key_out){
    b32 result = false;
    if (lookup.found_match){
        *key_out = table->keys[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_Data_u64 *table, String_Const_u8 key, u64 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_Data_u64 *table, Table_Lookup lookup, String_Const_u8 key, u64 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->hashes[lookup.index] = lookup.hash;
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_Data_u64 *dst, Table_Data_u64 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_hashes = src->hashes;
        for (u32 i = 0; i < src_slot_count; i += 1){
            if ((((src_hashes[i])&(bit_64))!=0)){
                String_Const_u8 key = src->keys[i];
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_Data_u64 *table, String_Const_u8 key, u64 val){
    b32 result = false;
    if (key.str != 0){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_Data_u64 new_table = make_table_Data_u64__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "493" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "493" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_Data_u64 *table, String_Const_u8 key){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        table->hashes[lookup.index] = table_erased_slot;
        block_zero((&table->keys[lookup.index]), sizeof(*(&table->keys[lookup.index])));
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static void
table_clear(Table_Data_u64 *table){
    block_zero((table->hashes), sizeof(*(table->hashes))*(table->slot_count));
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_u64_Data
make_table_u64_Data__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u64_Data table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    String_Const_u8 mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.str, mem.size);
    table.memory = mem.str;
    table.keys = (u64*)table.memory;
    table.vals = (String_Const_u8*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u64_Data *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u64_Data *table, u64 key){
    Table_Lookup result = {};

    if (key != table_empty_key && key != table_erased_key &&
        table->slot_count > 0){
        u64 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u64_Data *table, Table_Lookup lookup, String_Const_u8 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_u64_Data *table, u64 key, String_Const_u8 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_u64_Data *table, Table_Lookup lookup, String_Const_u8 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = lookup.hash;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u64_Data *dst, Table_u64_Data *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u64 key = src_keys[i];
            if (key != table_empty_key &&
                key != table_erased_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u64_Data *table, u64 key, String_Const_u8 val){
    b32 result = false;
    if (key != table_empty_key && table_erased_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u64_Data new_table = make_table_u64_Data__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "659" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "659" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u64_Data *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = 0;
        block_zero((&table->vals[lookup.index]), sizeof(*(&table->vals[lookup.index])));
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u64_Data *table, u64 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u64_Data *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_Data_Data
make_table_Data_Data__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_Data_Data table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    String_Const_u8 mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.hashes) + sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.str, mem.size);
    table.memory = mem.str;
    table.hashes = (u64*)table.memory;
    table.keys = (String_Const_u8*)(table.hashes + slot_count);
    table.vals = (String_Const_u8*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_Data_Data *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_Data_Data *table, String_Const_u8 key){
    Table_Lookup result = {};

    if (table->slot_count > 0){
        u64 *hashes = table->hashes;
        u32 slot_count = table->slot_count;

        u64 hash = table_hash(key);
        u32 first_index = hash % slot_count;
        u32 index = first_index;
        result.hash = hash;
        for (;;){
            if (hash == hashes[index]){
                if (data_match(key, table->keys[index])){
                    result.index = index;
                    result.found_match = true;
                    result.found_empty_slot = false;
                    result.found_erased_slot = false;
                    break;
                }
            }
            if (table_empty_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_slot == hashes[index] && !result.found_erased_slot){
                result.index = index;
                result.found_erased_slot = true;
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_Data_Data *table, Table_Lookup lookup, String_Const_u8 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read_key(Table_Data_Data *table, Table_Lookup lookup, String_Const_u8 *key_out){
    b32 result = false;
    if (lookup.found_match){
        *key_out = table->keys[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_Data_Data *table, String_Const_u8 key, String_Const_u8 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_Data_Data *table, Table_Lookup lookup, String_Const_u8 key, String_Const_u8 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->hashes[lookup.index] = lookup.hash;
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_Data_Data *dst, Table_Data_Data *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_hashes = src->hashes;
        for (u32 i = 0; i < src_slot_count; i += 1){
            if ((((src_hashes[i])&(bit_64))!=0)){
                String_Const_u8 key = src->keys[i];
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_Data_Data *table, String_Const_u8 key, String_Const_u8 val){
    b32 result = false;
    if (key.str != 0){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_Data_Data new_table = make_table_Data_Data__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "839" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_table.cpp" ":" "839" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_Data_Data *table, String_Const_u8 key){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        table->hashes[lookup.index] = table_erased_slot;
        block_zero((&table->keys[lookup.index]), sizeof(*(&table->keys[lookup.index])));
        block_zero((&table->vals[lookup.index]), sizeof(*(&table->vals[lookup.index])));
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static void
table_clear(Table_Data_Data *table){
    block_zero((table->hashes), sizeof(*(table->hashes))*(table->slot_count));
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}
# 90 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_codepoint_map.cpp" 1






static b32
codepoint_index_map_read(Codepoint_Index_Map *map, u32 codepoint, u16 *index_out){
    b32 success = true;
    if (codepoint == 0 && map->has_zero_index){
        *index_out = map->zero_index;
    }
    else if (table_read(&map->table, codepoint, index_out)){

    }
    else{
        success = false;
    }
    return(success);
}

static u16
codepoint_index_map_count(Codepoint_Index_Map *map){
    return(map->max_index + 1);
}

static f32
font_get_glyph_advance(Face_Advance_Map *map, Face_Metrics *metrics, u32 codepoint, f32 tab_multiplier){
    f32 result = 0.f;
    if (codepoint == '\t'){
        result = metrics->space_advance*tab_multiplier;
    }
    else{
        if (character_is_whitespace(codepoint)){
            codepoint = ' ';
        }
        u16 index = 0;
        if (codepoint_index_map_read(&map->codepoint_to_index, codepoint, &index)){
            if (index < map->index_count){
                result = map->advance[index];
            }
        }
    }
    return(result);
}

static f32
font_get_max_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                 u32 codepoint_first, u32 codepoint_last,
                                 f32 tab_multiplier){
    f32 result = font_get_glyph_advance(map, metrics, codepoint_first, tab_multiplier);
    for (u32 i = codepoint_first + 1; i <= codepoint_last; i += 1){
        f32 a = font_get_glyph_advance(map, metrics, i, tab_multiplier);
        result = (((a)>(result))?(a):(result));
    }
    return(result);
}

static f32
font_get_average_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                     u32 codepoint_first, u32 codepoint_last,
                                     f32 tab_multiplier){
    f32 result = 0.f;
    for (u32 i = codepoint_first; i <= codepoint_last; i += 1){
        result += font_get_glyph_advance(map, metrics, i, tab_multiplier);
    }
    result /= (f32)(codepoint_last - codepoint_first + 1);
    return(result);
}
# 91 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.cpp" 1
# 11 "/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.cpp"
static Async_System global_async_system = {};

static Async_Node*
async_pop_node(Async_System *async_system){
    for (;async_system->task_count == 0;){
        system_condition_variable_wait(async_system->cv, async_system->mutex);
    }
    Node *node = async_system->task_sent.next;
    do{ if (!(node != &async_system->task_sent)) { (*((i32*)0) = 0xA11E); } }while(0);
    ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0);
    async_system->task_count -= 1;
    Async_Node *a_node = (Async_Node*)( (u8*)(node) - ((u8*)(&(((Async_Node*)0)->node)) - (u8*)(0)) );
    a_node->next = 0;
    return(a_node);
}

static Async_Node*
async_push_node__inner(Async_System *async_system, Async_Task_Function_Type *func, String_Const_u8 data){
    Async_Task result = async_system->task_id_counter;
    async_system->task_id_counter += 1;

    Async_Node *node = async_system->free_nodes;
    if (node == 0){
        node = ((Async_Node*)linalloc_wrap_unintialized(linalloc_push((&async_system->node_arena), sizeof(Async_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.cpp" ":" "34" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_async_tasks.cpp" ":" "34" ":") - 1)))));
    }
    else{
        ((async_system->free_nodes)=(async_system->free_nodes)=(async_system->free_nodes)->next);
    }
    node->task = result;
    node->thread = 0;
    node->func = func;
    node->data.str = (u8*)heap_allocate(&async_system->node_heap, data.size);
    block_copy(node->data.str, data.str, data.size);
    node->data.size = data.size;
    ((&node->node)->prev=(&async_system->task_sent)->prev,(&node->node)->next=(&async_system->task_sent),(&async_system->task_sent)->prev->next=(&node->node),(&async_system->task_sent)->prev=(&node->node));
    async_system->task_count += 1;
    system_condition_variable_signal(async_system->cv);

    return(node);
}

static Async_Task
async_push_node(Async_System *async_system, Async_Task_Function_Type *func, String_Const_u8 data){
    Async_Node *node = async_push_node__inner(async_system, func, data);
    return(node->task);
}

static void
async_free_node(Async_System *async_system, Async_Node *node){
    heap_free(&async_system->node_heap, node->data.str);
    ((node)->next=(async_system->free_nodes),(async_system->free_nodes)=(node));
}

static void
async_task_thread(void *thread_ptr){
    Base_Allocator *allocator = get_base_allocator_system();

    Thread_Context_Extra_Info tctx_info = {};
    tctx_info.async_thread = thread_ptr;

    Thread_Context tctx_ = {};
    Thread_Context *tctx = &tctx_;
    thread_ctx_init(tctx, ThreadKind_AsyncTasks, allocator, allocator);

    Async_Thread *thread = (Async_Thread*)thread_ptr;
    Async_System *async_system = thread->async_system;

    Application_Links app = {};
    app.tctx = tctx;
    app.cmd_context = async_system->cmd_context;

    Profile_Global_List *list = get_core_profile_list(&app);
    profile_thread_set_name((tctx), (list), (SCu8((u8*)("async"), (u64)(sizeof("async") - 1))));

    Async_Context ctx = {&app, thread};

    for (;;){
        system_mutex_acquire(async_system->mutex);
        Async_Node *node = async_pop_node(async_system);
        node->thread = thread;
        thread->node = node;
        thread->task = node->task;
        thread->cancel_signal = false;
        system_mutex_release(async_system->mutex);

        node->func(&ctx, node->data);

        system_mutex_acquire(async_system->mutex);
        node->thread = 0;
        thread->node = 0;
        thread->task = 0;
        thread->cancel_signal = false;
        async_free_node(async_system, node);
        system_condition_variable_signal(async_system->join_cv);
        system_mutex_release(async_system->mutex);
    }
}

static Async_Node*
async_get_pending_node(Async_System *async_system, Async_Task task){
    Async_Node *result = 0;
    if (task != 0){
        for (Node *node = async_system->task_sent.next;
             node != &async_system->task_sent;
             node = node->next){
            Async_Node *a_node = (Async_Node*)( (u8*)(node) - ((u8*)(&(((Async_Node*)0)->node)) - (u8*)(0)) );
            if (a_node->task == task){
                result = a_node;
                break;
            }
        }
    }
    return(result);
}

static Async_Node*
async_get_running_node(Async_System *async_system, Async_Task task){
    Async_Node *result = 0;
    if (task != 0 && async_system->thread.task == task){
        result = async_system->thread.node;
    }
    return(result);
}



static void
async_task_handler_init(Application_Links *app, Async_System *async_system){
    block_zero((async_system), sizeof(*(async_system)));
    async_system->cmd_context = app->cmd_context;
    async_system->node_arena = make_arena_system(((4) << 10));
    heap_init(&async_system->node_heap, &async_system->node_arena);
    async_system->mutex = system_mutex_make();
    async_system->cv = system_condition_variable_make();
    async_system->join_cv = system_condition_variable_make();
    ((&async_system->task_sent)->next=(&async_system->task_sent),(&async_system->task_sent)->prev=(&async_system->task_sent));
    async_system->thread.async_system = async_system;
    async_system->thread.thread = system_thread_launch(async_task_thread, &async_system->thread);
}

static Async_Task
async_task_no_dep(Async_System *async_system, Async_Task_Function_Type *func, String_Const_u8 data){
    system_mutex_acquire(async_system->mutex);
    Async_Task result = async_push_node(async_system, func, data);
    system_mutex_release(async_system->mutex);
    return(result);
}

static b32
async_task_is_pending(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_pending_node(async_system, task);
    system_mutex_release(async_system->mutex);
    return(node != 0);
}

static b32
async_task_is_running(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_running_node(async_system, task);
    system_mutex_release(async_system->mutex);
    return(node != 0);
}

static b32
async_task_is_running_or_pending__inner(Async_System *async_system, Async_Task task){
    Async_Node *node = async_get_pending_node(async_system, task);
    if (node == 0){
        node = async_get_running_node(async_system, task);
    }
    return(node != 0);
}

static b32
async_task_is_running_or_pending(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    b32 result = async_task_is_running_or_pending__inner(async_system, task);
    system_mutex_release(async_system->mutex);
    return(result);
}

static void
async_task_wait__inner(Application_Links *app, Async_System *async_system, Async_Task task){
    release_global_frame_mutex(app);
    for (;async_task_is_running_or_pending__inner(async_system, task);){
        system_condition_variable_wait(async_system->join_cv, async_system->mutex);
    }
    acquire_global_frame_mutex(app);
}

static void
async_task_wait(Application_Links *app, Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    if (async_task_is_running_or_pending__inner(async_system, task)){
        async_task_wait__inner(app, async_system, task);
    }
    system_mutex_release(async_system->mutex);
}

static void
async_task_cancel(Application_Links *app, Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_pending_node(async_system, task);
    if (node != 0){
        ((&node->node)->next->prev=(&node->node)->prev,(&node->node)->prev->next=(&node->node)->next,(&node->node)->next=(&node->node)->prev=0);
        async_system->task_count -= 1;
        async_free_node(async_system, node);
    }
    else{
        node = async_get_running_node(async_system, task);
        if (node != 0){
            b32 *cancel_signal = &node->thread->cancel_signal;
            (*(cancel_signal)=(true));
            async_task_wait__inner(app, async_system, task);
        }
    }
    system_mutex_release(async_system->mutex);
}

static b32
async_check_canceled(Async_Context *actx){
    b32 *cancel_signal = &actx->thread->cancel_signal;
    b32 result = (*(cancel_signal));
    return(result);
}
# 92 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_string_match.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_string_match.cpp"
static void
string_match_list_push(Arena *arena, String_Match_List *list,
                       Buffer_ID buffer, i32 string_id, String_Match_Flag flags, Range_i64 range){
    String_Match *match = ((String_Match*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Match)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_string_match.cpp" ":" "15" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_string_match.cpp" ":" "15" ":") - 1)))));
    do{ if((match)){if((list->first)){(list->last)->next=(match);}else{(list->first)=(match);}(list->last)=(match);(list->last)->next=0;} }while(0);
    list->count += 1;
    match->buffer = buffer;
    match->string_id = string_id;
    match->flags = flags;
    match->range = range;
}

static void
string_match_list_push(Arena *arena, String_Match_List *list,
                       Buffer_ID buffer, i32 string_id, String_Match_Flag flags, i64 start, i64 length){
    string_match_list_push(arena, list, buffer, string_id, flags,
                           Ii64(start, start + length));
}

static String_Match_List
string_match_list_join(String_Match_List *a, String_Match_List *b){
    String_Match_List list = *a;
    block_zero((a), sizeof(*(a)));
    if (list.last != 0){
        list.last->next = b->first;
        if (b->last != 0){
            list.last = b->last;
        }
    }
    else{
        list.first = b->first;
        list.last = b->last;
    }
    list.count += b->count;
    block_zero((b), sizeof(*(b)));
    return(list);
}

static void
string_match_list_filter_flags(String_Match_List *list, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Match_List new_list = {};
    if ((must_have_flags & must_not_have_flags) == 0){
        for (String_Match *node = list->first, *next = 0;
             node != 0;
             node = next){
            next = node->next;
            if ((node->flags & must_have_flags) == must_have_flags && (node->flags & must_not_have_flags) == 0){
                do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
                new_list.count += 1;
            }
        }
    }
    *list = new_list;
}

static void
string_match_list_filter_remove_buffer(String_Match_List *list, Buffer_ID buffer){
    String_Match_List new_list = {};
    for (String_Match *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (node->buffer != buffer){
            do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
            new_list.count += 1;
        }
    }
    *list = new_list;
}

static void
string_match_list_filter_remove_buffer_predicate(Application_Links *app, String_Match_List *list, Buffer_Predicate *predicate){
    String_Match_List new_list = {};
    for (String_Match *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (!predicate(app, node->buffer)){
            do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
            new_list.count += 1;
        }
    }
    *list = new_list;
}

static String_Match_List
string_match_list_merge_nearest(String_Match_List *a, String_Match_List *b, Range_i64 range){
    String_Match_List list = {};
    String_Match *node_a = a->first;
    String_Match *node_b = b->first;
    for (String_Match *next_a = node_a, *next_b = node_b;
         node_a != 0 && node_b != 0;
         node_a = next_a, node_b = next_b){
        i64 dist_a = range_distance(node_a->range, range);
        i64 dist_b = range_distance(node_b->range, range);
        if (dist_a <= dist_b){
            next_a = next_a->next;
            do{ if((node_a)){if((list.first)){(list.last)->next=(node_a);}else{(list.first)=(node_a);}(list.last)=(node_a);(list.last)->next=0;} }while(0);
            list.count += 1;
        }
        else{
            next_b = next_b->next;
            do{ if((node_b)){if((list.first)){(list.last)->next=(node_b);}else{(list.first)=(node_b);}(list.last)=(node_b);(list.last)->next=0;} }while(0);
            list.count += 1;
        }
    }
    do{ if (!(node_a == 0 || node_b == 0)) { (*((i32*)0) = 0xA11E); } }while(0);

    String_Match *node = 0;
    if (node_a != 0){
        node = node_a;
    }
    else if (node_b != 0){
        node = node_b;
    }
    for (String_Match *next = 0;
         node != 0;
         node = next){
        next = node->next;
        do{ if((node)){if((list.first)){(list.last)->next=(node);}else{(list.first)=(node);}(list.last)=(node);(list.last)->next=0;} }while(0);
        list.count += 1;
    }
    block_zero((a), sizeof(*(a)));
    block_zero((b), sizeof(*(b)));
    return(list);
}

static String_Match_List
string_match_list_merge_front_to_back(String_Match_List *a, String_Match_List *b){
    return(string_match_list_merge_nearest(a, b, Ii64((i64)0)));
}
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_buffer_seek_constructors.cpp" 1






static Buffer_Seek
seek_pos(i64 pos){
    Buffer_Seek result;
    result.type = buffer_seek_pos;
    result.pos = pos;
    return(result);
}

static Buffer_Seek
seek_line_col(i64 line, i64 col){
    Buffer_Seek result;
    result.type = buffer_seek_line_col;
    result.line = line;
    result.col = col;
    return(result);
}
# 94 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" 1






static Range_i64
Ii64(Token *token){
    return(Ii64_size(token->pos, token->size));
}

static void
token_list_push(Arena *arena, Token_List *list, Token *token){
    Token_Block *block = list->last;
    if (block == 0 || block->count + 1 > block->max){
        block = ((Token_Block*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token_Block)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "16" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "16" ":") - 1)))));
        block->next = 0;
        block->prev = 0;
        u32 new_max = round_up_u32(1, ((4) << 10));
        block->tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(new_max), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "20" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "20" ":") - 1)))));
        block->count = 0;
        block->max = new_max;
        (((list->first)==0)?((block)->next=(block)->prev=0,(list->first)=(list->last)=(block)):((block)->prev=(list->last),(block)->next=0,(list->last)->next=(block),(list->last)=(block)));
        list->node_count += 1;
    }
    block_copy((&block->tokens[block->count]), (token), sizeof(*(&block->tokens[block->count])));
    block->count += 1;
    list->total_count += 1;
}

static void
token_fill_memory_from_list(Token *dst, Token_List *list, i64 count){
    Token *ptr = dst;
    for (Token_Block *node = list->first;
         node != 0 && count > 0;
         node = node->next){
        i64 write_count = (((node->count)<(count))?(node->count):(count));
        block_copy((ptr), (node->tokens), sizeof(*(ptr))*(write_count));
        ptr += write_count;
        count -= write_count;
    }
}

static void
token_fill_memory_from_list(Token *dst, Token_List *list){
    token_fill_memory_from_list(dst, list, list->total_count);
}

static Token_Array
token_array_from_list_always_copy(Arena *arena, Token_List *list){
    Token_Array array = {};
    if (list->node_count >= 1){
        array.tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(list->total_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "53" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "53" ":") - 1)))));
        token_fill_memory_from_list(array.tokens, list);
        array.count = list->total_count;
        array.max = array.count;
    }
    return(array);
}

static Token_Array
token_array_from_list(Arena *arena, Token_List *list){
    Token_Array array = {};
    if (list->node_count > 1){
        array.tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(list->total_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "65" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_token.cpp" ":" "65" ":") - 1)))));
        token_fill_memory_from_list(array.tokens, list);
        array.count = list->total_count;
        array.max = array.count;
    }
    else if (list->node_count == 1){
        array.tokens = list->first->tokens;
        array.count = list->first->count;
        array.max = list->first->max;
    }
    return(array);
}

static i64
token_index_from_pos(Token *tokens, i64 count, i64 pos){
    i64 result = 0;
    if (count > 0){
        if (pos >= tokens[count - 1].pos){
            result = count - 1;
        }
        else if (pos <= tokens[0].pos){
            result = 0;
        }
        else{
            i64 first = 0;
            i64 one_past_last = count;
            for (;;){
                i64 index = (first + one_past_last) >> 1;
                i64 index_pos = tokens[index].pos;
                if (index_pos > pos){
                    one_past_last = index;
                }
                else if (index_pos + tokens[index].size <= pos){
                    first = index + 1;
                }
                else{
                    result = index;
                    break;
                }
            }
        }
    }
    return(result);
}

static i64
token_index_from_pos(Token_Array *tokens, u64 pos){
    return(token_index_from_pos(tokens->tokens, tokens->count, pos));
}

static Token*
token_from_pos(Token *tokens, i64 count, i64 pos){
    i64 index = token_index_from_pos(tokens, count, pos);
    return(tokens + index);
}

static Token*
token_from_pos(Token_Array *tokens, u64 pos){
    i64 index = token_index_from_pos(tokens, pos);
    return(tokens->tokens + index);
}



static Token_Iterator_Array
token_iterator_index(u64 user_id, Token *tokens, i64 count, i64 token_index){
    Token_Iterator_Array it = {};
    if (tokens != 0){
        it.user_id = user_id;
        it.ptr = tokens + token_index;
        it.tokens = tokens;
        it.count = count;
    }
    return(it);
}

static Token_Iterator_Array
token_iterator_index(u64 user_id, Token_Array *tokens, i64 token_index){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, token_index));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token *tokens, i64 count, Token *token){
    return(token_iterator_index(user_id, tokens, count, (i64)(token - tokens)));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token_Array *tokens, Token *token){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, (i64)(token - tokens->tokens)));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token *tokens, i64 count){
    return(token_iterator_index(user_id, tokens, count, 0));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token_Array *tokens){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, 0));
}

static Token_Iterator_Array
token_iterator_pos(u64 user_id, Token *tokens, i64 count, i64 pos){
    i64 index = token_index_from_pos(tokens, count, pos);
    return(token_iterator_index(user_id, tokens, count, index));
}

static Token_Iterator_Array
token_iterator_pos(u64 user_id, Token_Array *tokens, i64 pos){
    i64 index = token_index_from_pos(tokens->tokens, tokens->count, pos);
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, index));
}

static Token*
token_it_read(Token_Iterator_Array *it){
    Token *result = 0;
    if (it->tokens != 0){
        result = it->ptr;
    }
    return(result);
}

static i64
token_it_index(Token_Iterator_Array *it){
    return((i64)(it->ptr - it->tokens));
}

static b32
token_it_inc_all(Token_Iterator_Array *it){
    b32 result = false;
    if (it->tokens != 0){
        if (it->ptr < it->tokens + it->count - 1){
            it->ptr += 1;
            result = true;
        }
    }
    return(result);
}

static b32
token_it_dec_all(Token_Iterator_Array *it){
    b32 result = false;
    if (it->tokens != 0){
        if (it->ptr > it->tokens){
            it->ptr -= 1;
            result = true;
        }
    }
    return(result);
}

static b32
token_it_inc_non_whitespace(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec_non_whitespace(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_inc(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static Token_Iterator_List
token_iterator_index(u64 user_id, Token_List *list, i64 index){
    Token_Iterator_List it = {};
    if (list->first != 0){
        index = (((0)>(index))?(0):(((list->total_count - 1)<(index))?(list->total_count - 1):(index)));
        i64 base_index = 0;
        Token_Block *block = 0;
        for (Token_Block *node = list->first;
             node != 0;
             node = node->next){
            if (index < base_index + node->count){
                block = node;
                break;
            }
            base_index += node->count;
        }
        do{ if (!(block != 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        it.user_id = user_id;
        it.index = index;
        it.ptr = block->tokens + (index - base_index);
        it.block = block;
        it.first = list->first;
        it.last = list->last;
        it.node_count = list->node_count;
        it.total_count = list->total_count;
    }
    return(it);
}

static Token_Iterator_List
token_iterator(u64 user_id, Token_List *list){
    return(token_iterator_index(user_id, list, 0));
}

static Token_Iterator_List
token_iterator_pos(u64 user_id, Token_List *list, i64 pos){
    Token_Iterator_List it = {};
    if (list->first != 0){
        Token_Block *block = list->last;
        Token *token = &block->tokens[block->count - 1];
        i64 size = token->pos + token->size;
        pos = (((0)>(pos))?(0):(((size)<(pos))?(size):(pos)));
        i64 base_index = 0;
        block = 0;
        for (Token_Block *node = list->first;
             node != 0;
             node = node->next){
            Token *last_token = &node->tokens[node->count - 1];
            i64 one_past_last = last_token->pos + last_token->size;
            if (pos < one_past_last ||
                (node->next == 0 && pos == one_past_last)){
                block = node;
                break;
            }
            base_index += node->count;
        }
        do{ if (!(block != 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        i64 sub_index = token_index_from_pos(block->tokens, block->count, pos);
        it.user_id = user_id;
        it.index = base_index + sub_index;
        it.ptr = block->tokens + sub_index;
        it.block = block;
        it.first = list->first;
        it.last = list->last;
        it.node_count = list->node_count;
        it.total_count = list->total_count;
    }
    return(it);
}

static Token*
token_it_read(Token_Iterator_List *it){
    Token *result = 0;
    if (it->block != 0){
        result = it->ptr;
    }
    return(result);
}

static i64
token_it_index(Token_Iterator_List *it){
    return(it->index);
}

static b32
token_it_inc_all(Token_Iterator_List *it){
    b32 result = false;
    if (it->block != 0){
        i64 sub_index = (i64)(it->ptr - it->block->tokens);
        if (sub_index + 1 < it->block->count){
            it->index += 1;
            it->ptr += 1;
            result = true;
        }
        else{
            if (it->block->next != 0){
                it->block = it->block->next;
                it->index += 1;
                it->ptr = it->block->tokens;
                result = true;
            }
        }
    }
    return(result);
}

static b32
token_it_dec_all(Token_Iterator_List *it){
    b32 result = false;
    if (it->block != 0){
        i64 sub_index = (i64)(it->ptr - it->block->tokens);
        if (sub_index > 0){
            it->index -= 1;
            it->ptr -= 1;
            result = true;
        }
        else{
            if (it->block->prev != 0){
                it->block = it->block->prev;
                it->index -= 1;
                it->ptr = it->block->tokens + it->block->count - 1;
                result = true;
            }
        }
    }
    return(result);
}

static b32
token_it_inc_non_whitespace(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec_non_whitespace(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_inc(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static Token_Iterator
token_iterator(Token_Iterator_Array it){
    Token_Iterator result = {};
    result.kind = TokenIterator_Array;
    result.array = it;
    return(result);
}

static Token_Iterator
token_iterator(Token_Iterator_List it){
    Token_Iterator result = {};
    result.kind = TokenIterator_List;
    result.list = it;
    return(result);
}

static Token*
token_it_read(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_read(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_read(&it->list));
        }break;
    }
    return(0);
}

static i64
token_it_index(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_index(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_index(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc_all(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc_all(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc_all(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec_all(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec_all(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec_all(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc_non_whitespace(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc_non_whitespace(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc_non_whitespace(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec_non_whitespace(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec_non_whitespace(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec_non_whitespace(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec(&it->list));
        }break;
    }
    return(0);
}



static void
token_drop_eof(Token_List *list){
    if (list->last != 0){
        Token_Block *block = list->last;
        if (block->tokens[block->count - 1].kind == TokenBaseKind_EOF){
            list->total_count -= 1;
            block->count -= 1;
            if (block->count == 0){
                (((list->last)==(block))?((((list->first)==(list->last))?((list->first)=(list->last)=0):((list->last)->prev->next=0,(list->last)=(list->last)->prev))) :((list->first)==(block))?((((list->last)==(list->first))?((list->last)=(list->first)=0):((list->first)->next->prev=0,(list->first)=(list->first)->next))) : ((block)->next->prev=(block)->prev,(block)->prev->next=(block)->next,(block)->next=(block)->prev=0));
                list->node_count -= 1;
            }
        }
    }
}



static i64
token_relex_first(Token_Array *tokens, i64 edit_range_first, i64 backup_repeats){
    Token_Iterator_Array it = token_iterator_pos(0, tokens, edit_range_first);
    b32 good_status = true;
    for (i64 i = 0; i < backup_repeats && good_status; i += 1){
        good_status = token_it_dec(&it);
    }
    if (good_status){
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                break;
            }
            if (!token_it_dec(&it)){
                break;
            }
        }
    }
    return(token_it_index(&it));
}

static i64
token_relex_resync(Token_Array *tokens, i64 edit_range_first, i64 look_ahead_repeats){
    Token_Iterator_Array it = token_iterator_pos(0, tokens, edit_range_first);
    b32 good_status = true;
    for (i64 i = 0; (i < look_ahead_repeats) && good_status; i += 1){
        good_status = token_it_inc(&it);
    }
    if (good_status){
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                break;
            }
            if (!token_it_inc(&it)){
                break;
            }
        }
    }
    return(token_it_index(&it));
}

static Token_Relex
token_relex(Token_List relex_list, i64 new_pos_to_old_pos_shift, Token *tokens, i64 relex_first, i64 relex_last){
    Token_Relex relex = {};
    if (relex_list.total_count > 0){
        Token_Array relexed_tokens = {tokens + relex_first, relex_last - relex_first + 1};
        Token_Iterator_List it = token_iterator_index(0, &relex_list, relex_list.total_count - 1);
        for (;;){
            Token *token = token_it_read(&it);
            i64 new_pos_rebased = token->pos + new_pos_to_old_pos_shift;
            i64 old_token_index = token_index_from_pos(&relexed_tokens, new_pos_rebased);
            Token *old_token = relexed_tokens.tokens + old_token_index;
            if (new_pos_rebased == old_token->pos &&
                token->size == old_token->size &&
                token->kind == old_token->kind &&
                token->sub_kind == old_token->sub_kind &&
                token->flags == old_token->flags &&
                token->sub_flags == old_token->sub_flags){
                relex.successful_resync = true;
                relex.first_resync_index = relex_first + old_token_index;
            }
            else{
                break;
            }
            if (!token_it_dec_all(&it)){
                break;
            }
        }
    }
    return(relex);
}
# 95 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 1
# 17 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
Command_Binding::Command_Binding(){
    block_zero((this), sizeof(*(this)));
}
Command_Binding::Command_Binding(Custom_Command_Function *c){
    this->custom = c;
}
Command_Binding::Command_Binding(char *n){
    this->name = n;
}
Command_Binding::operator Custom_Command_Function*(){
    return(this->custom);
}
Command_Binding::operator char*(){
    return(this->name);
}

static u64
mapping__key(Input_Event_Kind kind, u32 sub_code){
    return((((u64)kind) << 32) | sub_code);
}

static Command_Map*
mapping__alloc_map(Mapping *mapping){
    Command_Map *result = mapping->free_maps;
    if (result != 0){
        ((mapping->free_maps)=(mapping->free_maps)=(mapping->free_maps)->next);
    }
    else{
        result = ((Command_Map*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Map)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "45" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "45" ":") - 1)))));
    }
    (((mapping->first_map)==0)?((result)->next=(result)->prev=0,(mapping->first_map)=(mapping->last_map)=(result)):((result)->prev=(mapping->last_map),(result)->next=0,(mapping->last_map)->next=(result),(mapping->last_map)=(result)));
    return(result);
}

static void
mapping__free_map(Mapping *mapping, Command_Map *map){
    (((mapping->last_map)==(map))?((((mapping->first_map)==(mapping->last_map))?((mapping->first_map)=(mapping->last_map)=0):((mapping->last_map)->prev->next=0,(mapping->last_map)=(mapping->last_map)->prev))) :((mapping->first_map)==(map))?((((mapping->last_map)==(mapping->first_map))?((mapping->last_map)=(mapping->first_map)=0):((mapping->first_map)->next->prev=0,(mapping->first_map)=(mapping->first_map)->next))) : ((map)->next->prev=(map)->prev,(map)->prev->next=(map)->next,(map)->next=(map)->prev=0));
    ((map)->next=(mapping->free_maps),(mapping->free_maps)=(map));
}

static Command_Modified_Binding*
mapping__alloc_modified_binding(Mapping *mapping){
    Command_Modified_Binding *result = mapping->free_bindings;
    if (result != 0){
        ((mapping->free_bindings)=(mapping->free_bindings)=(mapping->free_bindings)->next);
    }
    else{
        result = ((Command_Modified_Binding*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Modified_Binding)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "64" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "64" ":") - 1)))));
    }
    return(result);
}

static void
mapping__free_modified_binding(Mapping *mapping, Command_Modified_Binding *binding){
    ((binding)->next=(mapping->free_bindings),(mapping->free_bindings)=(binding));
}

static Command_Binding_List*
mapping__alloc_binding_list(Mapping *mapping){
    Command_Binding_List *result = mapping->free_lists;
    if (result != 0){
        ((mapping->free_lists)=(mapping->free_lists)=(mapping->free_lists)->next);
    }
    else{
        result = ((Command_Binding_List*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Binding_List)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "81" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "81" ":") - 1)))));
    }
    return(result);
}

static void
mapping__free_binding_list(Mapping *mapping, Command_Binding_List *binding_list){
    ((binding_list)->next=(mapping->free_lists),(mapping->free_lists)=(binding_list));
}

static Command_Binding_List*
map__get_list(Command_Map *map, u64 key){
    Command_Binding_List *result = 0;
    Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, key);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&map->event_code_to_binding_list, lookup, &val);
        result = (Command_Binding_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Command_Binding_List*
map__get_or_make_list(Mapping *mapping, Command_Map *map, u64 key){
    Command_Binding_List *result = map__get_list(map, key);
    if (result == 0){
        result = mapping__alloc_binding_list(mapping);
        block_zero((result), sizeof(*(result)));
        do{ if((result)){if((map->list_first)){(map->list_last)->next=(result);}else{(map->list_first)=(result);}(map->list_last)=(result);(map->list_last)->next=0;} }while(0);
        table_insert(&map->event_code_to_binding_list, key, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}



static void
mapping_init(Thread_Context *tctx, Mapping *mapping){
    block_zero((mapping), sizeof(*(mapping)));
    mapping->node_arena = make_arena_system();
    heap_init(&mapping->heap, &mapping->node_arena);
    mapping->heap_wrapper = base_allocator_on_heap(&mapping->heap);
    mapping->id_to_map = make_table_u64_u64__inner((tctx->allocator),(10),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "123" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "123" ":") - 1)));
    mapping->id_counter = 1;
}

static void
mapping_release(Thread_Context *tctx, Mapping *mapping){
    linalloc_clear(&mapping->node_arena);
    table_free(&mapping->id_to_map);
}

static void
map__init(Mapping *mapping, Command_Map *map, Command_Map_ID id){
    block_zero((map), sizeof(*(map)));
    map->id = id;
    map->node_arena = make_arena(&mapping->heap_wrapper, ((2) << 10));
    map->event_code_to_binding_list = make_table_u64_u64__inner((&mapping->heap_wrapper),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "138" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "138" ":") - 1)));
    map->cmd_to_binding_trigger = make_table_u64_u64__inner((&mapping->heap_wrapper),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "139" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "139" ":") - 1)));
}

static Command_Map*
mapping_get_map(Mapping *mapping, Command_Map_ID id){
    Command_Map *result = 0;
    Table_Lookup lookup = table_lookup(&mapping->id_to_map, id);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&mapping->id_to_map, lookup, &val);
        result = (Command_Map*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Command_Map_ID
mapping_validate_id(Mapping *mapping, Command_Map_ID id){
    Table_Lookup lookup = table_lookup(&mapping->id_to_map, id);
    if (!lookup.found_match){
        id = 0;
    }
    return(id);
}

static Command_Map*
mapping_get_or_make_map(Mapping *mapping, Command_Map_ID id){
    Command_Map *result = mapping_get_map(mapping, id);
    if (result == 0){
        result = mapping__alloc_map(mapping);
        map__init(mapping, result, id);
        table_insert(&mapping->id_to_map, id, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static void
mapping_release_map(Mapping *mapping, Command_Map *map){
    table_erase(&mapping->id_to_map, map->id);
    if (map->binding_last != 0){
        map->binding_last->next = mapping->free_bindings;
        mapping->free_bindings = map->binding_first;
    }
    if (map->list_last != 0){
        map->list_last->next = mapping->free_lists;
        mapping->free_lists = map->list_first;
    }
    table_free(&map->event_code_to_binding_list);
    linalloc_clear(&map->node_arena);
}



static b32
map_strict_match(Input_Modifier_Set *binding_mod_set, Input_Modifier_Set *event_mod_set, Key_Code skip_self_mod){
    b32 result = true;
    i32 binding_mod_count = binding_mod_set->count;
    Key_Code *binding_mods = binding_mod_set->mods;
    for (i32 i = 0; i < binding_mod_count; i += 1){
        if (!has_modifier(event_mod_set, binding_mods[i])){
            result = false;
            break;
        }
    }
    i32 mod_count = event_mod_set->count;
    Key_Code *mods = event_mod_set->mods;
    for (i32 i = 0; i < mod_count; i += 1){
        if (mods[i] != skip_self_mod && !has_modifier(binding_mod_set, mods[i])){
            result = false;
            break;
        }
    }
    return(result);
}

static b32
map_loose_match(Input_Modifier_Set *binding_mod_set, Input_Modifier_Set *event_mod_set){
    b32 result = true;
    i32 binding_mod_count = binding_mod_set->count;
    Key_Code *binding_mods = binding_mod_set->mods;
    for (i32 i = 0; i < binding_mod_count; i += 1){
        if (!has_modifier(event_mod_set, binding_mods[i])){
            result = false;
            break;
        }
    }
    return(result);
}

static Map_Event_Breakdown
map_get_event_breakdown(Input_Event *event){
    Map_Event_Breakdown result = {};

    switch (event->kind){
        case InputEventKind_KeyStroke:
        {
            result.key = mapping__key(InputEventKind_KeyStroke, event->key.code);
            result.mod_set = &event->key.modifiers;
            result.skip_self_mod = event->key.code;
        }break;

        case InputEventKind_MouseButton:
        {
            result.key = mapping__key(InputEventKind_MouseButton, event->mouse.code);
            result.mod_set = &event->mouse.modifiers;
        }break;

        case InputEventKind_MouseWheel:
        {
            result.key = mapping__key(InputEventKind_MouseWheel, 0);
            result.mod_set = &event->mouse_wheel.modifiers;
        }break;

        case InputEventKind_MouseMove:
        {
            result.key = mapping__key(InputEventKind_MouseMove, 0);
            result.mod_set = &event->mouse_move.modifiers;
        }break;

        case InputEventKind_Core:
        {
            result.key = mapping__key(InputEventKind_Core, event->core.code);
        }break;
    }

    return(result);
}

static Command_Binding
map_get_binding_non_recursive(Command_Map *map, Input_Event *event, Binding_Match_Rule rule){
    Command_Binding result = {};

    if (event->kind == InputEventKind_CustomFunction){
        result.custom = event->custom_func;
    }
    else if (map != 0){
        if (event->kind == InputEventKind_TextInsert){
            result = map->text_input_command;
        }
        else{
            Map_Event_Breakdown breakdown = map_get_event_breakdown(event);
            Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, breakdown.key);
            if (lookup.found_match){
                u64 val = 0;
                table_read(&map->event_code_to_binding_list, lookup, &val);
                Command_Binding_List *list = (Command_Binding_List*)(void*)(((u8*)0) + val);
                if (breakdown.mod_set != 0){
                    switch (rule){
                        case BindingMatchRule_Strict:
                        {
                            for (SNode *node = list->first;
                                 node != 0;
                                 node = node->next){
                                Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(node) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                                Input_Modifier_Set *binding_mod_set = &mod_binding->mods;
                                if (map_strict_match(binding_mod_set, breakdown.mod_set, breakdown.skip_self_mod)){
                                    result = mod_binding->binding;
                                    goto done;
                                }
                            }
                        }break;

                        case BindingMatchRule_Loose:
                        {
                            for (SNode *node = list->first;
                                 node != 0;
                                 node = node->next){
                                Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(node) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                                Input_Modifier_Set *binding_mod_set = &mod_binding->mods;
                                if (map_loose_match(binding_mod_set, breakdown.mod_set)){
                                    result = mod_binding->binding;
                                    goto done;
                                }
                            }
                        }break;
                    }
                    done:;
                }
                else{
                    Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(list->first) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                    result = mod_binding->binding;
                }
            }
        }
    }

    return(result);
}

static Command_Binding
map_get_binding_non_recursive(Command_Map *map, Input_Event *event){
    Command_Binding result = map_get_binding_non_recursive(map, event, BindingMatchRule_Strict);
    if (result.custom == 0){
        result = map_get_binding_non_recursive(map, event, BindingMatchRule_Loose);
    }
    return(result);
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map *map, Input_Event *event, Binding_Match_Rule rule){
    Command_Binding result = {};
    for (i32 safety_counter = 0;
         map != 0 && safety_counter < 40;
         safety_counter += 1){
        result = map_get_binding_non_recursive(map, event, rule);
        if (result.custom != 0){
            break;
        }
        map = mapping_get_map(mapping, map->parent);
    }
    return(result);
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map *map, Input_Event *event){
    Command_Binding result = map_get_binding_recursive(mapping, map, event, BindingMatchRule_Strict);
    if (result.custom == 0){
        result = map_get_binding_recursive(mapping, map, event, BindingMatchRule_Loose);
    }
    return(result);
}

static void
map_set_parent(Command_Map *map, Command_Map *parent){
    if (map != 0 && parent != 0){
        map->parent = parent->id;
    }
}

static void
map_null_parent(Command_Map *map){
    map->parent = 0;
}

static void
map__command_add_trigger(Command_Map *map, Command_Binding binding, Command_Trigger *trigger){
    if (map != 0){
        u64 key = (u64)(((u8*)(((binding).custom)) - (u8*)(0)));
        Table_Lookup lookup = table_lookup(&map->cmd_to_binding_trigger, key);
        Command_Trigger_List *list = 0;
        if (!lookup.found_match){
            list = ((Command_Trigger_List*)linalloc_wrap_zero(linalloc_push((&map->node_arena), sizeof(Command_Trigger_List)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "379" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "379" ":") - 1)))));
            table_insert(&map->cmd_to_binding_trigger, key, (u64)(((u8*)(list) - (u8*)(0))));
        }
        else{
            u64 val = 0;
            table_read(&map->cmd_to_binding_trigger, lookup, &val);
            list = (Command_Trigger_List*)(void*)(((u8*)0) + val);
        }
        Command_Trigger *trigger_ptr = ((Command_Trigger*)linalloc_wrap_unintialized(linalloc_push((&map->node_arena), sizeof(Command_Trigger)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "387" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "387" ":") - 1)))));
        block_copy((trigger_ptr), (trigger), sizeof(*(trigger_ptr)));
        do{ if((trigger_ptr)){if((list->first)){(list->last)->next=(trigger_ptr);}else{(list->first)=(trigger_ptr);}(list->last)=(trigger_ptr);(list->last)->next=0;} }while(0);
    }
}

static Input_Event
map_trigger_as_event(Command_Trigger *trigger){
    Input_Event result = {};
    result.kind = trigger->kind;
    switch (result.kind){
        case InputEventKind_TextInsert:
        {}break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            result.key.code = trigger->sub_code;
            result.key.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseButton:
        case InputEventKind_MouseButtonRelease:
        {
            result.mouse.code = trigger->sub_code;
            result.mouse.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseWheel:
        {
            result.mouse_wheel.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseMove:
        {
            result.mouse_move.modifiers = trigger->mods;
        }break;

        case InputEventKind_Core:
        {
            result.core.code = trigger->sub_code;
        }break;
    }
    return(result);
}

static Command_Trigger_List
map_get_triggers_non_recursive(Mapping *mapping, Command_Map *map, Command_Binding binding){
    Command_Trigger_List *result_ptr = 0;
    if (map != 0){
        u64 key = (u64)(((u8*)(((binding).custom)) - (u8*)(0)));
        Table_Lookup lookup = table_lookup(&map->cmd_to_binding_trigger, key);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&map->cmd_to_binding_trigger, lookup, &val);
            result_ptr = (Command_Trigger_List*)(void*)(((u8*)0) + val);

            Command_Trigger_List list = {};
            for (Command_Trigger *node = result_ptr->first, *next = 0;
                 node != 0;
                 node = next){
                next = node->next;
                Input_Event event = map_trigger_as_event(node);
                Command_Binding this_binding = {};
                if (mapping != 0){
                    this_binding = map_get_binding_recursive(mapping, map, &event);
                }
                else{
                    this_binding = map_get_binding_non_recursive(map, &event);
                }
                if (((this_binding).custom) == ((binding).custom)){
                    do{ if((node)){if((list.first)){(list.last)->next=(node);}else{(list.first)=(node);}(list.last)=(node);(list.last)->next=0;} }while(0);
                }
            }
            *result_ptr = list;
        }
    }
    Command_Trigger_List result = {};
    if (result_ptr != 0){
        result = *result_ptr;
    }
    return(result);
}

static Command_Trigger_List
map_get_triggers_non_recursive(Command_Map *map, Command_Binding binding){
    return(map_get_triggers_non_recursive(0, map, binding));
}

static Command_Trigger_List
map_get_triggers_recursive(Arena *arena, Mapping *mapping, Command_Map *map, Command_Binding binding){
    Command_Trigger_List result = {};
    if (mapping != 0){
        for (i32 safety_counter = 0;
             map != 0 && safety_counter < 40;
             safety_counter += 1){
            Command_Trigger_List list = map_get_triggers_non_recursive(mapping, map, binding);

            for (Command_Trigger *node = list.first, *next = 0;
                 node != 0;
                 node = next){
                next = node->next;
                Command_Trigger *nnode = ((Command_Trigger*)linalloc_wrap_write(linalloc_push((arena), sizeof(Command_Trigger)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "489" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" ":" "489" ":") - 1))), sizeof(Command_Trigger)*(1), (node)));
                do{ if((nnode)){if((result.first)){(result.last)->next=(nnode);}else{(result.first)=(nnode);}(result.last)=(nnode);(result.last)->next=0;} }while(0);
            }

            map = mapping_get_map(mapping, map->parent);
        }
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_key(Command_Map *map, Key_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_KeyStroke, code);
        result = map__get_list(map, key);
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_mouse_button(Command_Map *map, Mouse_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_MouseButton, code);
        result = map__get_list(map, key);
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_core(Command_Map *map, Core_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_Core, code);
        result = map__get_list(map, key);
    }
    return(result);
}



static void
map_set_binding(Mapping *mapping, Command_Map *map, Command_Binding binding, u32 code1, u32 code2, Input_Modifier_Set *mods){
    if (map != 0){
        u64 key = mapping__key(code1, code2);
        Command_Binding_List *list = map__get_or_make_list(mapping, map, key);
        Command_Modified_Binding *mod_binding = mapping__alloc_modified_binding(mapping);
        ((mod_binding)->next=(map->binding_first),(map->binding_first)=(mod_binding));
        if (map->binding_last == 0){
            map->binding_last = map->binding_first;
        }
        ((&mod_binding->order_node)->next=(list->first),(list->first)=(&mod_binding->order_node));
        if (list->last == 0){
            list->last= list->first;
        }
        list->count += 1;
        mod_binding->mods = copy_modifier_set(&map->node_arena, mods);
        mod_binding->binding = binding;

        Command_Trigger trigger = {};
        trigger.kind = code1;
        trigger.sub_code = code2;
        trigger.mods = mod_binding->mods;
        map__command_add_trigger(map, binding, &trigger);
    }
}

static void
map_set_binding_key(Mapping *mapping, Command_Map *map, Command_Binding binding, Key_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_KeyStroke, code, modifiers);
}

static void
map_set_binding_mouse(Mapping *mapping, Command_Map *map, Command_Binding binding, Mouse_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_MouseButton, code, modifiers);
}

static void
map_set_binding_core(Mapping *mapping, Command_Map *map, Command_Binding binding, Core_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_Core, code, modifiers);
}

static void
map_set_binding_text_input(Command_Map *map, Command_Binding binding){
    if (map != 0){
        map->text_input_command = binding;
        Command_Trigger trigger = {};
        trigger.kind = InputEventKind_TextInsert;
        map__command_add_trigger(map, binding, &trigger);
    }
}



static Command_Binding_List*
map_get_binding_list_on_key(Mapping *mapping, Command_Map_ID map_id, Key_Code code){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_list_on_key(map, code));
}

static Command_Binding
map_get_binding_non_recursive(Mapping *mapping, Command_Map_ID map_id, Input_Event *event){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_non_recursive(map, event));
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map_ID map_id, Input_Event *event){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_recursive(mapping, map, event));
}

static Command_Trigger_List
map_get_triggers_non_recursive(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_triggers_non_recursive(map, binding));
}

static Command_Trigger_List
map_get_triggers_recursive(Arena *arena, Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_triggers_recursive(arena, mapping, map, binding));
}

static void
map_set_parent(Mapping *mapping, Command_Map_ID map_id, Command_Map_ID parent_id){
    Command_Map *map = mapping_get_map(mapping, map_id);
    Command_Map *parent = mapping_get_map(mapping, parent_id);
    map_set_parent(map, parent);
}

static void
map_set_parent(Mapping *mapping, Command_Map *map, Command_Map_ID parent_id){
    Command_Map *parent = mapping_get_map(mapping, parent_id);
    map_set_parent(map, parent);
}

static void
map_null_parent(Mapping *mapping, Command_Map_ID map_id){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_null_parent(map);
}

static void
map_set_binding(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                u32 code1, u32 code2, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding(mapping, map, binding, code1, code2, modifiers);
}

static void
map_set_binding_key(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                    Key_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_key(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_mouse(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                      Mouse_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_mouse(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_core(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                     Core_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_core(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_text_input(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_text_input(map, binding);
}



static void
command_trigger_stringize_mods(Arena *arena, List_String_Const_u8 *list, Input_Modifier_Set *modifiers){
    if (modifiers->count > 0){
        string_list_push(arena, list, SCu8((u8*)(" holding:"), (u64)(sizeof(" holding:") - 1)));
        i32 count = modifiers->count;
        Key_Code *mods = modifiers->mods;
        for (i32 i = 0; i < count; i += 1){
            string_list_pushf(arena, list, " %s", ((key_code_name)[(mods[i])%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
        }
    }
}

static void
command_trigger_stringize(Arena *arena, List_String_Const_u8 *list, Command_Trigger *trigger){
    string_list_push(arena, list, SCu8((u8*)("<"), (u64)(sizeof("<") - 1)));
    switch (trigger->kind){
        case InputEventKind_TextInsert:
        {
            string_list_push(arena, list, SCu8((u8*)("TextInsert"), (u64)(sizeof("TextInsert") - 1)));
        }break;

        case InputEventKind_KeyStroke:
        {
            String_Const_u8 key_name = SCu8(((key_code_name)[(trigger->sub_code)%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
            string_list_push(arena, list, key_name);
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_KeyRelease:
        {
            string_list_pushf(arena, list, "Release %s", ((key_code_name)[(trigger->sub_code)%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseButton:
        {
            string_list_pushf(arena, list, "Mouse %s", ((mouse_code_name)[(trigger->sub_code)%((sizeof(mouse_code_name))/(sizeof(*mouse_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseButtonRelease:
        {
            string_list_pushf(arena, list, "Release Mouse %s", ((mouse_code_name)[(trigger->sub_code)%((sizeof(mouse_code_name))/(sizeof(*mouse_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseWheel:
        {
            string_list_push(arena, list, SCu8((u8*)("MouseWheel"), (u64)(sizeof("MouseWheel") - 1)));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseMove:
        {
            string_list_push(arena, list, SCu8((u8*)("MouseMove"), (u64)(sizeof("MouseMove") - 1)));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_Core:
        {
            string_list_pushf(arena, list, "Core %s", ((core_code_name)[(trigger->sub_code)%((sizeof(core_code_name))/(sizeof(*core_code_name)))]));
        }break;

        default:
        {
            string_list_push(arena, list, SCu8((u8*)("ERROR unexpected trigger kind"), (u64)(sizeof("ERROR unexpected trigger kind") - 1)));
        }break;
    }
    string_list_push(arena, list, SCu8((u8*)(">"), (u64)(sizeof(">") - 1)));
}



static void
map_set_binding_lv(Mapping *mapping, Command_Map *map,
                   Command_Binding binding, u32 code1, u32 code2, va_list args){
    Input_Modifier_Set mods = {};
    Key_Code mods_array[Input_MaxModifierCount];
    mods.mods = mods_array;
    for (;mods.count < ((sizeof(mods_array))/(sizeof(*mods_array)));){
        i32 v = 
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
               __builtin_va_arg(
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
               args
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
               ,
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
               i32
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
               )
# 749 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
                                ;
        if (v <= 0){
            break;
        }
        mods.mods[mods.count] = v;
        mods.count += 1;
    }
    return(map_set_binding(mapping, map, binding, code1, code2, &mods));
}
# 770 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
static void
map_set_binding_l(Mapping *mapping, Command_Map *map, Custom_Command_Function *custom, u32 code1, u32 code2, ...){
    va_list args;
    
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
   __builtin_va_start(
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
   args
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
   ,
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
   code2
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
   )
# 773 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
                        ;
    Command_Binding binding = {};
    binding.custom = custom;
    map_set_binding_lv(mapping, map, binding, code1, code2, args);
    
# 777 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
   __builtin_va_end(
# 777 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
   args
# 777 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp" 3 4
   )
# 777 "/home/tabletel/dev/4cc/code/custom/4coder_command_map.cpp"
               ;
}
# 96 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/generated/lexer_cpp.cpp" 1



static u64
lexeme_hash(u64 seed, u8 *ptr, u64 size){
    u64 result = 0;
    for (u64 i = 0; i < size; i += 1, ptr += 1){
        result ^= ((*ptr) ^ result*59) + seed;
    }
    return(result);
}

static Lexeme_Table_Lookup
lexeme_table_lookup(u64 *hash_array, String_Const_u8 *key_array,
                    Lexeme_Table_Value *value_array, i32 slot_count, u64 seed,
                    u8 *ptr, u64 size){
    Lexeme_Table_Lookup result = {};
    u64 hash = lexeme_hash(seed, ptr, size);
    u64 comparison_hash = hash | 1;
    i32 first_index = (hash % slot_count);
    i32 index = first_index;
    for (;;){
        if (hash_array[index] == comparison_hash){
            if (string_match(SCu8(ptr, size), key_array[index])){
                result.found_match = true;
                result.base_kind = value_array[index].base_kind;
                result.sub_kind = value_array[index].sub_kind;
                break;
            }
        }
        else if (hash_array[index] == 0){
            break;
        }
        index += 1;
        if (index == slot_count){
            index = 0;
        }
        if (index == first_index){
            break;
        }
    }
    return(result);
}


u64 cpp_main_keys_hash_array[121] = {
0x37dbd51d70e155c9,0x0000000000000000,0x57decae2f55c3d49,0x37dbd51bbc5e1c73,
0x0000000000000000,0xf330e0d7833181c9,0x57def696bd543e89,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x37dbd572458dd737,0x138f5c6fa31d091b,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0x524d0480d6535a77,0x0000000000000000,0xf330e0d78336aa6f,0x0000000000000000,
0x0000000000000000,0x37c06ec52ad58377,0x37dbd57244d2601b,0x37dbd5680898d49d,
0x57df069845e1ac21,0x6ca672f98630d97d,0x0000000000000000,0xdeb718ddab4d213f,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0x57de7ec15b24f089,0x37dbd572429ce3f3,0x0000000000000000,
0xdeb718ddaae0e62b,0xdeb718dd71646925,0x86f257b8cba535e9,0x37dbd570ade720bd,
0x0000000000000000,0x0000000000000000,0x37dbd573f7a523bd,0x0000000000000000,
0x37dbd56a0f8e5afb,0x433fe5fed57c0a0b,0x57cbed1774cac347,0x0000000000000000,
0xdeb718ddaa06828b,0x0000000000000000,0x524d0480d70b34c3,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x37dbd51df8ce3809,0x0000000000000000,
0x57cc4189dc0b94f5,0x57de6c49d6b537e5,0x433f94c2d79acde3,0xf330e0d78336bd07,
0x0000000000000000,0x6ca672f98630d837,0xdeb718dda98b0aa9,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0xdeb718dd4259ec83,
0x524d0480d6bc8d33,0x524d0480d71d7e05,0x37dbd51c57596c9d,0x0000000000000000,
0x524d0480d65ab2e9,0xf31975eccb54cff3,0x524d0480d653e711,0x57def55e5afa993b,
0x37dbd5735269263b,0x0000000000000000,0xdeb718ddaae20e37,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0x57cc1cec96ac5009,0x0000000000000000,0x433f96ea6d183409,0x524d0480d67ed553,
0x0000000000000000,0x0000000000000000,0xdeb718dd73e39989,0x37dbd51c57485827,
0x0000000000000000,0xf330e0d78336d3d9,0x0000000000000000,0x82abfe6347c01d5b,
0x433fe5fed57c0ab5,0xf330e0d783374731,0x433f9777a21ee9dd,0x0000000000000000,
0x0000000000000000,0x433fe5896e6599ff,0x433f9681e3c561f1,0x0000000000000000,
0x23cd623790ebc91b,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0x67433a745c386d1b,0x74bacda927818d1b,0x37dbd51f9299567f,0x524d0480d6520429,
0x0000000000000000,0x524d0480d7057e9b,0xdeb718dd52021ea7,0x524d0480d65d14cd,
0xdeb718dd72c902c3,0x0000000000000000,0x0000000000000000,0x57cc07d2d41323ab,
0x0000000000000000,
};
u8 cpp_main_keys_key_array_0[] = {0x64,0x6f,0x75,0x62,0x6c,0x65,};
u8 cpp_main_keys_key_array_2[] = {0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,};
u8 cpp_main_keys_key_array_3[] = {0x70,0x75,0x62,0x6c,0x69,0x63,};
u8 cpp_main_keys_key_array_5[] = {0x74,0x72,0x79,};
u8 cpp_main_keys_key_array_6[] = {0x76,0x6f,0x6c,0x61,0x74,0x69,0x6c,0x65,};
u8 cpp_main_keys_key_array_10[] = {0x73,0x77,0x69,0x74,0x63,0x68,};
u8 cpp_main_keys_key_array_11[] = {0x63,0x6f,0x6e,0x73,0x74,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_16[] = {0x67,0x6f,0x74,0x6f,};
u8 cpp_main_keys_key_array_18[] = {0x69,0x6e,0x74,};
u8 cpp_main_keys_key_array_21[] = {0x73,0x74,0x61,0x74,0x69,0x63,0x5f,0x61,0x73,0x73,0x65,0x72,0x74,};
u8 cpp_main_keys_key_array_22[] = {0x73,0x74,0x72,0x75,0x63,0x74,};
u8 cpp_main_keys_key_array_23[] = {0x72,0x65,0x74,0x75,0x72,0x6e,};
u8 cpp_main_keys_key_array_24[] = {0x6f,0x70,0x65,0x72,0x61,0x74,0x6f,0x72,};
u8 cpp_main_keys_key_array_25[] = {0x69,0x66,};
u8 cpp_main_keys_key_array_27[] = {0x63,0x6c,0x61,0x73,0x73,};
u8 cpp_main_keys_key_array_33[] = {0x74,0x65,0x6d,0x70,0x6c,0x61,0x74,0x65,};
u8 cpp_main_keys_key_array_34[] = {0x73,0x74,0x61,0x74,0x69,0x63,};
u8 cpp_main_keys_key_array_36[] = {0x63,0x6f,0x6e,0x73,0x74,};
u8 cpp_main_keys_key_array_37[] = {0x75,0x6e,0x69,0x6f,0x6e,};
u8 cpp_main_keys_key_array_38[] = {0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,};
u8 cpp_main_keys_key_array_39[] = {0x73,0x69,0x7a,0x65,0x6f,0x66,};
u8 cpp_main_keys_key_array_42[] = {0x69,0x6e,0x6c,0x69,0x6e,0x65,};
u8 cpp_main_keys_key_array_44[] = {0x74,0x79,0x70,0x65,0x69,0x64,};
u8 cpp_main_keys_key_array_45[] = {0x61,0x6c,0x69,0x67,0x6e,0x61,0x73,};
u8 cpp_main_keys_key_array_46[] = {0x6e,0x6f,0x65,0x78,0x63,0x65,0x70,0x74,};
u8 cpp_main_keys_key_array_48[] = {0x66,0x6c,0x6f,0x61,0x74,};
u8 cpp_main_keys_key_array_50[] = {0x74,0x68,0x69,0x73,};
u8 cpp_main_keys_key_array_54[] = {0x64,0x65,0x6c,0x65,0x74,0x65,};
u8 cpp_main_keys_key_array_56[] = {0x63,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,};
u8 cpp_main_keys_key_array_57[] = {0x74,0x79,0x70,0x65,0x6e,0x61,0x6d,0x65,};
u8 cpp_main_keys_key_array_58[] = {0x76,0x69,0x72,0x74,0x75,0x61,0x6c,};
u8 cpp_main_keys_key_array_59[] = {0x6e,0x65,0x77,};
u8 cpp_main_keys_key_array_61[] = {0x64,0x6f,};
u8 cpp_main_keys_key_array_62[] = {0x66,0x61,0x6c,0x73,0x65,};
u8 cpp_main_keys_key_array_67[] = {0x62,0x72,0x65,0x61,0x6b,};
u8 cpp_main_keys_key_array_68[] = {0x62,0x6f,0x6f,0x6c,};
u8 cpp_main_keys_key_array_69[] = {0x74,0x72,0x75,0x65,};
u8 cpp_main_keys_key_array_70[] = {0x65,0x78,0x74,0x65,0x72,0x6e,};
u8 cpp_main_keys_key_array_72[] = {0x65,0x6c,0x73,0x65,};
u8 cpp_main_keys_key_array_73[] = {0x74,0x68,0x72,0x65,0x61,0x64,0x5f,0x6c,0x6f,0x63,0x61,0x6c,};
u8 cpp_main_keys_key_array_74[] = {0x63,0x68,0x61,0x72,};
u8 cpp_main_keys_key_array_75[] = {0x75,0x6e,0x73,0x69,0x67,0x6e,0x65,0x64,};
u8 cpp_main_keys_key_array_76[] = {0x73,0x69,0x67,0x6e,0x65,0x64,};
u8 cpp_main_keys_key_array_78[] = {0x63,0x61,0x74,0x63,0x68,};
u8 cpp_main_keys_key_array_84[] = {0x64,0x65,0x63,0x6c,0x74,0x79,0x70,0x65,};
u8 cpp_main_keys_key_array_86[] = {0x70,0x72,0x69,0x76,0x61,0x74,0x65,};
u8 cpp_main_keys_key_array_87[] = {0x6c,0x6f,0x6e,0x67,};
u8 cpp_main_keys_key_array_90[] = {0x77,0x68,0x69,0x6c,0x65,};
u8 cpp_main_keys_key_array_91[] = {0x65,0x78,0x70,0x6f,0x72,0x74,};
u8 cpp_main_keys_key_array_93[] = {0x66,0x6f,0x72,};
u8 cpp_main_keys_key_array_95[] = {0x70,0x72,0x6f,0x74,0x65,0x63,0x74,0x65,0x64,};
u8 cpp_main_keys_key_array_96[] = {0x61,0x6c,0x69,0x67,0x6e,0x6f,0x66,};
u8 cpp_main_keys_key_array_97[] = {0x61,0x73,0x6d,};
u8 cpp_main_keys_key_array_98[] = {0x74,0x79,0x70,0x65,0x64,0x65,0x66,};
u8 cpp_main_keys_key_array_101[] = {0x64,0x65,0x66,0x61,0x75,0x6c,0x74,};
u8 cpp_main_keys_key_array_102[] = {0x6e,0x75,0x6c,0x6c,0x70,0x74,0x72,};
u8 cpp_main_keys_key_array_104[] = {0x72,0x65,0x69,0x6e,0x74,0x65,0x72,0x70,0x72,0x65,0x74,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_108[] = {0x73,0x74,0x61,0x74,0x69,0x63,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_109[] = {0x64,0x79,0x6e,0x61,0x6d,0x69,0x63,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_110[] = {0x66,0x72,0x69,0x65,0x6e,0x64,};
u8 cpp_main_keys_key_array_111[] = {0x63,0x61,0x73,0x65,};
u8 cpp_main_keys_key_array_113[] = {0x76,0x6f,0x69,0x64,};
u8 cpp_main_keys_key_array_114[] = {0x73,0x68,0x6f,0x72,0x74,};
u8 cpp_main_keys_key_array_115[] = {0x65,0x6e,0x75,0x6d,};
u8 cpp_main_keys_key_array_116[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 cpp_main_keys_key_array_119[] = {0x65,0x78,0x70,0x6c,0x69,0x63,0x69,0x74,};
String_Const_u8 cpp_main_keys_key_array[121] = {
{cpp_main_keys_key_array_0, 6},
{0, 0},
{cpp_main_keys_key_array_2, 8},
{cpp_main_keys_key_array_3, 6},
{0, 0},
{cpp_main_keys_key_array_5, 3},
{cpp_main_keys_key_array_6, 8},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_10, 6},
{cpp_main_keys_key_array_11, 10},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_16, 4},
{0, 0},
{cpp_main_keys_key_array_18, 3},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_21, 13},
{cpp_main_keys_key_array_22, 6},
{cpp_main_keys_key_array_23, 6},
{cpp_main_keys_key_array_24, 8},
{cpp_main_keys_key_array_25, 2},
{0, 0},
{cpp_main_keys_key_array_27, 5},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_33, 8},
{cpp_main_keys_key_array_34, 6},
{0, 0},
{cpp_main_keys_key_array_36, 5},
{cpp_main_keys_key_array_37, 5},
{cpp_main_keys_key_array_38, 9},
{cpp_main_keys_key_array_39, 6},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_42, 6},
{0, 0},
{cpp_main_keys_key_array_44, 6},
{cpp_main_keys_key_array_45, 7},
{cpp_main_keys_key_array_46, 8},
{0, 0},
{cpp_main_keys_key_array_48, 5},
{0, 0},
{cpp_main_keys_key_array_50, 4},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_54, 6},
{0, 0},
{cpp_main_keys_key_array_56, 8},
{cpp_main_keys_key_array_57, 8},
{cpp_main_keys_key_array_58, 7},
{cpp_main_keys_key_array_59, 3},
{0, 0},
{cpp_main_keys_key_array_61, 2},
{cpp_main_keys_key_array_62, 5},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_67, 5},
{cpp_main_keys_key_array_68, 4},
{cpp_main_keys_key_array_69, 4},
{cpp_main_keys_key_array_70, 6},
{0, 0},
{cpp_main_keys_key_array_72, 4},
{cpp_main_keys_key_array_73, 12},
{cpp_main_keys_key_array_74, 4},
{cpp_main_keys_key_array_75, 8},
{cpp_main_keys_key_array_76, 6},
{0, 0},
{cpp_main_keys_key_array_78, 5},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_84, 8},
{0, 0},
{cpp_main_keys_key_array_86, 7},
{cpp_main_keys_key_array_87, 4},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_90, 5},
{cpp_main_keys_key_array_91, 6},
{0, 0},
{cpp_main_keys_key_array_93, 3},
{0, 0},
{cpp_main_keys_key_array_95, 9},
{cpp_main_keys_key_array_96, 7},
{cpp_main_keys_key_array_97, 3},
{cpp_main_keys_key_array_98, 7},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_101, 7},
{cpp_main_keys_key_array_102, 7},
{0, 0},
{cpp_main_keys_key_array_104, 16},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_108, 11},
{cpp_main_keys_key_array_109, 12},
{cpp_main_keys_key_array_110, 6},
{cpp_main_keys_key_array_111, 4},
{0, 0},
{cpp_main_keys_key_array_113, 4},
{cpp_main_keys_key_array_114, 5},
{cpp_main_keys_key_array_115, 4},
{cpp_main_keys_key_array_116, 5},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_119, 8},
{0, 0},
};
Lexeme_Table_Value cpp_main_keys_value_array[121] = {
{4, TokenCppKind_Double},
{0, 0},
{4, TokenCppKind_Register},
{4, TokenCppKind_Public},
{0, 0},
{4, TokenCppKind_Try},
{4, TokenCppKind_Volatile},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Switch},
{4, TokenCppKind_ConstCast},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Goto},
{0, 0},
{4, TokenCppKind_Int},
{0, 0},
{0, 0},
{4, TokenCppKind_StaticAssert},
{4, TokenCppKind_Struct},
{4, TokenCppKind_Return},
{4, TokenCppKind_Operator},
{4, TokenCppKind_If},
{0, 0},
{4, TokenCppKind_Class},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Template},
{4, TokenCppKind_Static},
{0, 0},
{4, TokenCppKind_Const},
{4, TokenCppKind_Union},
{4, TokenCppKind_Namespace},
{4, TokenCppKind_SizeOf},
{0, 0},
{0, 0},
{4, TokenCppKind_Inline},
{0, 0},
{4, TokenCppKind_TypeID},
{4, TokenCppKind_AlignAs},
{4, TokenCppKind_NoExcept},
{0, 0},
{4, TokenCppKind_Float},
{0, 0},
{4, TokenCppKind_This},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Delete},
{0, 0},
{4, TokenCppKind_Continue},
{4, TokenCppKind_Typename},
{4, TokenCppKind_Virtual},
{4, TokenCppKind_New},
{0, 0},
{4, TokenCppKind_Do},
{8, TokenCppKind_LiteralFalse},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Break},
{4, TokenCppKind_Bool},
{8, TokenCppKind_LiteralTrue},
{4, TokenCppKind_Extern},
{0, 0},
{4, TokenCppKind_Else},
{4, TokenCppKind_ThreadLocal},
{4, TokenCppKind_Char},
{4, TokenCppKind_Unsigned},
{4, TokenCppKind_Signed},
{0, 0},
{4, TokenCppKind_Catch},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_DeclType},
{0, 0},
{4, TokenCppKind_Private},
{4, TokenCppKind_Long},
{0, 0},
{0, 0},
{4, TokenCppKind_While},
{4, TokenCppKind_Export},
{0, 0},
{4, TokenCppKind_For},
{0, 0},
{4, TokenCppKind_Protected},
{4, TokenCppKind_AlignOf},
{4, TokenCppKind_Asm},
{4, TokenCppKind_Typedef},
{0, 0},
{0, 0},
{4, TokenCppKind_Default},
{4, TokenCppKind_NullPtr},
{0, 0},
{4, TokenCppKind_ReinterpretCast},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_StaticCast},
{4, TokenCppKind_DynamicCast},
{4, TokenCppKind_Friend},
{4, TokenCppKind_Case},
{0, 0},
{4, TokenCppKind_Void},
{4, TokenCppKind_Short},
{4, TokenCppKind_Enum},
{4, TokenCppKind_Using},
{0, 0},
{0, 0},
{4, TokenCppKind_Explicit},
{0, 0},
};
i32 cpp_main_keys_slot_count = 121;
u64 cpp_main_keys_seed = 0x953a12ac17c41417;
u64 cpp_pp_directives_hash_array[25] = {
0xfe56e8c4074028a1,0x0000000000000000,0xc3c57ac6cdcc8e13,0x0000000000000000,
0x0000000000000000,0x1ef2b594e6639499,0x1ef2b5945965d033,0xc3c57ac6cc3200a1,
0x0000000000000000,0xfe56e944526812e1,0xa2ead7c2d3f080b1,0x0000000000000000,
0x1ef2b594e525cd8d,0xc3c57ac6cdcc8bf9,0x0000000000000000,0x0000000000000000,
0xa2eaaf0527422dcd,0x0000000000000000,0x0000000000000000,0xfe56e924faa029ef,
0x0cfa51ab021d0e39,0x0000000000000000,0x1ef2b594e5647e39,0x1ef2b594592dbd19,
0xfe56e9455b09df59,
};
u8 cpp_pp_directives_key_array_0[] = {0x64,0x65,0x66,0x69,0x6e,0x65,};
u8 cpp_pp_directives_key_array_2[] = {0x65,0x6c,0x73,0x65,};
u8 cpp_pp_directives_key_array_5[] = {0x69,0x66,0x64,0x65,0x66,};
u8 cpp_pp_directives_key_array_6[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 cpp_pp_directives_key_array_7[] = {0x6c,0x69,0x6e,0x65,};
u8 cpp_pp_directives_key_array_9[] = {0x69,0x6d,0x70,0x6f,0x72,0x74,};
u8 cpp_pp_directives_key_array_10[] = {0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,};
u8 cpp_pp_directives_key_array_12[] = {0x65,0x72,0x72,0x6f,0x72,};
u8 cpp_pp_directives_key_array_13[] = {0x65,0x6c,0x69,0x66,};
u8 cpp_pp_directives_key_array_16[] = {0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,};
u8 cpp_pp_directives_key_array_19[] = {0x70,0x72,0x61,0x67,0x6d,0x61,};
u8 cpp_pp_directives_key_array_20[] = {0x69,0x66,};
u8 cpp_pp_directives_key_array_22[] = {0x65,0x6e,0x64,0x69,0x66,};
u8 cpp_pp_directives_key_array_23[] = {0x75,0x6e,0x64,0x65,0x66,};
u8 cpp_pp_directives_key_array_24[] = {0x69,0x66,0x6e,0x64,0x65,0x66,};
String_Const_u8 cpp_pp_directives_key_array[25] = {
{cpp_pp_directives_key_array_0, 6},
{0, 0},
{cpp_pp_directives_key_array_2, 4},
{0, 0},
{0, 0},
{cpp_pp_directives_key_array_5, 5},
{cpp_pp_directives_key_array_6, 5},
{cpp_pp_directives_key_array_7, 4},
{0, 0},
{cpp_pp_directives_key_array_9, 6},
{cpp_pp_directives_key_array_10, 7},
{0, 0},
{cpp_pp_directives_key_array_12, 5},
{cpp_pp_directives_key_array_13, 4},
{0, 0},
{0, 0},
{cpp_pp_directives_key_array_16, 7},
{0, 0},
{0, 0},
{cpp_pp_directives_key_array_19, 6},
{cpp_pp_directives_key_array_20, 2},
{0, 0},
{cpp_pp_directives_key_array_22, 5},
{cpp_pp_directives_key_array_23, 5},
{cpp_pp_directives_key_array_24, 6},
};
Lexeme_Table_Value cpp_pp_directives_value_array[25] = {
{5, TokenCppKind_PPDefine},
{0, 0},
{5, TokenCppKind_PPElse},
{0, 0},
{0, 0},
{5, TokenCppKind_PPIfDef},
{5, TokenCppKind_PPUsing},
{5, TokenCppKind_PPLine},
{0, 0},
{5, TokenCppKind_PPImport},
{5, TokenCppKind_PPVersion},
{0, 0},
{5, TokenCppKind_PPError},
{5, TokenCppKind_PPElIf},
{0, 0},
{0, 0},
{5, TokenCppKind_PPInclude},
{0, 0},
{0, 0},
{5, TokenCppKind_PPPragma},
{5, TokenCppKind_PPIf},
{0, 0},
{5, TokenCppKind_PPEndIf},
{5, TokenCppKind_PPUndef},
{5, TokenCppKind_PPIfNDef},
};
i32 cpp_pp_directives_slot_count = 25;
u64 cpp_pp_directives_seed = 0xbeb48380ba8b083c;
u64 cpp_pp_keys_hash_array[2] = {
0x1ed4e97587163439,0x0000000000000000,
};
u8 cpp_pp_keys_key_array_0[] = {0x64,0x65,0x66,0x69,0x6e,0x65,0x64,};
String_Const_u8 cpp_pp_keys_key_array[2] = {
{cpp_pp_keys_key_array_0, 7},
{0, 0},
};
Lexeme_Table_Value cpp_pp_keys_value_array[2] = {
{4, TokenCppKind_PPDefined},
{0, 0},
};
i32 cpp_pp_keys_slot_count = 2;
u64 cpp_pp_keys_seed = 0x93cbef5c9f9a0846;
struct Lex_State_Cpp{
u32 flags_ZF0;
u32 flags_KF0;
u16 flags_KB0;
u8 *base;
u8 *delim_first;
u8 *delim_one_past_last;
u8 *emit_ptr;
u8 *ptr;
u8 *opl_ptr;
};
static void
lex_full_input_cpp_init(Lex_State_Cpp *state_ptr, String_Const_u8 input){
state_ptr->flags_ZF0 = 0;
state_ptr->flags_KF0 = 0;
state_ptr->flags_KB0 = 0;
state_ptr->base = input.str;
state_ptr->delim_first = input.str;
state_ptr->delim_one_past_last = input.str;
state_ptr->emit_ptr = input.str;
state_ptr->ptr = input.str;
state_ptr->opl_ptr = input.str + input.size;
}
static b32
lex_full_input_cpp_breaks(Arena *arena, Token_List *list, Lex_State_Cpp *state_ptr, u64 max){
b32 result = false;
u64 emit_counter = 0;
Lex_State_Cpp state;
block_copy((&state), (state_ptr), sizeof(*(&state)));
{
state_label_1:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:
case 0x13:case 0x14:case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:
case 0x1a:case 0x1b:case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x40:
case 0x60:case 0x7f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
if (((((state.flags_KF0)&(0x2))!=0))){
state.ptr += 1;
goto state_label_4;
}
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
case 0x21:
{
state.ptr += 1;
goto state_label_61;
}break;
case 0x22:
{
if (((((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_26;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x23:
{
if ((!(((state.flags_KB0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_23;
}
state.ptr += 1;
goto state_label_68;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
case 0x25:
{
state.ptr += 1;
goto state_label_65;
}break;
case 0x26:
{
state.ptr += 1;
goto state_label_62;
}break;
case 0x27:
{
state.ptr += 1;
state.flags_ZF0 |= 0x40;
goto state_label_32;
}break;
case 0x28:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ParenOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x29:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ParenCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_64;
}break;
case 0x2b:
{
state.ptr += 1;
goto state_label_54;
}break;
case 0x2c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Comma;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2d:
{
state.ptr += 1;
goto state_label_55;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_6;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_7;
}break;
case 0x30:
{
state.ptr += 1;
goto state_label_9;
}break;
case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:case 0x37:
case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x3a:
{
state.ptr += 1;
goto state_label_53;
}break;
case 0x3b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Semicolon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
if ((!(((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_57;
}
state.ptr += 1;
goto state_label_25;
}break;
case 0x3d:
{
state.ptr += 1;
goto state_label_60;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_58;
}break;
case 0x3f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Ternary;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
state.flags_ZF0 |= 0x4;
goto state_label_27;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
case 0x55:
{
state.ptr += 1;
state.flags_ZF0 |= 0x20;
goto state_label_29;
}break;
case 0x5b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BrackOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_5;
}break;
case 0x5d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BrackCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Xor;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x75:
{
state.ptr += 1;
state.flags_ZF0 |= 0x10;
goto state_label_28;
}break;
case 0x7b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BraceOp;
token.kind = 11;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
goto state_label_63;
}break;
case 0x7d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BraceCl;
token.kind = 12;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Tilde;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_2:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_KB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_keys_hash_array, cpp_pp_keys_key_array, cpp_pp_keys_value_array, cpp_pp_keys_slot_count, cpp_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_main_keys_hash_array, cpp_main_keys_key_array, cpp_main_keys_value_array, cpp_main_keys_slot_count, cpp_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x09:case 0x0a:case 0x0b:case 0x0c:case 0x0d:
case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:case 0x13:case 0x14:
case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:case 0x1a:case 0x1b:
case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x20:case 0x21:case 0x22:
case 0x23:case 0x25:case 0x26:case 0x27:case 0x28:case 0x29:case 0x2a:
case 0x2b:case 0x2c:case 0x2d:case 0x2e:case 0x2f:case 0x3a:case 0x3b:
case 0x3c:case 0x3d:case 0x3e:case 0x3f:case 0x40:case 0x5b:case 0x5c:
case 0x5d:case 0x5e:case 0x60:case 0x7b:case 0x7c:case 0x7d:case 0x7e:
case 0x7f:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_KB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_keys_hash_array, cpp_pp_keys_key_array, cpp_pp_keys_value_array, cpp_pp_keys_slot_count, cpp_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_main_keys_hash_array, cpp_main_keys_key_array, cpp_main_keys_value_array, cpp_main_keys_slot_count, cpp_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
}
}
{
state_label_3:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
}
}
{
state_label_4:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_4;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_5:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x0a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_5;
}break;
}
}
{
state_label_6:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DotStar;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_69;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
}
}
{
state_label_7:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DivEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_8:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_9:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x58:case 0x78:
{
state.ptr += 1;
state.flags_ZF0 |= 0x1;
goto state_label_14;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_10:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_11:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2b:case 0x2d:
{
state.ptr += 1;
goto state_label_12;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_12:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_13:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_14:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
}
}
{
state_label_15:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_16:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_17:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_19;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_21;
}break;
}
}
{
state_label_18:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_22;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_19:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_20:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_22;
}break;
}
}
{
state_label_21:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_22:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_23:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x20:
{
state.ptr += 1;
goto state_label_23;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.delim_first = state.ptr;
state.flags_KB0 |= 0x1;
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_24:
if (state.ptr == state.opl_ptr){
if ((true)){
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_directives_hash_array, cpp_pp_directives_key_array, cpp_pp_directives_value_array, cpp_pp_directives_slot_count, cpp_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenCppKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenCppKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_directives_hash_array, cpp_pp_directives_key_array, cpp_pp_directives_value_array, cpp_pp_directives_slot_count, cpp_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenCppKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenCppKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_25:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x21:case 0x22:case 0x23:case 0x24:case 0x25:case 0x26:
case 0x27:case 0x28:case 0x29:case 0x2a:case 0x2b:case 0x2c:case 0x2d:
case 0x2e:case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:
case 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x3a:case 0x3b:
case 0x3d:case 0x3f:case 0x40:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5b:case 0x5c:case 0x5d:case 0x5e:case 0x5f:case 0x61:
case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:case 0x68:
case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:case 0x6f:
case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:case 0x76:
case 0x77:case 0x78:case 0x79:case 0x7a:case 0x7b:case 0x7c:case 0x7d:
{
state.ptr += 1;
goto state_label_25;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_26:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x21:case 0x23:case 0x24:case 0x25:case 0x26:case 0x27:
case 0x28:case 0x29:case 0x2a:case 0x2b:case 0x2c:case 0x2d:case 0x2e:
case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:
case 0x36:case 0x37:case 0x38:case 0x39:case 0x3a:case 0x3b:case 0x3c:
case 0x3d:case 0x3e:case 0x3f:case 0x40:case 0x41:case 0x42:case 0x43:
case 0x44:case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:
case 0x4b:case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:
case 0x52:case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:
case 0x59:case 0x5a:case 0x5b:case 0x5c:case 0x5d:case 0x5e:case 0x5f:
case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:
case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:
case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:
case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:case 0x7b:case 0x7c:
case 0x7d:
{
state.ptr += 1;
goto state_label_26;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_27:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_28:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x38:
{
state.ptr += 1;
state.flags_ZF0 |= 0x8;
goto state_label_30;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_29:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_30:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_31:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
state.delim_first = state.ptr;
goto state_label_45;
}break;
}
}
{
state_label_32:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x22:
{
if ((!(((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralStringWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralString;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x27:
{
if (((((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralCharacter;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_33;
}break;
}
}
{
state_label_33:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_34;
}break;
case 0x55:
{
state.ptr += 1;
goto state_label_37;
}break;
case 0x75:
{
state.ptr += 1;
goto state_label_41;
}break;
case 0x78:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_34:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_35;
}break;
}
}
{
state_label_35:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_36:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_37:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_38;
}break;
}
}
{
state_label_38:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_39;
}break;
}
}
{
state_label_39:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_40;
}break;
}
}
{
state_label_40:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_41;
}break;
}
}
{
state_label_41:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_42;
}break;
}
}
{
state_label_42:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_43;
}break;
}
}
{
state_label_43:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_44;
}break;
}
}
{
state_label_44:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_45:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_45;
}break;
case 0x20:case 0x29:case 0x5c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x28:
{
state.delim_one_past_last = state.ptr;
state.ptr += 1;
goto state_label_46;
}break;
}
}
{
state_label_46:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_46;
}break;
case 0x29:
{
state.ptr += 1;
goto state_label_47;
}break;
}
}
{
state_label_47:
u64 delim_length = state.delim_one_past_last - state.delim_first;
u64 parse_length = 0;
for (;;){
if (parse_length == delim_length){
goto state_label_48;
}
if (state.ptr == state.opl_ptr){
goto state_label_48;
}
if (*state.ptr == state.delim_first[parse_length]){
state.ptr += 1;
parse_length += 1;
}
else{
goto state_label_46;
}
}
}
{
state_label_48:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_46;
}
}
switch (*state.ptr){
default:
{
goto state_label_46;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralStringWideRaw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF8Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF16Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF32Raw;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralStringRaw;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_49:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
}
}
{
state_label_50:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
case 0x2f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_51:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_52:
if (state.ptr == state.opl_ptr){
if ((true)){
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_53:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Colon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Colon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ColonColon;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_54:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PlusPlus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PlusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_55:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_MinusMinus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_MinusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_56;
}break;
}
}
{
state_label_56:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Arrow;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Arrow;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ArrowStar;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_57:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
state.ptr += 1;
goto state_label_66;
}break;
case 0x3d:
{
state.ptr += 1;
goto state_label_59;
}break;
}
}
{
state_label_58:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_GrtrEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_67;
}break;
}
}
{
state_label_59:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LessEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LessEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Compare;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_60:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EqEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_61:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_NotEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_62:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x26:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_AndAnd;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_63:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_OrOr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_64:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_StarEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_65:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ModEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_66:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeftEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_67:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRightEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_68:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPStringify;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPStringify;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x23:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPConcat;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_69:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DotDotDot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
end:;
block_copy((state_ptr), (&state), sizeof(*(state_ptr)));
return(result);
}
static Token_List
lex_full_input_cpp(Arena *arena, String_Const_u8 input){
Lex_State_Cpp state = {};
lex_full_input_cpp_init(&state, input);
Token_List list = {};
lex_full_input_cpp_breaks(arena, &list, &state, max_u64);
return(list);
}
# 98 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_map.cpp" 1






static void
setup_default_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_id));
    map_set_binding_l(m, map, keyboard_macro_start_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, 0);
    map_set_binding_l(m, map, keyboard_macro_finish_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, keyboard_macro_replay, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Alt, 0);
    map_set_binding_l(m, map, change_active_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, 0);
    map_set_binding_l(m, map, change_active_panel_backwards, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, interactive_new, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_in_other, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Alt, 0);
    map_set_binding_l(m, map, interactive_kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_switch_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Alt, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, quick_swap_buffer, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, jump_to_last_point, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer_lister, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);

    map = mapping_get_or_make_map(m, (file_id));
    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, replace_in_range, InputEventKind_KeyStroke, (KeyCode_A), KeyCode_Control, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, center_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, 0);
    map_set_binding_l(m, map, left_adjust_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, snippet_lister, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Control, 0);
    map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Control, 0);
    map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
    map_set_binding_l(m, map, reopen, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
    map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Alt, 0);
    map_set_binding_l(m, map, reverse_search, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Control, 0);
    map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, view_buffer_other_panel, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Control, 0);
    map_set_binding_l(m, map, swap_panels, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Control, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);

    map = mapping_get_or_make_map(m, (code_id));
    map_set_parent(m, map, (file_id));
    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Alt, 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Control, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Control, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Alt, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);
    map_set_binding_l(m, map, jump_to_definition_at_cursor, InputEventKind_KeyStroke, (KeyCode_W), KeyCode_Control, 0);
}
# 100 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_mac_map.cpp" 1






static void
setup_mac_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_id));
    map_set_binding_l(m, map, keyboard_macro_start_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Command, 0);
    map_set_binding_l(m, map, keyboard_macro_finish_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, keyboard_macro_replay, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, 0);
    map_set_binding_l(m, map, change_active_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Command, 0);
    map_set_binding_l(m, map, change_active_panel_backwards, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, interactive_new, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Command, 0);
    map_set_binding_l(m, map, interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Command, 0);
    map_set_binding_l(m, map, open_in_other, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Command, 0);
    map_set_binding_l(m, map, interactive_switch_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Command, 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Command, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Control, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, quick_swap_buffer, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Command, 0);
    map_set_binding_l(m, map, jump_to_last_point, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);

    map = mapping_get_or_make_map(m, (file_id));
    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Command, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Command, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Command, 0);
    map_set_binding_l(m, map, replace_in_range, InputEventKind_KeyStroke, (KeyCode_A), KeyCode_Command, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, center_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Command, 0);
    map_set_binding_l(m, map, left_adjust_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, snippet_lister, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Command, 0);
    map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Command, 0);
    map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Command, 0);
    map_set_binding_l(m, map, reopen, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Command, 0);
    map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
    map_set_binding_l(m, map, reverse_search, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Command, 0);
    map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Command, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Command, 0);
    map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Command, 0);
    map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Command, 0);
    map_set_binding_l(m, map, view_buffer_other_panel, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Command, 0);
    map_set_binding_l(m, map, swap_panels, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Command, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Command, KeyCode_Shift, 0);

    map = mapping_get_or_make_map(m, (code_id));
    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Command, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Command, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Command, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Command, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Control, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Command, 0);
    map_set_binding_l(m, map, jump_to_definition_at_cursor, InputEventKind_KeyStroke, (KeyCode_W), KeyCode_Command, 0);
}
# 101 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework_variables.cpp" 1







CUSTOM_ID(attachment, view_rewrite_loc);
CUSTOM_ID(attachment, view_next_rewrite_loc);
CUSTOM_ID(attachment, view_paste_index_loc);
CUSTOM_ID(attachment, view_is_passive_loc);
CUSTOM_ID(attachment, view_snap_mark_to_cursor);
CUSTOM_ID(attachment, view_ui_data);
CUSTOM_ID(attachment, view_highlight_range);
CUSTOM_ID(attachment, view_highlight_buffer);
CUSTOM_ID(attachment, view_render_hook);
CUSTOM_ID(attachment, view_word_complete_menu);
CUSTOM_ID(attachment, view_lister_loc);
CUSTOM_ID(attachment, view_previous_buffer);

CUSTOM_ID(attachment, buffer_map_id);
CUSTOM_ID(attachment, buffer_eol_setting);
CUSTOM_ID(attachment, buffer_lex_task);
CUSTOM_ID(attachment, buffer_wrap_lines);

CUSTOM_ID(attachment, sticky_jump_marker_handle);
CUSTOM_ID(attachment, attachment_tokens);
# 39 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework_variables.cpp"
static b32 allow_immediate_close_without_checking_for_changes = false;

static char *default_extensions[] = {
    "cpp",
    "hpp",
    "c",
    "h",
    "cc",
    "cs",
    "java",
    "rs",
    "glsl",
    "m",
};




static b32 auto_center_after_jumps = true;
static u8 locked_buffer_space[256];
static String_Const_u8 locked_buffer = {};


static View_ID build_footer_panel_view_id = 0;

static u8 out_buffer_space[1024];
static u8 command_space[1024];
static char hot_directory_space[1024];

static b32 suppressing_mouse = false;

static b32 show_fps_hud = false;


static Heap global_heap;

enum{
    FCoderMode_Original = 0,
    FCoderMode_NotepadLike = 1,
};
static i32 fcoder_mode = FCoderMode_Original;

static ID_Pos_Jump_Location prev_location = {};

static Arena global_permanent_arena = {};

static Arena global_config_arena = {};

static char previous_isearch_query[256] = {};

static Mapping framework_mapping = {};

static Buffer_Modified_Set global_buffer_modified_set = {};

static b32 def_enable_virtual_whitespace = false;



static b32 global_keyboard_macro_is_recording = false;
static Range_i64 global_keyboard_macro_range = {};



static Fade_Range_List buffer_fade_ranges = {};
static Arena fade_range_arena = {};
static Fade_Range *free_fade_ranges = 0;



static Point_Stack point_stack = {};



static Clipboard clipboard0 = {};
# 103 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" 1






static Color_Array
finalize_color_array(Color_Table table, u64 id){
    return(table.arrays[id % table.count]);
}

static ARGB_Color
finalize_color(Color_Array array, i32 sub_index){
    ARGB_Color result = 0xFFFFFFFF;
    if (array.count > 0){
        result = array.vals[sub_index % array.count];
    }
    return(result);
}

static ARGB_Color
finalize_color(Color_Table color_table, u64 id, i32 sub_index){
    Color_Array array = finalize_color_array(color_table, id);
    return(finalize_color(array, sub_index));
}

static Color_Array
finalize_color_array(u64 id){
 return(finalize_color_array(active_color_table, id));
}

static ARGB_Color
finalize_color(u64 id, i32 sub_index){
 return(finalize_color(active_color_table, id, sub_index));
}



static Color_Array
make_colors(Arena *arena, ARGB_Color color){
    Color_Array result = {};
    result.count = 1;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "43" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "43" ":") - 1)))));
    result.vals[0] = color;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2){
    Color_Array result = {};
    result.count = 2;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(2), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "52" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "52" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2, ARGB_Color c3){
    Color_Array result = {};
    result.count = 3;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(3), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "62" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "62" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    result.vals[2] = c3;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2, ARGB_Color c3, ARGB_Color c4){
    Color_Array result = {};
    result.count = 4;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(4), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "73" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "73" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    result.vals[2] = c3;
    result.vals[3] = c4;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color *colors, i32 count){
    Color_Array result = {};
    result.count = count;
    result.vals = ((ARGB_Color*)linalloc_wrap_write(linalloc_push((arena), sizeof(ARGB_Color)*(count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "85" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "85" ":") - 1))), sizeof(ARGB_Color)*(count), (colors)));
    return(result);
}

static Color_Table
make_color_table(Application_Links *app, Arena *arena){
    Managed_ID highest_color_id = managed_id_group_highest_id(app, SCu8((u8*)("colors"), (u64)(sizeof("colors") - 1)));
    Color_Table result = {};
    result.count = (u32)((((highest_color_id + 1)<(max_u32))?(highest_color_id + 1):(max_u32)));
    result.arrays = ((Color_Array*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Color_Array)*(result.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "94" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "94" ":") - 1)))));
    u32 *dummy = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "95" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "95" ":") - 1)))));
    *dummy = 0xFF990099;
    for (i32 i = 0; i < result.count; i += 1){
        result.arrays[i].vals = dummy;
        result.arrays[i].count = 1;
    }
    return(result);
}

static void
set_default_color_scheme(Application_Links *app){
    if (global_theme_arena.base_allocator == 0){
        global_theme_arena = make_arena_system();
    }

    Arena *arena = &global_theme_arena;

    default_color_table = make_color_table(app, arena);

    default_color_table.arrays[0] = make_colors(arena, 0xFF90B080);
    default_color_table.arrays[defcolor_bar] = make_colors(arena, 0xFF888888);
    default_color_table.arrays[defcolor_base] = make_colors(arena, 0xFF000000);
    default_color_table.arrays[defcolor_pop1] = make_colors(arena, 0xFF3C57DC);
    default_color_table.arrays[defcolor_pop2] = make_colors(arena, 0xFFFF0000);
    default_color_table.arrays[defcolor_back] = make_colors(arena, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_margin] = make_colors(arena, 0xFF181818);
    default_color_table.arrays[defcolor_margin_hover] = make_colors(arena, 0xFF252525);
    default_color_table.arrays[defcolor_margin_active] = make_colors(arena, 0xFF323232);
    default_color_table.arrays[defcolor_list_item] = make_colors(arena, 0xFF181818, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_list_item_hover] = make_colors(arena, 0xFF252525, 0xFF181818);
    default_color_table.arrays[defcolor_list_item_active] = make_colors(arena, 0xFF323232, 0xFF323232);
    default_color_table.arrays[defcolor_cursor] = make_colors(arena, 0xFF00EE00, 0xFFEE7700);
    default_color_table.arrays[defcolor_at_cursor] = make_colors(arena, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_highlight_cursor_line] = make_colors(arena, 0xFF1E1E1E);
    default_color_table.arrays[defcolor_highlight] = make_colors(arena, 0xFFDDEE00);
    default_color_table.arrays[defcolor_at_highlight] = make_colors(arena, 0xFFFF44DD);
    default_color_table.arrays[defcolor_mark] = make_colors(arena, 0xFF494949);
    default_color_table.arrays[defcolor_text_default] = make_colors(arena, 0xFF90B080);
    default_color_table.arrays[defcolor_comment] = make_colors(arena, 0xFF2090F0);
    default_color_table.arrays[defcolor_comment_pop] = make_colors(arena, 0xFF00A000, 0xFFA00000);
    default_color_table.arrays[defcolor_keyword] = make_colors(arena, 0xFFD08F20);
    default_color_table.arrays[defcolor_str_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_char_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_int_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_float_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_bool_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_preproc] = make_colors(arena, 0xFFA0B8A0);
    default_color_table.arrays[defcolor_include] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_special_character] = make_colors(arena, 0xFFFF0000);
    default_color_table.arrays[defcolor_ghost_character] = make_colors(arena, 0xFF4E5E46);
    default_color_table.arrays[defcolor_highlight_junk] = make_colors(arena, 0xFF3A0000);
    default_color_table.arrays[defcolor_highlight_white] = make_colors(arena, 0xFF003A3A);
    default_color_table.arrays[defcolor_paste] = make_colors(arena, 0xFFDDEE00);
    default_color_table.arrays[defcolor_undo] = make_colors(arena, 0xFF00DDEE);
    default_color_table.arrays[defcolor_back_cycle] = make_colors(arena, 0xFF130707, 0xFF071307, 0xFF070713, 0xFF131307);
    default_color_table.arrays[defcolor_text_cycle] = make_colors(arena, 0xFFA00000, 0xFF00A000, 0xFF0030B0, 0xFFA0A000);
    default_color_table.arrays[defcolor_line_numbers_back] = make_colors(arena, 0xFF101010);
    default_color_table.arrays[defcolor_line_numbers_text] = make_colors(arena, 0xFF404040);

    active_color_table = default_color_table;
}



static void
set_active_color(Color_Table *table){
    if (table != 0){
        active_color_table = *table;
    }
}


static void
set_single_active_color(u64 id, ARGB_Color color){
    active_color_table.arrays[id] = make_colors(&global_theme_arena, color);
}

static void
save_theme(Color_Table table, String_Const_u8 name){
    Color_Table_Node *node = ((Color_Table_Node*)linalloc_wrap_unintialized(linalloc_push((&global_theme_arena), sizeof(Color_Table_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "174" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_colors.cpp" ":" "174" ":") - 1)))));
    do{ if((node)){if((global_theme_list.first)){(global_theme_list.last)->next=(node);}else{(global_theme_list.first)=(node);}(global_theme_list.last)=(node);(global_theme_list.last)->next=0;} }while(0);
    global_theme_list.count += 1;
    node->name = push_string_copy(&global_theme_arena, name);
    node->table = table;
}



static Color_Table*
get_color_table_by_name(String_Const_u8 name){
    Color_Table *result = 0;
    for (Color_Table_Node *node = global_theme_list.first;
         node != 0;
         node = node->next){
        if (string_match(node->name, name)){
            result = &node->table;
            break;
        }
    }
    return(result);
}
# 104 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
static i32
get_command_id(Custom_Command_Function *func){
    i32 result = -1;
    for (i32 i = 0; i < ((sizeof(fcoder_metacmd_table))/(sizeof(*fcoder_metacmd_table))); i += 1){
        if (func == fcoder_metacmd_table[i].proc){
            result = i;
            break;
        }
    }
    return(result);
}

static Command_Metadata*
get_command_metadata(Custom_Command_Function *func){
    Command_Metadata *result = 0;
    i32 id = get_command_id(func);
    if (id >= 0){
        result = &fcoder_metacmd_table[id];
    }
    return(result);
}

static Command_Metadata*
get_command_metadata_from_name(String_Const_u8 name){
    Command_Metadata *result = 0;
    Command_Metadata *candidate = fcoder_metacmd_table;
    for (i32 i = 0; i < ((sizeof(fcoder_metacmd_table))/(sizeof(*fcoder_metacmd_table))); i += 1, candidate += 1){
        if (string_match(SCu8(candidate->name, candidate->name_len), name)){
            result = candidate;
            break;
        }
    }
    return(result);
}



static Token_Array
get_token_array_from_buffer(Application_Links *app, Buffer_ID buffer){
    Token_Array result = {};
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
    if (lex_task_ptr != 0){
        async_task_wait(app, &global_async_system, *lex_task_ptr);
    }
    Token_Array *ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (ptr != 0){
        result = *ptr;
    }
    return(result);
}



static Buffer_Seek
seek_location(ID_Line_Column_Jump_Location location){
    return(seek_line_col(location.line, location.column));
}

static Buffer_Seek
seek_location(ID_Pos_Jump_Location location){
    return(seek_pos(location.pos));
}

static Buffer_Seek
seek_location(Name_Line_Column_Location location){
    return(seek_line_col(location.line, location.column));
}

static Buffer_Seek
seek_jump(Parsed_Jump jump){
    return(seek_location(jump.location));
}



View_Context_Block::View_Context_Block(Application_Links *a, View_ID v,
                                       View_Context *ctx){
    this->app = a;
    this->view = v;
    view_push_context(a, v, ctx);
}

View_Context_Block::~View_Context_Block(){
    view_pop_context(this->app, this->view);
}



static Character_Predicate
character_predicate_from_function(Character_Predicate_Function *func){
    Character_Predicate predicate = {};
    i32 byte_index = 0;
    for (u32 i = 0; i <= 255;){
        b8 v[8];
        for (i32 bit_index = 0; bit_index < 8; i += 1, bit_index += 1){
            v[bit_index] = func((u8)i);
        }
        predicate.b[byte_index] = ((v[0] << 0) |
                                   (v[1] << 1) |
                                   (v[2] << 2) |
                                   (v[3] << 3) |
                                   (v[4] << 4) |
                                   (v[5] << 5) |
                                   (v[6] << 6) |
                                   (v[7] << 7));
        byte_index += 1;
    }
    return(predicate);
}

static Character_Predicate
character_predicate_from_character(u8 character){
    Character_Predicate predicate = {};
    predicate.b[character/8] = (1 << (character%8));
    return(predicate);
}



static Character_Predicate
character_predicate_or(Character_Predicate *a, Character_Predicate *b){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = a->b[i] | b->b[i];
    }
    return(p);
}

static Character_Predicate
character_predicate_and(Character_Predicate *a, Character_Predicate *b){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = a->b[i] & b->b[i];
    }
    return(p);
}

static Character_Predicate
character_predicate_not(Character_Predicate *a){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = ~(a->b[i]);
    }
    return(p);
}

static i64
buffer_seek_character_class_change__inner(Application_Links *app, Buffer_ID buffer, Character_Predicate *positive, Character_Predicate *negative, Scan_Direction direction, i64 start_pos){
    i64 pos = start_pos;
    switch (direction){
        case Scan_Backward:
        {
            String_Match m1 = buffer_seek_character_class(app, buffer, negative, direction, pos);
            String_Match m2 = buffer_seek_character_class(app, buffer, positive, direction, m1.range.min);
            pos = m2.range.min;
            if (m1.buffer == buffer && m2.buffer == buffer){
                pos += 1;
            }
        }break;
        case Scan_Forward:
        {
            pos -= 1;
            String_Match m1 = buffer_seek_character_class(app, buffer, positive, direction, pos);
            String_Match m2 = buffer_seek_character_class(app, buffer, negative, direction, m1.range.min);
            pos = m2.range.min;
        }break;
    }
    return(pos);
}

static i64
buffer_seek_character_class_change_1_0(Application_Links *app, Buffer_ID buffer, Character_Predicate *predicate, Scan_Direction direction, i64 start_pos){
    Character_Predicate negative = character_predicate_not(predicate);
    return(buffer_seek_character_class_change__inner(app, buffer, predicate, &negative, direction, start_pos));
}

static i64
buffer_seek_character_class_change_0_1(Application_Links *app, Buffer_ID buffer, Character_Predicate *predicate, Scan_Direction direction, i64 start_pos){
    Character_Predicate negative = character_predicate_not(predicate);
    return(buffer_seek_character_class_change__inner(app, buffer, &negative, predicate, direction, start_pos));
}



static i64
view_pos_from_xy(Application_Links *app, View_ID view, Vec2_f32 p){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Rect_f32 region = view_get_buffer_region(app, view);
    f32 width = rect_width(region);
    Face_ID face_id = get_face_id(app, buffer);
    Buffer_Scroll scroll_vars = view_get_buffer_scroll(app, view);
    i64 line = scroll_vars.position.line_number;
    p = (p - region.p0) + scroll_vars.position.pixel_shift;
    return(buffer_pos_at_relative_xy(app, buffer, width, face_id, line, p));
}

static Buffer_Point
view_move_buffer_point(Application_Links *app, View_ID view, Buffer_Point buffer_point, Vec2_f32 delta){
    delta += buffer_point.pixel_shift;
    Line_Shift_Vertical shift = view_line_shift_y(app, view, buffer_point.line_number, delta.y);
    buffer_point.line_number = shift.line;
    buffer_point.pixel_shift = V2f32(delta.x, delta.y - shift.y_delta);
    return(buffer_point);
}

static void
view_zero_scroll(Application_Links *app, View_ID view){
    Buffer_Scroll scroll = {};
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
}

static Vec2_f32
view_relative_xy_of_pos(Application_Links *app, View_ID view, i64 base_line, i64 pos){
    Rect_f32 rect = view_relative_box_of_pos(app, view, base_line, pos);
    return(rect_center(rect));
}

static void
view_set_cursor_and_preferred_x(Application_Links *app, View_ID view, Buffer_Seek seek){
    view_set_cursor(app, view, seek);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek);
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, cursor.pos);
    view_set_preferred_x(app, view, p.x);
}

static i64
view_set_pos_by_character_delta(Application_Links *app, View_ID view, i64 pos, i64 character_delta){
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
    i64 new_pos = view_pos_from_relative_character(app, view, cursor.line, character + character_delta);
    return(new_pos);
}

static i64
view_set_cursor_by_character_delta(Application_Links *app, View_ID view, i64 character_delta){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, character_delta);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    return(new_pos);
}

static i64
view_correct_cursor(Application_Links *app, View_ID view){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, 0);
    view_set_cursor(app, view, seek_pos(new_pos));
    return(new_pos);
}

static i64
view_correct_mark(Application_Links *app, View_ID view){
    i64 pos = view_get_mark_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, 0);
    view_set_mark(app, view, seek_pos(new_pos));
    return(new_pos);
}

static Vec2_f32
buffer_point_difference(Application_Links *app, Buffer_ID buffer, f32 width, Face_ID face_id,
                        Buffer_Point a, Buffer_Point b){
    f32 y_difference = buffer_line_y_difference(app, buffer, width, face_id, a.line_number, b.line_number);
    Vec2_f32 result = a.pixel_shift - b.pixel_shift;
    result.y += y_difference;
    return(result);
}

static Vec2_f32
view_point_difference(Application_Links *app, View_ID view, Buffer_Point a, Buffer_Point b){
    f32 y_difference = view_line_y_difference(app, view, a.line_number, b.line_number);
    Vec2_f32 result = a.pixel_shift - b.pixel_shift;
    result.y += y_difference;
    return(result);
}



static Range_i64
buffer_range(Application_Links *app, Buffer_ID buffer){
    Range_i64 range = {};
    range.end = buffer_get_size(app, buffer);
    return(range);
}

static i64
buffer_side(Application_Links *app, Buffer_ID buffer, Side side){
    return(range_side(buffer_range(app, buffer), side));
}

static Range_i64
get_view_range(Application_Links *app, View_ID view){
    return(Ii64(view_get_cursor_pos(app, view), view_get_mark_pos(app, view)));
}

static void
set_view_range(Application_Links *app, View_ID view, Range_i64 range){
    i64 c = view_get_cursor_pos(app, view);
    i64 m = view_get_mark_pos(app, view);
    if (c < m){
        view_set_cursor_and_preferred_x(app, view, seek_pos(range.min));
        view_set_mark(app, view, seek_pos(range.max));
    }
    else{
        view_set_mark(app, view, seek_pos(range.min));
        view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
    }
}

static b32
is_valid_line(Application_Links *app, Buffer_ID buffer_id, i64 line){
    i64 max_line = buffer_get_line_count(app, buffer_id);
    return(1 <= line && line <= max_line);
}

static b32
is_valid_line_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 range){
    i64 max_line = buffer_get_line_count(app, buffer_id);
    return(1 <= range.first && range.first <= range.end && range.end <= max_line);
}

static i64
get_line_number_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));
    return(cursor.line);
}

static i64
buffer_get_character_legal_pos_from_pos(Application_Links *app, Buffer_ID buffer, f32 width, Face_ID face, i64 pos){
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));
    i64 character = buffer_relative_character_from_pos(app, buffer, width, face, cursor.line, pos);
    return(buffer_pos_from_relative_character(app, buffer, width, face, cursor.line, character));
}

static i64
view_get_character_legal_pos_from_pos(Application_Links *app, View_ID view, i64 pos){
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 character = view_relative_character_from_pos(app, view, cursor.line, pos);
    return(view_pos_from_relative_character(app, view, cursor.line, character));
}

static Buffer_Cursor
get_line_side(Application_Links *app, Buffer_ID buffer, i64 line_number, Side side){
    i64 character_index = (side == Side_Min)?(1):(-1);
    return(buffer_compute_cursor(app, buffer, seek_line_col(line_number, character_index)));
}
static i64
get_line_side_pos(Application_Links *app, Buffer_ID buffer, i64 line_number, Side side){
    i64 pos = -1;
    Buffer_Cursor cursor = get_line_side(app, buffer, line_number, side);
    if (cursor.line != 0){
        pos = cursor.pos;
    }
    return(pos);
}

static Buffer_Cursor
get_line_start(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side(app, buffer, line_number, Side_Min));
}
static i64
get_line_start_pos(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side_pos(app, buffer, line_number, Side_Min));
}



static Buffer_Cursor
get_line_end(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side(app, buffer, line_number, Side_Max));
}
static i64
get_line_end_pos(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side_pos(app, buffer, line_number, Side_Max));
}


static Range_Cursor
get_line_range(Application_Links *app, Buffer_ID buffer, i64 line_number){
    b32 success = false;
    Range_Cursor result = {};
    result.start = get_line_start(app, buffer, line_number);
    if (result.start.line != 0){
        result.end = get_line_end(app, buffer, line_number);
        if (result.end.line != 0){
            success = true;
        }
    }
    if (!success){
        block_zero((&result), sizeof(*(&result)));
    }
    return(result);
}


static Range_i64
get_line_pos_range(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Range_Cursor range = get_line_range(app, buffer, line_number);
    Range_i64 result = {};
    if (range.start.line != 0 && range.end.line != 0){
        result = Ii64(range.start.pos, range.end.pos);
    }
    return(result);
}

static Range_i64
make_range_from_cursors(Range_Cursor range){
    return(Ii64(range.start.pos, range.end.pos));
}

static i64
get_line_side_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos, Side side){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    return(get_line_side_pos(app, buffer, line_number, side));
}
static i64
get_line_start_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(get_line_side_pos_from_pos(app, buffer, pos, Side_Min));
}
static i64
get_line_end_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(get_line_side_pos_from_pos(app, buffer, pos, Side_Max));
}

static Token*
get_first_token_from_line(Application_Links *app, Buffer_ID buffer, Token_Array tokens, i64 line){
    i64 line_start = get_line_start_pos(app, buffer, line);
    return(token_from_pos(&tokens, line_start));
}



static i64
scan_any_boundary(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, Scan_Direction direction, i64 pos){
    i64 a = func(app, buffer, Side_Min, direction, pos);
    i64 b = func(app, buffer, Side_Max, direction, pos);
    i64 result = 0;
    if (direction == Scan_Forward){
        result = (((a)<(b))?(a):(b));
    }
    else{
        result = (((a)>(b))?(a):(b));
    }
    return(result);
}

static i64
scan(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, Scan_Direction direction, i64 pos){
    Side side = (direction == Scan_Forward)?(Side_Max):(Side_Min);
    return(func(app, buffer, side, direction, pos));
}

static i64
scan(Application_Links *app, Boundary_Function_List funcs, Buffer_ID buffer, Scan_Direction direction, i64 start_pos){
    i64 result = 0;
    if (direction == Scan_Forward){
        i64 size = buffer_get_size(app, buffer);
        result = size + 1;
        for (Boundary_Function_Node *node = funcs.first;
             node != 0;
             node = node->next){
            i64 pos = scan(app, node->func, buffer, direction, start_pos);
            result = (((result)<(pos))?(result):(pos));
        }
    }
    else{
        result = -1;
        for (Boundary_Function_Node *node = funcs.first;
             node != 0;
             node = node->next){
            i64 pos = scan(app, node->func, buffer, direction, start_pos);
            result = (((result)>(pos))?(result):(pos));
        }
    }
    return(result);
}

static void
push_boundary(Arena *arena, Boundary_Function_List *list, Boundary_Function *func){
    Boundary_Function_Node *node = ((Boundary_Function_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Boundary_Function_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "490" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "490" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    node->func = func;
}

static Boundary_Function_List
push_boundary_list__innerv(Arena *arena, va_list args){
    Boundary_Function_List list = {};
    for (;;){
        Boundary_Function *func = 
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
                                 __builtin_va_arg(
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                                 args
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
                                 ,
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                                 Boundary_Function*
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
                                 )
# 500 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                                                                 ;
        if (func == 0){
            break;
        }
        push_boundary(arena, &list, func);
    }
    return(list);
}
static Boundary_Function_List
push_boundary_list__inner(Arena *arena, ...){
    va_list args;
    
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
   __builtin_va_start(
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
   args
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
   ,
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
   arena
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
   )
# 511 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                        ;
    Boundary_Function_List result = push_boundary_list__innerv(arena, args);
    
# 513 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
   __builtin_va_end(
# 513 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
   args
# 513 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
   )
# 513 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
               ;
    return(result);
}


static i64
boundary_predicate(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos, Character_Predicate *predicate){
    i64 result = 0;
    switch (side){
        case Side_Min:
        {
            result = buffer_seek_character_class_change_0_1(app, buffer, predicate, direction, pos);
        }break;
        case Side_Max:
        {
            result = buffer_seek_character_class_change_1_0(app, buffer, predicate, direction, pos);
        }break;
    }
    return(result);
}

static i64
boundary_non_whitespace(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_non_whitespace));
}

static i64
boundary_base10(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_base10));
}

static i64
boundary_base10_colon(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    static Character_Predicate predicate = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        Character_Predicate colon = character_predicate_from_character((u8)':');
        predicate = character_predicate_or(&character_predicate_base10, &colon);
    }
    return(boundary_predicate(app, buffer, side, direction, pos, &predicate));
}

static i64
boundary_base16(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_base16));
}

static i64
boundary_alpha_numeric(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric));
}

static i64
boundary_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_utf8));
}

static i64
boundary_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore));
}

static i64
boundary_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore_utf8));
}

static i64
boundary_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 an_pos = boundary_alpha_numeric(app, buffer, side, direction, pos);
    String_Match m = buffer_seek_character_class(app, buffer, &character_predicate_uppercase, direction, pos);
    i64 cap_pos = m.range.min;
    if (side == Side_Max){
        i64 an_left_pos = boundary_alpha_numeric(app, buffer, flip_side(side), flip_direction(direction), an_pos);
        if (cap_pos == an_left_pos){
            m = buffer_seek_character_class(app, buffer, &character_predicate_uppercase, direction, cap_pos);
            cap_pos = m.range.min;
        }
    }
    i64 result = 0;
    if (direction == Scan_Backward){
        result = (((an_pos)>(cap_pos))?(an_pos):(cap_pos));
    }
    else{
        result = (((an_pos)<(cap_pos))?(an_pos):(cap_pos));
    }
    return(result);
}

static i64
boundary_inside_quotes(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    static Character_Predicate predicate = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        predicate = character_predicate_from_character((u8)'"');
        predicate = character_predicate_not(&predicate);
    }
    return(boundary_predicate(app, buffer, side, direction, pos, &predicate));
}

static i64
boundary_token(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 result = boundary_non_whitespace(app, buffer, side, direction, pos);
    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    if (tokens.tokens != 0){
        switch (direction){
            case Scan_Forward:
            {
                i64 buffer_size = buffer_get_size(app, buffer);
                result = buffer_size;
                if (tokens.count > 0){
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);
                    if (token->kind == TokenBaseKind_Whitespace){
                        token_it_inc_non_whitespace(&it);
                        token = token_it_read(&it);
                    }
                    if (token != 0){
                        if (side == Side_Max){
                            result = token->pos + token->size;
                        }
                        else{
                            if (token->pos <= pos){
                                token_it_inc_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            if (token != 0){
                                result = token->pos;
                            }
                        }
                    }
                }
            }break;

            case Scan_Backward:
            {
                result = 0;
                if (tokens.count > 0){
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);
                    if (token->kind == TokenBaseKind_Whitespace){
                        token_it_dec_non_whitespace(&it);
                        token = token_it_read(&it);
                    }
                    if (token != 0){
                        if (side == Side_Min){
                            if (token->pos >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos;
                        }
                        else{
                            if (token->pos + token->size >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos + token->size;
                        }
                    }
                }
            }break;
        }
    }
    return(result);
}

static i64
boundary_line(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    i64 new_pos = get_line_side_pos(app, buffer, line_number, side);
    if (direction == Scan_Backward && new_pos >= pos){
        if (line_number > 1){
            new_pos = get_line_side_pos(app, buffer, line_number - 1, side);
        }
        else{
            new_pos = 0;
        }
    }
    else if (direction == Scan_Forward && new_pos <= pos){
        new_pos = get_line_side_pos(app, buffer, line_number + 1, side);
        if (new_pos <= pos){
            new_pos = (i32)buffer_get_size(app, buffer);
        }
    }
    return(new_pos);
}




static void
seek_string_forward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 end, String_Const_u8 needle, i64 *result){
    if (end == 0){
        end = (i32)buffer_get_size(app, buffer);
    }
    String_Match match = {};
    match.range.first = pos;
    for (;;){
        match = buffer_seek_string(app, buffer, needle, Scan_Forward, (i32)match.range.first);
        if ((((match.flags)&(StringMatch_CaseSensitive))!=0) ||
            match.buffer != buffer || match.range.first >= end) break;
    }
    if (match.range.first < end && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = buffer_get_size(app, buffer);
    }
}

static void
seek_string_backward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 min, String_Const_u8 needle, i64 *result){
    String_Match match = {};
    match.range.first = pos;
    for (;;){
        match = buffer_seek_string(app, buffer, needle, Scan_Backward, match.range.first);
        if ((((match.flags)&(StringMatch_CaseSensitive))!=0) ||
            match.buffer != buffer || match.range.first < min) break;
    }
    if (match.range.first >= min && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = -1;
    }
}

static void
seek_string_insensitive_forward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 end, String_Const_u8 needle, i64 *result){
    if (end == 0){
        end = (i32)buffer_get_size(app, buffer);
    }
    String_Match match = buffer_seek_string(app, buffer, needle, Scan_Forward, pos);
    if (match.range.first < end && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = buffer_get_size(app, buffer);
    }
}

static void
seek_string_insensitive_backward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 min, String_Const_u8 needle, i64 *result){
    String_Match match = buffer_seek_string(app, buffer, needle, Scan_Backward, pos);
    if (match.range.first >= min && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = -1;
    }
}

static void
seek_string(Application_Links *app, Buffer_ID buffer_id, i64 pos, i64 end, i64 min, String_Const_u8 str, i64 *result, Buffer_Seek_String_Flags flags){
    switch (flags & 3){
        case 0:
        {
            seek_string_forward(app, buffer_id, pos, end, str, result);
        }break;

        case BufferSeekString_Backward:
        {
            seek_string_backward(app, buffer_id, pos, min, str, result);
        }break;

        case BufferSeekString_CaseInsensitive:
        {
            seek_string_insensitive_forward(app, buffer_id, pos, end, str, result);
        }break;

        case BufferSeekString_Backward|BufferSeekString_CaseInsensitive:
        {
            seek_string_insensitive_backward(app, buffer_id, pos, min, str, result);
        }break;
    }
}



static Range_i64
get_line_range_from_pos_range(Application_Links *app, Buffer_ID buffer, Range_i64 pos_range){
    Range_i64 line_range = {};
    line_range.first = get_line_number_from_pos(app, buffer, pos_range.first);
    if (line_range.first != 0){
        line_range.end = get_line_number_from_pos(app, buffer, pos_range.one_past_last);
        if (line_range.end == 0){
            line_range.first = 0;
        }
    }
    return(line_range);
}



static Range_i64
get_pos_range_from_line_range(Application_Links *app, Buffer_ID buffer, Range_i64 line_range){
    Range_i64 pos_range = {};
    if (is_valid_line_range(app, buffer, line_range)){
        pos_range.first = get_line_start_pos(app, buffer, line_range.first);
        pos_range.one_past_last = get_line_end_pos(app, buffer, line_range.end);
    }
    return(pos_range);
}

static Range_i64
enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                 Boundary_Function *func){
    i64 new_min = func(app, buffer, Side_Min, Scan_Backward, range.min + 1);
    i64 new_min_check = func(app, buffer, Side_Max, Scan_Backward, range.min + 1);
    if (new_min_check <= new_min && new_min < range.min){
        range.min = new_min;
    }
    i64 new_max = func(app, buffer, Side_Max, Scan_Forward, range.max - 1);
    i64 new_max_check = func(app, buffer, Side_Min, Scan_Forward, range.max);
    if (new_max_check >= new_max && new_max > range.max){
        range.max = new_max;
    }
    return(range);
}

static Range_i64
left_enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                      Boundary_Function *func){
    i64 new_min = func(app, buffer, Side_Min, Scan_Backward, range.min + 1);
    i64 new_min_check = func(app, buffer, Side_Max, Scan_Backward, range.min + 1);
    if (new_min_check <= new_min && new_min < range.min){
        range.min = new_min;
    }
    return(range);
}

static Range_i64
right_enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                       Boundary_Function *func){
    i64 new_max = func(app, buffer, Side_Max, Scan_Forward, range.max - 1);
    i64 new_max_check = func(app, buffer, Side_Min, Scan_Forward, range.max - 1);
    if (new_max_check >= new_max && new_max > range.max){
        range.max = new_max;
    }
    return(range);
}

static Range_i64
enclose_non_whitespace(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_non_whitespace));
}
static Range_i64
enclose_pos_non_whitespace(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_non_whitespace));
}

static Range_i64
enclose_tokens(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_token));
}
static Range_i64
enclose_pos_tokens(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_token));
}

static Range_i64
enclose_base10(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base10));
}
static Range_i64
enclose_pos_base10(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base10));
}

static Range_i64
enclose_base16(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base16));
}
static Range_i64
enclose_pos_base16(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base16));
}

static Range_i64
enclose_base10_colon(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base10_colon));
}
static Range_i64
enclose_pos_base10_colon(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base10_colon));
}

static Range_i64
enclose_alpha_numeric(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric));
}
static Range_i64
enclose_pos_alpha_numeric(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric));
}

static Range_i64
enclose_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_unicode));
}
static Range_i64
enclose_pos_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_unicode));
}

static Range_i64
enclose_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore));
}
static Range_i64
enclose_pos_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_underscore));
}
static Range_i64
right_enclose_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer,
                                       Range_i64 range){
    return(right_enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore));
}

static Range_i64
enclose_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore_utf8));
}
static Range_i64
enclose_pos_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_underscore_utf8));
}
static Range_i64
right_enclose_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer,
                                            Range_i64 range){
    return(right_enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore_utf8));
}


static Range_i64
enclose_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_camel));
}
static Range_i64
enclose_pos_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_camel));
}

static Range_i64
enclose_pos_inside_quotes(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_inside_quotes));
}

static Range_i64
enclose_whole_lines(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_line));
}
static Range_i64
enclose_pos_whole_lines(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_line));
}



static Range_i64
get_snipe_range(Application_Links *app, Boundary_Function_List funcs, Buffer_ID buffer, i64 pos, Scan_Direction direction){
    Range_i64 result = {};
    i64 buffer_size = buffer_get_size(app, buffer);
    i64 pos0 = pos;
    i64 pos1 = scan(app, funcs, buffer, direction, pos0);
    if (0 <= pos1 && pos1 <= buffer_size){
        i64 pos2 = scan(app, funcs, buffer, flip_direction(direction), pos1);
        if (0 <= pos2 && pos2 <= buffer_size){
            if (direction == Scan_Backward){
                pos2 = (((pos2)>(pos0))?(pos2):(pos0));
            }
            else{
                pos2 = (((pos2)<(pos0))?(pos2):(pos0));
            }
            result = Ii64(pos1, pos2);
        }
    }
    return(result);
}

static Range_i64
get_snipe_range(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, i64 pos, Scan_Direction direction){
    Scratch_Block scratch(app);
    return(get_snipe_range(app, push_boundary_list__inner((scratch), func, 0), buffer, pos, direction));
}



static String_Const_u8
push_buffer_range(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range){
    String_Const_u8 result = {};
    i64 length = range_size(range);
    if (length > 0){
        Temp_Memory restore_point = begin_temp(arena);
        u8 *memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(length), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "1010" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "1010" ":") - 1)))));
        if (buffer_read_range(app, buffer, range, memory)){
            result = SCu8(memory, length);
        }
        else{
            end_temp(restore_point);
        }
    }
    return(result);
}

static String_Const_u8
push_token_lexeme(Application_Links *app, Arena *arena, Buffer_ID buffer, Token *token){
    return(push_buffer_range(app, arena, buffer, Ii64(token)));
}

static String_Const_u8
push_buffer_line(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 line_number){







    String_Const_u8 string = push_buffer_range(app, arena, buffer, get_line_pos_range(app, buffer, line_number));
    for (;string.size > 0 && string.str[string.size - 1] == '\r';){
        string.size -= 1;
    }
    return(string);
}

static String_Const_u8
push_whole_buffer(Application_Links *app, Arena *arena, Buffer_ID buffer){
    return(push_buffer_range(app, arena, buffer, buffer_range(app, buffer)));
}

static String_Const_u8
push_view_range_string(Application_Links *app, Arena *arena, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    return(push_buffer_range(app, arena, buffer, get_view_range(app, view)));
}

static String_Const_u8
push_view_range_string(Application_Links *app, Arena *arena){
    View_ID view = get_active_view(app, Access_Always);
    return(push_view_range_string(app, arena, view));
}

static String_Const_u8
push_enclose_range_at_pos(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos, Enclose_Function *enclose){
    Range_i64 range = enclose(app, buffer, Ii64(pos));
    return(push_buffer_range(app, arena, buffer, range));
}



static String_Const_u8
token_it_lexeme(Application_Links *app, Arena *arena, Token_Iterator_Array *it){
    String_Const_u8 result = {};
    Token *token = token_it_read(it);
    if (token != 0){
        result = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static b32
token_it_check_and_get_lexeme(Application_Links *app, Arena *arena, Token_Iterator_Array *it, Token_Base_Kind kind, String_Const_u8 *lexeme_out){
    Token *token = token_it_read(it);
    b32 result = {};
    if (token != 0 && token->kind == kind){
        result = true;
        *lexeme_out = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static String_Const_u8
token_it_lexeme(Application_Links *app, Arena *arena, Token_Iterator_List *it){
    String_Const_u8 result = {};
    Token *token = token_it_read(it);
    if (token != 0){
        result = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static b32
token_it_check_and_get_lexeme(Application_Links *app, Arena *arena, Token_Iterator_List *it, Token_Base_Kind kind, String_Const_u8 *lexeme_out){
    Token *token = token_it_read(it);
    b32 result = {};
    if (token != 0 && token->kind == kind){
        result = true;
        *lexeme_out = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}



static b32
buffer_has_name_with_star(Application_Links *app, Buffer_ID buffer){
    Scratch_Block scratch(app);
    String_Const_u8 str = push_buffer_unique_name(app, scratch, buffer);
    return(str.size > 0 && str.str[0] == '*');
}

static u8
buffer_get_char(Application_Links *app, Buffer_ID buffer_id, i64 pos){
    i64 buffer_size = buffer_get_size(app, buffer_id);
    u8 result = ' ';
    if (0 <= pos && pos < buffer_size){
        buffer_read_range(app, buffer_id, Ii64(pos, pos + 1), &result);
    }
    return(result);
}

static b32
line_is_valid_and_blank(Application_Links *app, Buffer_ID buffer, i64 line_number){
    b32 result = false;
    if (is_valid_line(app, buffer, line_number)){
        Scratch_Block scratch(app);
        String_Const_u8 line = push_buffer_line(app, scratch, buffer, line_number);
        result = true;
        for (u64 i = 0; i < line.size; i += 1){
            if (!character_is_whitespace(line.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}



static i64
get_pos_past_lead_whitespace_from_line_number(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Scratch_Block scratch(app);
    Range_i64 line_range = get_line_pos_range(app, buffer, line_number);
    String_Const_u8 line = push_buffer_range(app, scratch, buffer, line_range);
    i64 result = line_range.end;
    for (u64 i = 0; i < line.size; i += 1){
        if (!character_is_whitespace(line.str[i])){
            result = line_range.start + i;
            break;
        }
    }
    return(result);
}

static i64
get_pos_past_lead_whitespace(Application_Links *app, Buffer_ID buffer, i64 pos){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    i64 result = get_pos_past_lead_whitespace_from_line_number(app, buffer, line_number);
    result = (((pos)>(result))?(pos):(result));
    return(result);
}

static void
move_past_lead_whitespace(Application_Links *app, View_ID view, Buffer_ID buffer){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_pos_past_lead_whitespace(app, buffer, pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
}

static void
move_past_lead_whitespace(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    move_past_lead_whitespace(app, view, buffer);
}

static b32
line_is_blank(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Scratch_Block scratch(app);
    String_Const_u8 line = push_buffer_line(app, scratch, buffer, line_number);
    b32 is_blank = true;
    for (u64 i = 0; i < line.size; i += 1){
        if (!character_is_whitespace(line.str[i])){
            is_blank = false;
            break;
        }
    }
    return(is_blank);
}

static i64
get_line_number_of__whitespace_status_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start, b32 get_blank_line){
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_number = line_number_start + direction;
    for (;1 <= line_number && line_number <= line_count; line_number += direction){
        b32 is_blank = line_is_blank(app, buffer, line_number);
        if (is_blank == get_blank_line){
            break;
        }
    }
    line_number = (((1)>(line_number))?(1):(((line_count)<(line_number))?(line_count):(line_number)));
    return(line_number);
}

static i64
get_line_number_of_non_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    return(get_line_number_of__whitespace_status_line(app, buffer, direction, line_number_start, false));
}

static i64
get_line_number_of_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    return(get_line_number_of__whitespace_status_line(app, buffer, direction, line_number_start, true));
}

static i64
get_pos_of_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos_start){
    i64 line_number_start = get_line_number_from_pos(app, buffer, pos_start);
    i64 blank_line = get_line_number_of_blank_line(app, buffer, direction, line_number_start);
    i64 pos = get_line_start_pos(app, buffer, blank_line);
    return(pos);
}

static i64
get_line_number_of_blank_line_grouped(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    i64 line_number = line_number_start;
    if (line_is_blank(app, buffer, line_number)){
        line_number = get_line_number_of_non_blank_line(app, buffer, direction, line_number);
    }
    line_number = get_line_number_of_blank_line(app, buffer, direction, line_number);
    return(line_number);
}

static i64
get_pos_of_blank_line_grouped(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos_start){
    i64 line_number_start = get_line_number_from_pos(app, buffer, pos_start);
    i64 blank_line = get_line_number_of_blank_line_grouped(app, buffer, direction, line_number_start);
    i64 pos = get_line_start_pos(app, buffer, blank_line);
    return(pos);
}

static Indent_Info
get_indent_info_range(Application_Links *app, Buffer_ID buffer, Range_i64 range, i32 tab_width){
    Scratch_Block scratch(app);
    String_Const_u8 s = push_buffer_range(app, scratch, buffer, range);

    Indent_Info info = {};
    info.first_char_pos = range.end;
    info.is_blank = true;
    info.all_space = true;

    for (u64 i = 0; i < s.size; i += 1){
        u8 c = s.str[i];
        if (!character_is_whitespace(c)){
            info.is_blank = false;
            info.all_space = false;
            info.first_char_pos = range.start + (i64)i;
            break;
        }
        if (c == ' '){
            info.indent_pos += 1;
        }
        else{
            info.all_space = false;
        }
        if (c == '\t'){
            info.indent_pos += tab_width;
        }
    }

    return(info);
}

static Indent_Info
get_indent_info_line_number_and_start(Application_Links *app, Buffer_ID buffer, i64 line_number, i64 line_start, i32 tab_width){
    i64 end = get_line_side_pos(app, buffer, line_number, Side_Max);
    return(get_indent_info_range(app, buffer, Ii64(line_start, end), tab_width));
}



static History_Group
history_group_begin(Application_Links *app, Buffer_ID buffer){
    History_Group group = {};
    group.app = app;
    group.buffer = buffer;
    group.first = buffer_history_get_current_state_index(app, buffer);
    group.first += 1;
    return(group);
}

static void
history_group_end(History_Group group){
    History_Record_Index last = buffer_history_get_current_state_index(group.app, group.buffer);
    if (group.first < last){
        buffer_history_merge_record_range(group.app, group.buffer, group.first, last, RecordMergeFlag_StateInRange_MoveStateForward);
    }
}



static void
replace_in_range(Application_Links *app, Buffer_ID buffer, Range_i64 range, String_Const_u8 needle, String_Const_u8 string){

    History_Group group = history_group_begin(app, buffer);
    i64 pos = range.min - 1;
    i64 new_pos = 0;
    seek_string_forward(app, buffer, pos, range.end, needle, &new_pos);
    i64 shift = replace_range_shift(needle.size, string.size);
    for (; new_pos + (i64)needle.size <= range.end;){
        Range_i64 needle_range = Ii64(new_pos, new_pos + (i32)needle.size);
        buffer_replace_range(app, buffer, needle_range, string);
        range.end += shift;
        pos = new_pos + (i32)string.size - 1;
        seek_string_forward(app, buffer, pos, range.end, needle, &new_pos);
    }
    history_group_end(group);
}

static Range_i64
swap_lines(Application_Links *app, Buffer_ID buffer, i64 line_1, i64 line_2){
    Range_i64 result = {};
    i64 line_count = buffer_get_line_count(app, buffer);
    if (1 <= line_1 && line_2 <= line_count){
        Range_i64 range_1 = get_line_pos_range(app, buffer, line_1);
        Range_i64 range_2 = get_line_pos_range(app, buffer, line_2);

        Scratch_Block scratch(app);

        String_Const_u8 text_1 = push_buffer_range(app, scratch, buffer, range_1);
        String_Const_u8 text_2 = push_buffer_range(app, scratch, buffer, range_2);

        History_Group group = history_group_begin(app, buffer);
        buffer_replace_range(app, buffer, range_2, text_1);
        buffer_replace_range(app, buffer, range_1, text_2);
        history_group_end(group);

        i64 shift = replace_range_shift(range_1, text_2.size);
        result.min = range_1.min;
        result.max = range_2.min + shift;
    }
    return(result);
}

static i64
move_line(Application_Links *app, Buffer_ID buffer, i64 line_number, Scan_Direction direction){
    i64 line_1 = 0;
    i64 line_2 = 0;
    if (direction == Scan_Forward){
        line_1 = line_number;
        line_2 = line_number + 1;
    }
    else{
        line_1 = line_number - 1;
        line_2 = line_number;
    }
    Range_i64 line_starts = swap_lines(app, buffer, line_1, line_2);
    i64 result = 0;
    if (line_starts.min < line_starts.max){
        if (direction == Scan_Forward){
            result = line_starts.max;
        }
        else{
            result = line_starts.min;
        }
    }
    else{
        result = get_line_side_pos(app, buffer, line_number, Side_Min);
    }
    return(result);
}

static void
clear_buffer(Application_Links *app, Buffer_ID buffer){
    buffer_replace_range(app, buffer, buffer_range(app, buffer), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}



static String_Match_List
find_all_matches_all_buffers(Application_Links *app, Arena *arena, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Match_List all_matches = {};
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        String_Match_List buffer_matches = {};
        for (i32 i = 0; i < match_patterns.count; i += 1){
            Range_i64 range = buffer_range(app, buffer);
            String_Match_List pattern_matches = buffer_find_all_matches(app, arena, buffer, i, range, match_patterns.vals[i],
                                                                        &character_predicate_alpha_numeric_underscore_utf8, Scan_Forward);
            string_match_list_filter_flags(&pattern_matches, must_have_flags, must_not_have_flags);
            if (pattern_matches.count > 0){
                if (buffer_matches.count == 0){
                    buffer_matches = pattern_matches;
                }
                else{
                    buffer_matches = string_match_list_merge_front_to_back(&buffer_matches, &pattern_matches);
                }
            }
        }
        all_matches = string_match_list_join(&all_matches, &buffer_matches);
    }
    return(all_matches);
}

static String_Match_List
find_all_matches_all_buffers(Application_Links *app, Arena *arena, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Const_u8_Array array = {&pattern, 1};
    return(find_all_matches_all_buffers(app, arena, array, must_have_flags, must_not_have_flags));
}



static b32
is_modified(User_Input *input){
    return(is_modified(&input->event));
}

static String_Const_u8
to_writable(User_Input *in){
    return(to_writable(&in->event));
}

static b32
has_modifier(User_Input *in, Key_Code key_code){
    b32 result = false;
    Input_Modifier_Set *mods = get_modifiers(&in->event);
    if (mods != 0){
        result = has_modifier(mods, key_code);
    }
    return(result);
}

static b32
match_key_code(User_Input *in, Key_Code key_code){
    return(match_key_code(&in->event, key_code));
}

static b32
match_core_code(User_Input *in, Key_Code core_code){
    return(match_core_code(&in->event, core_code));
}

static String_Const_u8
backspace_utf8(String_Const_u8 string){
    if (string.size > 0){
        u64 i = string.size - 1;
        for (; i > 0; --i){
            if (string.str[i] <= 0x7F || string.str[i] >= 0xC0){
                break;
            }
        }
        string.size = i;
    }
    return(string);
}



static User_Input
get_next_input(Application_Links *app, Event_Property use_flags, Event_Property abort_flags){
    User_Input in = {};
    if (use_flags != 0){
        for (;;){
            in = get_next_input_raw(app);
            if (in.abort){
                break;
            }
            Event_Property event_flags = get_event_properties(&in.event);
            if ((event_flags & abort_flags) != 0){
                in.abort = true;
                break;
            }
            if ((event_flags & use_flags) != 0){
                break;
            }
        }
    }
    return(in);
}



Query_Bar_Group::Query_Bar_Group(Application_Links *app){
    this->app = app;
    this->view = get_active_view(app, Access_Always);
}

Query_Bar_Group::Query_Bar_Group(Application_Links *app, View_ID view){
    this->app = app;
    this->view = view;
}

Query_Bar_Group::~Query_Bar_Group(){
    clear_all_query_bars(this->app, this->view);
}

static b32
query_user_general(Application_Links *app, Query_Bar *bar, b32 force_number, String_Const_u8 init_string){
    if (start_query_bar(app, bar, 0) == 0){
        return(false);
    }

    if (init_string.size > 0){
        String_u8 string = Su8(bar->string.str, bar->string.size, bar->string_capacity);
        string_append(&string, init_string);
        bar->string.size = string.string.size;
    }

    b32 success = true;
    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any,
                                       EventProperty_Escape|EventProperty_MouseButton);
        if (in.abort){
            success = false;
            break;
        }

        Scratch_Block scratch(app);
        b32 good_insert = false;
        String_Const_u8 insert_string = to_writable(&in);
        if (insert_string.str != 0 && insert_string.size > 0){
            insert_string = string_replace(scratch, insert_string,
                                           SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)),
                                           SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            insert_string = string_replace(scratch, insert_string,
                                           SCu8((u8*)("\t"), (u64)(sizeof("\t") - 1)),
                                           SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            if (force_number){
                if (string_is_integer(insert_string, 10)){
                    good_insert = true;
                }
            }
            else{
                good_insert = true;
            }
        }

        if (in.event.kind == InputEventKind_KeyStroke &&
            (in.event.key.code == KeyCode_Return || in.event.key.code == KeyCode_Tab)){
            break;
        }
        else if (in.event.kind == InputEventKind_KeyStroke &&
                 in.event.key.code == KeyCode_Backspace){
            bar->string = backspace_utf8(bar->string);
        }
        else if (good_insert){
            String_u8 string = Su8(bar->string.str, bar->string.size, bar->string_capacity);
            string_append(&string, insert_string);
            bar->string.size = string.string.size;
        }
        else{

            View_ID view = get_this_ctx_view(app, Access_Always);
            View_Context ctx = view_current_context(app, view);
            Mapping *mapping = ctx.mapping;
            Command_Map *map = mapping_get_map(mapping, ctx.map_id);
            Command_Binding binding = map_get_binding_recursive(mapping, map, &in.event);
            if (binding.custom != 0){
                Command_Metadata *metadata = get_command_metadata(binding.custom);
                if (metadata != 0){
                    if (metadata->is_ui){
                        view_enqueue_command_function(app, view, binding.custom);
                        break;
                    }
                }
                binding.custom(app);
            }
            else{
                leave_current_input_unhandled(app);
            }
        }
    }

    return(success);
}

static b32
query_user_string(Application_Links *app, Query_Bar *bar){
    return(query_user_general(app, bar, false, string_u8_empty));
}

static b32
query_user_number(Application_Links *app, Query_Bar *bar){
    return(query_user_general(app, bar, true, string_u8_empty));
}

static b32
query_user_number(Application_Links *app, Query_Bar *bar, i32 x){
    Scratch_Block scratch(app);
    String_Const_u8 string = push_u8_stringf(scratch, "%d", x);
    return(query_user_general(app, bar, true, string));
}



static Buffer_Identifier
buffer_identifier(char *str, i32 len){
    Buffer_Identifier identifier;
    identifier.name = str;
    identifier.name_len = len;
    identifier.id = 0;
    return(identifier);
}

static Buffer_Identifier
buffer_identifier(String_Const_u8 str){
    return(buffer_identifier((char*)str.str, (i32)str.size));
}

static Buffer_Identifier
buffer_identifier(Buffer_ID id){
    Buffer_Identifier identifier;
    identifier.name = 0;
    identifier.name_len = 0;
    identifier.id = id;
    return(identifier);
}

static Buffer_ID
buffer_identifier_to_id(Application_Links *app, Buffer_Identifier identifier){
    Buffer_ID id = 0;
    if (identifier.id != 0){
        id = identifier.id;
    }
    else{
        String_Const_u8 name = SCu8(identifier.name, identifier.name_len);
        id = get_buffer_by_name(app, name, Access_Always);
        if (id == 0){
            id = get_buffer_by_file_name(app, name, Access_Always);
        }
    }
    return(id);
}

static Buffer_ID
buffer_identifier_to_id_create_out_buffer(Application_Links *app, Buffer_Identifier buffer_id){
    Buffer_ID result = 0;
    if (buffer_id.name != 0 && buffer_id.name_len > 0){
        String_Const_u8 buffer_name = SCu8(buffer_id.name, buffer_id.name_len);
        Buffer_ID buffer_attach_id = get_buffer_by_name(app, buffer_name, Access_Always);
        if (buffer_attach_id != 0){
            result = buffer_attach_id;
        }
        else{
            buffer_attach_id = create_buffer(app, buffer_name, BufferCreate_AlwaysNew|BufferCreate_NeverAttachToFile);
            if (buffer_attach_id != 0){
                buffer_set_setting(app, buffer_attach_id, BufferSetting_ReadOnly, true);
                buffer_set_setting(app, buffer_attach_id, BufferSetting_Unimportant, true);
                result = buffer_attach_id;
            }
        }
    }
    else{
        result = buffer_id.id;
    }
    return(result);
}



static void
place_begin_and_end_on_own_lines(Application_Links *app, char *begin, char *end){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    Range_i64 range = get_view_range(app, view);
    Range_i64 lines = get_line_range_from_pos_range(app, buffer, range);
    range = get_pos_range_from_line_range(app, buffer, lines);

    Scratch_Block scratch(app);

    b32 min_line_blank = line_is_valid_and_blank(app, buffer, lines.min);
    b32 max_line_blank = line_is_valid_and_blank(app, buffer, lines.max);

    if ((lines.min < lines.max) || (!min_line_blank)){
        String_Const_u8 begin_str = {};
        String_Const_u8 end_str = {};

        i64 min_adjustment = 0;
        i64 max_adjustment = 0;

        if (min_line_blank){
            begin_str = push_u8_stringf(scratch, "\n%s", begin);
            min_adjustment += 1;
        }
        else{
            begin_str = push_u8_stringf(scratch, "%s\n", begin);
        }
        if (max_line_blank){
            end_str = push_u8_stringf(scratch, "%s\n", end);
        }
        else{
            end_str = push_u8_stringf(scratch, "\n%s", end);
            max_adjustment += 1;
        }

        max_adjustment += begin_str.size;
        Range_i64 new_pos = Ii64(range.min + min_adjustment, range.max + max_adjustment);

        History_Group group = history_group_begin(app, buffer);
        buffer_replace_range(app, buffer, Ii64(range.min), begin_str);
        buffer_replace_range(app, buffer, Ii64(range.max + begin_str.size), end_str);
        history_group_end(group);

        set_view_range(app, view, new_pos);
    }
    else{
        String_Const_u8 str = push_u8_stringf(scratch, "%s\n\n%s", begin, end);
        buffer_replace_range(app, buffer, range, str);
        i64 center_pos = range.min + cstring_length(begin) + 1;
        view_set_cursor_and_preferred_x(app, view, seek_pos(center_pos));
        view_set_mark(app, view, seek_pos(center_pos));
    }
}



static Face_ID
get_view_face_id(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    return(get_face_id(app, buffer));
}

static Face_Metrics
get_view_face_metrics(Application_Links *app, View_ID view){
    Face_ID face = get_view_face_id(app, view);
    return(get_face_metrics(app, face));
}

static f32
get_view_line_height(Application_Links *app, View_ID view){
    Face_Metrics metrics = get_view_face_metrics(app, view);
    return(metrics.line_height);
}

static View_ID
open_view(Application_Links *app, View_ID view_location, View_Split_Position position){
    View_ID result = 0;
    if (view_location != 0 && view_exists(app, view_location)){
        Panel_ID panel_id = view_get_panel(app, view_location);
        if (panel_id != 0){
            Dimension split = (position == ViewSplit_Left ||
                               position == ViewSplit_Right)?Dimension_X:Dimension_Y;
            Side side = (position == ViewSplit_Left ||
                         position == ViewSplit_Top)?Side_Min:Side_Max;
            if (panel_split(app, panel_id, split)){
                Panel_ID new_panel_id = panel_get_child(app, panel_id, side);
                if (new_panel_id != 0){
                    View_ID new_view_id = panel_get_view(app, new_panel_id,
                                                         Access_Always);
                    if (new_view_id != 0){
                        result = new_view_id;
                    }
                }
            }
        }
    }
    return(result);
}

static View_ID
get_first_view_with_buffer(Application_Links *app, Buffer_ID buffer_id){
    View_ID result = {};
    if (buffer_id != 0){
        for (View_ID test = get_view_next(app, 0, Access_Always);
             test != 0;
             test = get_view_next(app, test, Access_Always)){
            Buffer_ID test_buffer = view_get_buffer(app, test, Access_Always);
            if (test_buffer == buffer_id){
                result = test;
                break;
            }
        }
    }
    return(result);
}

static b32
open_file(Application_Links *app, Buffer_ID *buffer_out, String_Const_u8 file_name, b32 background, b32 never_new){
    b32 result = false;
    Buffer_ID buffer = get_buffer_by_name(app, file_name, Access_ReadVisible);
    b32 exists = buffer_exists(app, buffer);
    if (!exists){
        Buffer_Create_Flag flags = 0;
        if (background){
            flags |= BufferCreate_Background;
        }
        if (never_new){
            flags |= BufferCreate_NeverNew;
        }
        buffer = create_buffer(app, file_name, flags);
        exists = buffer_exists(app, buffer);
    }
    if (exists){
        if (buffer_out != 0){
            *buffer_out = buffer;
        }
        result = true;
    }
    return(result);
}

static b32
view_open_file(Application_Links *app, View_ID view, String_Const_u8 file_name, b32 never_new){
    b32 result = false;
    if (view != 0){
        Buffer_ID buffer = 0;
        if (open_file(app, &buffer, file_name, false, never_new)){
            view_set_buffer(app, view, buffer, 0);
            result = true;
        }
    }
    return(result);
}

static void
view_disable_highlight_range(Application_Links *app, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
    if (*highlight != 0){
        managed_object_free(app, *highlight);
    }
    managed_scope_attachment_erase(app, scope, view_highlight_range);
    managed_scope_attachment_erase(app, scope, view_highlight_buffer);
}

static void
view_set_highlight_range(Application_Links *app, View_ID view, Range_i64 range){
    view_disable_highlight_range(app, view);

    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
    *highlight = alloc_buffer_markers_on_buffer(app, buffer, 2, &scope);
    Marker markers[2] = {};
    markers[0].pos = range.min;
    markers[1].pos = range.max;
    managed_object_store_data(app, *highlight, 0, 2, markers);
    Buffer_ID *highlight_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_highlight_buffer), sizeof(Buffer_ID)));
    *highlight_buffer = buffer;
}

static void
view_look_at_region(Application_Links *app, View_ID view, i64 major_pos, i64 minor_pos){
    Range_i64 range = Ii64(major_pos, minor_pos);
    b32 bottom_major = false;
    if (major_pos == range.max){
        bottom_major = true;
    }

    Buffer_Cursor top = view_compute_cursor(app, view, seek_pos(range.min));
    if (top.line > 0){
        Buffer_Cursor bottom = view_compute_cursor(app, view, seek_pos(range.max));
        if (bottom.line > 0){
            Rect_f32 region = view_get_buffer_region(app, view);
            f32 view_height = rect_height(region);
            f32 skirt_height = view_height*.1f;
            Range_f32 acceptable_y = If32(skirt_height, view_height*.9f);

            f32 target_height = view_line_y_difference(app, view, bottom.line + 1, top.line);

            f32 line_height = get_view_line_height(app, view);
            if (target_height + 2*line_height > view_height){
                i64 major_line = bottom.line;
                if (range.min == major_pos){
                    major_line = top.line;
                }

                Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
                scroll.target.line_number = major_line;
                scroll.target.pixel_shift.y = -skirt_height;
                view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
            }
            else{
                Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
                Vec2_f32 top_p = view_relative_xy_of_pos(app, view, scroll.position.line_number, range.min);
                top_p -= scroll.position.pixel_shift;
                if (top_p.y < acceptable_y.min){
                    scroll.target.line_number = top.line;
                    scroll.target.pixel_shift.y = -skirt_height;
                    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
                }
                else{
                    Vec2_f32 bot_p = view_relative_xy_of_pos(app, view, scroll.position.line_number, range.max);
                    bot_p -= scroll.position.pixel_shift;
                    if (bot_p.y > acceptable_y.max){
                        scroll.target.line_number = bottom.line;
                        scroll.target.pixel_shift.y = skirt_height - view_height;
                        view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
                    }
                }
            }
        }
    }
}

static void
view_look_at_region(Application_Links *app, View_ID view, Range_i64 range){
    view_look_at_region(app, view, range.min, range.max);
}



static Buffer_ID
get_buffer_next_looped(Application_Links *app, Buffer_ID buffer, Access_Flag access){
    buffer = get_buffer_next(app, buffer, access);
    if (buffer == 0){
        buffer = get_buffer_next(app, 0, access);
    }
    return(buffer);
}



static View_ID
get_next_view_looped_all_panels(Application_Links *app, View_ID view_id, Access_Flag access){
    view_id = get_view_next(app, view_id, access);
    if (view_id == 0){
        view_id = get_view_next(app, 0, access);
    }
    return(view_id);
}

static View_ID
get_prev_view_looped_all_panels(Application_Links *app, View_ID view_id, Access_Flag access){
    view_id = get_view_prev(app, view_id, access);
    if (view_id == 0){
        view_id = get_view_prev(app, 0, access);
    }
    return(view_id);
}



static Buffer_Kill_Result
try_buffer_kill(Application_Links *app, Buffer_ID buffer, View_ID gui_view_id, Buffer_Kill_Flag flags){
    Buffer_Kill_Result result = buffer_kill(app, buffer, flags);
    if (result == BufferKillResult_Dirty){
        if (do_buffer_kill_user_check(app, buffer, gui_view_id)){
            result = buffer_kill(app, buffer, BufferKill_AlwaysKill);
        }
    }
    return(result);
}



static String_Const_u8
get_query_string(Application_Links *app, char *query_str, u8 *string_space, i32 space_size){
    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)query_str);
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = space_size;
    if (!query_user_string(app, &bar)){
        bar.string.size = 0;
    }
    return(bar.string);
}

static Token*
get_token_from_pos(Application_Links *app, Token_Array *array, u64 pos){
    Token *result = 0;
    if (array->count > 0){
        i64 index = token_index_from_pos(array, pos);
        result = array->tokens + index;
    }
    return(result);
}

static Token*
get_token_from_pos(Application_Links *app, Buffer_ID buffer, u64 pos){
    Token_Array array = get_token_array_from_buffer(app, buffer);
    return(get_token_from_pos(app, &array, pos));
}

static String_Const_u8
push_token_or_word_under_pos(Application_Links *app, Arena *arena, Buffer_ID buffer, u64 pos){
    String_Const_u8 result = {};
    Token *token = get_token_from_pos(app, buffer, pos);
    if (token != 0 && token->size > 0 && token->kind != TokenBaseKind_Whitespace){
        Range_i64 range = Ii64(token);
        result = push_buffer_range(app, arena, buffer, range);
    }
    return(result);
}

static String_Const_u8
push_token_or_word_under_active_cursor(Application_Links *app, Arena *arena){
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    return(push_token_or_word_under_pos(app, arena, buffer, pos));
}



static b32
file_exists(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0);
}

static b32
file_exists_and_is_file(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0 && !(((attributes.flags)&(FileAttribute_IsDirectory))!=0));
}

static b32
file_exists_and_is_folder(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0 && (((attributes.flags)&(FileAttribute_IsDirectory))!=0));
}

static String_Const_u8
dump_file_handle(Arena *arena, FILE *file){
    String_Const_u8 result = {};
    if (file != 0){
        fseek(file, 0, 
# 2029 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
                      2
# 2029 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                              );
        u64 size = ftell(file);
        char *mem = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "2031" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "2031" ":") - 1)))));
        if (mem != 0){
            fseek(file, 0, 
# 2033 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" 3 4
                          0
# 2033 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
                                  );
            fread(mem, 1, (size_t)size, file);
            result = make_data(mem, size);
        }
    }
    return(result);
}

static String_Const_u8
push_file_search_up_path(Application_Links *app, Arena *arena, String_Const_u8 start_path, String_Const_u8 file_name){
    String_Const_u8 result = {};
    String_Const_u8 path = start_path;
    for (;path.size > 0;){
        Temp_Memory temp = begin_temp(arena);
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        String_Const_u8 full_path = push_u8_stringf(arena, "%.*s/%.*s",
                                                    (i32)(path).size, (char*)(path).str,
                                                    (i32)(file_name).size, (char*)(file_name).str);
        if (file_exists(app, full_path)){
            result = full_path;
            break;
        }
        path = string_remove_last_folder(path);
        end_temp(temp);
    }
    return(result);
}

static FILE*
open_file(Arena *scratch, String_Const_u8 name){
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 name_copy = push_string_copy(scratch, name);
    FILE *file = fopen((char*)name_copy.str, "rb");
    end_temp(temp);
    return(file);
}

static File_Name_Data
dump_file(Arena *arena, String_Const_u8 file_name){
    File_Name_Data result = {};
    FILE *file = open_file(arena, file_name);
    if (file != 0){
        result.file_name = file_name;
        result.data = dump_file_handle(arena, file);
        fclose(file);
    }
    return(result);
}

static File_Name_Data
dump_file_search_up_path(Application_Links *app, Arena *arena, String_Const_u8 path, String_Const_u8 file_name){
    File_Name_Data result = {};
    String_Const_u8 full_path = push_file_search_up_path(app, arena, path, file_name);
    if (full_path.size > 0){
        result = dump_file(arena, full_path);
    }
    return(result);
}

static void
sort_pairs_by_key__quick(Sort_Pair_i32 *pairs, i32 first, i32 one_past_last){
    i32 dif = one_past_last - first;
    if (dif >= 2){
        i32 pivot = one_past_last - 1;
        Sort_Pair_i32 pivot_pair = pairs[pivot];
        i32 j = first;
        b32 interleave = false;
        for (i32 i = first; i < pivot; i += 1){
            Sort_Pair_i32 pair = pairs[i];
            if (pair.key < pivot_pair.key){
                pairs[i] = pairs[j];
                pairs[j] = pair;
                j += 1;
            }
            else if (pair.key == pivot_pair.key){
                if (interleave){
                    pairs[i] = pairs[j];
                    pairs[j] = pair;
                    j += 1;
                }
                interleave = !interleave;
            }
        }
        pairs[pivot] = pairs[j];
        pairs[j] = pivot_pair;
        sort_pairs_by_key__quick(pairs, first, j);
        sort_pairs_by_key__quick(pairs, j + 1, one_past_last);
    }
}

static void
sort_pairs_by_key(Sort_Pair_i32 *pairs, i32 count){
    sort_pairs_by_key__quick(pairs, 0, count);
}

static Range_i32_Array
get_ranges_of_duplicate_keys(Arena *arena, i32 *keys, i32 stride, i32 count){
    Range_i32_Array result = {};
    result.ranges = ((Range_i32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Range_i32)*(count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "2133" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp" ":" "2133" ":") - 1)))));
    u8 *ptr = (u8*)keys;
    i32 start_i = 0;
    for (i32 i = 1; i <= count; i += 1){
        b32 is_end = false;
        if (i == count){
            is_end = true;
        }
        else if (*(i32*)(ptr + i*stride) != *(i32*)(ptr + start_i*stride)){
            is_end = true;
        }
        if (is_end){
            Range_i32 *new_range = &result.ranges[result.count++];
            new_range->first = start_i;
            new_range->one_past_last = i;
            start_i = i;
        }
    }
    (linalloc_pop((arena), sizeof(Range_i32)*(count - result.count)));
    return(result);
}

static void
no_mark_snap_to_cursor(Application_Links *app, Managed_Scope view_scope){
    b32 *snap_to_cursor = ((b32*)managed_scope_get_attachment((app), (view_scope), (view_snap_mark_to_cursor), sizeof(b32)));
    *snap_to_cursor = false;
}

static void
no_mark_snap_to_cursor(Application_Links *app, View_ID view_id){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    no_mark_snap_to_cursor(app, scope);
}

static void
no_mark_snap_to_cursor_if_shift(Application_Links *app, View_ID view_id){
    Scratch_Block scratch(app);
    Input_Modifier_Set mods = system_get_keyboard_modifiers(scratch);
    if (has_modifier(&mods, KeyCode_Shift)){
        no_mark_snap_to_cursor(app, view_id);
    }
}

static b32
view_has_highlighted_range(Application_Links *app, View_ID view){
    b32 result = false;
    if (fcoder_mode == FCoderMode_NotepadLike){
        i64 pos = view_get_cursor_pos(app, view);
        i64 mark = view_get_mark_pos(app, view);
        result = (pos != mark);
    }
    return(result);
}

static b32
if_view_has_highlighted_range_delete_range(Application_Links *app, View_ID view_id){
    b32 result = false;
    if (view_has_highlighted_range(app, view_id)){
        Range_i64 range = get_view_range(app, view_id);
        Buffer_ID buffer = view_get_buffer(app, view_id, Access_ReadWriteVisible);
        buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
        result = true;
    }
    return(result);
}

static void
begin_notepad_mode(Application_Links *app){
    fcoder_mode = FCoderMode_NotepadLike;
    for (View_ID view = get_view_next(app, 0, Access_Always);
         view != 0;
         view = get_view_next(app, view, Access_Always)){
        i64 pos = view_get_cursor_pos(app, view);
        view_set_mark(app, view, seek_pos(pos));
    }
}



static void
seek_pos_of_textual_line(Application_Links *app, Side side){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_line_side_pos_from_pos(app, buffer, pos, side);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
seek_pos_of_visual_line(Application_Links *app, Side side){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, pos);
    p.x = (side == Side_Min)?(0.f):(max_f32);
    i64 new_pos = view_pos_at_relative_xy(app, view, cursor.line, p);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(seek_beginning_of_textual_line, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2234, Normal)
CUSTOM_DOC("Seeks the cursor to the beginning of the line across all text.")
{
    seek_pos_of_textual_line(app, Side_Min);
}

CUSTOM_COMMAND(seek_end_of_textual_line, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2240, Normal)
CUSTOM_DOC("Seeks the cursor to the end of the line across all text.")
{
    seek_pos_of_textual_line(app, Side_Max);
}

CUSTOM_COMMAND(seek_beginning_of_line, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2246, Normal)
CUSTOM_DOC("Seeks the cursor to the beginning of the visual line.")
{
    seek_pos_of_visual_line(app, Side_Min);
}

CUSTOM_COMMAND(seek_end_of_line, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2252, Normal)
CUSTOM_DOC("Seeks the cursor to the end of the visual line.")
{
    seek_pos_of_visual_line(app, Side_Max);
}

CUSTOM_COMMAND(goto_beginning_of_file, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2258, Normal)
CUSTOM_DOC("Sets the cursor to the beginning of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_and_preferred_x(app, view, seek_pos(0));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(goto_end_of_file, "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp", 2266, Normal)
CUSTOM_DOC("Sets the cursor to the end of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer_id = view_get_buffer(app, view, Access_ReadVisible);
    i32 size = (i32)buffer_get_size(app, buffer_id);
    view_set_cursor_and_preferred_x(app, view, seek_pos(size));
    no_mark_snap_to_cursor_if_shift(app, view);
}



static b32
view_set_split(Application_Links *app, View_ID view, View_Split_Kind kind, f32 t){
    b32 result = false;
    if (view != 0){
        Panel_ID panel_id = view_get_panel(app, view);
        if (panel_id != 0){
            Panel_ID parent_panel_id = panel_get_parent(app, panel_id);
            if (parent_panel_id != 0){
                Panel_ID min_child_id = panel_get_child(app, parent_panel_id, Side_Min);
                if (min_child_id != 0){
                    b32 panel_is_min = (min_child_id == panel_id);
                    Panel_Split_Kind panel_kind = ((kind == ViewSplitKind_Ratio)?
                                                   (panel_is_min?PanelSplitKind_Ratio_Min:PanelSplitKind_Ratio_Max):
                                                   (panel_is_min?PanelSplitKind_FixedPixels_Min:PanelSplitKind_FixedPixels_Max));
                    result = panel_set_split(app, parent_panel_id, panel_kind, t);
                }
            }
        }
    }
    return(result);
}

static b32
view_set_split_proportion(Application_Links *app, View_ID view, f32 t){
    return(view_set_split(app, view, ViewSplitKind_Ratio, t));
}

static b32
view_set_split_pixel_size(Application_Links *app, View_ID view, i32 t){
    return(view_set_split(app, view, ViewSplitKind_FixedPixels, (f32)t));
}



static Record_Info
get_single_record(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    if (record.error == RecordError_NoError && record.kind == RecordKind_Group){
        record = buffer_history_get_group_sub_record(app, buffer_id, index, record.group_count - 1);
    }
    return(record);
}



static Nest_Delimiter_Kind
get_nest_delimiter_kind(Token_Base_Kind kind, Find_Nest_Flag flags){
    Nest_Delimiter_Kind result = NestDelim_None;
    switch (kind){
        case TokenBaseKind_ScopeOpen:
        {
            if ((((flags)&(FindNest_Scope))!=0)){
                result = NestDelim_Open;
            }
        }break;
        case TokenBaseKind_ScopeClose:
        {
            if ((((flags)&(FindNest_Scope))!=0)){
                result = NestDelim_Close;
            }
        }break;
        case TokenBaseKind_ParentheticalOpen:
        {
            if ((((flags)&(FindNest_Paren))!=0)){
                result = NestDelim_Open;
            }
        }break;
        case TokenBaseKind_ParentheticalClose:
        {
            if ((((flags)&(FindNest_Paren))!=0)){
                result = NestDelim_Close;
            }
        }break;
    }
    return(result);
}

static b32
find_nest_side(Application_Links *app, Buffer_ID buffer, i64 pos,
               Find_Nest_Flag flags, Scan_Direction scan, Nest_Delimiter_Kind delim,
               Range_i64 *out){
    b32 result = false;

    b32 balanced = (((flags)&(FindNest_Balanced))!=0);
    if (balanced){
        if ((delim == NestDelim_Open && scan == Scan_Forward) ||
            (delim == NestDelim_Close && scan == Scan_Backward)){
            balanced = false;
        }
    }

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Token_Array *tokens = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (tokens != 0 && tokens->count > 0){
        Token_Iterator_Array it = token_iterator_pos(0, tokens, pos);
        i32 level = 0;
        for (;;){
            Token *token = token_it_read(&it);
            Nest_Delimiter_Kind token_delim = get_nest_delimiter_kind(token->kind, flags);

            if (level == 0 && token_delim == delim){
                *out = Ii64_size(token->pos, token->size);
                result = true;
                break;
            }

            if (balanced && token_delim != NestDelim_None){
                level += (token_delim == delim)?-1:1;
            }

            b32 good = false;
            if (scan == Scan_Forward){
                good = token_it_inc(&it);
            }
            else{
                good = token_it_dec(&it);
            }
            if (!good){
                break;
            }
        }
    }

    return(result);
}

static b32
find_nest_side(Application_Links *app, Buffer_ID buffer, i64 pos,
               Find_Nest_Flag flags, Scan_Direction scan, Nest_Delimiter_Kind delim,
               i64 *out){
    Range_i64 range = {};
    b32 result = find_nest_side(app, buffer, pos, flags, scan, delim, &range);
    if (result){
        if ((((flags)&(FindNest_EndOfToken))!=0)){
            *out = range.end;
        }
        else{
            *out = range.start;
        }
    }
    return(result);
}

static b32
find_surrounding_nest(Application_Links *app, Buffer_ID buffer, i64 pos,
                      Find_Nest_Flag flags, Range_i64 *out){
    b32 result = false;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos - 1, flags|FindNest_Balanced,
                       Scan_Backward, NestDelim_Open, &range.start) &&
        find_nest_side(app, buffer, pos, flags|FindNest_Balanced|FindNest_EndOfToken,
                       Scan_Forward, NestDelim_Close, &range.end)){
        *out = range;
        result = true;
    }
    return(result);
}

static void
select_scope(Application_Links *app, View_ID view, Range_i64 range){
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.first));
    view_set_mark(app, view, seek_pos(range.end));
    view_look_at_region(app, view, range.first, range.end);
    no_mark_snap_to_cursor(app, view);
}



static Line_Ending_Kind
guess_line_ending_kind_from_buffer(Application_Links *app, Buffer_ID buffer){
    u64 size = buffer_get_size(app, buffer);
    size = (((size)<(((8) << 10)))?(size):(((8) << 10)));
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, Ii64(0, size));
    return(string_guess_line_ending_kind(string));
}





static Child_Process_Set_Target_Flags
flags_system_command(Command_Line_Interface_Flag flags){
    Child_Process_Set_Target_Flags set_buffer_flags = 0;
    if (!(((flags)&(CLI_OverlapWithConflict))!=0)){
        set_buffer_flags |= ChildProcessSet_FailIfBufferAlreadyAttachedToAProcess;
    }
    if ((((flags)&(CLI_CursorAtEnd))!=0)){
        set_buffer_flags |= ChildProcessSet_CursorAtEnd;
    }
    return(set_buffer_flags);
}

static b32
set_buffer_system_command(Application_Links *app, Child_Process_ID process, Buffer_ID buffer, Command_Line_Interface_Flag flags){
    b32 result = false;
    Child_Process_Set_Target_Flags set_buffer_flags = flags_system_command(flags);
    if (child_process_set_target_buffer(app, process, buffer, set_buffer_flags)){
        clear_buffer(app, buffer);
        if ((((flags)&(CLI_SendEndSignal))!=0)){
            buffer_send_end_signal(app, buffer);

            Buffer_Hook_Function *begin_buffer = (Buffer_Hook_Function*)get_custom_hook(app, HookID_BeginBuffer);
            if (begin_buffer != 0){
                begin_buffer(app, buffer);
            }
        }
        result = true;
    }
    return(result);
}

static b32
exec_system_command(Application_Links *app, View_ID view, Buffer_Identifier buffer_id,
                    String_Const_u8 path, String_Const_u8 command, Command_Line_Interface_Flag flags){
    b32 result = false;
    Child_Process_ID child_process_id = create_child_process(app, path, command);
    if (child_process_id != 0){
        result = true;
        Buffer_ID buffer_attach_id = buffer_identifier_to_id_create_out_buffer(app, buffer_id);
        if (buffer_attach_id != 0){
            if (set_buffer_system_command(app, child_process_id, buffer_attach_id, flags)){
                if (view != 0){
                    view_set_buffer(app, view, buffer_attach_id, 0);
                    view_set_cursor(app, view, seek_pos(0));
                }
            }
        }
    }
    return(result);
}
# 2534 "/home/tabletel/dev/4cc/code/custom/4coder_helper.cpp"
static void
clear_all_layouts(Application_Links *app){
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        buffer_clear_layout_cache(app, buffer);
    }
}
# 105 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_delta_rule.cpp" 1






static u64
delta_ctx_size(u64 base_size){
    return(base_size + sizeof(Delta_Context_Header));
}

static Delta_Context_Header*
delta_ctx_get_header(String_Const_u8 delta_ctx){
    return((Delta_Context_Header*)delta_ctx.str);
}

static void*
delta_ctx_get_user_data(String_Const_u8 delta_ctx){
    Delta_Context_Header *ctx = (Delta_Context_Header*)delta_ctx.str;
    return(ctx + 1);
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, String_Const_u8 delta_ctx,
            f32 dt, Buffer_Point position, Buffer_Point target){
    Buffer_Point_Delta_Result result = {};
    Vec2_f32 pending = view_point_difference(app, view, target, position);
    if (!near_zero(pending, 0.5f)){
        Delta_Context_Header *ctx = delta_ctx_get_header(delta_ctx);
        b32 is_new_target = false;
        if (!block_match((&ctx->point), (&target), sizeof(*(&ctx->point)))){
            block_copy((&ctx->point), (&target), sizeof(*(&ctx->point)));
            is_new_target = true;
        }
        void *rule_data = delta_ctx_get_user_data(delta_ctx);
        Vec2_f32 partial = func(pending, is_new_target, dt, rule_data);



        Range_f32 x = If32(pending.x, 0.f);
        Range_f32 y = If32(pending.y, 0.f);
        partial.x = clamp_range(x, partial.x);
        partial.y = clamp_range(y, partial.y);

        result.point = view_move_buffer_point(app, view, position, partial);
        result.still_animating = true;
    }
    else{
        result.point = target;
    }
    return(result);
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, String_Const_u8 delta_ctx,
            f32 dt, Buffer_Scroll scroll){
    return(delta_apply(app, view, func, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Buffer_Point position, Buffer_Point target){
    View_Context ctx = view_current_context(app, view);
    String_Const_u8 delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, position, target));
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Buffer_Scroll scroll){
    View_Context ctx = view_current_context(app, view);
    String_Const_u8 delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, String_Const_u8 delta_ctx,
            f32 dt, Vec2_f32 position, Vec2_f32 target){
    Vec2_f32_Delta_Result result = {};
    Vec2_f32 pending = target - position;
    if (!near_zero(pending, 0.5f)){
        Delta_Context_Header *ctx = delta_ctx_get_header(delta_ctx);
        b32 is_new_target = false;
        if (!near_zero(ctx->p - target, 0.1f)){
            block_copy((&ctx->p), (&target), sizeof(*(&ctx->p)));
            is_new_target = true;
        }
        void *rule_data = delta_ctx_get_user_data(delta_ctx);
        Vec2_f32 partial = func(pending, is_new_target, dt, rule_data);



        Range_f32 x = If32(pending.x, 0.f);
        Range_f32 y = If32(pending.y, 0.f);
        partial.x = clamp_range(x, partial.x);
        partial.y = clamp_range(y, partial.y);

        result.p = position + partial;
        result.still_animating = true;
    }
    else{
        result.p = target;
    }
    return(result);
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, String_Const_u8 delta_ctx,
            f32 dt, Basic_Scroll scroll){
    return(delta_apply(app, view, func, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Vec2_f32 position, Vec2_f32 target){
    View_Context ctx = view_current_context(app, view);
    String_Const_u8 delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, position, target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Basic_Scroll scroll){
    View_Context ctx = view_current_context(app, view);
    String_Const_u8 delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, scroll.position, scroll.target));
}



static Smooth_Step
smooth_camera_step(f32 target, f32 v, f32 S, f32 T){
    Smooth_Step step = {};
    step.v = v;
    if (step.p != target){
        if (step.p > target - .1f && step.p < target + .1f){
            step.p = target;
            step.v = 1.f;
        }
        else{
            f32 L = step.p + T*(target - step.p);
            i32 sign = (target > step.p) - (target < step.p);
            f32 V = step.p + sign*step.v;
            if (sign > 0){
                step.p = (L<V)?(L):(V);
            }
            else{
                step.p = (L>V)?(L):(V);
            }
            if (step.p == V){
                step.v *= S;
            }
        }
    }
    return(step);
}
Vec2_f32 original_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    Vec2_f32 *velocity = (Vec2_f32*)data;
    if (velocity->x == 0.f){
        velocity->x = 1.f;
        velocity->y = 1.f;
    }
    Smooth_Step step_x = smooth_camera_step(pending.x, velocity->x, 80.f, 1.f/2.f);
    Smooth_Step step_y = smooth_camera_step(pending.y, velocity->y, 80.f, 1.f/2.f);
    *velocity = V2f32(step_x.v, step_y.v);
    return(V2f32(step_x.p, step_y.p));
}
static const u64 original_delta_memory_size = sizeof(Vec2_f32);

Vec2_f32 snap_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    return(pending);
}
static const u64 snap_delta_memory_size = 0;

static f32
cubic_reinterpolate(f32 t){
    f32 t2 = t*t;
    f32 t3 = t2*t;
    return(3*t2 - 2*t3);
}
Vec2_f32 fixed_time_cubic_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    static const f32 duration_in_seconds = (1.f/8.f);
    static const f32 dt_multiplier = 1.f/duration_in_seconds;
    f32 step = dt*dt_multiplier;
    f32 *t = (f32*)data;
    *t = (((0.f)>(*t))?(0.f):(((1.f)<(*t))?(1.f):(*t)));
    f32 prev_t = *t;
    if (is_new_target){
        prev_t = 0.f;
        *t = step;
    }
    else{
        *t += step;
    }
    *t = (((0.f)>(*t))?(0.f):(((1.f)<(*t))?(1.f):(*t)));
    Vec2_f32 result = pending;
    if (*t < 1.f){
        f32 prev_x = cubic_reinterpolate(prev_t);
        f32 x = cubic_reinterpolate(*t);
        f32 portion = ((x - prev_x)/(1.f - prev_x));
        result *= portion;
    }
    return(result);
}
static const u64 fixed_time_cubic_delta_memory_size = sizeof(f32);
# 106 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" 1






static Layout_Reflex
get_layout_reflex(Layout_Item_List *list, Buffer_ID buffer, f32 width, Face_ID face){
Layout_Reflex reflex = {};
reflex.list = list;
reflex.buffer = buffer;
reflex.width = width;
reflex.face = face;
return(reflex);
}

static Rect_f32
layout_reflex_get_rect(Application_Links *app, Layout_Reflex *reflex, i64 pos, b32 *unresolved_dependence){
Rect_f32 rect = {};
pos = (((0)>(pos))?(0):(pos));
if (range_contains(reflex->list->input_index_range, pos)){
if (range_contains(reflex->list->manifested_index_range, pos)){
rect = layout_box_of_pos(*reflex->list, pos);
*unresolved_dependence = false;
}
else{
*unresolved_dependence = true;
}
}
else{
Buffer_Cursor cursor = buffer_compute_cursor(app, reflex->buffer, seek_pos(pos));
rect = buffer_relative_box_of_pos(app, reflex->buffer, reflex->width, reflex->face, cursor.line, cursor.pos);
*unresolved_dependence = false;
}
return(rect);
}



static i64
layout_index_from_ptr(u8 *ptr, u8 *string_base, i64 index_base){
return((i64)(ptr - string_base) + index_base);
}

static Layout_Item_List
get_empty_item_list(Range_i64 input_range){
Layout_Item_List list = {};
list.input_index_range = input_range;
list.manifested_index_range = Ii64_neg_inf;
return(list);
}

static void
layout_item_list_finish(Layout_Item_List *list, f32 bottom_padding){
list->bottom_padding = bottom_padding;
list->height += bottom_padding;
}

static void
layout_write(Arena *arena, Layout_Item_List *list, Face_ID face, i64 index, u32 codepoint, Layout_Item_Flag flags, Rect_f32 rect, f32 padded_y1){
Temp_Memory restore_point = begin_temp(arena);
Layout_Item *item = ((Layout_Item*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "62" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "62" ":") - 1)))));
Layout_Item_Block *block = list->last;
if (block != 0){
if (block->face != face){
block = 0;
}
else if (block->items + block->item_count == item){
block->item_count += 1;
}
else{
block = 0;
}
}
if (block == 0){
end_temp(restore_point);
block = ((Layout_Item_Block*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item_Block)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "77" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "77" ":") - 1)))));
item = ((Layout_Item*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "78" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_layout_rule.cpp" ":" "78" ":") - 1)))));
do{ if((block)){if((list->first)){(list->last)->next=(block);}else{(list->first)=(block);}(list->last)=(block);(list->last)->next=0;} }while(0);
list->node_count += 1;
block->items = item;
block->item_count = 1;
block->face = face;
}

list->item_count += 1;
list->manifested_index_range.min = (((list->manifested_index_range.min)<(index))?(list->manifested_index_range.min):(index));
list->manifested_index_range.max = (((list->manifested_index_range.max)>(index))?(list->manifested_index_range.max):(index));

if (!(((flags)&(LayoutItemFlag_Ghost_Character))!=0)){
block->character_count += 1;
list->character_count += 1;
}

item->index = index;
item->codepoint = codepoint;
item->flags = flags;
item->rect = rect;
item->padded_y1 = padded_y1;
list->height = (((list->height)>(rect.y1))?(list->height):(rect.y1));
}



static Newline_Layout_Vars
get_newline_layout_vars(void){
Newline_Layout_Vars result = {};
result.newline_character_index = -1;
return(result);
}

static void
newline_layout_consume_CR(Newline_Layout_Vars *vars, i64 index){
if (!vars->consuming_newline_characters){
vars->consuming_newline_characters = true;
vars->newline_character_index = index;
}
vars->prev_did_emit_newline = false;
}

static i64
newline_layout_consume_LF(Newline_Layout_Vars *vars, i64 index){
if (!vars->consuming_newline_characters){
vars->newline_character_index = index;
}
vars->prev_did_emit_newline = true;
vars->consuming_newline_characters = false;
return(vars->newline_character_index);
}

static void
newline_layout_consume_default(Newline_Layout_Vars *vars){
vars->consuming_newline_characters = false;
vars->prev_did_emit_newline = false;
}

static b32
newline_layout_consume_finish(Newline_Layout_Vars *vars){
return((!vars->prev_did_emit_newline));
}



static LefRig_TopBot_Layout_Vars
get_lr_tb_layout_vars(Face_Advance_Map *advance_map, Face_Metrics *metrics, f32 tab_width, f32 width){
f32 text_height = metrics->text_height;
f32 line_height = metrics->line_height;

LefRig_TopBot_Layout_Vars result = {};
result.advance_map = advance_map;
result.metrics = metrics;
result.tab_width = tab_width;
result.line_to_text_shift = text_height - line_height;

result.blank_dim = V2f32(metrics->space_advance, text_height);

result.line_y = line_height;
result.text_y = text_height;
result.width = width;
return(result);
}

static b32
lr_tb_crosses_width(LefRig_TopBot_Layout_Vars *vars, f32 advance, f32 width){
return(vars->p.x + advance > width);
}

static b32
lr_tb_crosses_width(LefRig_TopBot_Layout_Vars *vars, f32 advance){
return(vars->p.x + advance > vars->width);
}

static f32
lr_tb_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, u32 codepoint){
return(font_get_glyph_advance(vars->advance_map, vars->metrics, codepoint, vars->tab_width));
}

static void
lr_tb_write_with_advance_with_flags(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint, Layout_Item_Flag flags){
if (codepoint == '\t'){
codepoint = ' ';
}
vars->p.x = f32_ceil32(vars->p.x);
f32 next_x = vars->p.x + advance;
layout_write(arena, list, face, index, codepoint, flags, Rf32(vars->p, V2f32(next_x, vars->text_y)), vars->line_y);
vars->p.x = next_x;
}

static void
lr_tb_write_with_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
lr_tb_write_with_advance_with_flags(vars, face, advance, arena, list, index, codepoint, 0);
}

static void
lr_tb_write(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
f32 advance = lr_tb_advance(vars, face, codepoint);
lr_tb_write_with_advance(vars, face, advance, arena, list, index, codepoint);
}

static void
lr_tb_write_ghost(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
f32 advance = lr_tb_advance(vars, face, codepoint);
lr_tb_write_with_advance_with_flags(vars, face, advance, arena, list, index, codepoint, LayoutItemFlag_Ghost_Character);
}

static f32
lr_tb_advance_byte(LefRig_TopBot_Layout_Vars *vars){
return(vars->metrics->byte_advance);
}

static void
lr_tb_write_byte_with_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u8 byte){
Face_Metrics *metrics = vars->metrics;

f32 final_next_x = vars->p.x + advance;
u32 lo = ((u32)byte )&0xF;
u32 hi = ((u32)byte >> 4)&0xF;

Vec2_f32 p = vars->p;
p.x = f32_ceil32(p.x);
f32 next_x = p.x + metrics->byte_sub_advances[0];
f32 text_y = vars->text_y;

Layout_Item_Flag flags = LayoutItemFlag_Special_Character;
layout_write(arena, list, face, index, '\\', flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);
p.x = next_x;

flags = LayoutItemFlag_Ghost_Character;
next_x += metrics->byte_sub_advances[1];
layout_write(arena, list, face, index, integer_symbols[hi], flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);
p.x = next_x;
next_x += metrics->byte_sub_advances[2];
layout_write(arena, list, face, index, integer_symbols[lo], flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);

vars->p.x = final_next_x;
}

static void
lr_tb_write_byte(LefRig_TopBot_Layout_Vars *vars, Face_ID face,
                 Arena *arena, Layout_Item_List *list, i64 index, u8 byte){
lr_tb_write_byte_with_advance(vars, face, vars->metrics->byte_advance,
                              arena, list, index, byte);
}

static void
lr_tb_write_blank_dim(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Vec2_f32 dim,
                      Arena *arena, Layout_Item_List *list, i64 index){
layout_write(arena, list, face, index, ' ', 0, Rf32_xy_wh(vars->p, dim), vars->line_y);
vars->p.x += dim.x;
}

static void
lr_tb_write_blank(LefRig_TopBot_Layout_Vars *vars, Face_ID face,
                  Arena *arena, Layout_Item_List *list, i64 index){
lr_tb_write_blank_dim(vars, face, vars->blank_dim, arena, list, index);
}

static void
lr_tb_next_line(LefRig_TopBot_Layout_Vars *vars){
vars->p.x = 0.f;
vars->p.y = vars->line_y;
vars->line_y += vars->metrics->line_height;
vars->text_y = vars->line_y + vars->line_to_text_shift;
}

static void
lr_tb_next_line_padded(LefRig_TopBot_Layout_Vars *vars, f32 top, f32 bot){
vars->p.x = 0.f;
vars->p.y = vars->line_y + top;
vars->line_y += top + vars->metrics->line_height;
vars->text_y = vars->line_y + vars->line_to_text_shift;
vars->line_y += bot;
}

static void
lr_tb_advance_x_without_item(LefRig_TopBot_Layout_Vars *vars, f32 advance){
vars->p.x += advance;
}

static void
lr_tb_align_rightward(LefRig_TopBot_Layout_Vars *vars, f32 align_x){
vars->p.x = (((align_x)>(vars->p.x))?(align_x):(vars->p.x));
}



static Layout_Item_List
layout_unwrapped_small_blank_lines(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
Layout_Item_List list = get_empty_item_list(range);

Scratch_Block scratch(app);
String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

Face_Advance_Map advance_map = get_face_advance_map(app, face);
Face_Metrics metrics = get_face_metrics(app, face);
f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
tab_width = (((1)>(tab_width))?(1):(tab_width));
LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

pos_vars.blank_dim = V2f32(metrics.space_advance, metrics.text_height*0.5f);

if (text.size == 0){
lr_tb_write_blank(&pos_vars, face, arena, &list, range.start);
}
else{
Newline_Layout_Vars newline_vars = get_newline_layout_vars();

b32 all_whitespace = true;
for (u64 i = 0; i < text.size; i += 1){
if (!character_is_whitespace(text.str[i])){
all_whitespace = false;
break;
}
}

if (!all_whitespace){
pos_vars.blank_dim.y = metrics.text_height;
}

u8 *ptr = text.str;
u8 *end_ptr = ptr + text.size;
for (;ptr < end_ptr;){
Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));

i64 index = layout_index_from_ptr(ptr, text.str, range.first);
switch (consume.codepoint){
case '\t':
{
newline_layout_consume_default(&newline_vars);
Vec2_f32 dim = pos_vars.blank_dim;
dim.x = lr_tb_advance(&pos_vars, face, '\t');
lr_tb_write_blank_dim(&pos_vars, face, dim, arena, &list, index);
}break;

case ' ':
case '\f':
case '\v':
{
newline_layout_consume_default(&newline_vars);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}break;

default:
{
newline_layout_consume_default(&newline_vars);
lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
}break;

case '\r':
{
newline_layout_consume_CR(&newline_vars, index);
}break;

case '\n':
{
i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
lr_tb_next_line(&pos_vars);
}break;

case max_u32:
{
newline_layout_consume_default(&newline_vars);
lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
}break;
}

ptr += consume.inc;
}

if (newline_layout_consume_finish(&newline_vars)){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}
}

layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

return(list);
}

static Layout_Item_List
layout_wrap_anywhere(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
Scratch_Block scratch(app);

Layout_Item_List list = get_empty_item_list(range);

String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

Face_Advance_Map advance_map = get_face_advance_map(app, face);
Face_Metrics metrics = get_face_metrics(app, face);
f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
tab_width = (((1)>(tab_width))?(1):(tab_width));
LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

if (text.size == 0){
lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
}
else{
b32 first_of_the_line = true;
Newline_Layout_Vars newline_vars = get_newline_layout_vars();

u8 *ptr = text.str;
u8 *end_ptr = ptr + text.size;
for (;ptr < end_ptr;){
Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
switch (consume.codepoint){
default:
{
newline_layout_consume_default(&newline_vars);
f32 advance = lr_tb_advance(&pos_vars, face, consume.codepoint);
if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
lr_tb_next_line(&pos_vars);
}
lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, consume.codepoint);
first_of_the_line = false;
}break;

case '\r':
{
newline_layout_consume_CR(&newline_vars, index);
}break;

case '\n':
{
i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
lr_tb_next_line(&pos_vars);
first_of_the_line = true;
}break;

case max_u32:
{
newline_layout_consume_default(&newline_vars);
f32 advance = lr_tb_advance_byte(&pos_vars);
if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
lr_tb_next_line(&pos_vars);
}
lr_tb_write_byte_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
first_of_the_line = false;
}break;
}
ptr += consume.inc;
}

if (newline_layout_consume_finish(&newline_vars)){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}
}

layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

return(list);
}

static Layout_Item_List
layout_unwrapped__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Virtual_Indent virt_indent){
Layout_Item_List list = get_empty_item_list(range);

Scratch_Block scratch(app);
String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

Face_Advance_Map advance_map = get_face_advance_map(app, face);
Face_Metrics metrics = get_face_metrics(app, face);
f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
tab_width = (((1)>(tab_width))?(1):(tab_width));
LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

if (text.size == 0){
lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
}
else{
b32 skipping_leading_whitespace = (virt_indent == LayoutVirtualIndent_On);
Newline_Layout_Vars newline_vars = get_newline_layout_vars();

u8 *ptr = text.str;
u8 *end_ptr = ptr + text.size;
for (;ptr < end_ptr;){
Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));

i64 index = layout_index_from_ptr(ptr, text.str, range.first);
switch (consume.codepoint){
case '\t':
case ' ':
{
newline_layout_consume_default(&newline_vars);
f32 advance = lr_tb_advance(&pos_vars, face, consume.codepoint);
if (!skipping_leading_whitespace){
lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, consume.codepoint);
}
else{
lr_tb_advance_x_without_item(&pos_vars, advance);
}
}break;

default:
{
newline_layout_consume_default(&newline_vars);
lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
}break;

case '\r':
{
newline_layout_consume_CR(&newline_vars, index);
}break;

case '\n':
{
i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
lr_tb_next_line(&pos_vars);
}break;

case max_u32:
{
newline_layout_consume_default(&newline_vars);
lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
}break;
}

ptr += consume.inc;
}

if (newline_layout_consume_finish(&newline_vars)){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}
}

layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

return(list);
}

static Layout_Item_List
layout_wrap_whitespace__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Virtual_Indent virt_indent){
Scratch_Block scratch(app);

Layout_Item_List list = get_empty_item_list(range);

String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

Face_Advance_Map advance_map = get_face_advance_map(app, face);
Face_Metrics metrics = get_face_metrics(app, face);
f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
tab_width = (((1)>(tab_width))?(1):(tab_width));
LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

if (text.size == 0){
lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
}
else{
b32 skipping_leading_whitespace = false;
b32 first_of_the_line = true;
Newline_Layout_Vars newline_vars = get_newline_layout_vars();

u8 *ptr = text.str;
u8 *end_ptr = ptr + text.size;
u8 *word_ptr = ptr;

if (character_is_whitespace(*ptr)){
skipping_leading_whitespace = (virt_indent == LayoutVirtualIndent_On);
goto consuming_whitespace;
}

consuming_non_whitespace:
for (;ptr <= end_ptr; ptr += 1){
if (ptr == end_ptr || character_is_whitespace(*ptr)){
break;
}
}

{
newline_layout_consume_default(&newline_vars);

String_Const_u8 word = SCu8(word_ptr, ptr);
u8 *word_end = ptr;

if (!first_of_the_line){
f32 total_advance = 0.f;
ptr = word.str;
for (;ptr < word_end;){
Character_Consume_Result consume =
utf8_consume(ptr, (u64)(word_end - ptr));
if (consume.codepoint != max_u32){
total_advance += lr_tb_advance(&pos_vars, face, consume.codepoint);
}
else{
total_advance += lr_tb_advance_byte(&pos_vars);
}
ptr += consume.inc;
}

if (lr_tb_crosses_width(&pos_vars, total_advance)){
lr_tb_next_line(&pos_vars);
}
}

ptr = word.str;

for (;ptr < word_end;){
Character_Consume_Result consume =
utf8_consume(ptr, (u64)(word_end - ptr));
i64 index = layout_index_from_ptr(ptr, text.str, range.first);

if (consume.codepoint != max_u32){
lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
}
else{
lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
}

ptr += consume.inc;
}

first_of_the_line = false;
}

consuming_whitespace:
for (; ptr < end_ptr; ptr += 1){
if (!character_is_whitespace(*ptr)){
word_ptr = ptr;
goto consuming_non_whitespace;
}

i64 index = layout_index_from_ptr(ptr, text.str, range.first);
switch (*ptr){
case '\t':
case ' ':
{
newline_layout_consume_default(&newline_vars);
f32 advance = lr_tb_advance(&pos_vars, face, *ptr);
if (!skipping_leading_whitespace){
if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
lr_tb_next_line(&pos_vars);
}
lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
first_of_the_line = false;
}
else{
lr_tb_advance_x_without_item(&pos_vars, advance);
}
}break;

default:
{
newline_layout_consume_default(&newline_vars);
f32 advance = lr_tb_advance(&pos_vars, face, *ptr);
if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
lr_tb_next_line(&pos_vars);
}
lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
first_of_the_line = false;
}break;

case '\r':
{
newline_layout_consume_CR(&newline_vars, index);
}break;

case '\n':
{
u64 newline_index = newline_layout_consume_LF(&newline_vars, index);
lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
lr_tb_next_line(&pos_vars);
first_of_the_line = true;
}break;
}
}

if (newline_layout_consume_finish(&newline_vars)){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}
}

layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

return(list);
}

static Layout_Item_List
layout_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_unwrapped__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_Off));
}

static Layout_Item_List
layout_wrap_whitespace(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_wrap_whitespace__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_Off));
}

static Layout_Item_List
layout_basic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
Layout_Item_List result = {};
switch (kind){
case Layout_Unwrapped:
{
result = layout_unwrapped(app, arena, buffer, range, face, width);
}break;
case Layout_Wrapped:
{
result = layout_wrap_whitespace(app, arena, buffer, range, face, width);
}break;
}
return(result);
}

static Layout_Item_List
layout_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
Managed_Scope scope = buffer_get_managed_scope(app, buffer);
b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
return(layout_basic(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}

static Layout_Item_List
layout_virt_indent_literal_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_unwrapped__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_On));
}

static Layout_Item_List
layout_virt_indent_literal_wrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_wrap_whitespace__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_On));
}

static Layout_Item_List
layout_virt_indent_literal(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
Layout_Item_List result = {};
switch (kind){
case Layout_Unwrapped:
{
result = layout_virt_indent_literal_unwrapped(app, arena, buffer, range, face, width);
}break;
case Layout_Wrapped:
{
result = layout_virt_indent_literal_wrapped(app, arena, buffer, range, face, width);
}break;
}
return(result);
}

static Layout_Item_List
layout_virt_indent_literal_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
Managed_Scope scope = buffer_get_managed_scope(app, buffer);
b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
return(layout_virt_indent_literal(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}
# 107 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" 1






static Code_Index global_code_index = {};






static Code_Index_Nest*
code_index_get_nest_(Code_Index_Nest_Ptr_Array *array, i64 pos){
Code_Index_Nest *result = 0;
i32 count = array->count;
Code_Index_Nest **nest_ptrs = array->ptrs;
for (i32 i = 0; i < count; i += 1){
Code_Index_Nest *nest = nest_ptrs[i];
if (nest->open.max <= pos && pos <= nest->close.min){
Code_Index_Nest *sub_nest = code_index_get_nest_(&nest->nest_array, pos);
if (sub_nest != 0){
result = sub_nest;
}
else{
result = nest;
}
break;
}
}
return(result);
}

static Code_Index_Nest*
code_index_get_nest(Code_Index_File *file, i64 pos){
return(code_index_get_nest_(&file->nest_array, pos));
}

static Code_Index_Note_List*
code_index__list_from_string(String_Const_u8 string){
u64 hash = table_hash_u8(string.str, string.size);
Code_Index_Note_List *result = &global_code_index.name_hash[hash % ((sizeof(global_code_index.name_hash))/(sizeof(*global_code_index.name_hash)))];
return(result);
}

static Code_Index_Note*
code_index_note_from_string(String_Const_u8 string){
Code_Index_Note_List *list = code_index__list_from_string(string);
Code_Index_Note *result = 0;
for (Code_Index_Note *node = list->first;
     node != 0;
     node = node->next_in_hash){
if (string_match(string, node->text)){
result = node;
break;
}
}
return(result);
}





static void
code_index_init(void){
global_code_index.mutex = system_mutex_make();
global_code_index.node_arena = make_arena_system(((4) << 10));
global_code_index.buffer_to_index_file = make_table_u64_u64__inner((global_code_index.node_arena.base_allocator),(500),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "70" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "70" ":") - 1)));
}

static Code_Index_File_Storage*
code_index__alloc_storage(void){
Code_Index_File_Storage *result = global_code_index.free_storage;
if (result == 0){
result = ((Code_Index_File_Storage*)linalloc_wrap_zero(linalloc_push((&global_code_index.node_arena), sizeof(Code_Index_File_Storage)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "77" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "77" ":") - 1)))));
}
else{
((global_code_index.free_storage)=(global_code_index.free_storage)=(global_code_index.free_storage)->next);
}
(((global_code_index.storage_first)==0)?((result)->next=(result)->prev=0,(global_code_index.storage_first)=(global_code_index.storage_last)=(result)):((result)->prev=(global_code_index.storage_last),(result)->next=0,(global_code_index.storage_last)->next=(result),(global_code_index.storage_last)=(result)));
global_code_index.storage_count += 1;
return(result);
}

static void
code_index__free_storage(Code_Index_File_Storage *storage){
(((global_code_index.storage_last)==(storage))?((((global_code_index.storage_first)==(global_code_index.storage_last))?((global_code_index.storage_first)=(global_code_index.storage_last)=0):((global_code_index.storage_last)->prev->next=0,(global_code_index.storage_last)=(global_code_index.storage_last)->prev))) :((global_code_index.storage_first)==(storage))?((((global_code_index.storage_last)==(global_code_index.storage_first))?((global_code_index.storage_last)=(global_code_index.storage_first)=0):((global_code_index.storage_first)->next->prev=0,(global_code_index.storage_first)=(global_code_index.storage_first)->next))) : ((storage)->next->prev=(storage)->prev,(storage)->prev->next=(storage)->next,(storage)->next=(storage)->prev=0));
global_code_index.storage_count -= 1;
((storage)->next=(global_code_index.free_storage),(global_code_index.free_storage)=(storage));
}

static void
code_index_push_nest(Code_Index_Nest_List *list, Code_Index_Nest *nest){
do{ if((nest)){if((list->first)){(list->last)->next=(nest);}else{(list->first)=(nest);}(list->last)=(nest);(list->last)->next=0;} }while(0);
list->count += 1;
}

static Code_Index_Nest_Ptr_Array
code_index_nest_ptr_array_from_list(Arena *arena, Code_Index_Nest_List *list){
Code_Index_Nest_Ptr_Array array = {};
array.ptrs = ((Code_Index_Nest**)linalloc_wrap_zero(linalloc_push((arena), sizeof(Code_Index_Nest*)*(list->count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "103" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "103" ":") - 1)))));
array.count = list->count;
i32 counter = 0;
for (Code_Index_Nest *node = list->first;
     node != 0;
     node = node->next){
array.ptrs[counter] = node;
counter += 1;
}
return(array);
}

static Code_Index_Note_Ptr_Array
code_index_note_ptr_array_from_list(Arena *arena, Code_Index_Note_List *list){
Code_Index_Note_Ptr_Array array = {};
array.ptrs = ((Code_Index_Note**)linalloc_wrap_zero(linalloc_push((arena), sizeof(Code_Index_Note*)*(list->count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "118" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "118" ":") - 1)))));
array.count = list->count;
i32 counter = 0;
for (Code_Index_Note *node = list->first;
     node != 0;
     node = node->next){
array.ptrs[counter] = node;
counter += 1;
}
return(array);
}

static void
code_index_lock(void){
system_mutex_acquire(global_code_index.mutex);
}

static void
code_index_unlock(void){
system_mutex_release(global_code_index.mutex);
}

static void
code_index__hash_file(Code_Index_File *file){
for (Code_Index_Note *node = file->note_list.first;
     node != 0;
     node = node->next){
Code_Index_Note_List *list = code_index__list_from_string(node->text);
((list->first==0)?(node->next_in_hash=node->prev_in_hash=0,list->first=list->last=node):(node->prev_in_hash=list->last,node->next_in_hash=0,list->last->next_in_hash=node,list->last=node));
list->count += 1;
}
}

static void
code_index__clear_file(Code_Index_File *file){
for (Code_Index_Note *node = file->note_list.first;
     node != 0;
     node = node->next){
Code_Index_Note_List *list = code_index__list_from_string(node->text);
((list->last==node)?(((list->first==list->last)?(list->first=list->last=0):(list->last->prev_in_hash->next_in_hash=0,list->last=list->last->prev_in_hash))) :(list->first==node)?(((list->last==list->first)?(list->last=list->first=0):(list->first->next_in_hash->prev_in_hash=0,list->first=list->first->next_in_hash))) : (node->next_in_hash->prev_in_hash=node->prev_in_hash,node->prev_in_hash->next_in_hash=node->next_in_hash,node->next_in_hash=node->prev_in_hash=0));
list->count -= 1;
}
}

static void
code_index_set_file(Buffer_ID buffer, Arena arena, Code_Index_File *index){
Code_Index_File_Storage *storage = 0;
Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
if (lookup.found_match){
u64 val = 0;
table_read(&global_code_index.buffer_to_index_file, lookup, &val);
storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);
code_index__clear_file(storage->file);
linalloc_clear(&storage->arena);
}
else{
storage = code_index__alloc_storage();
table_insert(&global_code_index.buffer_to_index_file, buffer, (u64)((u8*)(storage) - (u8*)(0)));
}
storage->arena = arena;
storage->file = index;

code_index__hash_file(index);
}

static void
code_index_erase_file(Buffer_ID buffer){
Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
if (lookup.found_match){
u64 val = 0;
table_read(&global_code_index.buffer_to_index_file, lookup, &val);
Code_Index_File_Storage *storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);

code_index__clear_file(storage->file);

linalloc_clear(&storage->arena);
table_erase(&global_code_index.buffer_to_index_file, lookup);
code_index__free_storage(storage);
}
}

static Code_Index_File*
code_index_get_file(Buffer_ID buffer){
Code_Index_File *result = 0;
Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
if (lookup.found_match){
u64 val = 0;
table_read(&global_code_index.buffer_to_index_file, lookup, &val);
Code_Index_File_Storage *storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);
result = storage->file;
}
return(result);
}

static void
index_shift(i64 *ptr, Range_i64 old_range, u64 new_size){
i64 i = *ptr;
if (old_range.min <= i && i < old_range.max){
*ptr = old_range.first;
}
else if (old_range.max <= i){
*ptr = i + new_size - (old_range.max - old_range.min);
}
}

static void
code_index_shift(Code_Index_Nest_Ptr_Array *array,
                 Range_i64 old_range, u64 new_size){
i32 count = array->count;
Code_Index_Nest **nest_ptr = array->ptrs;
for (i32 i = 0; i < count; i += 1, nest_ptr += 1){
Code_Index_Nest *nest = *nest_ptr;
index_shift(&nest->open.min, old_range, new_size);
index_shift(&nest->open.max, old_range, new_size);
if (nest->is_closed){
index_shift(&nest->close.min, old_range, new_size);
index_shift(&nest->close.max, old_range, new_size);
}
code_index_shift(&nest->nest_array, old_range, new_size);
}
}

static void
code_index_shift(Code_Index_File *file, Range_i64 old_range, u64 new_size){
code_index_shift(&file->nest_array, old_range, new_size);
}





static void
generic_parse_inc(Generic_Parse_State *state){
if (!token_it_inc_all(&state->it)){
state->finished = true;
}
}

static void
generic_parse_skip_soft_tokens(Code_Index_File *index, Generic_Parse_State *state){
Token *token = token_it_read(&state->it);
for (;token != 0 && !state->finished;){
if (state->in_preprocessor && !(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
break;
}
if (token->kind == TokenBaseKind_Comment){
state->handle_comment(state->app, state->arena, index, token, state->contents);
}
else if (token->kind == TokenBaseKind_Whitespace){
Range_i64 range = Ii64(token);
u8 *ptr = state->contents.str + range.one_past_last - 1;
for (i64 i = range.one_past_last - 1;
     i >= range.first;
     i -= 1, ptr -= 1){
if (*ptr == '\n'){
state->prev_line_start = ptr + 1;
break;
}
}
}
else{
break;
}
generic_parse_inc(state);
token = token_it_read(&state->it);
}
}

static void
generic_parse_init(Application_Links *app, Arena *arena, String_Const_u8 contents, Token_Array *tokens, Generic_Parse_Comment_Function *handle_comment, Generic_Parse_State *state){
state->app = app;
state->arena = arena;
state->contents = contents;
state->it = token_iterator(0, tokens);
state->handle_comment = handle_comment;
state->prev_line_start = contents.str;
}
# 330 "/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp"
static Code_Index_Note*
index_new_note(Code_Index_File *index, Generic_Parse_State *state, Range_i64 range, Code_Index_Note_Kind kind, Code_Index_Nest *parent){
Code_Index_Note *result = ((Code_Index_Note*)linalloc_wrap_unintialized(linalloc_push((state->arena), sizeof(Code_Index_Note)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "332" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "332" ":") - 1)))));
do{ if((result)){if((index->note_list.first)){(index->note_list.last)->next=(result);}else{(index->note_list.first)=(result);}(index->note_list.last)=(result);(index->note_list.last)->next=0;} }while(0);
index->note_list.count += 1;
result->note_kind = kind;
result->pos = range;
result->text = push_string_copy(state->arena, string_substring(state->contents, range));
result->file = index;
result->parent = parent;
return(result);
}

static void
cpp_parse_type_structure(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
if (state->finished){
return;
}
Token *token = token_it_read(&state->it);
if (token != 0 && token->kind == TokenBaseKind_Identifier){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
Token *peek = token_it_read(&state->it);
if (peek != 0 && peek->kind == TokenBaseKind_StatementClose ||
    peek->kind == TokenBaseKind_ScopeOpen){
index_new_note(index, state, Ii64(token), CodeIndexNote_Type, parent);
}
}
}

static void
cpp_parse_type_def(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
for (;;){
b32 did_advance = false;
Token *token = token_it_read(&state->it);
if (token == 0 || state->finished){
break;
}
if (token->kind == TokenBaseKind_Identifier){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
did_advance = true;
Token *peek = token_it_read(&state->it);
if (peek != 0 && peek->kind == TokenBaseKind_StatementClose ||
    peek->kind == TokenBaseKind_ParentheticalOpen){
index_new_note(index, state, Ii64(token), CodeIndexNote_Type, parent);
break;
}
}
else if (token->kind == TokenBaseKind_StatementClose ||
         token->kind == TokenBaseKind_ScopeOpen ||
         token->kind == TokenBaseKind_ScopeClose ||
         token->kind == TokenBaseKind_ScopeOpen ||
         token->kind == TokenBaseKind_ScopeClose){
break;
}
else if (token->kind == TokenBaseKind_Keyword){
String_Const_u8 lexeme = string_substring(state->contents, Ii64(token));
if (string_match(lexeme, SCu8((u8*)("struct"), (u64)(sizeof("struct") - 1))) ||
    string_match(lexeme, SCu8((u8*)("union"), (u64)(sizeof("union") - 1))) ||
    string_match(lexeme, SCu8((u8*)("enum"), (u64)(sizeof("enum") - 1)))){
break;
}
}
if (!did_advance){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
}
}
}

static void
cpp_parse_function(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
Token *token = token_it_read(&state->it);
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
if (state->finished){
return;
}
Token *peek = token_it_read(&state->it);
Token *reset_point = peek;
if (peek != 0 && peek->sub_kind == TokenCppKind_ParenOp){
b32 at_paren_close = false;
i32 paren_nest_level = 0;
for (; peek != 0;){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
peek = token_it_read(&state->it);
if (peek == 0 || state->finished){
break;
}

if (peek->kind == TokenBaseKind_ParentheticalOpen){
paren_nest_level += 1;
}
else if (peek->kind == TokenBaseKind_ParentheticalClose){
if (paren_nest_level > 0){
paren_nest_level -= 1;
}
else{
at_paren_close = true;
break;
}
}
}

if (at_paren_close){
generic_parse_inc(state);
generic_parse_skip_soft_tokens(index, state);
peek = token_it_read(&state->it);
if (peek != 0 &&
    peek->kind == TokenBaseKind_ScopeOpen ||
    peek->kind == TokenBaseKind_StatementClose){
index_new_note(index, state, Ii64(token), CodeIndexNote_Function, parent);
}
}
}
state->it = token_iterator(state->it.user_id, state->it.tokens, state->it.count, reset_point);
}

static Code_Index_Nest*
generic_parse_statement(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_preprocessor(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_scope(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_paren(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_statement(Code_Index_File *index, Generic_Parse_State *state){
Token *token = token_it_read(&state->it);
Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "469" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "469" ":") - 1)))));
result->kind = CodeIndexNest_Statement;
result->open = Ii64(token->pos);
result->close = Ii64(max_i64);
result->file = index;

state->in_statement = true;

for (;;){
generic_parse_skip_soft_tokens(index, state);
token = token_it_read(&state->it);
if (token == 0 || state->finished){
break;
}

if (state->in_preprocessor){
if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
    token->kind == TokenBaseKind_Preprocessor){
result->is_closed = true;
result->close = Ii64(token->pos);
break;
}
}
else{
if (token->kind == TokenBaseKind_Preprocessor){
result->is_closed = true;
result->close = Ii64(token->pos);
break;
}
}

if (token->kind == TokenBaseKind_ScopeOpen ||
    token->kind == TokenBaseKind_ScopeClose ||
    token->kind == TokenBaseKind_ParentheticalOpen){
result->is_closed = true;
result->close = Ii64(token->pos);
break;
}

if (token->kind == TokenBaseKind_StatementClose){
result->is_closed = true;
result->close = Ii64(token);
generic_parse_inc(state);
break;
}

generic_parse_inc(state);
}

state->in_statement = false;

return(result);
}

static Code_Index_Nest*
generic_parse_preprocessor(Code_Index_File *index, Generic_Parse_State *state){
Token *token = token_it_read(&state->it);
Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "526" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "526" ":") - 1)))));
result->kind = CodeIndexNest_Preprocessor;
result->open = Ii64(token->pos);
result->close = Ii64(max_i64);
result->file = index;

state->in_preprocessor = true;

b32 potential_macro = false;
if (state->do_cpp_parse){
if (token->sub_kind == TokenCppKind_PPDefine){
potential_macro = true;
}
}

generic_parse_inc(state);
for (;;){
generic_parse_skip_soft_tokens(index, state);
token = token_it_read(&state->it);
if (token == 0 || state->finished){
break;
}

if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
    token->kind == TokenBaseKind_Preprocessor){
result->is_closed = true;
result->close = Ii64(token->pos);
break;
}

if (state->do_cpp_parse && potential_macro){
if (token->sub_kind == TokenCppKind_Identifier){
index_new_note(index, state, Ii64(token), CodeIndexNote_Macro, result);
}
potential_macro = false;
}

if (token->kind == TokenBaseKind_ScopeOpen){
Code_Index_Nest *nest = generic_parse_scope(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
continue;
}

if (token->kind == TokenBaseKind_ParentheticalOpen){
Code_Index_Nest *nest = generic_parse_paren(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
continue;
}

generic_parse_inc(state);
}

result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

state->in_preprocessor = false;

return(result);
}

static Code_Index_Nest*
generic_parse_scope(Code_Index_File *index, Generic_Parse_State *state){
Token *token = token_it_read(&state->it);
Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "590" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "590" ":") - 1)))));
result->kind = CodeIndexNest_Scope;
result->open = Ii64(token);
result->close = Ii64(max_i64);
result->file = index;

state->scope_counter += 1;

generic_parse_inc(state);
for (;;){
generic_parse_skip_soft_tokens(index, state);
token = token_it_read(&state->it);
if (token == 0 || state->finished){
break;
}

if (state->in_preprocessor){
if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
    token->kind == TokenBaseKind_Preprocessor){
break;
}
}
else{
if (token->kind == TokenBaseKind_Preprocessor){
Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
code_index_push_nest(&index->nest_list, nest);
continue;
}
}

if (token->kind == TokenBaseKind_ScopeClose){
result->is_closed = true;
result->close = Ii64(token);
generic_parse_inc(state);
break;
}

if (token->kind == TokenBaseKind_ScopeOpen){
Code_Index_Nest *nest = generic_parse_scope(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
continue;
}

if (token->kind == TokenBaseKind_ParentheticalClose){
generic_parse_inc(state);
continue;
}

if (token->kind == TokenBaseKind_ParentheticalOpen){
Code_Index_Nest *nest = generic_parse_paren(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);



nest = generic_parse_statement(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);

continue;
}

{
Code_Index_Nest *nest = generic_parse_statement(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
}
}

result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

state->scope_counter -= 1;

return(result);
}

static Code_Index_Nest*
generic_parse_paren(Code_Index_File *index, Generic_Parse_State *state){
Token *token = token_it_read(&state->it);
Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "670" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp" ":" "670" ":") - 1)))));
result->kind = CodeIndexNest_Paren;
result->open = Ii64(token);
result->close = Ii64(max_i64);
result->file = index;

i64 manifested_characters_on_line = 0;
{
u8 *ptr = state->prev_line_start;
u8 *end_ptr = state->contents.str + token->pos;

for (;ptr < end_ptr; ptr += 1){
if (!character_is_whitespace(*ptr)){
break;
}
}

manifested_characters_on_line = (i64)(end_ptr - ptr) + token->size;
}

state->paren_counter += 1;

generic_parse_inc(state);
for (;;){
generic_parse_skip_soft_tokens(index, state);
token = token_it_read(&state->it);
if (token == 0 || state->finished){
break;
}

if (state->in_preprocessor){
if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
    token->kind == TokenBaseKind_Preprocessor){
break;
}
}
else{
if (token->kind == TokenBaseKind_Preprocessor){
Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
code_index_push_nest(&index->nest_list, nest);
continue;
}
}

if (token->kind == TokenBaseKind_ParentheticalClose){
result->is_closed = true;
result->close = Ii64(token);
generic_parse_inc(state);
break;
}

if (token->kind == TokenBaseKind_ScopeClose){
break;
}

if (token->kind == TokenBaseKind_ScopeOpen){
Code_Index_Nest *nest = generic_parse_scope(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
continue;
}

if (token->kind == TokenBaseKind_ParentheticalOpen){
Code_Index_Nest *nest = generic_parse_paren(index, state);
nest->parent = result;
code_index_push_nest(&result->nest_list, nest);
continue;
}

generic_parse_inc(state);
}

result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

state->paren_counter -= 1;

return(result);
}

static b32
generic_parse_full_input_breaks(Code_Index_File *index, Generic_Parse_State *state, i32 limit){
b32 result = false;

i64 first_index = token_it_index(&state->it);
i64 one_past_last_index = first_index + limit;
for (;;){
generic_parse_skip_soft_tokens(index, state);
Token *token = token_it_read(&state->it);

if (token == 0 || state->finished){
result = true;
break;
}

if (token->kind == TokenBaseKind_Preprocessor){
Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
code_index_push_nest(&index->nest_list, nest);
}
else if (token->kind == TokenBaseKind_ScopeOpen){
Code_Index_Nest *nest = generic_parse_scope(index, state);
code_index_push_nest(&index->nest_list, nest);
}
else if (token->kind == TokenBaseKind_ParentheticalOpen){
Code_Index_Nest *nest = generic_parse_paren(index, state);
code_index_push_nest(&index->nest_list, nest);
}
else if (state->do_cpp_parse){
if (token->sub_kind == TokenCppKind_Struct ||
    token->sub_kind == TokenCppKind_Union ||
    token->sub_kind == TokenCppKind_Enum){
cpp_parse_type_structure(index, state, 0);
}
else if (token->sub_kind == TokenCppKind_Typedef){
cpp_parse_type_def(index, state, 0);
}
else if (token->sub_kind == TokenCppKind_Identifier){
cpp_parse_function(index, state, 0);
}
else{
generic_parse_inc(state);
}
}
else{
generic_parse_inc(state);
}

i64 index = token_it_index(&state->it);
if (index >= one_past_last_index){
token = token_it_read(&state->it);
if (token == 0){
result = true;
}
break;
}
}

if (result){
index->nest_array = code_index_nest_ptr_array_from_list(state->arena, &index->nest_list);
index->note_array = code_index_note_ptr_array_from_list(state->arena, &index->note_list);
}

return(result);
}





static void
default_comment_index(Application_Links *app, Arena *arena, Code_Index_File *index, Token *token, String_Const_u8 contents){

}

static void
generic_parse_init(Application_Links *app, Arena *arena, String_Const_u8 contents, Token_Array *tokens, Generic_Parse_State *state){
generic_parse_init(app, arena, contents, tokens, default_comment_index, state);
}





static Token_Pair
layout_token_pair(Token_Array *tokens, i64 pos){
Token_Pair result = {};
Token_Iterator_Array it = token_iterator_pos(0, tokens, pos);
Token *b = token_it_read(&it);
if (b != 0){
if (b->kind == TokenBaseKind_Whitespace){
token_it_inc_non_whitespace(&it);
b = token_it_read(&it);
}
}
token_it_dec_non_whitespace(&it);
Token *a = token_it_read(&it);
if (a != 0){
result.a = *a;
}
if (b != 0){
result.b = *b;
}
return(result);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_Nest *nest, i64 pos, f32 regular_indent, b32 *unresolved_dependence){
f32 result = 0.f;
if (nest != 0){
switch (nest->kind){
case CodeIndexNest_Scope:
case CodeIndexNest_Preprocessor:
{
result = layout_index_x_shift(app, reflex, nest->parent, pos, regular_indent, unresolved_dependence);
if (nest->open.min < pos && nest->open.max <= pos &&
    (!nest->is_closed || pos < nest->close.min)){
result += regular_indent;
}
}break;

case CodeIndexNest_Statement:
{
result = layout_index_x_shift(app, reflex, nest->parent, pos, regular_indent, unresolved_dependence);
if (nest->open.min < pos && nest->open.max <= pos &&
    (!nest->is_closed || pos < nest->close.min)){
result += regular_indent;
}
}break;

case CodeIndexNest_Paren:
{
Rect_f32 box = layout_reflex_get_rect(app, reflex, nest->open.max - 1, unresolved_dependence);
result = box.x1;
}break;
}
}
return(result);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_Nest *nest, i64 pos, f32 regular_indent){
b32 ignore;
return(layout_index_x_shift(app, reflex, nest, pos, regular_indent, &ignore));
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_File *file, i64 pos, f32 regular_indent, b32 *unresolved_dependence){
f32 indent = 0;
Code_Index_Nest *nest = code_index_get_nest(file, pos);
if (nest != 0){
indent = layout_index_x_shift(app, reflex, nest, pos, regular_indent, unresolved_dependence);
}
return(indent);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_File *file, i64 pos, f32 regular_indent){
b32 ignore;
return(layout_index_x_shift(app, reflex, file, pos, regular_indent, &ignore));
}

static void
layout_index__emit_chunk(LefRig_TopBot_Layout_Vars *pos_vars, Face_ID face, Arena *arena, u8 *text_str, i64 range_first, u8 *ptr, u8 *end, Layout_Item_List *list){
for (;ptr < end;){
Character_Consume_Result consume = utf8_consume(ptr, (u64)(end - ptr));
if (consume.codepoint != '\r'){
i64 index = layout_index_from_ptr(ptr, text_str, range_first);
if (consume.codepoint != max_u32){
lr_tb_write(pos_vars, face, arena, list, index, consume.codepoint);
}
else{
lr_tb_write_byte(pos_vars, face, arena, list, index, *ptr);
}
}
ptr += consume.inc;
}
}

static i32
layout_token_score_wrap_token(Token_Pair *pair, Token_Cpp_Kind kind){
i32 result = 0;
if (pair->a.sub_kind != kind && pair->b.sub_kind == kind){
result -= 1;
}
else if (pair->a.sub_kind == kind && pair->b.sub_kind != kind){
result += 1;
}
return(result);
}

static Layout_Item_List
layout_index__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Code_Index_File *file, Layout_Wrap_Kind kind){
Scratch_Block scratch(app, arena);

Token_Array tokens = get_token_array_from_buffer(app, buffer);
Token_Array *tokens_ptr = &tokens;

Layout_Item_List list = get_empty_item_list(range);
String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

Face_Advance_Map advance_map = get_face_advance_map(app, face);
Face_Metrics metrics = get_face_metrics(app, face);
f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
tab_width = (((1)>(tab_width))?(1):(tab_width));
LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

u64 vw_indent = def_get_config_u64(app, vars_save_string(SCu8((u8*)("virtual_whitespace_regular_indent"), (u64)(sizeof("virtual_whitespace_regular_indent") - 1))));
f32 regular_indent = metrics.space_advance*vw_indent;
f32 wrap_align_x = width - metrics.normal_advance;

Layout_Reflex reflex = get_layout_reflex(&list, buffer, width, face);

if (text.size == 0){
lr_tb_write_blank(&pos_vars, face, arena, &list, range.start);
}
else{
b32 first_of_the_line = true;
Newline_Layout_Vars newline_vars = get_newline_layout_vars();

u8 *ptr = text.str;
u8 *end_ptr = ptr + text.size;
u8 *word_ptr = ptr;

u8 *pending_wrap_ptr = ptr;
f32 pending_wrap_x = 0.f;
i32 pending_wrap_paren_nest_count = 0;
i32 pending_wrap_token_score = 0;
f32 pending_wrap_accumulated_w = 0.f;

start:
if (ptr == end_ptr){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
lr_tb_advance_x_without_item(&pos_vars, shift);
goto finish;
}

if (!character_is_whitespace(*ptr)){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
lr_tb_advance_x_without_item(&pos_vars, shift);
goto consuming_non_whitespace;
}

{
for (;ptr < end_ptr; ptr += 1){
if (!character_is_whitespace(*ptr)){
pending_wrap_ptr = ptr;
word_ptr = ptr;
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
lr_tb_advance_x_without_item(&pos_vars, shift);
goto consuming_non_whitespace;
}
if (*ptr == '\r'){
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
newline_layout_consume_CR(&newline_vars, index);
}
else if (*ptr == '\n'){
pending_wrap_ptr = ptr;
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
lr_tb_advance_x_without_item(&pos_vars, shift);
goto consuming_normal_whitespace;
}
}

if (ptr == end_ptr){
pending_wrap_ptr = ptr;
i64 index = layout_index_from_ptr(ptr - 1, text.str, range.first);
f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
lr_tb_advance_x_without_item(&pos_vars, shift);
goto finish;
}
}

consuming_non_whitespace:
{
for (;ptr <= end_ptr; ptr += 1){
if (ptr == end_ptr || character_is_whitespace(*ptr)){
break;
}
}


newline_layout_consume_default(&newline_vars);
String_Const_u8 word = SCu8(word_ptr, ptr);
u8 *word_end = ptr;
{
f32 word_advance = 0.f;
ptr = word.str;
for (;ptr < word_end;){
Character_Consume_Result consume = utf8_consume(ptr, (u64)(word_end - ptr));
if (consume.codepoint != max_u32){
word_advance += lr_tb_advance(&pos_vars, face, consume.codepoint);
}
else{
word_advance += lr_tb_advance_byte(&pos_vars);
}
ptr += consume.inc;
}
pending_wrap_accumulated_w += word_advance;
}

if (!first_of_the_line && (kind == Layout_Wrapped) && lr_tb_crosses_width(&pos_vars, pending_wrap_accumulated_w)){
i64 index = layout_index_from_ptr(pending_wrap_ptr, text.str, range.first);
lr_tb_align_rightward(&pos_vars, wrap_align_x);
lr_tb_write_ghost(&pos_vars, face, arena, &list, index, '\\');

lr_tb_next_line(&pos_vars);





ptr = pending_wrap_ptr;
pending_wrap_accumulated_w = 0.f;
first_of_the_line = true;
goto start;
}
}

consuming_normal_whitespace:
for (; ptr < end_ptr; ptr += 1){
if (!character_is_whitespace(*ptr)){
u8 *new_wrap_ptr = ptr;

i64 index = layout_index_from_ptr(new_wrap_ptr, text.str, range.first);
Code_Index_Nest *new_wrap_nest = code_index_get_nest(file, index);
b32 invalid_wrap_x = false;
f32 new_wrap_x = layout_index_x_shift(app, &reflex, new_wrap_nest, index, regular_indent, &invalid_wrap_x);
if (invalid_wrap_x){
new_wrap_x = max_f32;
}

i32 new_wrap_paren_nest_count = 0;
for (Code_Index_Nest *nest = new_wrap_nest;
     nest != 0;
     nest = nest->parent){
if (nest->kind == CodeIndexNest_Paren){
new_wrap_paren_nest_count += 1;
}
}

Token_Pair new_wrap_token_pair = layout_token_pair(tokens_ptr, index);



i32 token_score = 0;
if (new_wrap_token_pair.a.kind == TokenBaseKind_Keyword){
if (new_wrap_token_pair.b.kind == TokenBaseKind_ParentheticalOpen ||
    new_wrap_token_pair.b.kind == TokenBaseKind_Keyword){
token_score -= 2;
}
}
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Eq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_PlusEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_MinusEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_StarEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_DivEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_ModEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_LeftLeftEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_RightRightEq);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Comma);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_AndAnd);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_OrOr);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Ternary);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Colon);
token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Semicolon);

i32 new_wrap_token_score = token_score;

b32 new_wrap_ptr_is_better = false;
if (first_of_the_line){
new_wrap_ptr_is_better = true;
}
else{
if (new_wrap_token_score > pending_wrap_token_score){
new_wrap_ptr_is_better = true;
}
else if (new_wrap_token_score == pending_wrap_token_score){
f32 new_score = new_wrap_paren_nest_count*10.f + new_wrap_x;
f32 old_score = pending_wrap_paren_nest_count*10.f + pending_wrap_x + metrics.normal_advance*4.f + pending_wrap_accumulated_w*0.5f;

if (new_score < old_score){
new_wrap_ptr_is_better = true;
}
}
}

if (new_wrap_ptr_is_better){
layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, new_wrap_ptr, &list);
first_of_the_line = false;

pending_wrap_ptr = new_wrap_ptr;
pending_wrap_paren_nest_count = new_wrap_paren_nest_count;
pending_wrap_x = layout_index_x_shift(app, &reflex, new_wrap_nest, index, regular_indent);
pending_wrap_paren_nest_count = new_wrap_paren_nest_count;
pending_wrap_token_score = new_wrap_token_score;
pending_wrap_accumulated_w = 0.f;
}

word_ptr = ptr;
goto consuming_non_whitespace;
}

i64 index = layout_index_from_ptr(ptr, text.str, range.first);
switch (*ptr){
default:
{
newline_layout_consume_default(&newline_vars);
pending_wrap_accumulated_w += lr_tb_advance(&pos_vars, face, *ptr);
}break;

case '\r':
{
newline_layout_consume_CR(&newline_vars, index);
}break;

case '\n':
{
layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, ptr, &list);
pending_wrap_ptr = ptr + 1;
pending_wrap_accumulated_w = 0.f;

u64 newline_index = newline_layout_consume_LF(&newline_vars, index);
lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
lr_tb_next_line(&pos_vars);
first_of_the_line = true;
ptr += 1;
goto start;
}break;
}
}

finish:
if (newline_layout_consume_finish(&newline_vars)){
layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, ptr, &list);
i64 index = layout_index_from_ptr(ptr, text.str, range.first);
lr_tb_write_blank(&pos_vars, face, arena, &list, index);
}
}

layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

return(list);
}

static Layout_Item_List
layout_virt_indent_index(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
Layout_Item_List result = {};

b32 enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
if (enable_virtual_whitespace){
code_index_lock();
Code_Index_File *file = code_index_get_file(buffer);
if (file != 0){
result = layout_index__inner(app, arena, buffer, range, face, width, file, kind);
}
code_index_unlock();
if (file == 0){
result = layout_virt_indent_literal(app, arena, buffer, range, face, width, kind);
}
}
else{
result = layout_basic(app, arena, buffer, range, face, width, kind);
}

return(result);
}

static Layout_Item_List
layout_virt_indent_index_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_virt_indent_index(app, arena, buffer, range, face, width, Layout_Unwrapped));
}

static Layout_Item_List
layout_virt_indent_index_wrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
return(layout_virt_indent_index(app, arena, buffer, range, face, width, Layout_Wrapped));
}

static Layout_Item_List
layout_virt_indent_index_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
Managed_Scope scope = buffer_get_managed_scope(app, buffer);
b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
return(layout_virt_indent_index(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}

CUSTOM_COMMAND(toggle_virtual_whitespace, "/home/tabletel/dev/4cc/code/custom/4coder_code_index.cpp", 1238, Normal)
CUSTOM_DOC("Toggles virtual whitespace for all files.")
{
String_ID key = vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1)));
b32 enable_virtual_whitespace = def_get_config_b32(key);
def_set_config_b32(key, !enable_virtual_whitespace);
}
# 108 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 1






static FColor
fcolor_argb(ARGB_Color color){
    FColor result = {};
    result.argb = color;
    if (result.a_byte == 0){
        result.argb = 0;
    }
    return(result);
}
static FColor
fcolor_argb(Vec4_f32 color){
    return(fcolor_argb(pack_color(color)));
}
static FColor
fcolor_argb(f32 r, f32 g, f32 b, f32 a){
    return(fcolor_argb(pack_color(V4f32(r, g, b, a))));
}

static FColor
fcolor_id(Managed_ID id){
    FColor result = {};
    result.id = (ID_Color)id;
    return(result);
}

static FColor
fcolor_id(Managed_ID id, u32 sub_index){
    FColor result = {};
    result.id = (ID_Color)id;
    result.sub_index = (u8)sub_index;
    return(result);
}

static ARGB_Color
argb_color_blend(ARGB_Color a, f32 at, ARGB_Color b, f32 bt){
    Vec4_f32 av = unpack_color(a);
    Vec4_f32 bv = unpack_color(b);
    Vec4_f32 value = at*av + bt*bv;
    return(pack_color(value));
}
static ARGB_Color
argb_color_blend(ARGB_Color a, f32 t, ARGB_Color b){
    return(argb_color_blend(a, 1.f - t, b, t));
}

static ARGB_Color
fcolor_resolve(FColor color){
    ARGB_Color result = 0;
    if (color.a_byte == 0){
        if (color.id != 0){
            result = finalize_color(color.id, color.sub_index);
        }
    }
    else{
        result = color.argb;
    }
    return(result);
}

static FColor
fcolor_change_alpha(FColor color, f32 alpha){
    Vec4_f32 v = unpack_color(fcolor_resolve(color));
    v.a = alpha;
    return(fcolor_argb(pack_color(v)));
}
static FColor
fcolor_blend(FColor a, f32 at, FColor b, f32 bt){
    ARGB_Color a_argb = fcolor_resolve(a);
    ARGB_Color b_argb = fcolor_resolve(b);
    return(fcolor_argb(argb_color_blend(a_argb, at, b_argb, bt)));
}
static FColor
fcolor_blend(FColor a, f32 t, FColor b){
    return(fcolor_blend(a, 1.f - t, b, t));
}

static FColor
fcolor_zero(void){
    FColor result = {};
    return(result);
}

static b32
fcolor_is_valid(FColor color){
    return(color.argb != 0);
}



static void
push_fancy_string(Fancy_Line *line, Fancy_String *string){
    do{ if((string)){if((line->first)){(line->last)->next=(string);}else{(line->first)=(string);}(line->last)=(string);(line->last)->next=0;} }while(0);
}

static void
push_fancy_line(Fancy_Block *block, Fancy_Line *line){
    do{ if((line)){if((block->first)){(block->last)->next=(line);}else{(block->first)=(line);}(block->last)=(line);(block->last)->next=0;} }while(0);
    block->line_count += 1;
}



static Fancy_String*
fill_fancy_string(Fancy_String *ptr, Face_ID face, FColor fore, f32 pre_margin, f32 post_margin,
                  String_Const_u8 value){
    ptr->value = value;
    ptr->face = face;
    ptr->fore = fore;
    ptr->pre_margin = pre_margin;
    ptr->post_margin = post_margin;
    return(ptr);
}

static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    Fancy_String *result = ((Fancy_String*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Fancy_String)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" ":" "123" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" ":" "123" ":") - 1)))));
    fill_fancy_string(result, face, fore, pre_margin, post_margin, value);
    if (line != 0){
        push_fancy_string(line, result);
    }
    return(result);
}

static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                  String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fore, 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fcolor_zero(),
                             pre_margin, post_margin, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, FColor fore,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fore, pre_margin, post_margin, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fcolor_zero(), 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, FColor color, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, color, 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                  String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fcolor_zero(), pre_margin, post_margin,
                             value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fcolor_zero(), 0, 0, value));
}



static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_string(arena, line, face, fore, pre_margin, post_margin,
                             push_u8_stringfv(arena, format, args)));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fore, 0, 0, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fcolor_zero(),
                               pre_margin, post_margin, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, FColor fore,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fore, pre_margin, post_margin,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fcolor_zero(), 0, 0,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, FColor color,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, color, 0, 0, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fcolor_zero(), pre_margin, post_margin,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fcolor_zero(), 0, 0, format, args));
}





static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 225 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_string(arena, line, face, fore, pre_margin, post_margin, push_u8_stringfv(arena, format, args))
                                                                         ;
    
# 228 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 228 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 228 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 228 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                   char *format, ...){
    va_list args; 
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 233 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fore, 0, 0, format, args);
    
# 235 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 235 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 235 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 235 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 241 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fcolor_zero(), pre_margin, post_margin, format, args)
                                                                           ;
    
# 244 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 244 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 244 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 244 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, FColor fore,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 250 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fore, pre_margin, post_margin, format, args)
                                                  ;
    
# 253 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 253 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 253 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 253 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face,
                   char *format, ...){
    va_list args; 
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 258 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fcolor_zero(), 0, 0, format, args)
                                                  ;
    
# 261 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 261 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 261 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 261 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, FColor color,
                   char *format, ...){
    va_list args; 
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 266 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, color, 0, 0, format, args);
    
# 268 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 268 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 268 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 268 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 273 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fcolor_zero(), pre_margin, post_margin, format, args)
                                                                           ;
    
# 276 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 276 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 276 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 276 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line,
                   char *format, ...){
    va_list args; 
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   ,
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   format
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 281 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fcolor_zero(), 0, 0, format, args);
    
# 283 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 283 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   args
# 283 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" 3 4
   )
# 283 "/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp"
   ; return(result);
}



static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        f32 pre_margin, f32 post_margin,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, FColor fore,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}

static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        f32 pre_margin, f32 post_margin,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, FColor fore,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}



static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, FColor fore,
                String_Const_u8 text){
    Fancy_Line *line = ((Fancy_Line*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Fancy_Line)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" ":" "503" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_fancy.cpp" ":" "503" ":") - 1)))));
    line->face = face;
    line->fore = fore;
    if (text.size != 0){
        push_fancy_string(arena, line, text);
    }
    if (block != 0){
        push_fancy_line(block, line);
    }
    return(line);
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, FColor fcolor){
    return(push_fancy_line(arena, block, face, fcolor, SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, String_Const_u8 val){
    return(push_fancy_line(arena, block, face, fcolor_zero(), val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, FColor color, String_Const_u8 val){
    return(push_fancy_line(arena, block, 0, color, val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face){
    return(push_fancy_line(arena, block, face, fcolor_zero(), SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, FColor color){
    return(push_fancy_line(arena, block, 0, color, SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, String_Const_u8 val){
    return(push_fancy_line(arena, block, 0, fcolor_zero(), val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block){
    return(push_fancy_line(arena, block, 0, fcolor_zero(), SCu8()));
}



static f32
get_fancy_string_width__inner(Application_Links *app, Face_ID face,
                              Fancy_String *string){
    f32 result = 0.f;
    for (;string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        if (use_face != 0){
            result += get_string_advance(app, use_face, string->value);
            Face_Metrics metrics = get_face_metrics(app, use_face);
            f32 normal_advance = metrics.normal_advance;
            result += (string->pre_margin + string->post_margin)*normal_advance;
        }
    }
    return(result);
}

static f32
get_fancy_string_height__inner(Application_Links *app, Face_ID face, Fancy_String *string){
    f32 result = 0.f;
    if (face != 0){
        Face_Metrics metrics = get_face_metrics(app, face);
        result = metrics.line_height;
    }
    for (;string != 0;
         string = string->next){
        if (string->face != 0){
            Face_ID use_face = string->face;
            Face_Metrics metrics = get_face_metrics(app, use_face);
            result = (((result)>(metrics.line_height))?(result):(metrics.line_height));
        }
    }
    return(result);
}

static f32
get_fancy_string_text_height__inner(Application_Links *app, Face_ID face, Fancy_String *string){
    f32 result = 0.f;
    if (face != 0){
        Face_Metrics metrics = get_face_metrics(app, face);
        result = metrics.text_height;
    }
    for (;string != 0;
         string = string->next){
        if (string->face != 0){
            Face_ID use_face = string->face;
            Face_Metrics metrics = get_face_metrics(app, use_face);
            result = (((result)>(metrics.text_height))?(result):(metrics.text_height));
        }
    }
    return(result);
}

static Vec2_f32
draw_fancy_string__inner(Application_Links *app, Face_ID face, FColor fore, Fancy_String *first_string, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    f32 base_line = 0.f;
    for (Fancy_String *string = first_string;
         string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        if (use_face != 0){
            Face_Metrics metrics = get_face_metrics(app, use_face);
            base_line = (((base_line)>(metrics.ascent))?(base_line):(metrics.ascent));
        }
    }

    Vec2_f32 down_delta = V2f32(-delta.y, delta.x);
    for (Fancy_String *string = first_string;
         string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        FColor use_fore = fore;
        if (fcolor_is_valid(string->fore)){
            use_fore = string->fore;
        }
        if (use_face != 0){
            ARGB_Color use_argb = fcolor_resolve(use_fore);
            Face_Metrics metrics = get_face_metrics(app, use_face);
            f32 down_shift = (base_line - metrics.ascent);
            down_shift = (((0.f)>(down_shift))?(0.f):(down_shift));
            Vec2_f32 p_shift = down_shift*down_delta;
            Vec2_f32 p_shifted = p + p_shift;

            if (fcolor_is_valid(use_fore)){
                Vec2_f32 margin_delta = delta*metrics.normal_advance;
                p_shifted += margin_delta*string->pre_margin;
                p_shifted = draw_string_oriented(app, use_face, use_argb, string->value, p_shifted, flags, delta);
                p_shifted += margin_delta*string->post_margin;
            }
            else{
                f32 adv =
                    (string->pre_margin + string->post_margin)*metrics.normal_advance;
                adv += get_string_advance(app, use_face, string->value);
                p_shifted += adv*delta;
            }

            p = p_shifted - p_shift;
        }
    }
    return(p);
}

static f32
get_fancy_string_width(Application_Links *app, Face_ID face,
                       Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_width__inner(app, face, string);
    string->next = next;
    return(result);
}

static f32
get_fancy_string_height(Application_Links *app, Face_ID face,
                        Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_height__inner(app, face, string);
    string->next = next;
    return(result);
}

static f32
get_fancy_string_text_height(Application_Links *app, Face_ID face,
                             Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_text_height__inner(app, face, string);
    string->next = next;
    return(result);
}

static Vec2_f32
get_fancy_string_dim(Application_Links *app, Face_ID face, Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    Vec2_f32 result = V2f32(get_fancy_string_width__inner(app, face, string),
                            get_fancy_string_height__inner(app, face, string));
    string->next = next;
    return(result);
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Face_ID face, FColor fore,
                  Fancy_String *string, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    Fancy_String *next = string->next;
    string->next = 0;
    Vec2_f32 result = draw_fancy_string__inner(app, face, fore, string, p, flags, delta);
    string->next = next;
    return(result);
}

static f32
get_fancy_line_width(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_width__inner(app, face, line->first);
    }
    return(result);
}

static f32
get_fancy_line_height(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_height__inner(app, face, line->first);
    }
    return(result);
}

static f32
get_fancy_line_text_height(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_text_height__inner(app, face, line->first);
    }
    return(result);
}

static Vec2_f32
get_fancy_line_dim(Application_Links *app, Face_ID face, Fancy_Line *line){
    Vec2_f32 result = {};
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = V2f32(get_fancy_string_width__inner(app, face, line->first), get_fancy_string_height__inner(app, face, line->first));
    }
    return(result);
}

static Vec2_f32
draw_fancy_line(Application_Links *app, Face_ID face, FColor fore,
                Fancy_Line *line, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    Vec2_f32 result = {};
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        if (fcolor_is_valid(line->fore)){
            fore = line->fore;
        }
        result = draw_fancy_string__inner(app, face, fore, line->first, p, flags, delta);
    }
    return(result);
}

static f32
get_fancy_block_width(Application_Links *app, Face_ID face, Fancy_Block *block){
    f32 width = 0.f;
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        f32 w = get_fancy_line_width(app, face, node);
        width = (((width)>(w))?(width):(w));
    }
    return(width);
}

static f32
get_fancy_block_height(Application_Links *app, Face_ID face, Fancy_Block *block){
    f32 height = 0.f;
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        height += get_fancy_line_height(app, face, node);
    }
    return(height);
}

static Vec2_f32
get_fancy_block_dim(Application_Links *app, Face_ID face, Fancy_Block *block){
    Vec2_f32 result = {};
    result.x = get_fancy_block_width(app, face, block);
    result.y = get_fancy_block_height(app, face, block);
    return(result);
}

static void
draw_fancy_block(Application_Links *app, Face_ID face, FColor fore,
                 Fancy_Block *block, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        draw_fancy_line(app, face, fore, node, p, flags, delta);
        p.y += get_fancy_line_height(app, face, node);
    }
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Face_ID face, FColor fore,
                  Fancy_String *string, Vec2_f32 p){
    return(draw_fancy_string(app, face, fore, string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Fancy_String *string, Vec2_f32 p){
    return(draw_fancy_string(app, 0, fcolor_zero(), string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_fancy_line(Application_Links *app, Face_ID face, FColor fore,
                Fancy_Line *line, Vec2_f32 p){
    return(draw_fancy_line(app, face, fore, line, p, 0, V2f32(1.f, 0.f)));
}

static void
draw_fancy_block(Application_Links *app, Face_ID face, FColor fore,
                 Fancy_Block *block, Vec2_f32 p){
    draw_fancy_block(app, face, fore, block, p, 0, V2f32(1.f, 0.f));
}




static FColor f_white = fcolor_argb(1.0f, 1.0f, 1.0f, 1.0f);
static FColor f_light_gray = fcolor_argb(0.7f, 0.7f, 0.7f, 1.0f);
static FColor f_gray = fcolor_argb(0.5f, 0.5f, 0.5f, 1.0f);
static FColor f_dark_gray = fcolor_argb(0.3f, 0.3f, 0.3f, 1.0f);
static FColor f_black = fcolor_argb(0.0f, 0.0f, 0.0f, 1.0f);
static FColor f_red = fcolor_argb(1.0f, 0.0f, 0.0f, 1.0f);
static FColor f_green = fcolor_argb(0.0f, 1.0f, 0.0f, 1.0f);
static FColor f_blue = fcolor_argb(0.0f, 0.0f, 1.0f, 1.0f);
static FColor f_yellow = fcolor_argb(1.0f, 1.0f, 0.0f, 1.0f);
static FColor f_pink = fcolor_argb(1.0f, 0.0f, 1.0f, 1.0f);
static FColor f_cyan = fcolor_argb(0.0f, 1.0f, 1.0f, 1.0f);
# 109 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" 1






static void
draw_text_layout_default(Application_Links *app, Text_Layout_ID layout_id){
    ARGB_Color special_color = finalize_color(defcolor_special_character, 0);
    ARGB_Color ghost_color = finalize_color(defcolor_ghost_character, 0);
    draw_text_layout(app, layout_id, special_color, ghost_color);
}

static FColor
get_item_margin_color(i32 level, i32 sub_id){
    FColor margin = fcolor_zero();
    switch (level){
        default:
        case UIHighlight_None:
        {
            margin = fcolor_id(defcolor_list_item, sub_id);
        }break;
        case UIHighlight_Hover:
        {
            margin = fcolor_id(defcolor_list_item_hover, sub_id);
        }break;
        case UIHighlight_Active:
        {
            margin = fcolor_id(defcolor_list_item_active, sub_id);
        }break;
    }
    return(margin);
}
static FColor
get_item_margin_color(i32 level){
    return(get_item_margin_color(level, 0));
}
static FColor
get_panel_margin_color(i32 level){
    FColor margin = fcolor_zero();
    switch (level){
        default:
        case UIHighlight_None:
        {
            margin = fcolor_id(defcolor_margin);
        }break;
        case UIHighlight_Hover:
        {
            margin = fcolor_id(defcolor_margin_hover);
        }break;
        case UIHighlight_Active:
        {
            margin = fcolor_id(defcolor_margin_active);
        }break;
    }
    return(margin);
}

static Vec2_f32
draw_string(Application_Links *app, Face_ID font_id, String_Const_u8 string, Vec2_f32 p, ARGB_Color color){
    return(draw_string_oriented(app, font_id, color, string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_string(Application_Links *app, Face_ID font_id, String_Const_u8 string, Vec2_f32 p, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    return(draw_string(app, font_id, string, p, argb));
}

static void
draw_rectangle_fcolor(Application_Links *app, Rect_f32 rect, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_rectangle(app, rect, roundness, argb);
}

static void
draw_rectangle_outline_fcolor(Application_Links *app, Rect_f32 rect, f32 roundness, f32 thickness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_rectangle_outline(app, rect, roundness, thickness, argb);
}

static void
draw_margin(Application_Links *app, Rect_f32 outer, Rect_f32 inner, ARGB_Color color){
    draw_rectangle(app, Rf32(outer.x0, outer.y0, outer.x1, inner.y0), 0.f, color);
    draw_rectangle(app, Rf32(outer.x0, inner.y1, outer.x1, outer.y1), 0.f, color);
    draw_rectangle(app, Rf32(outer.x0, inner.y0, inner.x0, inner.y1), 0.f, color);
    draw_rectangle(app, Rf32(inner.x1, inner.y0, outer.x1, inner.y1), 0.f, color);
}

static void
draw_margin(Application_Links *app, Rect_f32 outer, Rect_f32 inner, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_margin(app, outer, inner, argb);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    draw_rectangle(app, rect, roundness, color);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_block(app, layout, pos, roundness, argb);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, ARGB_Color color){
    if (range.first < range.one_past_last){
        i64 i = range.first;
        Rect_f32 first_rect = text_layout_character_on_screen(app, layout, i);
        i += 1;
        Range_f32 y = rect_range_y(first_rect);
        Range_f32 x = rect_range_x(first_rect);
        for (;i < range.one_past_last; i += 1){
            Rect_f32 rect = text_layout_character_on_screen(app, layout, i);
            if (rect.x0 < rect.x1 && rect.y0 < rect.y1){
                Range_f32 new_y = rect_range_y(rect);
                Range_f32 new_x = rect_range_x(rect);
                b32 joinable = false;
                if (new_y == y && (range_overlap(x, new_x) || x.max == new_x.min || new_x.max == x.min)){
                    joinable = true;
                }

                if (!joinable){
                    draw_rectangle(app, Rf32(x, y), roundness, color);
                    y = new_y;
                    x = new_x;
                }
                else{
                    x = range_union(x, new_x);
                }
            }
        }
        draw_rectangle(app, Rf32(x, y), roundness, color);
    }
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_block(app, layout, range, roundness, argb);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, f32 thickness, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    draw_rectangle_outline(app, rect, roundness, thickness, color);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, f32 thickness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_wire_frame(app, layout, pos, roundness, thickness, argb);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, f32 thickness, FColor color){
    for (i64 i = range.first; i < range.one_past_last; i += 1){
        draw_character_wire_frame(app, layout, i, roundness, thickness, color);
    }
}

static void
draw_character_i_bar(Application_Links *app, Text_Layout_ID layout, i64 pos, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    rect.x1 = rect.x0 + 1.f;
    draw_rectangle(app, rect, 0.f, color);
}

static void
draw_character_i_bar(Application_Links *app, Text_Layout_ID layout, i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_i_bar(app, layout, pos, argb);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, Range_i64 line_range, ARGB_Color color){
    Range_f32 y1 = text_layout_line_on_screen(app, layout, line_range.min);
    Range_f32 y2 = text_layout_line_on_screen(app, layout, line_range.max);
    Range_f32 y = range_union(y1, y2);
    if (range_size(y) > 0.f){
        Rect_f32 region = text_layout_region(app, layout);
        draw_rectangle(app, Rf32(rect_range_x(region), y), 0.f, color);
    }
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, Range_i64 line_range, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_line_highlight(app, layout, line_range, argb);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, i64 line, ARGB_Color color){
    draw_line_highlight(app, layout, Ii64(line), color);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, i64 line, FColor color){
    draw_line_highlight(app, layout, Ii64(line), color);
}

static void
paint_text_color_fcolor(Application_Links *app, Text_Layout_ID layout, Range_i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    paint_text_color(app, layout, pos, argb);
}

static void
paint_text_color_pos(Application_Links *app, Text_Layout_ID layout, i64 pos, ARGB_Color color){
    paint_text_color(app, layout, Ii64(pos, pos + 1), color);
}

static void
paint_text_color_pos(Application_Links *app, Text_Layout_ID layout, i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    paint_text_color_pos(app, layout, pos, argb);
}



static Rect_f32_Pair
layout_file_bar_on_top(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom(rect, line_height + 2.f));
}

static Rect_f32_Pair
layout_file_bar_on_bot(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom_neg(rect, line_height + 2.f));
}

static Rect_f32_Pair
layout_query_bar_on_top(Rect_f32 rect, f32 line_height, i32 bar_count){
    return(rect_split_top_bottom(rect, (line_height + 2.f)*bar_count));
}

static Rect_f32_Pair
layout_query_bar_on_bot(Rect_f32 rect, f32 line_height, i32 bar_count){
    return(rect_split_top_bottom_neg(rect, (line_height + 2.f)*bar_count));
}

static Rect_f32_Pair
layout_line_number_margin(Rect_f32 rect, f32 digit_advance, i64 digit_count){
    f32 margin_width = (f32)digit_count*digit_advance + 2.f;
    return(rect_split_left_right(rect, margin_width));
}

static Rect_f32_Pair
layout_line_number_margin(Application_Links *app, Buffer_ID buffer, Rect_f32 rect, f32 digit_advance){
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_count_digit_count = digit_count_from_integer(line_count, 10);
    return(layout_line_number_margin(rect, digit_advance, line_count_digit_count));
}

static const i32 fps_history_depth = 10;
static Rect_f32_Pair
layout_fps_hud_on_bottom(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom_neg(rect, line_height*fps_history_depth));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, ARGB_Color margin, ARGB_Color back, f32 width){
    Rect_f32 view_rect = view_get_screen_rect(app, view);
    Rect_f32 inner = rect_inner(view_rect, width);
    draw_rectangle(app, inner, 0.f, back);
    if (width > 0.f){
        draw_margin(app, view_rect, inner, margin);
    }
    return(inner);
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, ARGB_Color margin, ARGB_Color back){
    return(draw_background_and_margin(app, view, margin, back, 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, FColor margin, FColor back, f32 width){
    ARGB_Color margin_argb = fcolor_resolve(margin);
    ARGB_Color back_argb = fcolor_resolve(back);
    return(draw_background_and_margin(app, view, margin_argb, back_argb, width));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, FColor margin, FColor back){
    ARGB_Color margin_argb = fcolor_resolve(margin);
    ARGB_Color back_argb = fcolor_resolve(back);
    return(draw_background_and_margin(app, view, margin_argb, back_argb, 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, b32 is_active_view, f32 width){
    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    return(draw_background_and_margin(app, view, margin_color, fcolor_id(defcolor_back), width));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, b32 is_active_view){
    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    return(draw_background_and_margin(app, view, margin_color, fcolor_id(defcolor_back), 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view){
    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view);
    return(draw_background_and_margin(app, view, is_active_view));
}

static void
draw_file_bar(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Rect_f32 bar){
    Scratch_Block scratch(app);

    draw_rectangle_fcolor(app, bar, 0.f, fcolor_id(defcolor_bar));

    FColor base_color = fcolor_id(defcolor_base);
    FColor pop2_color = fcolor_id(defcolor_pop2);

    i64 cursor_position = view_get_cursor_pos(app, view_id);
    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(cursor_position));

    Fancy_Line list = {};
    String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);
    push_fancy_string(scratch, &list, base_color, unique_name);
    push_fancy_stringf(scratch, &list, base_color, " - Row: %3.lld Col: %3.lld -", cursor.line, cursor.col);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    switch (*eol_setting){
        case LineEndingKind_Binary:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" bin"), (u64)(sizeof(" bin") - 1)));
        }break;

        case LineEndingKind_LF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" lf"), (u64)(sizeof(" lf") - 1)));
        }break;

        case LineEndingKind_CRLF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" crlf"), (u64)(sizeof(" crlf") - 1)));
        }break;
    }

    u8 space[3];
    {
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        String_u8 str = Su8(space, 0, 3);
        if (dirty != 0){
            string_append(&str, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
        }
        if ((((dirty)&(DirtyState_UnsavedChanges))!=0)){
            string_append(&str, SCu8((u8*)("*"), (u64)(sizeof("*") - 1)));
        }
        if ((((dirty)&(DirtyState_UnloadedChanges))!=0)){
            string_append(&str, SCu8((u8*)("!"), (u64)(sizeof("!") - 1)));
        }
        push_fancy_string(scratch, &list, pop2_color, str.string);
    }

    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
}

static void
draw_query_bar(Application_Links *app, Query_Bar *query_bar, Face_ID face_id, Rect_f32 bar){
    Scratch_Block scratch(app);
    Fancy_Line list = {};
    push_fancy_string(scratch, &list, fcolor_id(defcolor_pop1) , query_bar->prompt);
    push_fancy_string(scratch, &list, fcolor_id(defcolor_text_default), query_bar->string);
    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
}

static void
draw_line_number_margin(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Text_Layout_ID text_layout_id, Rect_f32 margin){
    Profile_Scope_Block profile_block_381 ((app), SCu8((u8*)("draw line number margin"), (u64)(sizeof("draw line number margin") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "381" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "381" ":") - 1)));

    Scratch_Block scratch(app);
    FColor line_color = fcolor_id(defcolor_line_numbers_text);

    Rect_f32 prev_clip = draw_set_clip(app, margin);
    draw_rectangle_fcolor(app, margin, 0.f, fcolor_id(defcolor_line_numbers_back));

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_count_digit_count = digit_count_from_integer(line_count, 10);

    Fancy_String fstring = {};
    u8 *digit_buffer = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(line_count_digit_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "394" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "394" ":") - 1)))));
    String_Const_u8 digit_string = SCu8(digit_buffer, line_count_digit_count);
    for (i32 i = 0; i < line_count_digit_count; i += 1){
        digit_buffer[i] = ' ';
    }

    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(visible_range.first));
    i64 line_number = cursor.line;

    Buffer_Cursor cursor_opl = view_compute_cursor(app, view_id, seek_pos(visible_range.one_past_last));
    i64 one_past_last_line_number = cursor_opl.line + 1;

    u8 *small_digit = digit_buffer + line_count_digit_count - 1;
    {
        u8 *ptr = small_digit;
        if (line_number == 0){
            *ptr = '0';
        }
        else{
            for (u64 X = line_number; X > 0; X /= 10){
                *ptr = '0' + (X%10);
                ptr -= 1;
            }
        }
    }

    for (;line_number < one_past_last_line_number &&
         line_number < line_count;){
        Range_f32 line_y = text_layout_line_on_screen(app, text_layout_id, line_number);
        Vec2_f32 p = V2f32(margin.x0, line_y.min);

        fill_fancy_string(&fstring, 0, line_color, 0, 0, digit_string);
        draw_fancy_string(app, face_id, fcolor_zero(), &fstring, p);

        line_number += 1;
        {
            u8 *ptr = small_digit;
            for (;;){
                if (ptr < digit_buffer){
                    break;
                }
                if (*ptr == ' '){
                    *ptr = '0';
                }
                if (*ptr == '9'){
                    *ptr = '0';
                    ptr -= 1;
                }
                else{
                    *ptr += 1;
                    break;
                }
            }
        }
    }

    draw_set_clip(app, prev_clip);
}

static void
draw_fps_hud(Application_Links *app, Frame_Info frame_info, Face_ID face_id, Rect_f32 rect){
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;

    static f32 history_literal_dt[fps_history_depth] = {};
    static f32 history_animation_dt[fps_history_depth] = {};
    static i32 history_frame_index[fps_history_depth] = {};

    i32 wrapped_index = frame_info.index%fps_history_depth;
    history_literal_dt[wrapped_index] = frame_info.literal_dt;
    history_animation_dt[wrapped_index] = frame_info.animation_dt;
    history_frame_index[wrapped_index] = frame_info.index;

    draw_rectangle_fcolor(app, rect, 0.f, f_black);
    draw_rectangle_outline_fcolor(app, rect, 0.f, 1.f, f_white);

    Vec2_f32 p = rect.p0;

    Scratch_Block scratch(app);

    Range_i32 ranges[2] = {};
    ranges[0].first = wrapped_index;
    ranges[0].one_past_last = -1;
    ranges[1].first = fps_history_depth - 1;
    ranges[1].one_past_last = wrapped_index;
    for (i32 i = 0; i < 2; i += 1){
        Range_i32 r = ranges[i];
        for (i32 j = r.first; j > r.one_past_last; j -= 1, p.y += line_height){
            f32 dts[2];
            dts[0] = history_literal_dt[j];
            dts[1] = history_animation_dt[j];
            i32 frame_index = history_frame_index[j];

            Fancy_Line list = {};
            push_fancy_stringf(scratch, &list, f_pink , "FPS: ");
            push_fancy_stringf(scratch, &list, f_green, "[");
            push_fancy_stringf(scratch, &list, f_white, "%5d", frame_index);
            push_fancy_stringf(scratch, &list, f_green, "]: ");

            for (i32 k = 0; k < 2; k += 1){
                f32 dt = dts[k];
                if (dt == 0.f){
                    push_fancy_stringf(scratch, &list, f_white, "----------");
                }
                else{
                    push_fancy_stringf(scratch, &list, f_white, "%10.6f", dt);
                }
                push_fancy_stringf(scratch, &list, f_green, " | ");
            }

            draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
        }
    }
}

static FColor
get_token_color_cpp(Token token){
    Managed_ID color = defcolor_text_default;
    switch (token.kind){
        case TokenBaseKind_Preprocessor:
        {
            color = defcolor_preproc;
        }break;
        case TokenBaseKind_Keyword:
        {
            color = defcolor_keyword;
        }break;
        case TokenBaseKind_Comment:
        {
            color = defcolor_comment;
        }break;
        case TokenBaseKind_LiteralString:
        {
            color = defcolor_str_constant;
        }break;
        case TokenBaseKind_LiteralInteger:
        {
            color = defcolor_int_constant;
        }break;
        case TokenBaseKind_LiteralFloat:
        {
            color = defcolor_float_constant;
        }break;
    }

    switch (token.sub_kind){
        case TokenCppKind_LiteralTrue:
        case TokenCppKind_LiteralFalse:
        {
            color = defcolor_bool_constant;
        }break;
        case TokenCppKind_LiteralCharacter:
        case TokenCppKind_LiteralCharacterWide:
        case TokenCppKind_LiteralCharacterUTF8:
        case TokenCppKind_LiteralCharacterUTF16:
        case TokenCppKind_LiteralCharacterUTF32:
        {
            color = defcolor_char_constant;
        }break;
        case TokenCppKind_PPIncludeFile:
        {
            color = defcolor_include;
        }break;
    }
    FColor result = fcolor_id(color);
    return(result);
}

static void
draw_cpp_token_colors(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);
    for (;;){
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        FColor color = get_token_color_cpp(*token);
        ARGB_Color argb = fcolor_resolve(color);
        paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), argb);
        if (!token_it_inc_all(&it)){
            break;
        }
    }
}

static void
draw_whitespace_highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, f32 roundness){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);
    for (;;){
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        if (token->kind == TokenBaseKind_Whitespace){
            Range_i64 range = Ii64(token);
            draw_character_block(app, text_layout_id, range, roundness,
                                 fcolor_id(defcolor_highlight_white));
        }
        if (!token_it_inc_all(&it)){
            break;
        }
    }
}

static void
draw_whitespace_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id, f32 roundness){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    for (i64 i = visible_range.first; i < visible_range.one_past_last;){
        u8 c = buffer_get_char(app, buffer, i);
        if (character_is_whitespace(c)){
            i64 s = i;
            i += 1;
            for (; i < visible_range.one_past_last; i += 1){
                c = buffer_get_char(app, buffer, i);
                if (!character_is_whitespace(c)){
                    break;
                }
            }
            Range_i64 range = Ii64(s, i);
            draw_character_block(app, text_layout_id, range, roundness,
                                 fcolor_id(defcolor_highlight_white));
        }
        else{
            i += 1;
        }
    }
}

static void
draw_comment_highlights(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                        Token_Array *array, Comment_Highlight_Pair *pairs, i32 pair_count){
    Scratch_Block scratch(app);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(buffer, array, first_index);
    for (;;){
        Temp_Memory_Block temp(scratch);
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        String_Const_u8 tail = {};
        if (token_it_check_and_get_lexeme(app, scratch, &it, TokenBaseKind_Comment, &tail)){
            for (i64 index = token->pos;
                 tail.size > 0;
                 tail = string_skip(tail, 1), index += 1){
                Comment_Highlight_Pair *pair = pairs;
                for (i32 i = 0; i < pair_count; i += 1, pair += 1){
                    u64 needle_size = pair->needle.size;
                    if (needle_size == 0){
                        continue;
                    }
                    String_Const_u8 prefix = string_prefix(tail, needle_size);
                    if (string_match(prefix, pair->needle)){
                        Range_i64 range = Ii64_size(index, needle_size);
                        paint_text_color(app, text_layout_id, range, pair->color);
                        tail = string_skip(tail, needle_size - 1);
                        index += needle_size - 1;
                        break;
                    }
                }
            }
        }
        if (!token_it_inc_non_whitespace(&it)){
            break;
        }
    }
}

static Range_i64_Array
get_enclosure_ranges(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos, u32 flags){
    Range_i64_Array array = {};
    i32 max = 100;
    array.ranges = ((Range_i64*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Range_i64)*(max), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "671" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "671" ":") - 1)))));
    for (;;){
        Range_i64 range = {};
        if (find_surrounding_nest(app, buffer, pos, flags, &range)){
            array.ranges[array.count] = range;
            array.count += 1;
            pos = range.first;
            if (array.count >= max){
                break;
            }
        }
        else{
            break;
        }
    }
    return(array);
}

static void
draw_enclosures(Application_Links *app, Text_Layout_ID text_layout_id, Buffer_ID buffer,
                i64 pos, u32 flags, Range_Highlight_Kind kind,
                ARGB_Color *back_colors, i32 back_count,
                ARGB_Color *fore_colors, i32 fore_count){
    Scratch_Block scratch(app);
    Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, flags);

    i32 color_index = 0;
    for (i32 i = ranges.count - 1; i >= 0; i -= 1){
        Range_i64 range = ranges.ranges[i];
        if (kind == RangeHighlightKind_LineHighlight){
            Range_i64 r[2] = {};
            if (i > 0){
                Range_i64 inner_range = ranges.ranges[i - 1];
                Range_i64 lines = get_line_range_from_pos_range(app, buffer, range);
                Range_i64 inner_lines = get_line_range_from_pos_range(app, buffer, inner_range);
                inner_lines.min = (((lines.min)>(inner_lines.min))?(lines.min):(inner_lines.min));
                inner_lines.max = (((inner_lines.max)<(lines.max))?(inner_lines.max):(lines.max));
                inner_lines.min -= 1;
                inner_lines.max += 1;
                if (lines.min <= inner_lines.min){
                    r[0] = Ii64(lines.min, inner_lines.min);
                }
                if (inner_lines.max <= lines.max){
                    r[1] = Ii64(inner_lines.max, lines.max);
                }
            }
            else{
                r[0] = get_line_range_from_pos_range(app, buffer, range);
            }
            for (i32 j = 0; j < 2; j += 1){
                if (r[j].min == 0){
                    continue;
                }
                Range_i64 line_range = r[j];
                if (back_colors != 0){
                    i32 back_index = color_index%back_count;
                    draw_line_highlight(app, text_layout_id, line_range, back_colors[back_index]);
                }
                if (fore_colors != 0){
                    i32 fore_index = color_index%fore_count;
                    Range_i64 pos_range = get_pos_range_from_line_range(app, buffer, line_range);
                    paint_text_color(app, text_layout_id, pos_range, fore_colors[fore_index]);
                }
            }
        }
        else{
            if (back_colors != 0){
                i32 back_index = color_index%back_count;
                draw_character_block(app, text_layout_id, range.min, 0.f, back_colors[back_index]);
                draw_character_block(app, text_layout_id, range.max - 1, 0.f, back_colors[back_index]);
            }
            if (fore_colors != 0){
                i32 fore_index = color_index%fore_count;
                paint_text_color_pos(app, text_layout_id, range.min, fore_colors[fore_index]);
                paint_text_color_pos(app, text_layout_id, range.max - 1, fore_colors[fore_index]);
            }
        }
        color_index += 1;
    }
}

static void
draw_scope_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     i64 pos, ARGB_Color *colors, i32 color_count){
    draw_enclosures(app, text_layout_id, buffer,
                    pos, FindNest_Scope, RangeHighlightKind_LineHighlight,
                    colors, color_count, 0, 0);
}

static void
draw_paren_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     i64 pos, ARGB_Color *colors, i32 color_count){
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.tokens != 0){
        Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
        Token *token = token_it_read(&it);
        if (token != 0 && token->kind == TokenBaseKind_ParentheticalOpen){
            pos = token->pos + token->size;
        }
        else{
            if (token_it_dec_all(&it)){
                token = token_it_read(&it);
                if (token->kind == TokenBaseKind_ParentheticalClose &&
                    pos == token->pos + token->size){
                    pos = token->pos;
                }
            }
        }
    }
    draw_enclosures(app, text_layout_id, buffer,
                    pos, FindNest_Paren, RangeHighlightKind_CharacterHighlight,
                    0, 0, colors, color_count);
}

static void
draw_jump_highlights(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     Buffer_ID jump_buffer, FColor line_color){
    Scratch_Block scratch(app);
    if (jump_buffer != 0){
        Managed_Scope scopes[2];
        scopes[0] = buffer_get_managed_scope(app, jump_buffer);
        scopes[1] = buffer_get_managed_scope(app, buffer);
        Managed_Scope comp_scope = get_managed_scope_with_multiple_dependencies(app, scopes, ((sizeof(scopes))/(sizeof(*scopes))));
        Managed_Object *markers_object = ((Managed_Object*)managed_scope_get_attachment((app), (comp_scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));

        i32 count = managed_object_get_item_count(app, *markers_object);
        Marker *markers = ((Marker*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Marker)*(count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "797" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_draw.cpp" ":" "797" ":") - 1)))));
        managed_object_load_data(app, *markers_object, 0, count, markers);
        for (i32 i = 0; i < count; i += 1){
            i64 line_number = get_line_number_from_pos(app, buffer, markers[i].pos);
            draw_line_highlight(app, text_layout_id, line_number, line_color);
        }
    }
}

static b32
draw_highlight_range(Application_Links *app, View_ID view_id,
                     Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     f32 roundness){
    b32 has_highlight_range = false;
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    Buffer_ID *highlight_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_highlight_buffer), sizeof(Buffer_ID)));
    if (*highlight_buffer != 0){
        if (*highlight_buffer != buffer){
            view_disable_highlight_range(app, view_id);
        }
        else{
            has_highlight_range = true;
            Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
            Marker marker_range[2];
            if (managed_object_load_data(app, *highlight, 0, 2, marker_range)){
                Range_i64 range = Ii64(marker_range[0].pos, marker_range[1].pos);
                draw_character_block(app, text_layout_id, range, roundness,
                                     fcolor_id(defcolor_highlight));
                paint_text_color_fcolor(app, text_layout_id, range,
                                        fcolor_id(defcolor_at_highlight));
            }
        }
    }
    return(has_highlight_range);
}

static i32
default_cursor_sub_id(void){
    i32 result = 0;
    if (global_keyboard_macro_is_recording){
        result = 1;
    }
    return(result);
}

static void
draw_original_4coder_style_cursor_mark_highlight(Application_Links *app, View_ID view_id, b32 is_active_view,
                                                 Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                                 f32 roundness, f32 outline_thickness){
    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);
    if (!has_highlight_range){
        i32 cursor_sub_id = default_cursor_sub_id();

        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);
        if (is_active_view){
            draw_character_block(app, text_layout_id, cursor_pos, roundness,
                                 fcolor_id(defcolor_cursor, cursor_sub_id));
            paint_text_color_pos(app, text_layout_id, cursor_pos,
                                 fcolor_id(defcolor_at_cursor));
            draw_character_wire_frame(app, text_layout_id, mark_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_mark));
        }
        else{
            draw_character_wire_frame(app, text_layout_id, mark_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_mark));
            draw_character_wire_frame(app, text_layout_id, cursor_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_cursor, cursor_sub_id));
        }
    }
}

static void
draw_notepad_style_cursor_highlight(Application_Links *app, View_ID view_id,
                                    Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                    f32 roundness){
    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);
    if (!has_highlight_range){
        i32 cursor_sub_id = default_cursor_sub_id();
        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);
        if (cursor_pos != mark_pos){
            Range_i64 range = Ii64(cursor_pos, mark_pos);
            draw_character_block(app, text_layout_id, range, roundness, fcolor_id(defcolor_highlight));
            paint_text_color_fcolor(app, text_layout_id, range, fcolor_id(defcolor_at_highlight));
        }
        draw_character_i_bar(app, text_layout_id, cursor_pos, fcolor_id(defcolor_cursor, cursor_sub_id));
    }
}



static Rect_f32
get_contained_box_near_point(Rect_f32 container, Vec2_f32 p, Vec2_f32 box_dims){
    Vec2_f32 container_dims = rect_dim(container);
    box_dims.x = (((box_dims.x)<(container_dims.x))?(box_dims.x):(container_dims.x));
    box_dims.y = (((box_dims.y)<(container_dims.y))?(box_dims.y):(container_dims.y));
    Vec2_f32 q = p + V2f32(-20.f, 22.f);
    if (q.x + box_dims.x > container.x1){
        q.x = container.x1 - box_dims.x;
    }
    if (q.y + box_dims.y > container.y1){
        q.y = p.y - box_dims.y - 2.f;
        if (q.y < container.y0){
            q.y = (container.y0 + container.y1 - box_dims.y)*0.5f;
        }
    }
    return(Rf32_xy_wh(q, box_dims));
}

static Rect_f32
draw_tool_tip(Application_Links *app, Face_ID face, Fancy_Block *block,
              Vec2_f32 p, Rect_f32 region, f32 x_padding, f32 x_half_padding,
              FColor back_color){
    Rect_f32 box = Rf32(p, p);
    if (block->line_count > 0){
        Vec2_f32 dims = get_fancy_block_dim(app, face, block);
        dims += V2f32(x_padding, 2.f);
        box = get_contained_box_near_point(region, p, dims);
        box.x0 = f32_round32(box.x0);
        box.y0 = f32_round32(box.y0);
        box.x1 = f32_round32(box.x1);
        box.y1 = f32_round32(box.y1);
        Rect_f32 prev_clip = draw_set_clip(app, box);
        draw_rectangle_fcolor(app, box, 6.f, back_color);
        draw_fancy_block(app, face, fcolor_zero(), block,
                         box.p0 + V2f32(x_half_padding, 1.f));
        draw_set_clip(app, prev_clip);
    }
    return(box);
}

static Rect_f32
draw_drop_down(Application_Links *app, Face_ID face, Fancy_Block *block,
               Vec2_f32 p, Rect_f32 region, f32 x_padding, f32 x_half_padding,
               FColor outline_color, FColor back_color){
    Rect_f32 box = Rf32(p, p);
    if (block->line_count > 0){
        Vec2_f32 dims = get_fancy_block_dim(app, face, block);
        dims += V2f32(x_padding, 4.f);
        box = get_contained_box_near_point(region, p, dims);
        box.x0 = f32_round32(box.x0);
        box.y0 = f32_round32(box.y0);
        box.x1 = f32_round32(box.x1);
        box.y1 = f32_round32(box.y1);
        Rect_f32 prev_clip = draw_set_clip(app, box);
        draw_rectangle_fcolor(app, box, 0.f, back_color);
        draw_margin(app, box, rect_inner(box, 1.f), outline_color);
        draw_fancy_block(app, face, fcolor_zero(), block,
                         box.p0 + V2f32(x_half_padding, 2.f));
        draw_set_clip(app, prev_clip);
    }
    return(box);
}

static b32
draw_button(Application_Links *app, Rect_f32 rect, Vec2_f32 mouse_p, Face_ID face, String_Const_u8 text){
    b32 hovered = false;
    if (rect_contains_point(rect, mouse_p)){
        hovered = true;
    }

    UI_Highlight_Level highlight = hovered?UIHighlight_Active:UIHighlight_None;
    draw_rectangle_fcolor(app, rect, 3.f, get_item_margin_color(highlight));
    rect = rect_inner(rect, 3.f);
    draw_rectangle_fcolor(app, rect, 3.f, get_item_margin_color(highlight, 1));

    Scratch_Block scratch(app);
    Fancy_String *fancy = push_fancy_string(scratch, 0, face, fcolor_id(defcolor_text_default), text);
    Vec2_f32 dim = get_fancy_string_dim(app, 0, fancy);
    Vec2_f32 p = (rect.p0 + rect.p1 - dim)*0.5f;
    draw_fancy_string(app, fancy, p);

    return(hovered);
}
# 110 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_font_helper.cpp" 1






static Face_Description
get_buffer_face_description(Application_Links *app, Buffer_ID buffer){
    Face_ID current_id = get_face_id(app, buffer);
    Face_Description description = {};
    if (current_id != 0){
        description = get_face_description(app, current_id);
    }
    return(description);
}

static Face_Description
get_global_face_description(Application_Links *app){
    return(get_buffer_face_description(app, 0));
}

static b32
font_load_location_match(Font_Load_Location *a, Font_Load_Location *b){
    return(string_match(a->file_name, b->file_name));
}

static b32
face_load_parameters_match(Face_Load_Parameters *a, Face_Load_Parameters *b){
    return(block_compare(a, b, sizeof(*a)) == 0);
}

static b32
face_description_match(Face_Description *a, Face_Description *b){
    b32 result = false;
    if (font_load_location_match(&a->font, &b->font) &&
        face_load_parameters_match(&a->parameters, &b->parameters)){
        result = true;
    }
    return(result);
}

static Face_ID
face_id_from_font_load_target(Application_Links *app, Font_Load_Location *font){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (font_load_location_match(&compare.font, font)){
            result = id;
            break;
        }
    }
    return(result);
}

static Face_ID
face_id_from_face_load_parameters(Application_Links *app, Face_Load_Parameters *parameters){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (face_load_parameters_match(&compare.parameters, parameters)){
            result = id;
            break;
        }
    }
    return(result);
}

static Face_ID
face_id_from_description(Application_Links *app, Face_Description *description){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (face_description_match(&compare, description)){
            result = id;
            break;
        }
    }
    return(result);
}

static b32
modify_global_face_by_description(Application_Links *app, Face_Description description){
    Face_ID face_id = get_face_id(app, 0);
    return(try_modify_face(app, face_id, &description));
}

static void
set_buffer_face_by_description(Application_Links *app, Buffer_ID buffer, Face_Description *description){
    Face_ID id = face_id_from_description(app, description);
    if (id == 0){
        id = try_create_new_face(app, description);
    }
    if (id != 0){
        buffer_set_face(app, buffer, id);
    }
}

static void
set_buffer_face_by_font_load_location(Application_Links *app, Buffer_ID buffer, Font_Load_Location *font){
    Face_Description description = get_buffer_face_description(app, buffer);
    description.font = *font;
    set_buffer_face_by_description(app, buffer, &description);
}

static void
set_buffer_face_by_face_load_parameters(Application_Links *app, Buffer_ID buffer, Face_Load_Parameters *parameters){
    Face_Description description = get_buffer_face_description(app, buffer);
    description.parameters = *parameters;
    set_buffer_face_by_description(app, buffer, &description);
}
# 111 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_config.cpp"
static void
def_search_normal_load_list(Arena *arena, String8List *list){
    Variable_Handle prj_var = vars_read_key(vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))));
    String_Const_u8 prj_dir = prj_path_from_project(arena, prj_var);
    if (prj_dir.size > 0){
        string_list_push(arena, list, prj_dir);
    }
    def_search_list_add_system_path(arena, list, SystemPath_UserDirectory);
    def_search_list_add_system_path(arena, list, SystemPath_Binary);
}

static String8
def_search_normal_full_path(Arena *arena, String8 relative){
    String8List list = {};
    def_search_normal_load_list(arena, &list);
    String8 result = def_search_get_full_path(arena, &list, relative);
    return(result);
}

static FILE*
def_search_normal_fopen(Arena *arena, char *file_name, char *opt){
    Temp_Memory_Block block(arena);
    String8List list = {};
    def_search_normal_load_list(arena, &list);
    FILE *file = def_search_fopen(arena, &list, file_name, opt);
    return(file);
}




static String_Const_u8_Array
parse_extension_line_to_extension_list(Application_Links *app, Arena *arena, String_Const_u8 str){
    Profile_Scope_Block profile_block_43 ((app), SCu8((u8*)("parse extension line to extension list"), (u64)(sizeof("parse extension line to extension list") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "43" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "43" ":") - 1)));
    i32 count = 0;
    for (u64 i = 0; i < str.size; i += 1){
        if (str.str[i] == '.'){
            count += 1;
        }
    }

    String_Const_u8_Array array = {};
    array.count = count;
    array.strings = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "53" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "53" ":") - 1)))));

    (linalloc_align((arena), (1)));
    str = string_skip(str, string_find_first(str, '.') + 1);
    for (i32 i = 0; i < count; i += 1){
        u64 next_period = string_find_first(str, '.');
        String_Const_u8 extension = string_prefix(str, next_period);
        str = string_skip(str, next_period + 1);
        array.strings[i] = push_string_copy(arena, extension);
    }
    (linalloc_align((arena), (8)));

    return(array);
}




static Token_Array
token_array_from_text(Application_Links *app, Arena *arena, String_Const_u8 data){
    Profile_Scope_Block profile_block_73 ((app), SCu8((u8*)("token array from text"), (u64)(sizeof("token array from text") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "73" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "73" ":") - 1)));
    Token_List list = lex_full_input_cpp(arena, data);
    return(token_array_from_list(arena, &list));
}




static void
setup_built_in_mapping(Application_Links *app, String_Const_u8 name, Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Thread_Context *tctx = get_thread_context(app);
    if (string_match(name, SCu8((u8*)("default"), (u64)(sizeof("default") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);
        setup_default_mapping(mapping, global_id, file_id, code_id);
    }
    else if (string_match(name, SCu8((u8*)("mac-default"), (u64)(sizeof("mac-default") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);
        setup_mac_mapping(mapping, global_id, file_id, code_id);
    }
    else if (string_match(name, SCu8((u8*)("choose"), (u64)(sizeof("choose") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);



        setup_default_mapping(mapping, global_id, file_id, code_id);

    }
}




static Error_Location
get_error_location(Application_Links *app, u8 *base, u8 *pos){
    Profile_Scope_Block profile_block_110 ((app), SCu8((u8*)("get error location"), (u64)(sizeof("get error location") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "110" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "110" ":") - 1)));
    Error_Location location = {};
    location.line_number = 1;
    location.column_number = 1;
    for (u8 *ptr = base;
         ptr < pos;
         ptr += 1){
        if (*ptr == '\n'){
            location.line_number += 1;
            location.column_number = 1;
        }
        else{
            location.column_number += 1;
        }
    }
    return(location);
}

static String_Const_u8
config_stringize_errors(Application_Links *app, Arena *arena, Config *parsed){
    Profile_Scope_Block profile_block_130 ((app), SCu8((u8*)("stringize errors"), (u64)(sizeof("stringize errors") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "130" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "130" ":") - 1)));
    String_Const_u8 result = {};
    if (parsed->errors.first != 0){
        List_String_Const_u8 list = {};
        for (Config_Error *error = parsed->errors.first;
             error != 0;
             error = error->next){
            Error_Location location = get_error_location(app, parsed->data.str, error->pos);
            string_list_pushf(arena, &list, "%.*s:%d:%d: %.*s\n",
                              (i32)(error->file_name).size, (char*)(error->file_name).str, location.line_number, location.column_number, (i32)(error->text).size, (char*)(error->text).str);
        }
        result = string_list_flatten(arena, list);
    }
    return(result);
}




static Config_Parser
def_config_parser_init(Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Token_Array array){
    Config_Parser ctx = {};
    ctx.token = array.tokens - 1;
    ctx.opl = array.tokens + array.count;
    ctx.file_name = file_name;
    ctx.data = data;
    ctx.arena = arena;
    def_config_parser_inc(&ctx);
    return(ctx);
}

static void
def_config_parser_inc(Config_Parser *ctx){
    Token *t = ctx->token;
    Token *opl = ctx->opl;
    for (t += 1;
         t < opl && (t->kind == TokenBaseKind_Comment ||
                     t->kind == TokenBaseKind_Whitespace);
         t += 1);
    ctx->token = t;
}

static u8*
def_config_parser_get_pos(Config_Parser *ctx){
    return(ctx->data.str + ctx->token->pos);
}

static b32
def_config_parser_recognize_base_kind(Config_Parser *ctx, Token_Base_Kind kind){
    b32 result = false;
    if (ctx->token < ctx->opl){
        result = (ctx->token->kind == kind);
    }
    else if (kind == TokenBaseKind_EOF){
        result = true;
    }
    return(result);
}

static b32
def_config_parser_recognize_cpp_kind(Config_Parser *ctx, Token_Cpp_Kind kind){
    b32 result = false;
    if (ctx->token < ctx->opl){
        result = (ctx->token->sub_kind == kind);
    }
    else if (kind == TokenCppKind_EOF){
        result = true;
    }
    return(result);
}

static b32
def_config_parser_recognize_boolean(Config_Parser *ctx){
    b32 result = false;
    Token *token = ctx->token;
    if (ctx->token < ctx->opl){
        result = (token->sub_kind == TokenCppKind_LiteralTrue ||
                  token->sub_kind == TokenCppKind_LiteralFalse);
    }
    return(result);
}

static b32
def_config_parser_recognize_text(Config_Parser *ctx, String_Const_u8 text){
    String_Const_u8 lexeme = def_config_parser_get_lexeme(ctx);
    return(lexeme.str != 0 && string_match(lexeme, text));
}

static b32
def_config_parser_match_cpp_kind(Config_Parser *ctx, Token_Cpp_Kind kind){
    b32 result = def_config_parser_recognize_cpp_kind(ctx, kind);
    if (result){
        def_config_parser_inc(ctx);
    }
    return(result);
}

static b32
def_config_parser_match_text(Config_Parser *ctx, String_Const_u8 text){
    b32 result = def_config_parser_recognize_text(ctx, text);
    if (result){
        def_config_parser_inc(ctx);
    }
    return(result);
}

static String_Const_u8
def_config_parser_get_lexeme(Config_Parser *ctx){
    String_Const_u8 lexeme = {};
    Token *token = ctx->token;
    if (token < ctx->opl){
        lexeme = SCu8(ctx->data.str + token->pos, token->size);
    }
    return(lexeme);
}

static Config_Integer
def_config_parser_get_int(Config_Parser *ctx){
    Config_Integer config_integer = {};
    String_Const_u8 str = def_config_parser_get_lexeme(ctx);
    if (string_match(string_prefix(str, 2), SCu8((u8*)("0x"), (u64)(sizeof("0x") - 1)))){
        config_integer.is_signed = false;
        config_integer.uinteger = (u32)(string_to_integer(string_skip(str, 2), 16));
    }
    else{
        b32 is_negative = (string_get_character(str, 0) == '-');
        if (is_negative){
            str = string_skip(str, 1);
        }
        config_integer.is_signed = true;
        config_integer.integer = (i32)(string_to_integer(str, 10));
        if (is_negative){
            config_integer.integer *= -1;
        }
    }
    return(config_integer);
}

static b32
def_config_parser_get_boolean(Config_Parser *ctx){
    String_Const_u8 str = def_config_parser_get_lexeme(ctx);
    return(string_match(str, SCu8((u8*)("true"), (u64)(sizeof("true") - 1))));
}

static Config*
def_config_parser_top(Config_Parser *ctx){
    i32 *version = def_config_parser_version(ctx);

    Config_Assignment *first = 0;
    Config_Assignment *last = 0;
    i32 count = 0;
    for (;!def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_EOF);){
        Config_Assignment *assignment = def_config_parser_assignment(ctx);
        if (assignment != 0){
            (((first)==0)?((assignment)->next=(assignment)->prev=0,(first)=(last)=(assignment)):((assignment)->prev=(last),(assignment)->next=0,(last)->next=(assignment),(last)=(assignment)));
            count += 1;
        }
    }

    Config *config = ((Config*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "289" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "289" ":") - 1)))));
    block_zero((config), sizeof(*(config)));
    config->version = version;
    config->first = first;
    config->last = last;
    config->count = count;
    config->errors = ctx->errors;
    config->file_name = ctx->file_name;
    config->data = ctx->data;
    return(config);
}

static i32*
def_config_parser_version(Config_Parser *ctx){
    do{ if (!(def_config_parser_match_text(ctx, {(u8*)("version"), sizeof("version") - 1}))){ return(0); } }while(0);

    if (!def_config_parser_match_cpp_kind(ctx, TokenCppKind_ParenOp)){
        def_config_parser_push_error_here(ctx, "expected token '(' for version specifier: 'version(#)'");
        def_config_parser_recover(ctx);
        return(0);
    }

    if (!def_config_parser_recognize_base_kind(ctx, TokenBaseKind_LiteralInteger)){
        def_config_parser_push_error_here(ctx, "expected an integer constant for version specifier: 'version(#)'");
        def_config_parser_recover(ctx);
        return(0);
    }

    Config_Integer value = def_config_parser_get_int(ctx);
    def_config_parser_inc(ctx);

    if (!def_config_parser_match_cpp_kind(ctx, TokenCppKind_ParenCl)){
        def_config_parser_push_error_here(ctx, "expected token ')' for version specifier: 'version(#)'");
        def_config_parser_recover(ctx);
        return(0);
    }

    if (!def_config_parser_match_cpp_kind(ctx, TokenCppKind_Semicolon)){
        def_config_parser_push_error_here(ctx, "expected token ';' for version specifier: 'version(#)'");
        def_config_parser_recover(ctx);
        return(0);
    }

    i32 *ptr = ((i32*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(i32)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "332" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "332" ":") - 1)))));
    *ptr = value.integer;
    return(ptr);
}

static Config_Assignment*
def_config_parser_assignment(Config_Parser *ctx){
    u8 *pos = def_config_parser_get_pos(ctx);

    Config_LValue *l = def_config_parser_lvalue(ctx);
    if (l == 0){
        def_config_parser_push_error_here(ctx, "expected an l-value; l-value formats: 'identifier', 'identifier[#]'");
        def_config_parser_recover(ctx);
        return(0);
    }

    if (!def_config_parser_match_cpp_kind(ctx, TokenCppKind_Eq)){
        def_config_parser_push_error_here(ctx, "expected token '=' for assignment: 'l-value = r-value;'");
        def_config_parser_recover(ctx);
        return(0);
    }

    Config_RValue *r = def_config_parser_rvalue(ctx);
    if (r == 0){
        def_config_parser_push_error_here(ctx, "expected an r-value; r-value formats:\n"
                                          "\tconstants (true, false, integers, hexadecimal integers, strings, characters)\n"
                                          "\tany l-value that is set in the file\n"
                                          "\tcompound: '{ compound-element, compound-element, compound-element ...}'\n"
                                          "\ta compound-element is an r-value, and can have a layout specifier\n"
                                          "\tcompound-element with layout specifier: .name = r-value, .integer = r-value");
        def_config_parser_recover(ctx);
        return(0);
    }

    if (!def_config_parser_match_cpp_kind(ctx, TokenCppKind_Semicolon)){
        def_config_parser_push_error_here(ctx, "expected token ';' for assignment: 'l-value = r-value;'");
        def_config_parser_recover(ctx);
        return(0);
    }

    Config_Assignment *assignment = ((Config_Assignment*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_Assignment)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "372" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "372" ":") - 1)))));
    assignment->pos = pos;
    assignment->l = l;
    assignment->r = r;
    return(assignment);
}

static Config_LValue*
def_config_parser_lvalue(Config_Parser *ctx){
    do{ if (!(def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_Identifier))){ return(0); } }while(0);
    String_Const_u8 identifier = def_config_parser_get_lexeme(ctx);
    def_config_parser_inc(ctx);

    i32 index = 0;
    if (def_config_parser_match_cpp_kind(ctx, TokenCppKind_BrackOp)){
        do{ if (!(def_config_parser_recognize_base_kind(ctx, TokenBaseKind_LiteralInteger))){ return(0); } }while(0);
        Config_Integer value = def_config_parser_get_int(ctx);
        index = value.integer;
        def_config_parser_inc(ctx);
        do{ if (!(def_config_parser_match_cpp_kind(ctx, TokenCppKind_BrackCl))){ return(0); } }while(0);
    }

    Config_LValue *lvalue = ((Config_LValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_LValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "394" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "394" ":") - 1)))));
    lvalue->identifier = identifier;
    lvalue->index = index;
    return(lvalue);
}

static Config_RValue*
def_config_parser_rvalue(Config_Parser *ctx){
    Config_RValue *rvalue = 0;
    if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_Identifier)){
        Config_LValue *l = def_config_parser_lvalue(ctx);
        do{ if (!(l != 0)){ return(0); } }while(0);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "406" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "406" ":") - 1)))));
        rvalue->type = ConfigRValueType_LValue;
        rvalue->lvalue = l;
    }
    else if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_BraceOp)){
        def_config_parser_inc(ctx);
        Config_Compound *compound = def_config_parser_compound(ctx);
        do{ if (!(compound != 0)){ return(0); } }while(0);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "414" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "414" ":") - 1)))));
        rvalue->type = ConfigRValueType_Compound;
        rvalue->compound = compound;
    }
    else if (def_config_parser_recognize_boolean(ctx)){
        b32 b = def_config_parser_get_boolean(ctx);
        def_config_parser_inc(ctx);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "421" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "421" ":") - 1)))));
        rvalue->type = ConfigRValueType_Boolean;
        rvalue->boolean = b;
    }
    else if (def_config_parser_recognize_base_kind(ctx, TokenBaseKind_LiteralInteger)){
        Config_Integer value = def_config_parser_get_int(ctx);
        def_config_parser_inc(ctx);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "428" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "428" ":") - 1)))));
        rvalue->type = ConfigRValueType_Integer;
        if (value.is_signed){
            rvalue->integer = value.integer;
        }
        else{
            rvalue->uinteger = value.uinteger;
        }
    }
    else if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_LiteralString)){
        String_Const_u8 s = def_config_parser_get_lexeme(ctx);
        def_config_parser_inc(ctx);
        s = string_chop(string_skip(s, 1), 1);
        String_Const_u8 interpreted = string_interpret_escapes(ctx->arena, s);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "442" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "442" ":") - 1)))));
        rvalue->type = ConfigRValueType_String;
        rvalue->string = interpreted;
    }
    return(rvalue);
}

static void
config_parser__compound__check(Config_Parser *ctx, Config_Compound *compound){
    b32 implicit_index_allowed = true;
    for (Config_Compound_Element *node = compound->first;
         node != 0;
         node = node->next){
        if (node->l.type != ConfigLayoutType_Unset){
            implicit_index_allowed = false;
        }
        else if (!implicit_index_allowed){
            def_config_parser_push_error(ctx, node->l.pos,
                                         "encountered unlabeled member after one or more labeled members");
        }
    }
}

static Config_Compound*
def_config_parser_compound(Config_Parser *ctx){
    Config_Compound_Element *first = 0;
    Config_Compound_Element *last = 0;
    i32 count = 0;

    Config_Compound_Element *element = def_config_parser_element(ctx);
    do{ if (!(element != 0)){ return(0); } }while(0);
    (((first)==0)?((element)->next=(element)->prev=0,(first)=(last)=(element)):((element)->prev=(last),(element)->next=0,(last)->next=(element),(last)=(element)));
    count += 1;

    for (;def_config_parser_match_cpp_kind(ctx, TokenCppKind_Comma);){
        if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_BraceCl)){
            break;
        }
        element = def_config_parser_element(ctx);
        do{ if (!(element != 0)){ return(0); } }while(0);
        (((first)==0)?((element)->next=(element)->prev=0,(first)=(last)=(element)):((element)->prev=(last),(element)->next=0,(last)->next=(element),(last)=(element)));
        count += 1;
    }

    do{ if (!(def_config_parser_match_cpp_kind(ctx, TokenCppKind_BraceCl))){ return(0); } }while(0);

    Config_Compound *compound = ((Config_Compound*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config_Compound)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "488" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "488" ":") - 1)))));
    block_zero((compound), sizeof(*(compound)));
    compound->first = first;
    compound->last = last;
    compound->count = count;
    config_parser__compound__check(ctx, compound);
    return(compound);
}

static Config_Compound_Element*
def_config_parser_element(Config_Parser *ctx){
    Config_Layout layout = {};
    layout.pos = def_config_parser_get_pos(ctx);
    if (def_config_parser_match_cpp_kind(ctx, TokenCppKind_Dot)){
        if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_Identifier)){
            layout.type = ConfigLayoutType_Identifier;
            layout.identifier = def_config_parser_get_lexeme(ctx);
            def_config_parser_inc(ctx);
        }
        else if (def_config_parser_recognize_base_kind(ctx, TokenBaseKind_LiteralInteger)){
            layout.type = ConfigLayoutType_Integer;
            Config_Integer value = def_config_parser_get_int(ctx);
            layout.integer = value.integer;
            def_config_parser_inc(ctx);
        }
        else{
            return(0);
        }
        do{ if (!(def_config_parser_match_cpp_kind(ctx, TokenCppKind_Eq))){ return(0); } }while(0);
    }
    Config_RValue *rvalue = def_config_parser_rvalue(ctx);
    do{ if (!(rvalue != 0)){ return(0); } }while(0);
    Config_Compound_Element *element = ((Config_Compound_Element*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config_Compound_Element)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "520" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "520" ":") - 1)))));
    block_zero((element), sizeof(*(element)));
    element->l = layout;
    element->r = rvalue;
    return(element);
}

static Config*
def_config_parse(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Token_Array array){
    Profile_Scope_Block profile_block_529 ((app), SCu8((u8*)("config parse"), (u64)(sizeof("config parse") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "529" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "529" ":") - 1)));
    Temp_Memory restore_point = begin_temp(arena);
    Config_Parser ctx = def_config_parser_init(arena, file_name, data, array);
    Config *config = def_config_parser_top(&ctx);
    if (config == 0){
        end_temp(restore_point);
    }
    return(config);
}

static Config*
def_config_from_text(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data){
    Config *parsed = 0;
    Temp_Memory restore_point = begin_temp(arena);
    Token_Array array = token_array_from_text(app, arena, data);
    if (array.tokens != 0){
        parsed = def_config_parse(app, arena, file_name, data, array);
        if (parsed == 0){
            end_temp(restore_point);
        }
    }
    return(parsed);
}

static Config_Error*
def_config_push_error(Arena *arena, Config_Error_List *list, String_Const_u8 file_name, u8 *pos, char *error_text){
    Config_Error *error = ((Config_Error*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Config_Error)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "555" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "555" ":") - 1)))));
    (((list->first)==0)?((error)->next=(error)->prev=0,(list->first)=(list->last)=(error)):((error)->prev=(list->last),(error)->next=0,(list->last)->next=(error),(list->last)=(error)));
    list->count += 1;
    error->file_name = file_name;
    error->pos = pos;
    error->text = push_string_copy(arena, SCu8(error_text));
    return(error);
}

static Config_Error*
def_config_push_error(Arena *arena, Config *config, u8 *pos, char *error_text){
    return(def_config_push_error(arena, &config->errors, config->file_name, pos, error_text));
}

static void
def_config_parser_push_error(Config_Parser *ctx, u8 *pos, char *error_text){
    def_config_push_error(ctx->arena, &ctx->errors, ctx->file_name, pos, error_text);
}

static void
def_config_parser_push_error_here(Config_Parser *ctx, char *error_text){
    def_config_parser_push_error(ctx, def_config_parser_get_pos(ctx), error_text);
}

static void
def_config_parser_recover(Config_Parser *ctx){
    for (;;){
        if (def_config_parser_match_cpp_kind(ctx, TokenCppKind_Semicolon)){
            break;
        }
        if (def_config_parser_recognize_cpp_kind(ctx, TokenCppKind_EOF)){
            break;
        }
        def_config_parser_inc(ctx);
    }
}





static Config_Get_Result
config_var(Config *config, String_Const_u8 var_name, i32 subscript);

static void
def_var_dump_rvalue(Application_Links *app, Config *config, Variable_Handle dst, String_ID l_value, Config_RValue *r){
    Scratch_Block scratch(app);

    b32 *boolean = 0;
    i32 *integer = 0;
    String_Const_u8 *string = 0;
    Config_Compound *compound = 0;

    Config_Get_Result get_result = {};

    switch (r->type){
        case ConfigRValueType_LValue:
        {
            Config_LValue *l = r->lvalue;
            if (l != 0){
                get_result = config_var(config, l->identifier, l->index);
                if (get_result.success){
                    switch (get_result.type){
                        case ConfigRValueType_Boolean:
                        {
                            boolean = &get_result.boolean;
                        }break;

                        case ConfigRValueType_Integer:
                        {
                            integer = &get_result.integer;
                        }break;

                        case ConfigRValueType_String:
                        {
                            string = &get_result.string;
                        }break;

                        case ConfigRValueType_Compound:
                        {
                            compound = get_result.compound;
                        }break;
                    }
                }
            }
        }break;

        case ConfigRValueType_Boolean:
        {
            boolean = &r->boolean;
        }break;

        case ConfigRValueType_Integer:
        {
            integer = &r->integer;
        }break;

        case ConfigRValueType_String:
        {
            string = &r->string;
        }break;

        case ConfigRValueType_Compound:
        {
            compound = r->compound;
        }break;
    }

    if (boolean != 0){
        String_ID val = 0;
        if (*boolean){
            val = vars_save_string({(u8*)("true"), sizeof("true") - 1});
        }
        else{
            val = vars_save_string({(u8*)("false"), sizeof("false") - 1});
        }
        vars_new_variable(dst, l_value, val);
    }
    else if (integer != 0){

        String_ID val = vars_save_string(push_stringf(scratch, "%d", *integer));
        vars_new_variable(dst, l_value, val);
    }
    else if (string != 0){
        String_ID val = vars_save_string(*string);
        vars_new_variable(dst, l_value, val);
    }
    else if (compound != 0){
        Variable_Handle sub_var = vars_new_variable(dst, l_value);

        i32 implicit_index = 0;
        b32 implicit_allowed = true;

        Config_Compound_Element *node = 0;
        if (compound != 0){
            node = compound->first;
        }
        for (; node != 0;
             node = node->next, implicit_index += 1){
            String_ID sub_l_value = 0;

            switch (node->l.type){
                case ConfigLayoutType_Unset:
                {
                    if (implicit_allowed){
                        sub_l_value = vars_save_string(push_stringf(scratch, "%d", implicit_index));
                    }
                }break;

                case ConfigLayoutType_Identifier:
                {
                    implicit_allowed = false;
                    sub_l_value = vars_save_string(node->l.identifier);
                }break;

                case ConfigLayoutType_Integer:
                {
                    implicit_allowed = false;
                    sub_l_value = vars_save_string(push_stringf(scratch, "%d", node->l.integer));
                }break;
            }

            if (sub_l_value != 0){
                Config_RValue *r = node->r;
                if (r != 0){
                    def_var_dump_rvalue(app, config, sub_var, sub_l_value, r);
                }
            }
        }
    }
}

static Variable_Handle
def_fill_var_from_config(Application_Links *app, Variable_Handle parent, String_ID key, Config *config){
    Variable_Handle result = vars_get_nil();

    if (key != 0){
        String_ID file_name_id = vars_save_string(config->file_name);
        result = vars_new_variable(parent, key, file_name_id);

        Variable_Handle var = result;

        Scratch_Block scratch(app);

        if (config->version != 0){
            String_ID version_key = vars_save_string(SCu8((u8*)("version"), (u64)(sizeof("version") - 1)));
            String_ID version_value = vars_save_string(push_stringf(scratch, "%d", *config->version));
            vars_new_variable(parent, version_key, version_value);
        }

        for (Config_Assignment *node = config->first;
             node != 0;
             node = node->next){
            String_ID l_value = 0;
            Config_LValue *l = node->l;
            if (l != 0){
                String_Const_u8 string = l->identifier;
                if (l->index != 0){
                    string = push_stringf(scratch, "%.*s.%d", (i32)(string).size, (char*)(string).str, l->index);
                }
                l_value = vars_save_string(string);
            }

            if (l_value != 0){
                Config_RValue *r = node->r;
                if (r != 0){
                    def_var_dump_rvalue(app, config, var, l_value, r);
                }
            }
        }
    }

    return(result);
}





static const u64 def_config_lookup_count = 4;
static String_ID def_config_lookup_table[def_config_lookup_count] = {};

static void
_def_config_table_init(void){
    if (def_config_lookup_table[0] == 0){
        def_config_lookup_table[0] = vars_save_string({(u8*)("ses_config"), sizeof("ses_config") - 1});
        def_config_lookup_table[1] = vars_save_string({(u8*)("prj_config"), sizeof("prj_config") - 1});
        def_config_lookup_table[2] = vars_save_string({(u8*)("usr_config"), sizeof("usr_config") - 1});
        def_config_lookup_table[3] = vars_save_string({(u8*)("def_config"), sizeof("def_config") - 1});
    }
}

static Variable_Handle
def_get_config_var(String_ID key){
    _def_config_table_init();

    Variable_Handle result = vars_get_nil();
    Variable_Handle root = vars_get_root();
    for (u64 i = 0; i < def_config_lookup_count; i += 1){
        String_ID block_key = def_config_lookup_table[i];
        Variable_Handle block_var = vars_read_key(root, block_key);
        Variable_Handle var = vars_read_key(block_var, key);
        if (!vars_is_nil(var)){
            result = var;
            break;
        }
    }

    return(result);
}

static void
def_set_config_var(String_ID key, String_ID val){
    _def_config_table_init();
    Variable_Handle root = vars_get_root();
    Variable_Handle block_var = vars_read_key(root, def_config_lookup_table[0]);
 if (vars_is_nil(block_var)){
  block_var = vars_new_variable(root, def_config_lookup_table[0]);
 }
    vars_new_variable(block_var, key, val);
}

static b32
def_get_config_b32(String_ID key){
    Variable_Handle var = def_get_config_var(key);
    String_ID val = vars_string_id_from_var(var);
    b32 result = (val != 0 && val != vars_save_string(SCu8((u8*)("false"), (u64)(sizeof("false") - 1))));
    return(result);
}

static void
def_set_config_b32(String_ID key, b32 val){
    String_ID val_id = val?vars_save_string(SCu8((u8*)("true"), (u64)(sizeof("true") - 1))):vars_save_string(SCu8((u8*)("false"), (u64)(sizeof("false") - 1)));
    def_set_config_var(key, val_id);
}

static String_Const_u8
def_get_config_string(Arena *arena, String_ID key){
    Variable_Handle var = def_get_config_var(key);
    String_Const_u8 result = vars_string_from_var(arena, var);
    return(result);
}

static void
def_set_config_string(String_ID key, String_Const_u8 val){
    def_set_config_var(key, vars_save_string(val));
}

static u64
def_get_config_u64(Application_Links *app, String_ID key){
    Scratch_Block scratch(app);
    Variable_Handle var = def_get_config_var(key);
    u64 result = vars_u64_from_var(app, var);
    return(result);
}

static void
def_set_config_u64(Application_Links *app, String_ID key, u64 val){
    Scratch_Block scratch(app);
    String_Const_u8 val_string = push_stringf(scratch, "%llu", val);
    def_set_config_var(key, vars_save_string(val_string));
}





static Config_Assignment*
config_lookup_assignment(Config *config, String_Const_u8 var_name, i32 subscript){
    Config_Assignment *assignment = 0;
    for (assignment = config->first;
         assignment != 0;
         assignment = assignment->next){
        Config_LValue *l = assignment->l;
        if (l != 0 && string_match(l->identifier, var_name) && l->index == subscript){
            break;
        }
    }
    return(assignment);
}

static Config_Get_Result
config_evaluate_rvalue(Config *config, Config_Assignment *assignment, Config_RValue *r){
    Config_Get_Result result = {};
    if (r != 0 && !assignment->visited){
        if (r->type == ConfigRValueType_LValue){
            assignment->visited = true;
            Config_LValue *l = r->lvalue;
            result = config_var(config, l->identifier, l->index);
            assignment->visited = false;
        }
        else{
            result.success = true;
            result.pos = assignment->pos;
            result.type = r->type;
            switch (r->type){
                case ConfigRValueType_Boolean:
                {
                    result.boolean = r->boolean;
                }break;

                case ConfigRValueType_Integer:
                {
                    result.integer = r->integer;
                }break;

                case ConfigRValueType_String:
                {
                    result.string = r->string;
                }break;

                case ConfigRValueType_Compound:
                {
                    result.compound = r->compound;
                }break;
            }
        }
    }
    return(result);
}

static Config_Get_Result
config_var(Config *config, String_Const_u8 var_name, i32 subscript){
    Config_Get_Result result = {};
    Config_Assignment *assignment = config_lookup_assignment(config, var_name, subscript);
    if (assignment != 0){
        result = config_evaluate_rvalue(config, assignment, assignment->r);
    }
    return(result);
}





static Config_Get_Result
config_compound_member(Config *config, Config_Compound *compound, String_Const_u8 var_name, i32 index){
    Config_Get_Result result = {};
    i32 implicit_index = 0;
    b32 implicit_index_is_valid = true;
    for (Config_Compound_Element *element = compound->first;
         element != 0;
         element = element->next, implicit_index += 1){
        b32 element_matches_query = false;
        switch (element->l.type){
            case ConfigLayoutType_Unset:
            {
                if (implicit_index_is_valid && index == implicit_index){
                    element_matches_query = true;
                }
            }break;

            case ConfigLayoutType_Identifier:
            {
                implicit_index_is_valid = false;
                if (string_match(element->l.identifier, var_name)){
                    element_matches_query = true;
                }
            }break;

            case ConfigLayoutType_Integer:
            {
                implicit_index_is_valid = false;
                if (element->l.integer == index){
                    element_matches_query = true;
                }
            }break;
        }
        if (element_matches_query){
            Config_Assignment dummy_assignment = {};
            dummy_assignment.pos = element->l.pos;
            result = config_evaluate_rvalue(config, &dummy_assignment, element->r);
            break;
        }
    }
    return(result);
}

static Config_Iteration_Step_Result
typed_array_iteration_step(Config *parsed, Config_Compound *compound, Config_RValue_Type type, i32 index);

static i32
typed_array_get_count(Config *parsed, Config_Compound *compound, Config_RValue_Type type);

static Config_Get_Result_List
typed_array_reference_list(Arena *arena, Config *parsed, Config_Compound *compound, Config_RValue_Type type);





static b32
config_bool_var(Config *config, String_Const_u8 var_name, i32 subscript, b32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_Boolean);
    if (success){
        *var_out = result.boolean;
    }
    return(success);
}
static b32
config_bool_var(Config *config, String_Const_u8 var_name, i32 subscript, b8 *var_out){
    b32 temp = false;
    b32 success = config_bool_var(config, var_name, subscript, &temp);
    if (success){
        *var_out = (temp != false);
    }
    return(success);
}
static b32
config_bool_var(Config *config, char *var_name, i32 subscript, b32* var_out){
    return(config_bool_var(config, SCu8(var_name), subscript, var_out));
}
static b32
config_bool_var(Config *config, char* var_name, i32 subscript, b8 *var_out){
    b32 temp = false;
    b32 success = config_bool_var(config, SCu8(var_name), subscript, &temp);
    if (success){
        *var_out = (temp != false);
    }
    return(success);
}

static b32
config_int_var(Config *config, String_Const_u8 var_name, i32 subscript, i32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.integer;
    }
    return(success);
}

static b32
config_int_var(Config *config, char *var_name, i32 subscript, i32* var_out){
    return(config_int_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_uint_var(Config *config, String_Const_u8 var_name, i32 subscript, u32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.uinteger;
    }
    return(success);
}

static b32
config_uint_var(Config *config, char *var_name, i32 subscript, u32* var_out){
    return(config_uint_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_string_var(Config *config, String_Const_u8 var_name, i32 subscript, String_Const_u8* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_String;
    if (success){
        *var_out = result.string;
    }
    return(success);
}

static b32
config_string_var(Config *config, char *var_name, i32 subscript, String_Const_u8* var_out){
    return(config_string_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_placed_string_var(Config *config, String_Const_u8 var_name, i32 subscript, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        u64 size = result.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(success);
}

static b32
config_placed_string_var(Config *config, char *var_name, i32 subscript, String_Const_u8* var_out, u8 *space, u64 space_size){
    return(config_placed_string_var(config, SCu8(var_name), subscript, var_out, space, space_size));
}

static b32
config_compound_var(Config *config, String_Const_u8 var_name, i32 subscript, Config_Compound** var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_Compound);
    if (success){
        *var_out = result.compound;
    }
    return(success);
}

static b32
config_compound_var(Config *config, char *var_name, i32 subscript, Config_Compound** var_out){
    return(config_compound_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_compound_bool_member(Config *config, Config_Compound *compound,
                            String_Const_u8 var_name, i32 index, b32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Boolean;
    if (success){
        *var_out = result.boolean;
    }
    return(success);
}

static b32
config_compound_bool_member(Config *config, Config_Compound *compound,
                            char *var_name, i32 index, b32* var_out){
    return(config_compound_bool_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_int_member(Config *config, Config_Compound *compound,
                           String_Const_u8 var_name, i32 index, i32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.integer;
    }
    return(success);
}

static b32
config_compound_int_member(Config *config, Config_Compound *compound,
                           char *var_name, i32 index, i32* var_out){
    return(config_compound_int_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_uint_member(Config *config, Config_Compound *compound,
                            String_Const_u8 var_name, i32 index, u32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.uinteger;
    }
    return(success);
}

static b32
config_compound_uint_member(Config *config, Config_Compound *compound,
                            char *var_name, i32 index, u32* var_out){
    return(config_compound_uint_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_string_member(Config *config, Config_Compound *compound,
                              String_Const_u8 var_name, i32 index, String_Const_u8* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        *var_out = result.string;
    }
    return(success);
}

static b32
config_compound_string_member(Config *config, Config_Compound *compound,
                              char *var_name, i32 index, String_Const_u8* var_out){
    return(config_compound_string_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_placed_string_member(Config *config, Config_Compound *compound,
                                     String_Const_u8 var_name, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        u64 size = result.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(success);
}

static b32
config_compound_placed_string_member(Config *config, Config_Compound *compound,
                                     char *var_name, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    return(config_compound_placed_string_member(config, compound, SCu8(var_name), index, var_out, space, space_size));
}

static b32
config_compound_compound_member(Config *config, Config_Compound *compound,
                                String_Const_u8 var_name, i32 index, Config_Compound** var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_Compound);
    if (success){
        *var_out = result.compound;
    }
    return(success);
}

static b32
config_compound_compound_member(Config *config, Config_Compound *compound,
                                char *var_name, i32 index, Config_Compound** var_out){
    return(config_compound_compound_member(config, compound, SCu8(var_name), index, var_out));
}

static Iteration_Step_Result
typed_bool_array_iteration_step(Config *config, Config_Compound *compound, i32 index, b32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Boolean, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.boolean;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_int_array_iteration_step(Config *config, Config_Compound *compound, i32 index, i32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Integer, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.integer;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_uint_array_iteration_step(Config *config, Config_Compound *compound, i32 index, u32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Integer, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.uinteger;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_string_array_iteration_step(Config *config, Config_Compound *compound, i32 index, String_Const_u8* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_String, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.string;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_placed_string_array_iteration_step(Config *config, Config_Compound *compound, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_String, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        u64 size = result.get.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.get.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(result.step);
}

static Iteration_Step_Result
typed_compound_array_iteration_step(Config *config, Config_Compound *compound, i32 index, Config_Compound** var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Compound, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.compound;
    }
    return(result.step);
}

static i32
typed_bool_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Boolean);
    return(count);
}

static i32
typed_int_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Integer);
    return(count);
}

static i32
typed_string_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_String);
    return(count);
}

static i32
typed_compound_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Compound);
    return(count);
}

static Config_Get_Result_List
typed_bool_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Boolean);
    return(list);
}

static Config_Get_Result_List
typed_int_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Integer);
    return(list);
}

static Config_Get_Result_List
typed_string_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_String);
    return(list);
}

static Config_Get_Result_List
typed_compound_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Compound);
    return(list);
}



static Config_Iteration_Step_Result
typed_array_iteration_step(Config *parsed, Config_Compound *compound, Config_RValue_Type type, i32 index){
    Config_Iteration_Step_Result result = {};
    result.step = Iteration_Quit;
    Config_Get_Result get_result = config_compound_member(parsed, compound, SCu8((u8*)("~"), (u64)(sizeof("~") - 1)), index);
    if (get_result.success){
        if (get_result.type == type){
            result.step = Iteration_Good;
            result.get = get_result;
        }
        else{
            result.step = Iteration_Skip;
        }
    }
    return(result);
}

static i32
typed_array_get_count(Config *parsed, Config_Compound *compound, Config_RValue_Type type){
    i32 count = 0;
    for (i32 i = 0;; ++i){
        Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, type, i);
        if (result.step == Iteration_Skip){
            continue;
        }
        else if (result.step == Iteration_Quit){
            break;
        }
        count += 1;
    }
    return(count);
}

static Config_Get_Result_List
typed_array_reference_list(Arena *arena, Config *parsed, Config_Compound *compound, Config_RValue_Type type){
    Config_Get_Result_List list = {};
    for (i32 i = 0;; ++i){
        Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, type, i);
        if (result.step == Iteration_Skip){
            continue;
        }
        else if (result.step == Iteration_Quit){
            break;
        }
        Config_Get_Result_Node *node = ((Config_Get_Result_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Config_Get_Result_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "1358" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_config.cpp" ":" "1358" ":") - 1)))));
        node->result = result.get;
        (((list.first)==0)?((node)->next=(node)->prev=0,(list.first)=(list.last)=(node)):((node)->prev=(list.last),(node)->next=0,(list.last)->next=(node),(list.last)=(node)));
        list.count += 1;
    }
    return(list);
}



static void
change_mode(Application_Links *app, String_Const_u8 mode){
    fcoder_mode = FCoderMode_Original;
    if (string_match(mode, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)))){
        fcoder_mode = FCoderMode_Original;
    }
    else if (string_match(mode, SCu8((u8*)("notepad-like"), (u64)(sizeof("notepad-like") - 1)))){
        begin_notepad_mode(app);
    }
    else{
        print_message(app, SCu8((u8*)("Unknown mode.\n"), (u64)(sizeof("Unknown mode.\n") - 1)));
    }
}





static Config*
theme_parse__data(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Arena *color_arena, Color_Table *color_table){
    Config *parsed = def_config_from_text(app, arena, file_name, data);
    if (parsed != 0){
        for (Config_Assignment *node = parsed->first;
             node != 0;
             node = node->next){
            Scratch_Block scratch(app, arena);
            Config_LValue *l = node->l;
            String_Const_u8 l_name = push_string_copy(scratch, l->identifier);
            Managed_ID id = managed_id_get(app, SCu8((u8*)("colors"), (u64)(sizeof("colors") - 1)), l_name);
            if (id != 0){
                u32 color = 0;
                if (config_uint_var(parsed, l_name, 0, &color)){
                    color_table->arrays[id%color_table->count] = make_colors(color_arena, color);
                }
                else{
                    Config_Compound *compound = 0;
                    if (config_compound_var(parsed, l_name, 0, &compound)){
                        static u32 color_array[256];
                        i32 counter = 0;
                        for (i32 i = 0;; i += 1){
                            Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, ConfigRValueType_Integer, i);
                            if (result.step == Iteration_Skip){
                                continue;
                            }
                            else if (result.step == Iteration_Quit){
                                break;
                            }

                            color_array[counter] = result.get.uinteger;
                            counter += 1;
                            if (counter == 256){
                                break;
                            }
                        }

                        color_table->arrays[id%color_table->count] = make_colors(color_arena, color_array, counter);
                    }
                }
            }

        }
    }
    return(parsed);
}

static Config*
theme_parse__buffer(Application_Links *app, Arena *arena, Buffer_ID buffer, Arena *color_arena, Color_Table *color_table){
    String_Const_u8 contents = push_whole_buffer(app, arena, buffer);
    Config *parsed = 0;
    if (contents.str != 0){
        String_Const_u8 file_name = push_buffer_file_name(app, arena, buffer);
        parsed = theme_parse__data(app, arena, file_name, contents, color_arena, color_table);
    }
    return(parsed);
}

static Config*
theme_parse__file_name(Application_Links *app, Arena *arena, char *file_name, Arena *color_arena, Color_Table *color_table){
    Config *parsed = 0;
 FILE* file = fopen(file_name, "rb");
    if (file == 0){
        file = def_search_normal_fopen(arena, file_name, "rb");
    }
    if (file != 0){
        String_Const_u8 data = dump_file_handle(arena, file);
        fclose(file);
        parsed = theme_parse__data(app, arena, SCu8(file_name), data, color_arena, color_table);
    }
    if (parsed == 0){
        Scratch_Block scratch(app, arena);
        String_Const_u8 str = push_u8_stringf(scratch, "Did not find %s, theme not loaded", file_name);
        print_message(app, str);
    }
    return(parsed);
}




static void
load_config_and_apply(Application_Links *app, Arena *out_arena, i32 override_font_size, b32 override_hinting){
    Scratch_Block scratch(app, out_arena);

    linalloc_clear(out_arena);

    Config *parsed = 0;
    FILE *file = def_search_normal_fopen(scratch, "config.4coder", "rb");
    if (file != 0){
        String_Const_u8 data = dump_file_handle(scratch, file);
        fclose(file);
        if (data.str != 0){
            parsed = def_config_from_text(app, scratch, {(u8*)("config.4coder"), sizeof("config.4coder") - 1}, data);
        }
    }

    if (parsed != 0){

        String_Const_u8 error_text = config_stringize_errors(app, scratch, parsed);
        if (error_text.str != 0){
            print_message(app, SCu8((u8*)("trying to load config file:\n"), (u64)(sizeof("trying to load config file:\n") - 1)));
            print_message(app, error_text);
        }


        if (error_text.str == 0){

            Variable_Handle config_var = def_fill_var_from_config(app, vars_get_root(),
                                                                  vars_save_string(SCu8((u8*)("def_config"), (u64)(sizeof("def_config") - 1))),
                                                                  parsed);
   vars_print(app, config_var);
            print_message(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }
    }
    else{
        print_message(app, SCu8((u8*)("Using default config:\n"), (u64)(sizeof("Using default config:\n") - 1)));
        Face_Description description = get_face_description(app, 0);
        if (description.font.file_name.str != 0){
            def_set_config_string(vars_save_string(SCu8((u8*)("default_font_name"), (u64)(sizeof("default_font_name") - 1))), description.font.file_name);
        }
    }

    String_Const_u8 default_font_name = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_font_name"), (u64)(sizeof("default_font_name") - 1))));
    if (default_font_name.size == 0){
        default_font_name = SCu8((u8*)("liberation-mono.ttf"), (u64)(sizeof("liberation-mono.ttf") - 1));
    }






    String_Const_u8 mode = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("mode"), (u64)(sizeof("mode") - 1))));
    change_mode(app, mode);

    b32 lalt_lctrl_is_altgr = def_get_config_b32(vars_save_string(SCu8((u8*)("lalt_lctrl_is_altgr"), (u64)(sizeof("lalt_lctrl_is_altgr") - 1))));
    global_set_setting(app, GlobalSetting_LAltLCtrlIsAltGr, lalt_lctrl_is_altgr);

    String_Const_u8 default_theme_name = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_theme_name"), (u64)(sizeof("default_theme_name") - 1))));
    Color_Table *colors = get_color_table_by_name(default_theme_name);
    set_active_color(colors);

    Face_Description description = {};
    if (override_font_size != 0){
        description.parameters.pt_size = override_font_size;
    }
    else{
        description.parameters.pt_size = (i32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_font_size"), (u64)(sizeof("default_font_size") - 1))));
    }
    if (description.parameters.pt_size == 0){
        description.parameters.pt_size = 12;
    }

    b32 default_font_hinting = def_get_config_b32(vars_save_string(SCu8((u8*)("default_font_hinting"), (u64)(sizeof("default_font_hinting") - 1))));
    description.parameters.hinting = default_font_hinting || override_hinting;

    Face_Antialiasing_Mode aa_mode = FaceAntialiasingMode_8BitMono;
    String8 aa_mode_string = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_font_aa_mode"), (u64)(sizeof("default_font_aa_mode") - 1))));
    if (string_match(aa_mode_string, {(u8*)("8bit"), sizeof("8bit") - 1})){
        aa_mode = FaceAntialiasingMode_8BitMono;
    }
    else if (string_match(aa_mode_string, {(u8*)("1bit"), sizeof("1bit") - 1})){
        aa_mode = FaceAntialiasingMode_1BitMono;
    }
    description.parameters.aa_mode = aa_mode;

    description.font.file_name = default_font_name;
    if (!modify_global_face_by_description(app, description)){
        String8 name_in_fonts_folder = push_u8_stringf(scratch, "fonts/%.*s", (i32)(default_font_name).size, (char*)(default_font_name).str);
        description.font.file_name = def_search_normal_full_path(scratch, name_in_fonts_folder);
        modify_global_face_by_description(app, description);
    }

    b32 bind_by_physical_key = def_get_config_b32(vars_save_string(SCu8((u8*)("bind_by_physical_key"), (u64)(sizeof("bind_by_physical_key") - 1))));
    if (bind_by_physical_key){
        system_set_key_mode(KeyMode_Physical);
    }
    else{
        system_set_key_mode(KeyMode_LanguageArranged);
    }
}

static void
load_theme_file_into_live_set(Application_Links *app, char *file_name){
    Arena *arena = &global_theme_arena;
    Color_Table color_table = make_color_table(app, arena);
    Scratch_Block scratch(app, arena);
    Config *config = theme_parse__file_name(app, scratch, file_name, arena, &color_table);
    String_Const_u8 error_text = config_stringize_errors(app, scratch, config);
    print_message(app, error_text);

    String_Const_u8 name = SCu8(file_name);
    name = string_front_of_path(name);
    if (string_match(string_postfix(name, 7), SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1)))){
        name = string_chop(name, 7);
    }
    save_theme(color_table, name);
}

static void
load_folder_of_themes_into_live_set(Application_Links *app, String_Const_u8 path){
    Scratch_Block scratch(app);

    File_List list = system_get_file_list(scratch, path);
    for (File_Info **ptr = list.infos, **end = list.infos + list.count;
         ptr < end;
         ptr += 1){
        File_Info *info = *ptr;
        if (!(((info->attributes.flags)&(FileAttribute_IsDirectory))!=0)){
            String_Const_u8 name = info->file_name;
            if (string_match(string_postfix(name, 7), {(u8*)(".4coder"), sizeof(".4coder") - 1})){
                Temp_Memory_Block temp(scratch);
                String_Const_u8 full_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                            (i32)(path).size, (char*)(path).str,
                                                            (i32)(name).size, (char*)(name).str);
                load_theme_file_into_live_set(app, (char*)full_name.str);
            }
        }
    }
}




CUSTOM_COMMAND(load_theme_current_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_config.cpp", 1611, Normal)
CUSTOM_DOC("Parse the current buffer as a theme file and add the theme to the theme list. If the buffer has a .4coder postfix in it's name, it is removed when the name is saved.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        Arena *arena = &global_theme_arena;
        Color_Table color_table = make_color_table(app, arena);
        Config *config = theme_parse__buffer(app, scratch, buffer, arena, &color_table);
        String_Const_u8 error_text = config_stringize_errors(app, scratch, config);
        print_message(app, error_text);

        u64 problem_score = 0;
        if (color_table.count < defcolor_line_numbers_text){
            problem_score = defcolor_line_numbers_text - color_table.count;
        }
        for (i32 i = 0; i < color_table.count; i += 1){
            if (color_table.arrays[i].count == 0){
                problem_score += 1;
            }
        }

        if (error_text.size > 0 || problem_score >= 10){
            String_Const_u8 string = push_u8_stringf(scratch, "There appears to be a problem parsing %.*s; no theme change applied\n", (i32)(file_name).size, (char*)(file_name).str);
            print_message(app, string);
        }
        else{
            String_Const_u8 name = string_front_of_path(file_name);
            if (string_match(string_postfix(name, 7), SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1)))){
                name = string_chop(name, 7);
            }
            save_theme(color_table, name);

            Color_Table_Node *node = global_theme_list.last;
            if (node != 0 && string_match(node->name, name)){
                active_color_table = node->table;
            }
        }
    }
}

CUSTOM_COMMAND(go_to_user_directory, "/home/tabletel/dev/4cc/code/custom/4coder_config.cpp", 1655, Normal)
CUSTOM_DOC("Go to the 4coder user directory")
{
    Scratch_Block scratch(app);
    String_Const_u8 hot = push_hot_directory(app, scratch);
    String8 user_4coder_path = system_get_path(scratch, SystemPath_UserDirectory);
    String8 cmd = push_u8_stringf(scratch, "mkdir \"%.*s\"", (i32)(user_4coder_path).size, (char*)(user_4coder_path).str);
    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
    set_hot_directory(app, user_4coder_path);
}
# 112 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_dynamic_bindings.cpp" 1






static Key_Code
dynamic_binding_key_code_from_string(String_Const_u8 key_string){
    Key_Code result = 0;
    for (i32 i = 1; i < KeyCode_COUNT; i += 1){
        String_Const_u8 str = SCu8(key_code_name[i]);
        if (string_match(str, key_string)){
            result = i;
            break;
        }
    }
    return result;
}

static b32
dynamic_binding_load_from_file(Application_Links *app, Mapping *mapping, String_Const_u8 filename){
    b32 result = false;

    Scratch_Block scratch(app);

    String_Const_u8 filename_copied = push_string_copy(scratch, filename);
    String8List search_list = {};
    def_search_normal_load_list(scratch, &search_list);
    String_Const_u8 full_path = def_search_get_full_path(scratch, &search_list, filename_copied);

    {
        String8 message = push_stringf(scratch, "loading bindings: %.*s\n",
                                       (i32)(full_path).size, (char*)(full_path).str);
        print_message(app, message);
    }

    FILE *file = 0;
    if (full_path.size > 0){
        file = fopen((char*)full_path.str, "rb");
    }

    if (file != 0){
        String_Const_u8 data = dump_file_handle(scratch, file);
        Config *parsed = def_config_from_text(app, scratch, filename, data);
  fclose(file);

        if (parsed != 0){
            result = true;

   Thread_Context* tctx = get_thread_context(app);
   mapping_release(tctx, mapping);
   mapping_init(tctx, mapping);
   Mapping *m = 0; Command_Map *map = 0;
   m = (mapping);

            for (Config_Assignment *assignment = parsed->first;
                 assignment != 0;
                 assignment = assignment->next){
                Config_LValue *l = assignment->l;
                if (l != 0 && l->index == 0){
                    Config_Get_Result rvalue = config_evaluate_rvalue(parsed, assignment, assignment->r);
                    if (rvalue.type == ConfigRValueType_Compound){
                        String_Const_u8 map_name = l->identifier;
                        String_ID map_name_id = vars_save_string(map_name);

                        map = mapping_get_or_make_map(m, (map_name_id));


                        Config_Compound *compound = rvalue.compound;

                        Config_Get_Result_List list = typed_compound_array_reference_list(scratch, parsed, compound);
                        for (Config_Get_Result_Node *node = list.first; node != 0; node = node->next){
                            Config_Compound *src = node->result.compound;
                            String_Const_u8 cmd_string = {0};
                            String_Const_u8 key_string = {0};
                            String_Const_u8 mod_string[9] = {0};

                            if (!config_compound_string_member(parsed, src, "cmd", 0, &cmd_string)){
                                def_config_push_error(scratch, parsed, node->result.pos, "Command string is required in binding");
                                goto finish_map;
                            }

                            if (!config_compound_string_member(parsed, src, "key", 1, &key_string)){
                                def_config_push_error(scratch, parsed, node->result.pos, "Key string is required in binding");
                                goto finish_map;
                            }

                            for (i32 mod_idx = 0; mod_idx < ((sizeof(mod_string))/(sizeof(*mod_string))); mod_idx += 1){
                                String_Const_u8 str = push_stringf(scratch, "mod_%i", mod_idx);
                                if (config_compound_string_member(parsed, src, str, 2 + mod_idx, &mod_string[mod_idx])){

                                }
                            }


                            {

                                Command_Metadata *command = get_command_metadata_from_name(cmd_string);


                                Key_Code keycode = dynamic_binding_key_code_from_string(key_string);


                                i32 mod_count = 0;
                                Key_Code mods[((sizeof(mod_string))/(sizeof(*mod_string)))] = {0};
                                for (i32 i = 0; i < ((sizeof(mod_string))/(sizeof(*mod_string))); i += 1){
                                    if (mod_string[i].str){
                                        mods[mod_count] = dynamic_binding_key_code_from_string(mod_string[i]);
                                        mod_count += 1;
                                    }
                                }

                                if (keycode != 0 && command != 0){
                                    Input_Modifier_Set mods_set = { mods, mod_count, };
                                    map_set_binding(mapping, map, command->proc, InputEventKind_KeyStroke, keycode, &mods_set);
                                }
                                else{
                                    def_config_push_error(scratch, parsed, node->result.pos,
                                                          (keycode != 0) ? (char*)"Invalid command" :
                                                          (command != 0) ? (char*)"Invalid key":
                                                          (char*)"Invalid command and key");
                                }
                            }

                            finish_map:;
                        }


                        if (parsed->errors.first != 0){
                            String_Const_u8 error_text = config_stringize_errors(app, scratch, parsed);
                            print_message(app, error_text);
                        }
                    }
                }
            }
        }
    }

    return(result);
}
# 113 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" 1






static void
point_stack_push(Application_Links *app, Buffer_ID buffer, i64 pos){
    Managed_Object object = alloc_buffer_markers_on_buffer(app, buffer, 1, 0);
    Marker *marker = (Marker*)managed_object_get_pointer(app, object);
    marker->pos = pos;
    marker->lean_right = false;

    i32 next_top = (point_stack.top + 1)%((sizeof(point_stack.markers))/(sizeof(*point_stack.markers)));
    if (next_top == point_stack.bot){
        Point_Stack_Slot *slot = &point_stack.markers[point_stack.bot];
        managed_object_free(app, slot->object);
        block_zero((slot), sizeof(*(slot)));
        point_stack.bot = (point_stack.bot + 1)%((sizeof(point_stack.markers))/(sizeof(*point_stack.markers)));
    }

    Point_Stack_Slot *slot = &point_stack.markers[point_stack.top];
    slot->buffer = buffer;
    slot->object = object;
    point_stack.top = next_top;
}

static void
point_stack_push_view_cursor(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    point_stack_push(app, buffer, pos);
}

static b32
point_stack_pop(Application_Links *app){
    b32 result = false;
    if (point_stack.top != point_stack.bot){
        result = true;
        if (point_stack.top > 0){
            point_stack.top -= 1;
        }
        else{
            point_stack.top = ((sizeof(point_stack.markers))/(sizeof(*point_stack.markers))) - 1;
        }
        Point_Stack_Slot *slot = &point_stack.markers[point_stack.top];
        managed_object_free(app, slot->object);
        block_zero((slot), sizeof(*(slot)));
    }
    return(result);
}

static b32
point_stack_read_top(Application_Links *app, Buffer_ID *buffer_out, i64 *pos_out){
    b32 result = false;
    if (point_stack.top != point_stack.bot){
        result = true;
        i32 prev_top = point_stack.top;
        if (prev_top > 0){
            prev_top -= 1;
        }
        else{
            prev_top = ((sizeof(point_stack.markers))/(sizeof(*point_stack.markers))) - 1;
        }
        Point_Stack_Slot *slot = &point_stack.markers[prev_top];
        Managed_Object object = slot->object;
        Marker *marker = (Marker*)managed_object_get_pointer(app, object);
        if (marker != 0){
            *buffer_out = slot->buffer;
            *pos_out = marker->pos;
        }
        else{
            *buffer_out = 0;
            *pos_out = 0;
        }
    }
    return(result);
}



static void
unlock_jump_buffer(void){
    locked_buffer.size = 0;
}

static void
lock_jump_buffer(Application_Links *app, String_Const_u8 name){
    if (name.size < sizeof(locked_buffer_space)){
        block_copy(locked_buffer_space, name.str, name.size);
        locked_buffer = SCu8(locked_buffer_space, name.size);
        Scratch_Block scratch(app);
        String_Const_u8 escaped = string_escape(scratch, name);
        do{ Temp_Memory temp_LOG_F = begin_temp(scratch); String_Const_u8 E = push_u8_stringf(scratch, "lock jump buffer [name=\"%.*s\"]", (i32)(escaped).size, (char*)(escaped).str); do{ Temp_Memory temp_LOG = begin_temp(scratch); String_Const_u8 M = log_event(scratch, E, SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp") - 1)), 94, (0), (0), (system_thread_get_id())); log_string(app, M); end_temp(temp_LOG); }while(0); end_temp(temp_LOG_F); }while(0)
                                                                             ;
    }
}

static void
lock_jump_buffer(Application_Links *app, char *name, i32 size){
    lock_jump_buffer(app, SCu8(name, size));
}

static void
lock_jump_buffer(Application_Links *app, Buffer_ID buffer_id){
    Scratch_Block scratch(app);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer_id);
    lock_jump_buffer(app, buffer_name);
}

static Buffer_ID
get_locked_jump_buffer(Application_Links *app){
    Buffer_ID result = 0;
    if (locked_buffer.size > 0){
        result = get_buffer_by_name(app, locked_buffer, Access_Always);
    }
    if (result == 0){
        unlock_jump_buffer();
    }
    return(result);
}

static View_ID
get_view_for_locked_jump_buffer(Application_Links *app){
    View_ID result = 0;
    Buffer_ID buffer = get_locked_jump_buffer(app);
    if (buffer != 0){
        result = get_first_view_with_buffer(app, buffer);
    }
    return(result);
}




static void
new_view_settings(Application_Links *app, View_ID view){
    b32 use_file_bars = def_get_config_b32(vars_save_string(SCu8((u8*)("use_file_bars"), (u64)(sizeof("use_file_bars") - 1))));
    view_set_setting(app, view, ViewSetting_ShowFileBar, use_file_bars);
}



static void
view_set_passive(Application_Links *app, View_ID view_id, b32 value){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    b32 *is_passive = ((b32*)managed_scope_get_attachment((app), (scope), (view_is_passive_loc), sizeof(b32)));
    if (is_passive != 0){
        *is_passive = value;
    }
}

static b32
view_get_is_passive(Application_Links *app, View_ID view_id){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    b32 *is_passive = ((b32*)managed_scope_get_attachment((app), (scope), (view_is_passive_loc), sizeof(b32)));
    b32 result = false;
    if (is_passive != 0){
        result = *is_passive;
    }
    return(result);
}

static View_ID
open_footer_panel(Application_Links *app, View_ID view){
    View_ID special_view = open_view(app, view, ViewSplit_Bottom);
    new_view_settings(app, special_view);
    Buffer_ID buffer = view_get_buffer(app, special_view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    view_set_split_pixel_size(app, special_view, (i32)(metrics.line_height*14.f));
    view_set_passive(app, special_view, true);
    return(special_view);
}

static void
close_build_footer_panel(Application_Links *app){
    if (view_exists(app, build_footer_panel_view_id)){
        view_close(app, build_footer_panel_view_id);
    }
    build_footer_panel_view_id = 0;
}

static View_ID
open_build_footer_panel(Application_Links *app){
    if (!view_exists(app, build_footer_panel_view_id)){
        View_ID view = get_active_view(app, Access_Always);
        build_footer_panel_view_id = open_footer_panel(app, view);
        view_set_active(app, view);
    }
    return(build_footer_panel_view_id);
}

static View_ID
get_next_view_looped_primary_panels(Application_Links *app, View_ID start_view_id, Access_Flag access){
    View_ID view_id = start_view_id;
    do{
        view_id = get_next_view_looped_all_panels(app, view_id, access);
        if (!view_get_is_passive(app, view_id)){
            break;
        }
    }while(view_id != start_view_id);
    return(view_id);
}

static View_ID
get_prev_view_looped_primary_panels(Application_Links *app, View_ID start_view_id, Access_Flag access){
    View_ID view_id = start_view_id;
    do{
        view_id = get_prev_view_looped_all_panels(app, view_id, access);
        if (!view_get_is_passive(app, view_id)){
            break;
        }
    }while(view_id != start_view_id);
    return(view_id);
}

static View_ID
get_next_view_after_active(Application_Links *app, Access_Flag access){
    View_ID view = get_active_view(app, access);
    if (view != 0){
        view = get_next_view_looped_primary_panels(app, view, access);
    }
    return(view);
}



static void
call_after_ctx_shutdown(Application_Links *app, View_ID view, Custom_Command_Function *func){
    view_enqueue_command_function(app, view, func);
}

static Fallback_Dispatch_Result
fallback_command_dispatch(Application_Links *app, Mapping *mapping, Command_Map *map,
                          User_Input *in){
    Fallback_Dispatch_Result result = {};
    if (mapping != 0 && map != 0){
        Command_Binding binding = map_get_binding_recursive(mapping, map, &in->event);
        if (binding.custom != 0){
            Command_Metadata *metadata = get_command_metadata(binding.custom);
            if (metadata != 0){
                if (metadata->is_ui){
                    result.code = FallbackDispatch_DelayedUICall;
                    result.func = binding.custom;
                }
                else{
                    binding.custom(app);
                    result.code = FallbackDispatch_DidCall;
                }
            }
            else{
                binding.custom(app);
                result.code = FallbackDispatch_DidCall;
            }
        }
    }
    return(result);
}

static b32
ui_fallback_command_dispatch(Application_Links *app, View_ID view,
                             Mapping *mapping, Command_Map *map, User_Input *in){
    b32 result = false;
    Fallback_Dispatch_Result disp_result =
        fallback_command_dispatch(app, mapping, map, in);
    if (disp_result.code == FallbackDispatch_DelayedUICall){
        call_after_ctx_shutdown(app, view, disp_result.func);
        result = true;
    }
    if (disp_result.code == FallbackDispatch_Unhandled){
        leave_current_input_unhandled(app);
    }
    return(result);
}

static b32
ui_fallback_command_dispatch(Application_Links *app, View_ID view, User_Input *in){
    b32 result = false;
    View_Context ctx = view_current_context(app, view);
    if (ctx.mapping != 0){
        Command_Map *map = mapping_get_map(ctx.mapping, ctx.map_id);
        result = ui_fallback_command_dispatch(app, view, ctx.mapping, map, in);
    }
    else{
        leave_current_input_unhandled(app);
    }
    return(result);
}



static void
view_buffer_set(Application_Links *app, Buffer_ID *buffers, i64 *positions, i32 count){
    if (count > 0){
        Scratch_Block scratch(app);

        struct View_Node{
            View_Node *next;
            View_ID view_id;
        };

        View_ID active_view_id = get_active_view(app, Access_Always);
        View_ID first_view_id = active_view_id;
        if (view_get_is_passive(app, active_view_id)){
            first_view_id = get_next_view_looped_primary_panels(app, active_view_id, Access_Always);
        }

        View_ID view_id = first_view_id;

        View_Node *primary_view_first = 0;
        View_Node *primary_view_last = 0;
        i32 available_view_count = 0;

        primary_view_first = primary_view_last = ((View_Node*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(View_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "315" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "315" ":") - 1)))));
        primary_view_last->next = 0;
        primary_view_last->view_id = view_id;
        available_view_count += 1;
        for (;;){
            view_id = get_next_view_looped_primary_panels(app, view_id, Access_Always);
            if (view_id == first_view_id){
                break;
            }
            View_Node *node = ((View_Node*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(View_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "324" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "324" ":") - 1)))));
            primary_view_last->next = node;
            node->next = 0;
            node->view_id = view_id;
            primary_view_last = node;
            available_view_count += 1;
        }

        i32 buffer_set_count = (((count)<(available_view_count))?(count):(available_view_count));
        View_Node *node = primary_view_first;
        for (i32 i = 0; i < buffer_set_count; i += 1, node = node->next){
            if (view_set_buffer(app, node->view_id, buffers[i], 0)){
                view_set_cursor_and_preferred_x(app, node->view_id, seek_pos(positions[i]));
            }
        }
    }
}



static void
change_active_panel_send_command(Application_Links *app, Custom_Command_Function *custom_func){
    View_ID view = get_active_view(app, Access_Always);
    view = get_next_view_looped_primary_panels(app, view, Access_Always);
    if (view != 0){
        view_set_active(app, view);
    }
    if (custom_func != 0){
        view_enqueue_command_function(app, view, custom_func);
    }
}

CUSTOM_COMMAND(change_active_panel, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 356, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next highest view_id.")
{
    change_active_panel_send_command(app, 0);
}

CUSTOM_COMMAND(change_active_panel_backwards, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 362, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next lowest view_id.")
{
    View_ID view = get_active_view(app, Access_Always);
    view = get_prev_view_looped_primary_panels(app, view, Access_Always);
    if (view != 0){
        view_set_active(app, view);
    }
}

CUSTOM_COMMAND(open_panel_vsplit, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 372, Normal)
CUSTOM_DOC("Create a new panel by vertically splitting the active panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    View_ID new_view = open_view(app, view, ViewSplit_Right);
    new_view_settings(app, new_view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    view_set_buffer(app, new_view, buffer, 0);
}

CUSTOM_COMMAND(open_panel_hsplit, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 382, Normal)
CUSTOM_DOC("Create a new panel by horizontally splitting the active panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    View_ID new_view = open_view(app, view, ViewSplit_Bottom);
    new_view_settings(app, new_view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    view_set_buffer(app, new_view, buffer, 0);
}





static Buffer_ID
create_or_switch_to_buffer_and_clear_by_name(Application_Links *app, String_Const_u8 name_string, View_ID default_target_view){
    Buffer_ID search_buffer = get_buffer_by_name(app, name_string, Access_Always);
    if (search_buffer != 0){
        buffer_set_setting(app, search_buffer, BufferSetting_ReadOnly, true);

        View_ID target_view = default_target_view;

        View_ID view_with_buffer_already_open = get_first_view_with_buffer(app, search_buffer);
        if (view_with_buffer_already_open != 0){
            target_view = view_with_buffer_already_open;



        }
        else{
            view_set_buffer(app, target_view, search_buffer, 0);
        }
        view_set_active(app, target_view);

        clear_buffer(app, search_buffer);
        buffer_send_end_signal(app, search_buffer);
    }
    else{
        search_buffer = create_buffer(app, name_string, BufferCreate_AlwaysNew);
        buffer_set_setting(app, search_buffer, BufferSetting_Unimportant, true);
        buffer_set_setting(app, search_buffer, BufferSetting_ReadOnly, true);



        view_set_buffer(app, default_target_view, search_buffer, 0);
        view_set_active(app, default_target_view);
    }

    return(search_buffer);
}



static void
save_all_dirty_buffers_with_postfix(Application_Links *app, String_Const_u8 postfix){
    Profile_Scope_Block profile_block_437 ((app), SCu8((u8*)("save all dirty buffers"), (u64)(sizeof("save all dirty buffers") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "437" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "437" ":") - 1)));
    Scratch_Block scratch(app);
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_ReadWriteVisible);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_ReadWriteVisible)){
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        if (dirty == DirtyState_UnsavedChanges){
            Temp_Memory temp = begin_temp(scratch);
            String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
            if (string_match(string_postfix(file_name, postfix.size), postfix)){
                buffer_save(app, buffer, file_name, 0);
            }
            end_temp(temp);
        }
    }
}

CUSTOM_COMMAND(save_all_dirty_buffers, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 454, Normal)
CUSTOM_DOC("Saves all buffers marked dirty (showing the '*' indicator).")
{
    String_Const_u8 empty = {};
    save_all_dirty_buffers_with_postfix(app, empty);
}



static void
set_mouse_suppression(b32 suppress){
    if (suppress){
        suppressing_mouse = true;
        system_show_mouse_cursor(MouseCursorShow_Never);
    }
    else{
        suppressing_mouse = false;
        system_show_mouse_cursor(MouseCursorShow_Always);
    }
}

CUSTOM_COMMAND(suppress_mouse, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 475, Normal)
CUSTOM_DOC("Hides the mouse and causes all mosue input (clicks, position, wheel) to be ignored.")
{
    set_mouse_suppression(true);
}

CUSTOM_COMMAND(allow_mouse, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 481, Normal)
CUSTOM_DOC("Shows the mouse and causes all mouse input to be processed normally.")
{
    set_mouse_suppression(false);
}

CUSTOM_COMMAND(toggle_mouse, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 487, Normal)
CUSTOM_DOC("Toggles the mouse suppression mode, see suppress_mouse and allow_mouse.")
{
    set_mouse_suppression(!suppressing_mouse);
}

CUSTOM_COMMAND(set_mode_to_original, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 493, Normal)
CUSTOM_DOC("Sets the edit mode to 4coder original.")
{
    fcoder_mode = FCoderMode_Original;
}

CUSTOM_COMMAND(set_mode_to_notepad_like, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 499, Normal)
CUSTOM_DOC("Sets the edit mode to Notepad like.")
{
    begin_notepad_mode(app);
}

CUSTOM_COMMAND(toggle_highlight_line_at_cursor, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 505, Normal)
CUSTOM_DOC("Toggles the line highlight at the cursor.")
{
    String_ID key = vars_save_string(SCu8((u8*)("highlight_line_at_cursor"), (u64)(sizeof("highlight_line_at_cursor") - 1)));
    b32 val = def_get_config_b32(key);
    def_set_config_b32(key, !val);
}

CUSTOM_COMMAND(toggle_highlight_enclosing_scopes, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 513, Normal)
CUSTOM_DOC("In code files scopes surrounding the cursor are highlighted with distinguishing colors.")
{
    String_ID key = vars_save_string(SCu8((u8*)("use_scope_highlight"), (u64)(sizeof("use_scope_highlight") - 1)));
    b32 val = def_get_config_b32(key);
    def_set_config_b32(key, !val);
}

CUSTOM_COMMAND(toggle_paren_matching_helper, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 521, Normal)
CUSTOM_DOC("In code files matching parentheses pairs are colored with distinguishing colors.")
{
    String_ID key = vars_save_string(SCu8((u8*)("use_paren_helper"), (u64)(sizeof("use_paren_helper") - 1)));
    b32 val = def_get_config_b32(key);
    def_set_config_b32(key, !val);
}

CUSTOM_COMMAND(toggle_fullscreen, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 529, Normal)
CUSTOM_DOC("Toggle fullscreen mode on or off.  The change(s) do not take effect until the next frame.")
{
    system_set_fullscreen(!system_is_fullscreen());
}

CUSTOM_COMMAND(load_themes_default_folder, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 535, Normal)
CUSTOM_DOC("Loads all the theme files in the default theme folder.")
{
    String_Const_u8 fcoder_extension = SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1));
    save_all_dirty_buffers_with_postfix(app, fcoder_extension);

    Scratch_Block scratch(app);
    String8List list = {};
    def_search_normal_load_list(scratch, &list);

    for (String8Node *node = list.first;
         node != 0;
         node = node->next){
        String8 folder_path = node->string;
        String8 themes_path = push_u8_stringf(scratch, "%.*sthemes", (i32)(folder_path).size, (char*)(folder_path).str);
        load_folder_of_themes_into_live_set(app, themes_path);
    }
}

CUSTOM_COMMAND(load_themes_hot_directory, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 554, Normal)
CUSTOM_DOC("Loads all the theme files in the current hot directory.")
{
    String_Const_u8 fcoder_extension = SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1));
    save_all_dirty_buffers_with_postfix(app, fcoder_extension);

    Scratch_Block scratch(app);
    String_Const_u8 path = push_hot_directory(app, scratch);
    load_folder_of_themes_into_live_set(app, path);
}

CUSTOM_COMMAND(clear_all_themes, "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp", 565, Normal)
CUSTOM_DOC("Clear the theme list")
{
    if (global_theme_arena.base_allocator == 0){
        global_theme_arena = make_arena_system();
    }
    else{
        linalloc_clear(&global_theme_arena);
    }

    block_zero((&global_theme_list), sizeof(*(&global_theme_list)));
    set_default_color_scheme(app);
}



static void
setup_essential_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_id));
    map_set_binding_l(m, map, default_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, clipboard_record_clip, InputEventKind_Core, (CoreCode_NewClipboardContents), 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);

    map = mapping_get_or_make_map(m, (file_id));
    map_set_parent(m, map, (global_id));
    map_set_binding_text_input(map, write_text_input);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map = mapping_get_or_make_map(m, (code_id));
    map_set_parent(m, map, (file_id));
    map_set_binding_text_input(map, write_text_and_auto_indent);
}

static void
default_4coder_initialize(Application_Links *app, String_Const_u8_Array file_names, i32 override_font_size, b32 override_hinting){
# 620 "/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp"
    print_message(app, SCu8((u8*)("Welcome to " "beta " "4" "." "1" "." "8" "\n" "If you're new to 4coder there is a built in tutorial\n" "Use the key combination [ X Alt ] (on mac [ X Control ])\n" "Type in 'hms_demo_tutorial' and press enter\n" "\n" "Direct bug reports and feature requests to https://github.com/4coder-editor/4coder/issues\n" "\n" "Other questions and discussion can be directed to editor@4coder.net or 4coder.handmade.network\n" "\n" "The change log can be found in CHANGES.txt\n" "\n"), (u64)(sizeof("Welcome to " "beta " "4" "." "1" "." "8" "\n" "If you're new to 4coder there is a built in tutorial\n" "Use the key combination [ X Alt ] (on mac [ X Control ])\n" "Type in 'hms_demo_tutorial' and press enter\n" "\n" "Direct bug reports and feature requests to https://github.com/4coder-editor/4coder/issues\n" "\n" "Other questions and discussion can be directed to editor@4coder.net or 4coder.handmade.network\n" "\n" "The change log can be found in CHANGES.txt\n" "\n") - 1)));


    Scratch_Block scratch(app);

    load_config_and_apply(app, &global_config_arena, override_font_size, override_hinting);

    String_Const_u8 bindings_file_name = SCu8((u8*)("bindings.4coder"), (u64)(sizeof("bindings.4coder") - 1));
    String_Const_u8 mapping = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("mapping"), (u64)(sizeof("mapping") - 1))));

    if (string_match(mapping, SCu8((u8*)("mac-default"), (u64)(sizeof("mac-default") - 1)))){
        bindings_file_name = SCu8((u8*)("mac-bindings.4coder"), (u64)(sizeof("mac-bindings.4coder") - 1));
    }
    else if (0 && string_match(mapping, SCu8((u8*)("choose"), (u64)(sizeof("choose") - 1)))){
        bindings_file_name = SCu8((u8*)("mac-bindings.4coder"), (u64)(sizeof("mac-bindings.4coder") - 1));
    }


    String_ID global_map_id = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
    String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

    if (dynamic_binding_load_from_file(app, &framework_mapping, bindings_file_name)){
        setup_essential_mapping(&framework_mapping, global_map_id, file_map_id, code_map_id);
    }
    else{
        setup_built_in_mapping(app, mapping, &framework_mapping, global_map_id, file_map_id, code_map_id);
    }


    String_Const_u8 hot_directory = push_hot_directory(app, scratch);
    for (i32 i = 0; i < file_names.count; i += 1){
        Temp_Memory_Block temp(scratch);
        String_Const_u8 input_name = file_names.vals[i];
        String_Const_u8 full_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                    (i32)(hot_directory).size, (char*)(hot_directory).str,
                                                    (i32)(input_name).size, (char*)(input_name).str);
        Buffer_ID new_buffer = create_buffer(app, full_name, BufferCreate_NeverNew|BufferCreate_MustAttachToFile);
        if (new_buffer == 0){
            create_buffer(app, input_name, 0);
        }
    }
}

static void
default_4coder_initialize(Application_Links *app, i32 override_font_size, b32 override_hinting){
    String_Const_u8_Array file_names = {};
    default_4coder_initialize(app, file_names, override_font_size, override_hinting);
}

static void
default_4coder_initialize(Application_Links *app, String_Const_u8_Array file_names){
    Face_Description description = get_face_description(app, 0);
    default_4coder_initialize(app, file_names,
                              description.parameters.pt_size,
                              description.parameters.hinting);
}

static void
default_4coder_initialize(Application_Links *app){
    Face_Description command_line_description = get_face_description(app, 0);
    String_Const_u8_Array file_names = {};
    default_4coder_initialize(app, file_names, command_line_description.parameters.pt_size, command_line_description.parameters.hinting);
}

static void
default_4coder_side_by_side_panels(Application_Links *app,
                                   Buffer_Identifier left, Buffer_Identifier right){
    Buffer_ID left_id = buffer_identifier_to_id(app, left);
    Buffer_ID right_id = buffer_identifier_to_id(app, right);


    View_ID view = get_active_view(app, Access_Always);
    new_view_settings(app, view);
    view_set_buffer(app, view, left_id, 0);


    open_panel_vsplit(app);
    View_ID right_view = get_active_view(app, Access_Always);
    view_set_buffer(app, right_view, right_id, 0);


    view_set_active(app, view);
}

static void
default_4coder_side_by_side_panels(Application_Links *app,
                                   Buffer_Identifier left, Buffer_Identifier right,
                                   String_Const_u8_Array file_names){
    if (file_names.count > 0){
        left = buffer_identifier(file_names.vals[0]);
        if (file_names.count > 1){
            right = buffer_identifier(file_names.vals[1]);
        }
    }
    default_4coder_side_by_side_panels(app, left, right);
}

static void
default_4coder_side_by_side_panels(Application_Links *app, String_Const_u8_Array file_names){
    Buffer_Identifier left = buffer_identifier(SCu8((u8*)("*scratch*"), (u64)(sizeof("*scratch*") - 1)));
    Buffer_Identifier right = buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1)));
    default_4coder_side_by_side_panels(app, left, right, file_names);
}

static void
default_4coder_side_by_side_panels(Application_Links *app){
    String_Const_u8_Array file_names = {};
    default_4coder_side_by_side_panels(app, file_names);
}

static void
default_4coder_one_panel(Application_Links *app, Buffer_Identifier buffer){
    Buffer_ID id = buffer_identifier_to_id(app, buffer);
    View_ID view = get_active_view(app, Access_Always);
    new_view_settings(app, view);
    view_set_buffer(app, view, id, 0);
}

static void
default_4coder_one_panel(Application_Links *app, String_Const_u8_Array file_names){
    Buffer_Identifier buffer = buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1)));
    if (file_names.count > 0){
        buffer = buffer_identifier(file_names.vals[0]);
    }
    default_4coder_one_panel(app, buffer);
}

static void
default_4coder_one_panel(Application_Links *app){
    String_Const_u8_Array file_names = {};
    default_4coder_one_panel(app, file_names);
}



static void
buffer_modified_set_init(void){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    block_zero((set), sizeof(*(set)));
    Base_Allocator *allocator = get_base_allocator_system();
    set->arena = make_arena(allocator);
    set->id_to_node = make_table_u64_u64__inner((allocator),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "763" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "763" ":") - 1)));
}

static Buffer_Modified_Node*
buffer_modified_set__alloc_node(Buffer_Modified_Set *set){
    Buffer_Modified_Node *result = set->free;
    if (result == 0){
        result = ((Buffer_Modified_Node*)linalloc_wrap_unintialized(linalloc_push((&set->arena), sizeof(Buffer_Modified_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "770" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "770" ":") - 1)))));
    }
    else{
        ((set->free)=(set->free)=(set->free)->next);
    }
    return(result);
}

static void
buffer_mark_as_modified(Buffer_ID buffer){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    Table_Lookup lookup = table_lookup(&set->id_to_node, (u64)buffer);
    if (!lookup.found_match){
        Buffer_Modified_Node *node = buffer_modified_set__alloc_node(set);
        (((set->first)==0)?((node)->next=(node)->prev=0,(set->first)=(set->last)=(node)):((node)->prev=(set->last),(node)->next=0,(set->last)->next=(node),(set->last)=(node)));
        node->buffer = buffer;
        table_insert(&set->id_to_node, (u64)buffer, (u64)((u8*)(node) - (u8*)(0)));
    }
}

static void
buffer_unmark_as_modified(Buffer_ID buffer){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    Table_Lookup lookup = table_lookup(&set->id_to_node, (u64)buffer);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&set->id_to_node, (u64)buffer, &val);
        Buffer_Modified_Node *node = (Buffer_Modified_Node*)(void*)(((u8*)0) + val);
        (((set->last)==(node))?((((set->first)==(set->last))?((set->first)=(set->last)=0):((set->last)->prev->next=0,(set->last)=(set->last)->prev))) :((set->first)==(node))?((((set->last)==(set->first))?((set->last)=(set->first)=0):((set->first)->next->prev=0,(set->first)=(set->first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
        table_erase(&set->id_to_node, lookup);
        ((node)->next=(set->free),(set->free)=(node));
    }
}

static void
buffer_modified_set_clear(void){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    table_clear(&set->id_to_node);
    if (set->last != 0){
        set->last->next = set->free;
        set->free = set->first;
        set->first = 0;
        set->last = 0;
    }
}



static Fade_Range*
alloc_fade_range(void){
    Fade_Range *result = free_fade_ranges;
    if (result == 0){
        result = ((Fade_Range*)linalloc_wrap_unintialized(linalloc_push((&fade_range_arena), sizeof(Fade_Range)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "825" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "825" ":") - 1)))));
    }
    else{
        ((free_fade_ranges)=(free_fade_ranges)=(free_fade_ranges)->next);
    }
    block_zero((result), sizeof(*(result)));
    return(result);
}

static void
free_fade_range(Fade_Range *range){
    ((range)->next=(free_fade_ranges),(free_fade_ranges)=(range));
}

static Fade_Range*
buffer_post_fade(Application_Links *app, Buffer_ID buffer_id, f32 seconds, Range_i64 range, ARGB_Color color){
    Fade_Range *fade_range = alloc_fade_range();
    do{ if((fade_range)){if((buffer_fade_ranges.first)){(buffer_fade_ranges.last)->next=(fade_range);}else{(buffer_fade_ranges.first)=(fade_range);}(buffer_fade_ranges.last)=(fade_range);(buffer_fade_ranges.last)->next=0;} }while(0);
    buffer_fade_ranges.count += 1;
    fade_range->buffer_id = buffer_id;
    fade_range->t = seconds;
    fade_range->full_t = seconds;
    fade_range->range = range;
    fade_range->color = color;
    return(fade_range);
}

static void
buffer_shift_fade_ranges(Buffer_ID buffer_id, i64 shift_after_p, i64 shift_amount){
    for (Fade_Range *node = buffer_fade_ranges.first;
         node != 0;
         node = node->next){
        if (node->buffer_id == buffer_id){
            if (node->range.min >= shift_after_p){
                node->range.min += shift_amount;
                node->range.max += shift_amount;
            }
            else if (node->range.max >= shift_after_p){
                node->range.max += shift_amount;
            }
        }
    }
}

static b32
tick_all_fade_ranges(Application_Links *app, f32 t){
    Fade_Range **prev_next = &buffer_fade_ranges.first;
    for (Fade_Range *node = buffer_fade_ranges.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        node->t -= t;
        if (node->t <= 0.f){
            if (node->finish_call != 0){
                node->finish_call(app, node);
            }
            *prev_next = next;
            free_fade_range(node);
            buffer_fade_ranges.count -= 1;
        }
        else{
            prev_next = &node->next;
            buffer_fade_ranges.last = node;
        }
    }
    return(buffer_fade_ranges.count > 0);
}

static void
paint_fade_ranges(Application_Links *app, Text_Layout_ID layout, Buffer_ID buffer){
    for (Fade_Range *node = buffer_fade_ranges.first;
         node != 0;
         node = node->next){
        if (node->buffer_id == buffer){
            f32 blend = node->t/node->full_t;
            if (node->negate_fade_direction){
                blend = 1.f - blend;
            }
            paint_text_color_blend(app, layout, node->range, node->color, blend);
        }
    }
}



static void
clipboard_init_empty(Clipboard *clipboard, u32 history_depth){
    history_depth = (((1)>(history_depth))?(1):(history_depth));
    heap_init(&clipboard->heap, &clipboard->arena);
    clipboard->clip_index = 0;
    clipboard->clip_capacity = history_depth;
    clipboard->clips = ((String_Const_u8*)linalloc_wrap_zero(linalloc_push((&clipboard->arena), sizeof(String_Const_u8)*(history_depth), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "916" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_framework.cpp" ":" "916" ":") - 1)))));
}

static void
clipboard_init(Base_Allocator *allocator, u32 history_depth, Clipboard *clipboard_out){
    u64 memsize = sizeof(String_Const_u8)*history_depth;
    memsize = round_up_u64(memsize, ((4) << 10));
    clipboard_out->arena = make_arena(allocator, memsize, 8);
    clipboard_init_empty(clipboard_out, history_depth);
}

static void
clipboard_clear(Clipboard *clipboard){
    linalloc_clear(&clipboard->arena);
    clipboard_init_empty(clipboard, clipboard->clip_capacity);
}

static String_Const_u8
clipboard_post_internal_only(Clipboard *clipboard, String_Const_u8 string){
    u32 rolled_index = clipboard->clip_index%clipboard->clip_capacity;
    clipboard->clip_index += 1;
    String_Const_u8 *slot = &clipboard->clips[rolled_index];
    if (slot->str != 0){
        if (slot->size < string.size ||
            (slot->size - string.size) > ((1) << 10)){
            heap_free(&clipboard->heap, slot->str);
            goto alloc_new;
        }
    }
    else{
        alloc_new:;
        u8 *new_buf = (u8*)heap_allocate(&clipboard->heap, string.size);
        slot->str = new_buf;
    }
    block_copy(slot->str, string.str, string.size);
    slot->size = string.size;
    return(*slot);
}

static u32
clipboard_count(Clipboard *clipboard){
    u32 result = clipboard->clip_index;
    result = (((result)<(clipboard->clip_capacity))?(result):(clipboard->clip_capacity));
    return(result);
}

static String_Const_u8
get_clipboard_index(Clipboard *clipboard, u32 item_index){
    String_Const_u8 result = {};
    u32 top = (((clipboard->clip_index)<(clipboard->clip_capacity))?(clipboard->clip_index):(clipboard->clip_capacity));
    if (top > 0){
        item_index = item_index%top;
        i32 array_index = ((clipboard->clip_index - 1) - item_index)%top;
        result = clipboard->clips[array_index];
    }
    return(result);
}

static String_Const_u8
push_clipboard_index(Arena *arena, Clipboard *clipboard, i32 item_index){
    String_Const_u8 result = get_clipboard_index(clipboard, item_index);
    result = push_string_copy(arena, result);
    return(result);
}



static void
clipboard_clear(i32 clipboard_id){
    clipboard_clear(&clipboard0);
}

static String_Const_u8
clipboard_post_internal_only(i32 clipboard_id, String_Const_u8 string){
    return(clipboard_post_internal_only(&clipboard0, string));
}

static b32
clipboard_post(i32 clipboard_id, String_Const_u8 string){
    clipboard_post_internal_only(clipboard_id, string);
    system_post_clipboard(string, clipboard_id);
    return(true);
}

static i32
clipboard_count(i32 clipboard_id){
    return(clipboard_count(&clipboard0));
}

static String_Const_u8
push_clipboard_index(Arena *arena, i32 clipboard_id, i32 item_index){
    return(push_clipboard_index(arena, &clipboard0, item_index));
}



static void
initialize_managed_id_metadata(Application_Links *app);

static void
default_framework_init(Application_Links *app){
    Thread_Context *tctx = get_thread_context(app);
    async_task_handler_init(app, &global_async_system);
    clipboard_init(get_base_allocator_system(), 64, &clipboard0);
    code_index_init();
    buffer_modified_set_init();
    Profile_Global_List *list = get_core_profile_list(app);
    profile_thread_set_name((tctx), (list), (SCu8((u8*)("main"), (u64)(sizeof("main") - 1))));
    initialize_managed_id_metadata(app);
    set_default_color_scheme(app);
    heap_init(&global_heap, tctx->allocator);
 global_permanent_arena = make_arena_system();
    global_config_arena = make_arena_system();
    fade_range_arena = make_arena_system(((8) << 10));
}



static void
default_input_handler_init(Application_Links *app, Arena *arena){
    Thread_Context *tctx = get_thread_context(app);

    View_ID view = get_this_ctx_view(app, Access_Always);
    String_Const_u8 name = push_u8_stringf(arena, "view %d", view);

    Profile_Global_List *list = get_core_profile_list(app);
    profile_thread_set_name((tctx), (list), (name));

    View_Context ctx = view_current_context(app, view);
    ctx.mapping = &framework_mapping;
    ctx.map_id = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    view_alter_context(app, view, &ctx);
}

static Command_Map_ID
default_get_map_id(Application_Links *app, View_ID view){
    Command_Map_ID result = 0;
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
    Command_Map_ID *result_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
    if (result_ptr != 0){
        if (*result_ptr == 0){
            *result_ptr = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
        }
        result = *result_ptr;
    }
    else{
        result = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    }
    return(result);
}

static void
set_next_rewrite(Application_Links *app, View_ID view, Rewrite_Type rewrite){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    if (next_rewrite != 0){
        *next_rewrite = rewrite;
    }
}

static void
default_pre_command(Application_Links *app, Managed_Scope scope){
    Rewrite_Type *next_rewrite =
        ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    *next_rewrite = Rewrite_None;
    if (fcoder_mode == FCoderMode_NotepadLike){
        for (View_ID view_it = get_view_next(app, 0, Access_Always);
             view_it != 0;
             view_it = get_view_next(app, view_it, Access_Always)){
            Managed_Scope scope_it = view_get_managed_scope(app, view_it);
            b32 *snap_mark_to_cursor =
                ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)))
                                     ;
            *snap_mark_to_cursor = true;
        }
    }
}

static void
default_post_command(Application_Links *app, Managed_Scope scope){
    Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    if (next_rewrite != 0){
        if (*next_rewrite != Rewrite_NoChange){
            Rewrite_Type *rewrite =
                ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
            *rewrite = *next_rewrite;
        }
    }
    if (fcoder_mode == FCoderMode_NotepadLike){
        for (View_ID view_it = get_view_next(app, 0, Access_Always);
             view_it != 0;
             view_it = get_view_next(app, view_it, Access_Always)){
            Managed_Scope scope_it = view_get_managed_scope(app, view_it);
            b32 *snap_mark_to_cursor =
                ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)));
            if (*snap_mark_to_cursor){
                i64 pos = view_get_cursor_pos(app, view_it);
                view_set_mark(app, view_it, seek_pos(pos));
            }
        }
    }
}
# 114 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp" 1






CUSTOM_COMMAND(clipboard_record_clip, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 7, Normal)
CUSTOM_DOC("In response to a new clipboard contents events, saves the new clip onto the clipboard history")
{
    User_Input in = get_current_input(app);
    if (in.event.kind == InputEventKind_Core &&
        in.event.core.code == CoreCode_NewClipboardContents){
        clipboard_post_internal_only(0, in.event.core.string);
    }
}



static b32
clipboard_post_buffer_range(Application_Links *app, i32 clipboard_index, Buffer_ID buffer, Range_i64 range){
    b32 success = false;
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    if (string.size > 0){
        clipboard_post(clipboard_index, string);
        success = true;
    }
    return(success);
}

static b32
clipboard_update_history_from_system(Application_Links *app, i32 clipboard_id){
    Scratch_Block scratch(app);
    b32 result = false;
    String_Const_u8 string = system_get_clipboard(scratch, clipboard_id);
    if (string.str != 0){
        clipboard_post_internal_only(clipboard_id, string);
        result = true;
    }
    return(result);
}

static List_String_Const_u8 clipboard_collection_list = {};

static void
clipboard_collection_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);
    Rect_f32 region = draw_background_and_margin(app, view);
    Vec2_f32 mid_p = (region.p1 + region.p0)*0.5f;

    Fancy_Block message = {};
    Fancy_Line *line = push_fancy_line(scratch, &message);
    push_fancy_string(scratch, line, fcolor_id(defcolor_pop2),
                      SCu8((u8*)("Collecting all clipboard events "), (u64)(sizeof("Collecting all clipboard events ") - 1)));
    push_fancy_string(scratch, line, fcolor_id(defcolor_pop1),
                      SCu8((u8*)("press [escape] to stop"), (u64)(sizeof("press [escape] to stop") - 1)));

    for (Node_String_Const_u8 *node = clipboard_collection_list.first;
         node != 0;
         node = node->next){
        line = push_fancy_line(scratch, &message);
        push_fancy_string(scratch, line, fcolor_id(defcolor_text_default), node->string);
    }

    Face_ID face_id = get_face_id(app, 0);
    Vec2_f32 dim = get_fancy_block_dim(app, face_id, &message);
    Vec2_f32 half_dim = dim*0.5f;
    draw_fancy_block(app, face_id, fcolor_zero(), &message, mid_p - half_dim);
}

CUSTOM_COMMAND(begin_clipboard_collection_mode, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 71, UI)
CUSTOM_DOC("Allows the user to copy multiple strings from other applications before switching to 4coder and pasting them all.")
{
    static b32 in_clipboard_collection_mode = false;
    if (!in_clipboard_collection_mode){
        in_clipboard_collection_mode = true;
        system_set_clipboard_catch_all(true);

        Scratch_Block scratch(app);
        block_zero((&clipboard_collection_list), sizeof(*(&clipboard_collection_list)));

        View_ID view = get_this_ctx_view(app, Access_Always);
        View_Context ctx = view_current_context(app, view);
        ctx.render_caller = clipboard_collection_render;
        ctx.hides_buffer = true;
        View_Context_Block ctx_block(app, view, &ctx);

        for (;;){
            User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
            if (in.abort){
                break;
            }
            if (in.event.kind == InputEventKind_KeyStroke && in.event.key.code == KeyCode_Escape){
                break;
            }
            if (in.event.kind == InputEventKind_Core &&
                in.event.core.code == CoreCode_NewClipboardContents){
                String_Const_u8 stable_clip = clipboard_post_internal_only(0, in.event.core.string);
                string_list_push(scratch, &clipboard_collection_list, stable_clip);
            }
        }

        block_zero((&clipboard_collection_list), sizeof(*(&clipboard_collection_list)));

        system_set_clipboard_catch_all(false);
        in_clipboard_collection_mode = false;
    }
}

CUSTOM_COMMAND(copy, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 110, Normal)
CUSTOM_DOC("Copy the text in the range from the cursor to the mark onto the clipboard.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Range_i64 range = get_view_range(app, view);
    clipboard_post_buffer_range(app, 0, buffer, range);
}

CUSTOM_COMMAND(cut, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 119, Normal)
CUSTOM_DOC("Cut the text in the range from the cursor to the mark onto the clipboard.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    if (clipboard_post_buffer_range(app, 0, buffer, range)){
        buffer_replace_range(app, buffer, range, string_u8_empty);
    }
}

CUSTOM_COMMAND(paste, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 130, Normal)
CUSTOM_DOC("At the cursor, insert the text at the top of the clipboard.")
{
    clipboard_update_history_from_system(app, 0);
    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        if_view_has_highlighted_range_delete_range(app, view);

        set_next_rewrite(app, view, Rewrite_Paste);

        Managed_Scope scope = view_get_managed_scope(app, view);
        i32 *paste_index = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
        if (paste_index != 0){
            *paste_index = 0;

            Scratch_Block scratch(app);

            String_Const_u8 string = push_clipboard_index(scratch, 0, *paste_index);
            if (string.size > 0){
                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

                i64 pos = view_get_cursor_pos(app, view);
                buffer_replace_range(app, buffer, Ii64(pos), string);
                view_set_mark(app, view, seek_pos(pos));
                view_set_cursor_and_preferred_x(app, view, seek_pos(pos + (i32)string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, string.size), argb);
            }
        }
    }
}

CUSTOM_COMMAND(paste_next, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 164, Normal)
CUSTOM_DOC("If the previous command was paste or paste_next, replaces the paste range with the next text down on the clipboard, otherwise operates as the paste command.")
{
    Scratch_Block scratch(app);

    b32 new_clip = clipboard_update_history_from_system(app, 0);

    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        Managed_Scope scope = view_get_managed_scope(app, view);

        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (rewrite != 0){
            if (*rewrite == Rewrite_Paste && !new_clip){
                no_mark_snap_to_cursor(app, scope);

                set_next_rewrite(app, view, Rewrite_Paste);

                i32 *paste_index_ptr = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
                i32 paste_index = (*paste_index_ptr) + 1;
                *paste_index_ptr = paste_index;

                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);

                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

                Range_i64 range = get_view_range(app, view);
                i64 pos = range.min;

                buffer_replace_range(app, buffer, range, string);
                view_set_cursor_and_preferred_x(app, view, seek_pos(pos + string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, string.size), argb);
            }
            else{
                paste(app);
            }
        }
    }
}

CUSTOM_COMMAND(paste_and_indent, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 207, Normal)
CUSTOM_DOC("Paste from the top of clipboard and run auto-indent on the newly pasted text.")
{
    paste(app);
    auto_indent_range(app);
}

CUSTOM_COMMAND(paste_next_and_indent, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 214, Normal)
CUSTOM_DOC("Paste the next item on the clipboard and run auto-indent on the newly pasted text.")
{
    paste_next(app);
    auto_indent_range(app);
}

CUSTOM_COMMAND(clear_clipboard, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 221, Normal)
CUSTOM_DOC("Clears the history of the clipboard")
{
    clipboard_clear(0);
}



CUSTOM_COMMAND(multi_paste, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 229, Normal)
CUSTOM_DOC("Paste multiple entries from the clipboard at once")
{
    Scratch_Block scratch(app);

    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        Managed_Scope scope = view_get_managed_scope(app, view);

        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (rewrite != 0){
            if (*rewrite == Rewrite_Paste){
                Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
                *next_rewrite = Rewrite_Paste;
                i32 *paste_index_ptr = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
                i32 paste_index = (*paste_index_ptr) + 1;
                *paste_index_ptr = paste_index;

                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);

                String_Const_u8 insert_string = push_u8_stringf(scratch, "\n%.*s", (i32)(string).size, (char*)(string).str);

                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
                Range_i64 range = get_view_range(app, view);
                buffer_replace_range(app, buffer, Ii64(range.max), insert_string);
                view_set_mark(app, view, seek_pos(range.max + 1));
                view_set_cursor_and_preferred_x(app, view, seek_pos(range.max + insert_string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64(range.max + 1, range.max + insert_string.size), argb);
            }
            else{
                paste(app);
            }
        }
    }
}

static Range_i64
multi_paste_range(Application_Links *app, View_ID view, Range_i64 range, i32 paste_count, b32 old_to_new){
    Scratch_Block scratch(app);

    Range_i64 finish_range = range;
    if (paste_count >= 1){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        if (buffer != 0){
            i64 total_size = 0;
            for (i32 paste_index = 0; paste_index < paste_count; ++paste_index){
                Temp_Memory temp = begin_temp(scratch);
                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);
                total_size += string.size + 1;
                end_temp(temp);
            }
            total_size -= 1;

            i32 first = paste_count - 1;
            i32 one_past_last = -1;
            i32 step = -1;
            if (!old_to_new){
                first = 0;
                one_past_last = paste_count;
                step = 1;
            }

            List_String_Const_u8 list = {};

            for (i32 paste_index = first; paste_index != one_past_last; paste_index += step){
                if (paste_index != first){
                    string_list_push(scratch, &list, SCu8("\n", 1));
                }
                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);
                if (string.size > 0){
                    string_list_push(scratch, &list, string);
                }
            }

            String_Const_u8 flattened = string_list_flatten(scratch, list);

            buffer_replace_range(app, buffer, range, flattened);
            i64 pos = range.min;
            finish_range.min = pos;
            finish_range.max = pos + total_size;
            view_set_mark(app, view, seek_pos(finish_range.min));
            view_set_cursor_and_preferred_x(app, view, seek_pos(finish_range.max));

            ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
            buffer_post_fade(app, buffer, 0.667f, finish_range, argb);
        }
    }
    return(finish_range);
}

static void
multi_paste_interactive_up_down(Application_Links *app, i32 paste_count, i32 clip_count){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    b32 old_to_new = true;
    Range_i64 range = multi_paste_range(app, view, Ii64(pos), paste_count, old_to_new);

    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Up and Down to condense and expand paste stages; R to reverse order; Return to finish; Escape to abort."), (u64)(sizeof("Up and Down to condense and expand paste stages; R to reverse order; Return to finish; Escape to abort.") - 1));
    if (start_query_bar(app, &bar, 0) == 0) return;

    User_Input in = {};
    for (;;){
        in = get_next_input(app, EventProperty_AnyKey, EventProperty_Escape);
        if (in.abort) break;

        b32 did_modify = false;
        if (match_key_code(&in, KeyCode_Up)){
            if (paste_count > 1){
                --paste_count;
                did_modify = true;
            }
        }
        else if (match_key_code(&in, KeyCode_Down)){
            if (paste_count < clip_count){
                ++paste_count;
                did_modify = true;
            }
        }
        else if (match_key_code(&in, KeyCode_R)){
            old_to_new = !old_to_new;
            did_modify = true;
        }
        else if (match_key_code(&in, KeyCode_Return)){
            break;
        }

        if (did_modify){
            range = multi_paste_range(app, view, range, paste_count, old_to_new);
        }
    }

    if (in.abort){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        buffer_replace_range(app, buffer, range, SCu8(""));
    }
}

CUSTOM_COMMAND(multi_paste_interactive, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 371, Normal)
CUSTOM_DOC("Paste multiple lines from the clipboard history, controlled with arrow keys")
{
    i32 clip_count = clipboard_count(0);
    if (clip_count > 0){
        multi_paste_interactive_up_down(app, 1, clip_count);
    }
}

CUSTOM_COMMAND(multi_paste_interactive_quick, "/home/tabletel/dev/4cc/code/custom/4coder_clipboard.cpp", 380, Normal)
CUSTOM_DOC("Paste multiple lines from the clipboard history, controlled by inputing the number of lines to paste")
{
    i32 clip_count = clipboard_count(0);
    if (clip_count > 0){
        u8 string_space[256];
        Query_Bar_Group group(app);
        Query_Bar bar = {};
        bar.prompt = SCu8((u8*)("How Many Slots To Paste: "), (u64)(sizeof("How Many Slots To Paste: ") - 1));
        bar.string = SCu8(string_space, (u64)0);
        bar.string_capacity = sizeof(string_space);
        query_user_number(app, &bar);

        i32 initial_paste_count = (i32)string_to_integer(bar.string, 10);
        initial_paste_count = (((1)>(initial_paste_count))?(1):(((clip_count)<(initial_paste_count))?(clip_count):(initial_paste_count)));
        end_query_bar(app, &bar, 0);

        multi_paste_interactive_up_down(app, initial_paste_count, clip_count);
    }
}




static void
clipboard_clear(Application_Links *app, i32 clipboard_id){
    clipboard_clear(clipboard_id);
}
static b32
clipboard_post(Application_Links *app, i32 clipboard_id, String_Const_u8 string){
    return(clipboard_post(clipboard_id, string));
}
static i32
clipboard_count(Application_Links *app, i32 clipboard_id){
    return(clipboard_count(clipboard_id));
}
static String_Const_u8
push_clipboard_index(Application_Links *app, Arena *arena, i32 clipboard_id, i32 item_index){
    return(push_clipboard_index(arena, clipboard_id, item_index));
}
# 115 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" 1






static Vec2_f32
panel_space_from_screen_space(Vec2_f32 p, Vec2_f32 file_region_p0){
    return(p - file_region_p0);
}

static Vec2_f32
get_mouse_position_in_panel_space(Mouse_State mouse, Vec2_f32 file_region_p0){
    return(panel_space_from_screen_space(V2f32(mouse.p), file_region_p0));
}

static Vec2_f32
get_mouse_position_in_panel_space(Application_Links *app, Vec2_f32 file_region_p0){
    return(get_mouse_position_in_panel_space(get_mouse_state(app), file_region_p0));
}



static f32
lister_get_text_field_height(f32 line_height){
    return(line_height);
}

static f32
lister_get_block_height(f32 line_height){
    return(line_height*2);
}

static Rect_f32_Pair
lister_get_top_level_layout(Rect_f32 rect, f32 text_field_height){
    return(rect_split_top_bottom(rect, text_field_height));
}



static Lister*
view_get_lister(Application_Links *app, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Lister **ptr = ((Lister**)managed_scope_get_attachment((app), (scope), (view_lister_loc), sizeof(Lister*)));
    Lister *result = 0;
    if (ptr != 0){
        result = *ptr;
    }
    return(result);
}

static Lister*
view_set_lister(Application_Links *app, View_ID view, Lister *lister){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Lister **ptr = ((Lister**)managed_scope_get_attachment((app), (scope), (view_lister_loc), sizeof(Lister*)));
    Lister *result = 0;
    if (ptr != 0){
        result = *ptr;
        *ptr = lister;
    }
    return(result);
}

static void
lister_set_map(Lister *lister, Mapping *mapping, Command_Map *map){
    lister->mapping = mapping;
    lister->map = map;
}

static void
lister_set_map(Lister *lister, Mapping *mapping, Command_Map_ID map){
    lister->mapping = mapping;
    lister->map = mapping_get_map(mapping, map);
}

static Lister_Prev_Current
begin_lister(Application_Links *app, Arena *arena){
    Lister_Prev_Current result = {};
    Lister *lister = ((Lister*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Lister)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "79" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "79" ":") - 1)))));
    lister->arena = arena;
    lister->query = Su8(lister->query_space, 0, sizeof(lister->query_space));
    lister->text_field = Su8(lister->text_field_space, 0, sizeof(lister->text_field_space));
    lister->key_string = Su8(lister->key_string_space, 0, sizeof(lister->key_string_space));
    View_ID view = get_this_ctx_view(app, Access_Always);
    result.prev = view_set_lister(app, view, lister);
    result.current = lister;
    lister->restore_all_point = begin_temp(lister->arena);
    View_Context ctx = view_current_context(app, view);
    lister_set_map(lister, ctx.mapping, ctx.map_id);
    return(result);
}

Lister_Block::Lister_Block(Application_Links *a, Arena *arena){
    Lister_Prev_Current new_lister = begin_lister(a, arena);
    this->app = a;
    this->lister = new_lister;
}

Lister_Block::~Lister_Block(){
    View_ID view = get_this_ctx_view(app, Access_Always);
    view_set_lister(this->app, view, this->lister.prev);
}

Lister_Block::operator Lister *(){
    return(this->lister.current);
}

static void
lister_set_string(String_Const_u8 string, String_u8 *target){
    target->size = 0;
    string_append(target, string);
}
static void
lister_append_string(String_Const_u8 string, String_u8 *target){
    string_append(target, string);
}

static void
lister_set_query(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->query);
}
static void
lister_set_query(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->query);
}
static void
lister_set_text_field(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->text_field);
}
static void
lister_set_text_field(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->text_field);
}
static void
lister_set_key(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->key_string);
}
static void
lister_set_key(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->key_string);
}

static void
lister_append_query(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->query);
}
static void
lister_append_query(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->query);
}
static void
lister_append_text_field(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->text_field);
}
static void
lister_append_text_field(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->text_field);
}
static void
lister_append_key(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->key_string);
}
static void
lister_append_key(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->key_string);
}

static void
lister_set_handlers(Lister *lister, Lister_Handlers *handlers){
    block_copy((&lister->handlers), (handlers), sizeof(*(&lister->handlers)));
}

static void
lister_zero_scroll(Lister *lister){
    block_zero((&lister->scroll), sizeof(*(&lister->scroll)));
}

static void
lister_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);

    Lister *lister = view_get_lister(app, view);
    if (lister == 0){
        return;
    }

    Rect_f32 region = draw_background_and_margin(app, view);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    Face_ID face_id = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 block_height = lister_get_block_height(line_height);
    f32 text_field_height = lister_get_text_field_height(line_height);



    b64 showing_file_bar = false;
    b32 hide_file_bar_in_ui = def_get_config_b32(vars_save_string(SCu8((u8*)("hide_file_bar_in_ui"), (u64)(sizeof("hide_file_bar_in_ui") - 1))));
    if (view_get_setting(app, view, ViewSetting_ShowFileBar, &showing_file_bar) &&
        showing_file_bar && !hide_file_bar_in_ui){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        draw_file_bar(app, view, buffer, face_id, pair.min);
        region = pair.max;
    }

    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p);

    lister->visible_count = (i32)((rect_height(region)/block_height)) - 3;
    lister->visible_count = (((1)>(lister->visible_count))?(1):(lister->visible_count));

    Rect_f32 text_field_rect = {};
    Rect_f32 list_rect = {};
    {
        Rect_f32_Pair pair = lister_get_top_level_layout(region, text_field_height);
        text_field_rect = pair.min;
        list_rect = pair.max;
    }

    {
        Vec2_f32 p = V2f32(text_field_rect.x0 + 3.f, text_field_rect.y0);
        Fancy_Line text_field = {};
        push_fancy_string(scratch, &text_field, fcolor_id(defcolor_pop1),
                          lister->query.string);
        push_fancy_stringf(scratch, &text_field, " ");
        p = draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);




        block_zero((&text_field), sizeof(*(&text_field)));
        push_fancy_string(scratch, &text_field, fcolor_id(defcolor_text_default),
                          lister->text_field.string);
        f32 width = get_fancy_line_width(app, face_id, &text_field);
        f32 cap_width = text_field_rect.x1 - p.x - 6.f;
        if (cap_width < width){
            Rect_f32 prect = draw_set_clip(app, Rf32(p.x, text_field_rect.y0, p.x + cap_width, text_field_rect.y1));
            p.x += cap_width - width;
            draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);
            draw_set_clip(app, prect);
        }
        else{
            draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);
        }
    }


    Range_f32 x = rect_range_x(list_rect);
    draw_set_clip(app, list_rect);


    f32 scroll_y = lister->scroll.position.y;

    if (lister->set_vertical_focus_to_item){
        lister->set_vertical_focus_to_item = false;
        Range_f32 item_y = If32_size(lister->item_index*block_height, block_height);
        f32 view_h = rect_height(list_rect);
        Range_f32 view_y = If32_size(scroll_y, view_h);
        if (view_y.min > item_y.min || item_y.max > view_y.max){
            f32 item_center = (item_y.min + item_y.max)*0.5f;
            f32 view_center = (view_y.min + view_y.max)*0.5f;
            f32 margin = view_h*.3f;
            margin = (((margin)<(block_height*3.f))?(margin):(block_height*3.f));
            if (item_center < view_center){
                lister->scroll.target.y = item_y.min - margin;
            }
            else{
                f32 target_bot = item_y.max + margin;
                lister->scroll.target.y = target_bot - view_h;
            }
        }
    }


    i32 count = lister->filtered.count;
    Range_f32 scroll_range = If32(0.f, (((0.f)>(count*block_height - block_height))?(0.f):(count*block_height - block_height)));
    lister->scroll.target.y = clamp_range(scroll_range, lister->scroll.target.y);
    lister->scroll.target.x = 0.f;

    Vec2_f32_Delta_Result delta = delta_apply(app, view,
                                              frame_info.animation_dt, lister->scroll);
    lister->scroll.position = delta.p;
    if (delta.still_animating){
        animate_in_n_milliseconds(app, 0);
    }

    lister->scroll.position.y = clamp_range(scroll_range, lister->scroll.position.y);
    lister->scroll.position.x = 0.f;

    scroll_y = lister->scroll.position.y;
    f32 y_pos = list_rect.y0 - scroll_y;

    i32 first_index = (i32)(scroll_y/block_height);
    y_pos += first_index*block_height;

    for (i32 i = first_index; i < count; i += 1){
        Lister_Node *node = lister->filtered.node_ptrs[i];

        Range_f32 y = If32(y_pos, y_pos + block_height);
        y_pos = y.max;

        Rect_f32 item_rect = Rf32(x, y);
        if (item_rect.y0 > region.y1) { break; }
        Rect_f32 item_inner = rect_inner(item_rect, 3.f);

        b32 hovered = rect_contains_point(item_rect, m_p);
        UI_Highlight_Level highlight = UIHighlight_None;
        if (node == lister->highlighted_node){
            highlight = UIHighlight_Active;
        }
        else if (node->user_data == lister->hot_user_data){
            if (hovered){
                highlight = UIHighlight_Active;
            }
            else{
                highlight = UIHighlight_Hover;
            }
        }
        else if (hovered){
            highlight = UIHighlight_Hover;
        }

        u64 lister_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("lister_roundness"), (u64)(sizeof("lister_roundness") - 1))));
        f32 roundness = block_height*lister_roundness_100*0.01f;
        draw_rectangle_fcolor(app, item_rect, roundness, get_item_margin_color(highlight));
        draw_rectangle_fcolor(app, item_inner, roundness, get_item_margin_color(highlight, 1));

        Fancy_Line line = {};
        push_fancy_string(scratch, &line, fcolor_id(defcolor_text_default), node->string);
        push_fancy_stringf(scratch, &line, " ");
        push_fancy_string(scratch, &line, fcolor_id(defcolor_pop2), node->status);

        Vec2_f32 p = item_inner.p0 + V2f32(3.f, (block_height - line_height)*0.5f);
        draw_fancy_line(app, face_id, fcolor_zero(), &line, p);
    }

    draw_set_clip(app, prev_clip);
}

static void*
lister_get_user_data(Lister *lister, i32 index){
    void *result = 0;
    if (0 <= index && index < lister->options.count){
        i32 counter = 0;
        for (Lister_Node *node = lister->options.first;
             node != 0;
             node = node->next, counter += 1){
            if (counter == index){
                result = node->user_data;
                break;
            }
        }
    }
    return(result);
}

static Lister_Filtered
lister_get_filtered(Arena *arena, Lister *lister){
    i32 node_count = lister->options.count;

    Lister_Filtered filtered = {};
    filtered.exact_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "364" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "364" ":") - 1)))));
    filtered.before_extension_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(node_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "365" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "365" ":") - 1)))));
    filtered.substring_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(node_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "366" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "366" ":") - 1)))));

    Temp_Memory_Block temp(arena);

    String_Const_u8 key = lister->key_string.string;
    key = push_string_copy(arena, key);
    string_mod_replace_character(key, '_', '*');
    string_mod_replace_character(key, ' ', '*');

    List_String_Const_u8 absolutes = {};
    string_list_push(arena, &absolutes, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
    List_String_Const_u8 splits = string_split(arena, key, (u8*)"*", 1);
    b32 has_wildcard = (splits.node_count > 1);
    string_list_push(&absolutes, &splits);
    string_list_push(arena, &absolutes, SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    for (Lister_Node *node = lister->options.first;
         node != 0;
         node = node->next){
        String_Const_u8 node_string = node->string;
        if (key.size == 0 || string_wildcard_match_insensitive(absolutes, node_string)){
            if (string_match_insensitive(node_string, key) && filtered.exact_matches.count == 0){
                filtered.exact_matches.node_ptrs[filtered.exact_matches.count++] = node;
            }
            else if (key.size > 0 &&
                     !has_wildcard &&
                     string_match_insensitive(string_prefix(node_string, key.size), key) &&
                     node->string.size > key.size &&
                     node->string.str[key.size] == '.'){
                filtered.before_extension_matches.node_ptrs[filtered.before_extension_matches.count++] = node;
            }
            else{
                filtered.substring_matches.node_ptrs[filtered.substring_matches.count++] = node;
            }
        }
    }

    return(filtered);
}

static void
lister_update_selection_values(Lister *lister){
    lister->raw_item_index = -1;
    lister->highlighted_node = 0;
    i32 count = lister->filtered.count;
    for (i32 i = 0; i < count; i += 1){
        Lister_Node *node = lister->filtered.node_ptrs[i];
        if (lister->item_index == i){
            lister->highlighted_node = node;
            lister->raw_item_index = node->raw_index;
        }
    }
}

static void
lister_update_filtered_list(Application_Links *app, Lister *lister){
    Arena *arena = lister->arena;
    Scratch_Block scratch(app, arena);

    Lister_Filtered filtered = lister_get_filtered(scratch, lister);

    Lister_Node_Ptr_Array node_ptr_arrays[] = {
        filtered.exact_matches,
        filtered.before_extension_matches,
        filtered.substring_matches,
    };

    end_temp(lister->filter_restore_point);

    i32 total_count = 0;
    for (i32 array_index = 0; array_index < ((sizeof(node_ptr_arrays))/(sizeof(*node_ptr_arrays))); array_index += 1){
        Lister_Node_Ptr_Array node_ptr_array = node_ptr_arrays[array_index];
        total_count += node_ptr_array.count;
    }

    Lister_Node **node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(total_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "441" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "441" ":") - 1)))));
    lister->filtered.node_ptrs = node_ptrs;
    lister->filtered.count = total_count;
    i32 counter = 0;
    for (i32 array_index = 0; array_index < ((sizeof(node_ptr_arrays))/(sizeof(*node_ptr_arrays))); array_index += 1){
        Lister_Node_Ptr_Array node_ptr_array = node_ptr_arrays[array_index];
        for (i32 node_index = 0; node_index < node_ptr_array.count; node_index += 1){
            Lister_Node *node = node_ptr_array.node_ptrs[node_index];
            node_ptrs[counter] = node;
            counter += 1;
        }
    }

    lister_update_selection_values(lister);
}

static void
lister_call_refresh_handler(Application_Links *app, Lister *lister){
    if (lister->handlers.refresh != 0){
        lister->handlers.refresh(app, lister);
        lister->filter_restore_point = begin_temp(lister->arena);
        lister_update_filtered_list(app, lister);
    }
}

static void
lister_activate(Application_Links *app, Lister *lister, void *user_data, b32 mouse){
    lister->out.activated_by_click = mouse;
    lister->out.text_field = lister->text_field.string;
    lister->out.user_data = user_data;
}

static void*
lister_user_data_at_p(Application_Links *app, View_ID view, Lister *lister, Vec2_f32 m_p){
    Rect_f32 region = view_get_screen_rect(app, view);

    region = rect_inner(region, 3.f);

    Face_ID face_id = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 block_height = lister_get_block_height(line_height);
    f32 text_field_height = lister_get_text_field_height(line_height);

    b64 showing_file_bar = false;
    b32 hide_file_bar_in_ui = def_get_config_b32(vars_save_string(SCu8((u8*)("hide_file_bar_in_ui"), (u64)(sizeof("hide_file_bar_in_ui") - 1))));
    if (view_get_setting(app, view, ViewSetting_ShowFileBar, &showing_file_bar) &&
        showing_file_bar && hide_file_bar_in_ui){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        region = pair.max;
    }

    Rect_f32_Pair pair = lister_get_top_level_layout(region, text_field_height);
    Rect_f32 list_rect = pair.max;

    void *result = 0;
    if (rect_contains_point(list_rect, m_p)){
        f32 y = m_p.y - list_rect.y0 + lister->scroll.position.y;
        i32 index = (i32)(y/block_height);
        if (0 <= index && index < lister->filtered.count){
            Lister_Node *node = lister->filtered.node_ptrs[index];
            result = node->user_data;
        }
    }

    return(result);
}

static Lister_Result
run_lister(Application_Links *app, Lister *lister){
    lister->filter_restore_point = begin_temp(lister->arena);
    lister_update_filtered_list(app, lister);

    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = lister_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            block_zero((&lister->out), sizeof(*(&lister->out)));
            lister->out.canceled = true;
            break;
        }

        Lister_Activation_Code result = ListerActivation_Continue;
        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_TextInsert:
            {
                if (lister->handlers.write_character != 0){
                    result = lister->handlers.write_character(app);
                }
            }break;

            case InputEventKind_KeyStroke:
            {
                switch (in.event.key.code){
                    case KeyCode_Return:
                    case KeyCode_Tab:
                    {
                        void *user_data = 0;
                        if (0 <= lister->raw_item_index &&
                            lister->raw_item_index < lister->options.count){
                            user_data = lister_get_user_data(lister, lister->raw_item_index);
                        }
                        lister_activate(app, lister, user_data, false);
                        result = ListerActivation_Finished;
                    }break;

                    case KeyCode_Backspace:
                    {
                        if (lister->handlers.backspace != 0){
                            lister->handlers.backspace(app);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_Up:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister, -1);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_Down:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister, 1);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_PageUp:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister,
                                                      -lister->visible_count);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_PageDown:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister,
                                                      lister->visible_count);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    default:
                    {
                        if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;
                }
            }break;

            case InputEventKind_MouseButton:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        Vec2_f32 p = V2f32(in.event.mouse.p);
                        void *clicked = lister_user_data_at_p(app, view, lister, p);
                        lister->hot_user_data = clicked;
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseButtonRelease:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        if (lister->hot_user_data != 0){
                            Vec2_f32 p = V2f32(in.event.mouse.p);
                            void *clicked = lister_user_data_at_p(app, view, lister, p);
                            if (lister->hot_user_data == clicked){
                                lister_activate(app, lister, clicked, true);
                                result = ListerActivation_Finished;
                            }
                        }
                        lister->hot_user_data = 0;
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseWheel:
            {
                Mouse_State mouse = get_mouse_state(app);
                lister->scroll.target.y += mouse.wheel;
                lister_update_filtered_list(app, lister);
            }break;

            case InputEventKind_MouseMove:
            {
                lister_update_filtered_list(app, lister);
            }break;

            case InputEventKind_Core:
            {
                switch (in.event.core.code){
                    case CoreCode_Animate:
                    {
                        lister_update_filtered_list(app, lister);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (result == ListerActivation_Finished){
            break;
        }

        if (!handled){
            Mapping *mapping = lister->mapping;
            Command_Map *map = lister->map;

            Fallback_Dispatch_Result disp_result =
                fallback_command_dispatch(app, mapping, map, &in);
            if (disp_result.code == FallbackDispatch_DelayedUICall){
                call_after_ctx_shutdown(app, view, disp_result.func);
                break;
            }
            if (disp_result.code == FallbackDispatch_Unhandled){
                leave_current_input_unhandled(app);
            }
            else{
                lister_call_refresh_handler(app, lister);
            }
        }
    }

    return(lister->out);
}

static Lister_Prealloced_String
lister_prealloced(String_Const_u8 string){
    Lister_Prealloced_String result = {};
    result.string = string;
    return(result);
}

static void
lister_begin_new_item_set(Application_Links *app, Lister *lister){
    end_temp(lister->restore_all_point);
    block_zero((&lister->options), sizeof(*(&lister->options)));
    block_zero((&lister->filtered), sizeof(*(&lister->filtered)));
}

static void*
lister_add_item(Lister *lister, Lister_Prealloced_String string, Lister_Prealloced_String status, void *user_data, u64 extra_space){
    void *base_memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((lister->arena), sizeof(u8)*(sizeof(Lister_Node) + extra_space), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "747" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "747" ":") - 1)))));
    Lister_Node *node = (Lister_Node*)base_memory;
    node->string = string.string;
    node->status = status.string;
    node->user_data = user_data;
    node->raw_index = lister->options.count;
    (((lister->options.first)==0)?((node)->next=(node)->prev=0,(lister->options.first)=(lister->options.last)=(node)):((node)->prev=(lister->options.last),(node)->next=0,(lister->options.last)->next=(node),(lister->options.last)=(node)));
    lister->options.count += 1;
    void *result = (node + 1);
    return(result);
}

static void*
lister_add_item(Lister *lister, Lister_Prealloced_String string, String_Const_u8 status,
                void *user_data, u64 extra_space){
    return(lister_add_item(lister, string, lister_prealloced(push_string_copy(lister->arena, status)), user_data, extra_space));
}

static void*
lister_add_item(Lister *lister, String_Const_u8 string, Lister_Prealloced_String status, void *user_data, u64 extra_space){
    return(lister_add_item(lister, lister_prealloced(push_string_copy(lister->arena, string)), status, user_data, extra_space));
}

static void*
lister_add_item(Lister *lister, String_Const_u8 string, String_Const_u8 status, void *user_data, u64 extra_space){
    return(lister_add_item(lister,
                           lister_prealloced(push_string_copy(lister->arena, string)),
                           lister_prealloced(push_string_copy(lister->arena, status)),
                           user_data, extra_space));
}

static Lister_Activation_Code
lister__write_string__default(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        String_Const_u8 string = to_writable(&in);
        if (string.str != 0 && string.size > 0){
            lister_append_text_field(lister, string);
            lister_append_key(lister, string);
            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
    return(result);
}

static void
lister__backspace_text_field__default(Application_Links *app){
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        lister->text_field.string = backspace_utf8(lister->text_field.string);
        lister->key_string.string = backspace_utf8(lister->key_string.string);
        lister->item_index = 0;
        lister_zero_scroll(lister);
        lister_update_filtered_list(app, lister);
    }
}

static void
lister__navigate__default(Application_Links *app, View_ID view, Lister *lister, i32 delta){
    i32 new_index = lister->item_index + delta;
    if (new_index < 0 && lister->item_index == 0){
        lister->item_index = lister->filtered.count - 1;
    }
    else if (new_index >= lister->filtered.count &&
             lister->item_index == lister->filtered.count - 1){
        lister->item_index = 0;
    }
    else{
        lister->item_index = (((0)>(new_index))?(0):(((lister->filtered.count - 1)<(new_index))?(lister->filtered.count - 1):(new_index)));
    }
    lister->set_vertical_focus_to_item = true;
    lister_update_selection_values(lister);
}

static Lister_Handlers
lister_get_default_handlers(void){
    Lister_Handlers handlers = {};
    handlers.write_character = lister__write_string__default;
    handlers.backspace = lister__backspace_text_field__default;
    handlers.navigate = lister__navigate__default;
    return(handlers);
}

static void
lister_set_default_handlers(Lister *lister){
    Lister_Handlers handlers = lister_get_default_handlers();
    lister_set_handlers(lister, &handlers);
}



static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, Arena *arena, String_Const_u8 query, Lister_Handlers handlers){
    Lister_Result result = {};
    if (handlers.refresh != 0){
        Lister_Block lister(app, arena);
        lister_set_query(lister, query);
        lister_set_handlers(lister, &handlers);
        handlers.refresh(app, lister);
        result = run_lister(app, lister);
    }
    else{

        String_Const_u8 str = push_u8_stringf(arena, "ERROR: No refresh handler specified for lister (query_string = \"%.*s\")\n", (i32)(query).size, (char*)(query).str);

        print_message(app, str);
        result.canceled = true;
    }
    return(result);
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, String_Const_u8 query, Lister_Handlers handlers){
    Scratch_Block scratch(app);
    return(run_lister_with_refresh_handler(app, scratch, query, handlers));
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, Arena *arena, char *query, Lister_Handlers handlers){
    return(run_lister_with_refresh_handler(app, arena, SCu8(query), handlers));
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, char *query, Lister_Handlers handlers){
    return(run_lister_with_refresh_handler(app, SCu8(query), handlers));
}



static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, String_Const_u8 status, Key_Code code, u64 user_data){
    Lister_Choice *choice = ((Lister_Choice*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Choice)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "884" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_lister_base.cpp" ":" "884" ":") - 1)))));
    do{ if((choice)){if((list->first)){(list->last)->next=(choice);}else{(list->first)=(choice);}(list->last)=(choice);(list->last)->next=0;} }while(0);
    choice->string = string;
    choice->status = status;
    choice->key_code = code;
    choice->user_data = user_data;
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, String_Const_u8 status, Key_Code code, u64 user_data){
    lister_choice(arena, list, SCu8(string), status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, char *status, Key_Code code, u64 user_data){
    lister_choice(arena, list, string, SCu8(status), code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, char *status, Key_Code code, u64 user_data){
    lister_choice(arena, list, SCu8(string), SCu8(status), code,
                  (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, String_Const_u8 status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, String_Const_u8 status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, char *status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, char *status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static Lister_Activation_Code
lister__key_stroke__choice_list(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        if (in.event.kind == InputEventKind_KeyStroke){
            void *user_data = 0;
            b32 did_shortcut_key = false;
            for (Lister_Node *node = lister->options.first;
                 node != 0;
                 node = node->next){
                Key_Code *key_code = (Key_Code*)(node + 1);
                if (*key_code == in.event.key.code){
                    user_data = node->user_data;
                    did_shortcut_key = true;
                    break;
                }
            }
            if (did_shortcut_key){
                lister_activate(app, lister, user_data, false);
                result = ListerActivation_Finished;
            }
        }
    }
    return(result);
}

static Lister_Choice*
get_choice_from_user(Application_Links *app, String_Const_u8 query,
                     Lister_Choice_List list){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    for (Lister_Choice *choice = list.first;
         choice != 0;
         choice = choice->next){
        u64 code_size = sizeof(choice->key_code);
        void *extra = lister_add_item(lister, choice->string, choice->status,
                                      choice, code_size);
        block_copy(extra, &choice->key_code, code_size);
    }
    lister_set_query(lister, query);
    Lister_Handlers handlers = {};
    handlers.navigate = lister__navigate__default;
    handlers.key_stroke = lister__key_stroke__choice_list;
    lister_set_handlers(lister, &handlers);

    Lister_Result l_result = run_lister(app, lister);
    Lister_Choice *result = 0;
    if (!l_result.canceled){
        result = (Lister_Choice*)l_result.user_data;
    }
    return(result);
}

static Lister_Choice*
get_choice_from_user(Application_Links *app, char *query, Lister_Choice_List list){
    return(get_choice_from_user(app, SCu8(query), list));
}
# 116 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" 1







static void
write_text(Application_Links *app, String_Const_u8 insert){
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("write character"), (u64)(sizeof("write character") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "10" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "10" ":") - 1)));
    if (insert.str != 0 && insert.size > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        if_view_has_highlighted_range_delete_range(app, view);

        i64 pos = view_get_cursor_pos(app, view);
        pos = view_get_character_legal_pos_from_pos(app, view, pos);

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);


        History_Record_Index first_index = buffer_history_get_current_state_index(app, buffer);
        b32 do_merge = false;
        if (insert.str[0] != '\n'){
            Record_Info record = get_single_record(app, buffer, first_index);
            if (record.error == RecordError_NoError && record.kind == RecordKind_Single){
                String_Const_u8 string = record.single_string_forward;
                i32 last_end = (i32)(record.single_first + string.size);
                if (last_end == pos && string.size > 0){
                    char c = string.str[string.size - 1];
                    if (c != '\n'){
                        if (character_is_whitespace(insert.str[0]) &&
                            character_is_whitespace(c)){
                            do_merge = true;
                        }
                        else if (character_is_alpha_numeric(insert.str[0]) && character_is_alpha_numeric(c)){
                            do_merge = true;
                        }
                    }
                }
            }
        }


        b32 edit_success = buffer_replace_range(app, buffer, Ii64(pos), insert);


        if (do_merge){
            History_Record_Index last_index = buffer_history_get_current_state_index(app, buffer);
            buffer_history_merge_record_range(app, buffer, first_index, last_index, RecordMergeFlag_StateInRange_MoveStateForward);
        }


        if (edit_success){
            view_set_cursor_and_preferred_x(app, view, seek_pos(pos + insert.size));
        }
    }
}

CUSTOM_COMMAND(write_text_input, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 59, Normal)
CUSTOM_DOC("Inserts whatever text was used to trigger this command.")
{
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    write_text(app, insert);
}

CUSTOM_COMMAND(write_space, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 67, Normal)
CUSTOM_DOC("Inserts a space.")
{
    write_text(app, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
}

CUSTOM_COMMAND(write_underscore, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 73, Normal)
CUSTOM_DOC("Inserts an underscore.")
{
    write_text(app, SCu8((u8*)("_"), (u64)(sizeof("_") - 1)));
}

CUSTOM_COMMAND(delete_char, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 79, Normal)
CUSTOM_DOC("Deletes the character to the right of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    if (!if_view_has_highlighted_range_delete_range(app, view)){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 start = view_get_cursor_pos(app, view);
        i64 buffer_size = buffer_get_size(app, buffer);
        if (0 <= start && start < buffer_size){
            Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(start));
            i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
            i64 end = view_pos_from_relative_character(app, view, cursor.line, character + 1);
            buffer_replace_range(app, buffer, Ii64(start, end), string_u8_empty);
        }
    }
}

CUSTOM_COMMAND(backspace_char, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 96, Normal)
CUSTOM_DOC("Deletes the character to the left of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    if (!if_view_has_highlighted_range_delete_range(app, view)){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 end = view_get_cursor_pos(app, view);
        i64 buffer_size = buffer_get_size(app, buffer);
        if (0 < end && end <= buffer_size){
            Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(end));
            i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
            i64 start = view_pos_from_relative_character(app, view, cursor.line, character - 1);
            if (buffer_replace_range(app, buffer, Ii64(start, end), string_u8_empty)){
                view_set_cursor_and_preferred_x(app, view, seek_pos(start));
            }
        }
    }
}

CUSTOM_COMMAND(set_mark, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 115, Normal)
CUSTOM_DOC("Sets the mark to the current position of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    view_set_mark(app, view, seek_pos(pos));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(cursor_mark_swap, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 124, Normal)
CUSTOM_DOC("Swaps the position of the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 cursor = view_get_cursor_pos(app, view);
    i64 mark = view_get_mark_pos(app, view);
    view_set_cursor_and_preferred_x(app, view, seek_pos(mark));
    view_set_mark(app, view, seek_pos(cursor));
}

CUSTOM_COMMAND(delete_range, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 134, Normal)
CUSTOM_DOC("Deletes the text in the range between the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    buffer_replace_range(app, buffer, range, string_u8_empty);
}

static void
current_view_boundary_delete(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = {};
    range.first = view_get_cursor_pos(app, view);
    range.one_past_last = scan(app, funcs, buffer, direction, range.first);
    range = rectify(range);
    buffer_replace_range(app, buffer, range, string_u8_empty);
}

CUSTOM_COMMAND(backspace_alpha_numeric_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 154, Normal)
CUSTOM_DOC("Delete characters between the cursor position and the first alphanumeric boundary to the left.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Backward,
                                 push_boundary_list__inner((scratch), boundary_alpha_numeric_unicode, 0));
}

CUSTOM_COMMAND(delete_alpha_numeric_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 162, Normal)
CUSTOM_DOC("Delete characters between the cursor position and the first alphanumeric boundary to the right.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Forward,
                                 push_boundary_list__inner((scratch), boundary_alpha_numeric_unicode, 0));
}

static void
current_view_snipe_delete(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = get_snipe_range(app, funcs, buffer, pos, direction);
    buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}

CUSTOM_COMMAND(snipe_backward_whitespace_or_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 179, Normal)
CUSTOM_DOC("Delete a single, whole token on or to the left of the cursor and post it to the clipboard.")
{
    Scratch_Block scratch(app);
    current_view_snipe_delete(app, Scan_Backward,
                              push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(snipe_forward_whitespace_or_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 187, Normal)
CUSTOM_DOC("Delete a single, whole token on or to the right of the cursor and post it to the clipboard.")
{
    Scratch_Block scratch(app);
    current_view_snipe_delete(app, Scan_Forward,
                              push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}



CUSTOM_COMMAND(center_view, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 197, Normal)
CUSTOM_DOC("Centers the view vertically on the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Rect_f32 region = view_get_buffer_region(app, view);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    f32 view_height = rect_height(region);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.line_number = cursor.line;
    scroll.target.pixel_shift.y = -view_height*0.5f;
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(left_adjust_view, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 212, Normal)
CUSTOM_DOC("Sets the left size of the view near the x position of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, pos);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.pixel_shift.x = (((0.f)>(p.x - 30.f))?(0.f):(p.x - 30.f));
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(click_set_cursor_and_mark, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 225, Normal)
CUSTOM_DOC("Sets the cursor position and mark to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    view_set_mark(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(click_set_cursor, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 235, Normal)
CUSTOM_DOC("Sets the cursor position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(click_set_cursor_if_lbutton, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 245, Normal)
CUSTOM_DOC("If the mouse left button is pressed, sets the cursor position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    if (mouse.l){
        i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
        view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    }
    no_mark_snap_to_cursor(app, view);
    set_next_rewrite(app, view, Rewrite_NoChange);
}

CUSTOM_COMMAND(click_set_mark, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 258, Normal)
CUSTOM_DOC("Sets the mark position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_mark(app, view, seek_pos(pos));
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(mouse_wheel_scroll, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 268, Normal)
CUSTOM_DOC("Reads the scroll wheel value from the mouse state and scrolls accordingly.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    if (mouse.wheel != 0){
        Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
        scroll.target = view_move_buffer_point(app, view, scroll.target, V2f32(0.f, (f32)mouse.wheel));
        view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    }
    if (mouse.l){
        no_mark_snap_to_cursor(app, view);
    }
}



static void
move_vertical_pixels(Application_Links *app, View_ID view, f32 pixels){
    Profile_Scope_Block profile_block_287 ((app), SCu8((u8*)("move vertical pixels"), (u64)(sizeof("move vertical pixels") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "287" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "287" ":") - 1)));
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Rect_f32 r = view_padded_box_of_pos(app, view, cursor.line, pos);
    Vec2_f32 p = {};
    p.x = view_get_preferred_x(app, view);
    if (pixels > 0.f){
        p.y = r.y1 + pixels;
    }
    else{
        p.y = r.y0 + pixels;
    }
    i64 new_pos = view_pos_at_relative_xy(app, view, cursor.line, p);
    view_set_cursor(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
move_vertical_pixels(Application_Links *app, f32 pixels){
    View_ID view = get_active_view(app, Access_ReadVisible);
    move_vertical_pixels(app, view, pixels);
}

static void
move_vertical_lines(Application_Links *app, View_ID view, i64 lines){
    if (lines > 0){
        for (i64 i = 0; i < lines; i += 1){
            move_vertical_pixels(app, 1.f);
        }
    }
    else{
        for (i64 i = 0; i > lines; i -= 1){
            move_vertical_pixels(app, -1.f);
        }
    }
}

static void
move_vertical_lines(Application_Links *app, i64 lines){
    View_ID view = get_active_view(app, Access_ReadVisible);
    move_vertical_lines(app, view, lines);
}

static f32
get_page_jump(Application_Links *app, View_ID view){
    Rect_f32 region = view_get_buffer_region(app, view);
    return(rect_height(region)*.9f);
}

CUSTOM_COMMAND(move_up, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 336, Normal)
CUSTOM_DOC("Moves the cursor up one line.")
{
    move_vertical_lines(app, -1);
}

CUSTOM_COMMAND(move_down, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 342, Normal)
CUSTOM_DOC("Moves the cursor down one line.")
{
    move_vertical_lines(app, 1);
}

CUSTOM_COMMAND(move_up_10, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 348, Normal)
CUSTOM_DOC("Moves the cursor up ten lines.")
{
    move_vertical_lines(app, -10);
}

CUSTOM_COMMAND(move_down_10, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 354, Normal)
CUSTOM_DOC("Moves the cursor down ten lines.")
{
    move_vertical_lines(app, 10);
}

CUSTOM_COMMAND(move_down_textual, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 360, Normal)
CUSTOM_DOC("Moves down to the next line of actual text, regardless of line wrapping.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 next_line = cursor.line + 1;
    view_set_cursor_and_preferred_x(app, view, seek_line_col(next_line, 1));
}

CUSTOM_COMMAND(page_up, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 370, Normal)
CUSTOM_DOC("Scrolls the view up one view height and moves the cursor up one view height.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = get_page_jump(app, view);
    move_vertical_pixels(app, -page_jump);
}

CUSTOM_COMMAND(page_down, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 378, Normal)
CUSTOM_DOC("Scrolls the view down one view height and moves the cursor down one view height.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = get_page_jump(app, view);
    move_vertical_pixels(app, page_jump);
}

static void
seek_blank_line(Application_Links *app, Scan_Direction direction, Position_Within_Line position){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_pos_of_blank_line_grouped(app, buffer, direction, pos);
    switch (position){
        case PositionWithinLine_SkipLeadingWhitespace:
        {
            new_pos = get_pos_past_lead_whitespace(app, buffer, new_pos);
        }break;
        case PositionWithinLine_End:
        {
            new_pos = get_line_side_pos_from_pos(app, buffer, new_pos, Side_Max);
        }break;
    }
    new_pos = view_get_character_legal_pos_from_pos(app, view, new_pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_up_to_blank_line, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 407, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_Start);
}

CUSTOM_COMMAND(move_down_to_blank_line, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 413, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_Start);
}

CUSTOM_COMMAND(move_up_to_blank_line_skip_whitespace, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 419, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_SkipLeadingWhitespace);
}

CUSTOM_COMMAND(move_down_to_blank_line_skip_whitespace, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 425, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_SkipLeadingWhitespace);
}

CUSTOM_COMMAND(move_up_to_blank_line_end, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 431, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_End);
}

CUSTOM_COMMAND(move_down_to_blank_line_end, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 437, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_End);
}

CUSTOM_COMMAND(move_left, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 443, Normal)
CUSTOM_DOC("Moves the cursor one character to the left.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_by_character_delta(app, view, -1);
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_right, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 451, Normal)
CUSTOM_DOC("Moves the cursor one character to the right.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_by_character_delta(app, view, 1);
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
current_view_scan_move(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    i64 pos = scan(app, funcs, buffer, direction, cursor_pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_right_whitespace_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 469, Normal)
CUSTOM_DOC("Seek right for the next boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward,
                           push_boundary_list__inner((scratch), boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_left_whitespace_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 477, Normal)
CUSTOM_DOC("Seek left for the next boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward,
                           push_boundary_list__inner((scratch), boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_right_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 485, Normal)
CUSTOM_DOC("Seek right for the next end of a token.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_token, 0));
}

CUSTOM_COMMAND(move_left_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 492, Normal)
CUSTOM_DOC("Seek left for the next beginning of a token.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_token, 0));
}

CUSTOM_COMMAND(move_right_whitespace_or_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 499, Normal)
CUSTOM_DOC("Seek right for the next end of a token or boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_left_whitespace_or_token_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 506, Normal)
CUSTOM_DOC("Seek left for the next end of a token or boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_right_alpha_numeric_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 513, Normal)
CUSTOM_DOC("Seek right for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

CUSTOM_COMMAND(move_left_alpha_numeric_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 520, Normal)
CUSTOM_DOC("Seek left for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

CUSTOM_COMMAND(move_right_alpha_numeric_or_camel_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 527, Normal)
CUSTOM_DOC("Seek right for boundary between alphanumeric characters or camel case word and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric_camel, 0));
}

CUSTOM_COMMAND(move_left_alpha_numeric_or_camel_boundary, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 534, Normal)
CUSTOM_DOC("Seek left for boundary between alphanumeric characters or camel case word and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric_camel, 0));
}



CUSTOM_COMMAND(select_all, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 543, Normal)
CUSTOM_DOC("Puts the cursor at the top of the file, and the mark at the bottom of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i32 buffer_size = (i32)buffer_get_size(app, buffer);
    view_set_cursor_and_preferred_x(app, view, seek_pos(0));
    view_set_mark(app, view, seek_pos(buffer_size));
    no_mark_snap_to_cursor(app, view);
}



CUSTOM_COMMAND(to_uppercase, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 556, Normal)
CUSTOM_DOC("Converts all ascii text in the range between the cursor and the mark to uppercase.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    string = string_mod_upper(string);
    buffer_replace_range(app, buffer, range, string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
}

CUSTOM_COMMAND(to_lowercase, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 569, Normal)
CUSTOM_DOC("Converts all ascii text in the range between the cursor and the mark to lowercase.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    string = string_mod_lower(string);
    buffer_replace_range(app, buffer, range, string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
}

typedef i32 Clean_All_Lines_Mode;
enum{
    CleanAllLinesMode_RemoveBlankLines,
    CleanAllLinesMode_LeaveBlankLines,
};

static void
clean_all_lines_buffer(Application_Links *app, Buffer_ID buffer, Clean_All_Lines_Mode mode){
    Profile_Scope_Block profile_block_590 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "590" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "590" ":") - 1)));
    Scratch_Block scratch(app);
    Batch_Edit *batch_first = 0;
    Batch_Edit *batch_last = 0;

    i64 line_count = buffer_get_line_count(app, buffer);
    for (i64 line_number = 1; line_number <= line_count; line_number += 1){
        i64 line_start = get_line_side_pos(app, buffer, line_number, Side_Min);
        i64 line_end = get_line_side_pos(app, buffer, line_number, Side_Max);
        u8 prev = buffer_get_char(app, buffer, line_end - 1);
        b32 has_cr_character = false;
        b32 has_tail_whitespace = false;
        if (prev == '\r'){
            has_cr_character = true;
            if (line_end - 2 >= line_start){
                prev = buffer_get_char(app, buffer, line_end - 2);
                has_tail_whitespace = character_is_whitespace(prev);
            }
        }
        else{
            has_tail_whitespace = character_is_whitespace(prev);
        }
        if (has_tail_whitespace){
            String_Const_u8 line = push_buffer_range(app, scratch, buffer,
                                                     Ii64(line_start, line_end));
            if (line.size > 0){
                i64 end_offset = line.size;
                i64 i = line.size - 1;
                if (has_cr_character){
                    end_offset -= 1;
                    i -= 1;
                }
                i64 start_offset = 0;
                for (; i >= 0; i -= 1){
                    if (!character_is_whitespace(line.str[i])){
                        start_offset = i + 1;
                        break;
                    }
                }

                if (mode == CleanAllLinesMode_RemoveBlankLines || start_offset > 0){
                    i64 start = start_offset + line_start;
                    i64 end = end_offset + line_start;

                    Batch_Edit *batch = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "634" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "634" ":") - 1)))));
                    do{ if((batch)){if((batch_first)){(batch_last)->next=(batch);}else{(batch_first)=(batch);}(batch_last)=(batch);(batch_last)->next=0;} }while(0);
                    batch->edit.text = SCu8();
                    batch->edit.range = Ii64(start, end);
                }
            }
        }
    }

    if (batch_first != 0){
        buffer_batch_edit(app, buffer, batch_first);
    }
}

CUSTOM_COMMAND(clean_all_lines, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 648, Normal)
CUSTOM_DOC("Removes trailing whitespace from all lines and removes all blank lines in the current buffer.")
{
    Profile_Scope_Block profile_block_651 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "651" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "651" ":") - 1)));
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    clean_all_lines_buffer(app, buffer, CleanAllLinesMode_RemoveBlankLines);
}

CUSTOM_COMMAND(clean_trailing_whitespace, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 657, Normal)
CUSTOM_DOC("Removes trailing whitespace from all lines in the current buffer.")
{
    Profile_Scope_Block profile_block_660 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "660" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "660" ":") - 1)));
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    clean_all_lines_buffer(app, buffer, CleanAllLinesMode_LeaveBlankLines);
}



CUSTOM_COMMAND(basic_change_active_panel, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 668, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next highest view_id.  Will not skipe the build panel if it is open.")
{
    View_ID view = get_active_view(app, Access_Always);
    get_next_view_looped_all_panels(app, view, Access_Always);
    view_set_active(app, view);
}

CUSTOM_COMMAND(close_panel, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 676, Normal)
CUSTOM_DOC("Closes the currently active panel if it is not the only panel open.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_close(app, view);
}



CUSTOM_COMMAND(show_scrollbar, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 685, Normal)
CUSTOM_DOC("Sets the current view to show it's scrollbar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowScrollbar, true);
}

CUSTOM_COMMAND(hide_scrollbar, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 692, Normal)
CUSTOM_DOC("Sets the current view to hide it's scrollbar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowScrollbar, false);
}

CUSTOM_COMMAND(show_filebar, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 699, Normal)
CUSTOM_DOC("Sets the current view to show it's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowFileBar, true);
}

CUSTOM_COMMAND(hide_filebar, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 706, Normal)
CUSTOM_DOC("Sets the current view to hide it's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowFileBar, false);
}

CUSTOM_COMMAND(toggle_filebar, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 713, Normal)
CUSTOM_DOC("Toggles the visibility status of the current view's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    b64 value = false;
    view_get_setting(app, view, ViewSetting_ShowFileBar, &value);
    view_set_setting(app, view, ViewSetting_ShowFileBar, !value);
}

CUSTOM_COMMAND(toggle_fps_meter, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 722, Normal)
CUSTOM_DOC("Toggles the visibility of the FPS performance meter")
{
    show_fps_hud = !show_fps_hud;
}

CUSTOM_COMMAND(set_face_size, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 728, Normal)
CUSTOM_DOC("Set face size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);

    Query_Bar_Group group(app);
    u8 string_space[256];
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Face Size: "), (u64)(sizeof("Face Size: ") - 1));
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = sizeof(string_space);
    if (query_user_number(app, &bar, description.parameters.pt_size)){
        description.parameters.pt_size = (u32)string_to_integer(bar.string, 10);
        try_modify_face(app, face_id, &description);
    }
}

CUSTOM_COMMAND(increase_face_size, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 748, Normal)
CUSTOM_DOC("Increase the size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);
    ++description.parameters.pt_size;
    try_modify_face(app, face_id, &description);
}

CUSTOM_COMMAND(decrease_face_size, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 759, Normal)
CUSTOM_DOC("Decrease the size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);
    --description.parameters.pt_size;
    try_modify_face(app, face_id, &description);
}

CUSTOM_COMMAND(set_face_size_this_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 770, Normal)
CUSTOM_DOC("Set face size of the face used by the current buffer; if any other buffers are using the same face a new face is created so that only this buffer is effected")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);

    b32 is_shared = false;
    for (Buffer_ID buf_it = get_buffer_next(app, 0, Access_Always);
         buf_it != 0;
         buf_it = get_buffer_next(app, buf_it, Access_Always)){
        if (buf_it == buffer){
            continue;
        }
        Face_ID buf_it_face_id = get_face_id(app, buf_it);
        if (buf_it_face_id == face_id){
            is_shared = true;
        }
    }

    if (is_shared){
        Face_Description description = get_face_description(app, face_id);
        face_id = try_create_new_face(app, &description);
        if (face_id != 0){
            buffer_set_face(app, buffer, face_id);
        }
    }

    set_face_size(app);
}

CUSTOM_COMMAND(mouse_wheel_change_face_size, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 801, Normal)
CUSTOM_DOC("Reads the state of the mouse wheel and uses it to either increase or decrease the face size.")
{
    static u64 next_resize_time = 0;
    u64 now = system_now_time();
    if (now >= next_resize_time){
        next_resize_time = now + 50*1000;
        Mouse_State mouse = get_mouse_state(app);
        if (mouse.wheel > 0){
            decrease_face_size(app);
        }
        else if (mouse.wheel < 0){
            increase_face_size(app);
        }
    }
}

CUSTOM_COMMAND(toggle_show_whitespace, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 818, Normal)
CUSTOM_DOC("Toggles the current buffer's whitespace visibility status.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    b64 show_whitespace = false;
    view_get_setting(app, view, ViewSetting_ShowWhitespace, &show_whitespace);
    view_set_setting(app, view, ViewSetting_ShowWhitespace, !show_whitespace);
}

CUSTOM_COMMAND(toggle_line_numbers, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 827, Normal)
CUSTOM_DOC("Toggles the left margin line numbers.")
{
    String_ID key = vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1)));
    b32 val = def_get_config_b32(key);
    def_set_config_b32(key, !val);
}

CUSTOM_COMMAND(toggle_line_wrap, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 835, Normal)
CUSTOM_DOC("Toggles the line wrap setting on this buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    if (wrap_lines_ptr != 0){
        *wrap_lines_ptr = !(*wrap_lines_ptr);
        buffer_clear_layout_cache(app, buffer);
    }
}

CUSTOM_COMMAND(exit_4coder, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 848, Normal)
CUSTOM_DOC("Attempts to close 4coder.")
{
    send_exit_signal(app);
}



CUSTOM_COMMAND(goto_line, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 856, Normal)
CUSTOM_DOC("Queries the user for a number, and jumps the cursor to the corresponding line.")
{
    Query_Bar_Group group(app);
    u8 string_space[256];
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Goto Line: "), (u64)(sizeof("Goto Line: ") - 1));
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = sizeof(string_space);
    if (query_user_number(app, &bar)){
        i32 line_number = (i32)string_to_integer(bar.string, 10);
        View_ID view = get_active_view(app, Access_ReadVisible);
        view_set_cursor_and_preferred_x(app, view, seek_line_col(line_number, 0));
    }
}

CUSTOM_COMMAND(search, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 872, Normal);
CUSTOM_COMMAND(reverse_search, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 873, Normal);

static void
isearch__update_highlight(Application_Links *app, View_ID view, Range_i64 range){
    view_set_highlight_range(app, view, range);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.start));
}

static void
isearch(Application_Links *app, Scan_Direction start_scan, i64 first_pos,
        String_Const_u8 query_init){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)){
        return;
    }

    i64 buffer_size = buffer_get_size(app, buffer);

    Query_Bar_Group group(app);
    Query_Bar bar = {};
    if (start_query_bar(app, &bar, 0) == 0){
        return;
    }

    Vec2_f32 old_margin = {};
    Vec2_f32 old_push_in = {};
    view_get_camera_bounds(app, view, &old_margin, &old_push_in);

    Vec2_f32 margin = old_margin;
    margin.y = (((200.f)>(margin.y))?(200.f):(margin.y));
    view_set_camera_bounds(app, view, margin, old_push_in);

    Scan_Direction scan = start_scan;
    i64 pos = first_pos;

    u8 bar_string_space[256];
    bar.string = SCu8(bar_string_space, query_init.size);
    block_copy(bar.string.str, query_init.str, query_init.size);

    String_Const_u8 isearch_str = SCu8((u8*)("I-Search: "), (u64)(sizeof("I-Search: ") - 1));
    String_Const_u8 rsearch_str = SCu8((u8*)("Reverse-I-Search: "), (u64)(sizeof("Reverse-I-Search: ") - 1));

    u64 match_size = bar.string.size;

    User_Input in = {};
    for (;;){
        switch (scan){
            case Scan_Forward:
            {
                bar.prompt = isearch_str;
            }break;
            case Scan_Backward:
            {
                bar.prompt = rsearch_str;
            }break;
        }
        isearch__update_highlight(app, view, Ii64_size(pos, match_size));

        in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        String_Const_u8 string = to_writable(&in);

        b32 string_change = false;
        if (match_key_code(&in, KeyCode_Return) ||
            match_key_code(&in, KeyCode_Tab)){
            Input_Modifier_Set *mods = &in.event.key.modifiers;
            if (has_modifier(mods, KeyCode_Control)){
                bar.string.size = cstring_length(previous_isearch_query);
                block_copy(bar.string.str, previous_isearch_query, bar.string.size);
            }
            else{
                u64 size = bar.string.size;
                size = (((size)<(sizeof(previous_isearch_query) - 1))?(size):(sizeof(previous_isearch_query) - 1));
                block_copy(previous_isearch_query, bar.string.str, size);
                previous_isearch_query[size] = 0;
                break;
            }
        }
        else if (string.str != 0 && string.size > 0){
            String_u8 bar_string = Su8(bar.string, sizeof(bar_string_space));
            string_append(&bar_string, string);
            bar.string = bar_string.string;
            string_change = true;
        }
        else if (match_key_code(&in, KeyCode_Backspace)){
            if (is_unmodified_key(&in.event)){
                u64 old_bar_string_size = bar.string.size;
                bar.string = backspace_utf8(bar.string);
                string_change = (bar.string.size < old_bar_string_size);
            }
            else if (has_modifier(&in.event.key.modifiers, KeyCode_Control)){
                if (bar.string.size > 0){
                    string_change = true;
                    bar.string.size = 0;
                }
            }
        }

        b32 do_scan_action = false;
        b32 do_scroll_wheel = false;
        Scan_Direction change_scan = scan;
        if (!string_change){
            if (match_key_code(&in, KeyCode_PageDown) ||
                match_key_code(&in, KeyCode_Down)){
                change_scan = Scan_Forward;
                do_scan_action = true;
            }
            else if (match_key_code(&in, KeyCode_PageUp) ||
                     match_key_code(&in, KeyCode_Up)){
                change_scan = Scan_Backward;
                do_scan_action = true;
            }
            else{

                View_Context ctx = view_current_context(app, view);
                Mapping *mapping = ctx.mapping;
                Command_Map *map = mapping_get_map(mapping, ctx.map_id);
                Command_Binding binding = map_get_binding_recursive(mapping, map, &in.event);
                if (binding.custom != 0){
                    if (binding.custom == search){
                        change_scan = Scan_Forward;
                        do_scan_action = true;
                    }
                    else if (binding.custom == reverse_search){
                        change_scan = Scan_Backward;
                        do_scan_action = true;
                    }
                    else{
                        Command_Metadata *metadata = get_command_metadata(binding.custom);
                        if (metadata != 0){
                            if (metadata->is_ui){
                                view_enqueue_command_function(app, view, binding.custom);
                                break;
                            }
                        }
                        binding.custom(app);
                    }
                }
                else{
                    leave_current_input_unhandled(app);
                }
            }
        }

        if (string_change){
            switch (scan){
                case Scan_Forward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_forward(app, buffer, pos - 1, 0, bar.string, &new_pos);
                    if (new_pos < buffer_size){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;

                case Scan_Backward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_backward(app, buffer, pos + 1, 0, bar.string, &new_pos);
                    if (new_pos >= 0){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;
            }
        }
        else if (do_scan_action){
            scan = change_scan;
            switch (scan){
                case Scan_Forward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_forward(app, buffer, pos, 0, bar.string, &new_pos);
                    if (new_pos < buffer_size){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;

                case Scan_Backward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_backward(app, buffer, pos, 0, bar.string, &new_pos);
                    if (new_pos >= 0){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;
            }
        }
        else if (do_scroll_wheel){
            mouse_wheel_scroll(app);
        }
    }

    view_disable_highlight_range(app, view);

    if (in.abort){
        u64 size = bar.string.size;
        size = (((size)<(sizeof(previous_isearch_query) - 1))?(size):(sizeof(previous_isearch_query) - 1));
        block_copy(previous_isearch_query, bar.string.str, size);
        previous_isearch_query[size] = 0;
        view_set_cursor_and_preferred_x(app, view, seek_pos(first_pos));
    }

    view_set_camera_bounds(app, view, old_margin, old_push_in);
}

static void
isearch(Application_Links *app, Scan_Direction start_scan, String_Const_u8 query_init){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);;
    isearch(app, start_scan, pos, query_init);
}

static void
isearch(Application_Links *app, Scan_Direction start_scan){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);;
    isearch(app, start_scan, pos, SCu8());
}

static void
isearch_identifier(Application_Links *app, Scan_Direction scan){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer_id = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Scratch_Block scratch(app);
    Range_i64 range = enclose_pos_alpha_numeric_underscore(app, buffer_id, pos);
    String_Const_u8 query = push_buffer_range(app, scratch, buffer_id, range);
    isearch(app, scan, range.first, query);
}

CUSTOM_COMMAND(search, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1111, Normal)
CUSTOM_DOC("Begins an incremental search down through the current buffer for a user specified string.")
{
    isearch(app, Scan_Forward);
}

CUSTOM_COMMAND(reverse_search, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1117, Normal)
CUSTOM_DOC("Begins an incremental search up through the current buffer for a user specified string.")
{
    isearch(app, Scan_Backward);
}

CUSTOM_COMMAND(search_identifier, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1123, Normal)
CUSTOM_DOC("Begins an incremental search down through the current buffer for the word or token under the cursor.")
{
    isearch_identifier(app, Scan_Forward);
}

CUSTOM_COMMAND(reverse_search_identifier, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1129, Normal)
CUSTOM_DOC("Begins an incremental search up through the current buffer for the word or token under the cursor.")
{
    isearch_identifier(app, Scan_Backward);
}

struct String_Pair{
    b32 valid;
    String_Const_u8 a;
    String_Const_u8 b;
};

static String_Pair
query_user_replace_pair(Application_Links *app, Arena *arena){
    Query_Bar *replace = ((Query_Bar*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Query_Bar)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1143" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1143" ":") - 1)))));
    u8 *replace_space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1144" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1144" ":") - 1)))));
    replace->prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
    replace->string = SCu8(replace_space, (u64)0);
    replace->string_capacity = ((1) << 10);

    Query_Bar *with = ((Query_Bar*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Query_Bar)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1149" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1149" ":") - 1)))));
    u8 *with_space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1150" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1150" ":") - 1)))));
    with->prompt = SCu8((u8*)("With: "), (u64)(sizeof("With: ") - 1));
    with->string = SCu8(with_space, (u64)0);
    with->string_capacity = ((1) << 10);

    String_Pair result = {};
    if (query_user_string(app, replace) && replace->string.size != 0 && query_user_string(app, with)){
        result.valid = true;
        result.a = replace->string;
        result.b = with->string;
    }
    return(result);
}



static void
replace_in_range_query_user(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Pair pair = query_user_replace_pair(app, scratch);
    if (pair.valid){
        replace_in_range(app, buffer, range, pair.a, pair.b);
    }
}

CUSTOM_COMMAND(replace_in_range, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1176, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in the range between cursor and the mark in the active buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    replace_in_range_query_user(app, buffer, range);
}

CUSTOM_COMMAND(replace_in_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1185, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in the active buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = buffer_range(app, buffer);
    replace_in_range_query_user(app, buffer, range);
}

CUSTOM_COMMAND(replace_in_all_buffers, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1194, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in all editable buffers.")
{
    global_history_edit_group_begin(app);

    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Pair pair = query_user_replace_pair(app, scratch);
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_ReadWriteVisible);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_ReadWriteVisible)){
        Range_i64 range = buffer_range(app, buffer);
        replace_in_range(app, buffer, range, pair.a, pair.b);
    }

    global_history_edit_group_end(app);
}

static void
query_replace_base(Application_Links *app, View_ID view, Buffer_ID buffer_id, i64 pos, String_Const_u8 r, String_Const_u8 w){
    i64 new_pos = 0;
    seek_string_forward(app, buffer_id, pos - 1, 0, r, &new_pos);

    User_Input in = {};
    for (;;){
        Range_i64 match = Ii64(new_pos, new_pos + r.size);
        isearch__update_highlight(app, view, match);

        in = get_next_input(app, EventProperty_AnyKey, EventProperty_MouseButton);
        if (in.abort || match_key_code(&in, KeyCode_Escape) || !is_unmodified_key(&in.event)){
            break;
        }

        i64 size = buffer_get_size(app, buffer_id);
        if (match.max <= size &&
            (match_key_code(&in, KeyCode_Y) ||
             match_key_code(&in, KeyCode_Return) ||
             match_key_code(&in, KeyCode_Tab))){
            buffer_replace_range(app, buffer_id, match, w);
            pos = match.start + w.size;
        }
        else{
            pos = match.max;
        }

        seek_string_forward(app, buffer_id, pos, 0, r, &new_pos);
    }

    view_disable_highlight_range(app, view);

    if (in.abort){
        return;
    }

    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void
query_replace_parameter(Application_Links *app, String_Const_u8 replace_str, i64 start_pos, b32 add_replace_query_bar){
    Query_Bar_Group group(app);
    Query_Bar replace = {};
    replace.prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
    replace.string = replace_str;

    if (add_replace_query_bar){
        start_query_bar(app, &replace, 0);
    }

    Query_Bar with = {};
    u8 with_space[1024];
    with.prompt = SCu8((u8*)("With: "), (u64)(sizeof("With: ") - 1));
    with.string = SCu8(with_space, (u64)0);
    with.string_capacity = sizeof(with_space);

    if (query_user_string(app, &with)){
        String_Const_u8 r = replace.string;
        String_Const_u8 w = with.string;

        View_ID view = get_active_view(app, Access_ReadVisible);
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
        i64 pos = start_pos;

        Query_Bar bar = {};
        bar.prompt = SCu8((u8*)("Replace? (y)es, (n)ext, (esc)\n"), (u64)(sizeof("Replace? (y)es, (n)ext, (esc)\n") - 1));
        start_query_bar(app, &bar, 0);

        query_replace_base(app, view, buffer, pos, r, w);
    }
}

CUSTOM_COMMAND(query_replace, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1284, Normal)
CUSTOM_DOC("Queries the user for two strings, and incrementally replaces every occurence of the first string with the second string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Query_Bar_Group group(app);
        Query_Bar replace = {};
        u8 replace_space[1024];
        replace.prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
        replace.string = SCu8(replace_space, (u64)0);
        replace.string_capacity = sizeof(replace_space);
        if (query_user_string(app, &replace)){
            if (replace.string.size > 0){
                i64 pos = view_get_cursor_pos(app, view);
                query_replace_parameter(app, replace.string, pos, false);
            }
        }
    }
}

CUSTOM_COMMAND(query_replace_identifier, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1305, Normal)
CUSTOM_DOC("Queries the user for a string, and incrementally replace every occurence of the word or token found at the cursor with the specified string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Scratch_Block scratch(app);
        i64 pos = view_get_cursor_pos(app, view);
        Range_i64 range = enclose_pos_alpha_numeric_underscore(app, buffer, pos);
        String_Const_u8 replace = push_buffer_range(app, scratch, buffer, range);
        if (replace.size != 0){
            query_replace_parameter(app, replace, range.min, true);
        }
    }
}

CUSTOM_COMMAND(query_replace_selection, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1321, Normal)
CUSTOM_DOC("Queries the user for a string, and incrementally replace every occurence of the string found in the selected range with the specified string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Scratch_Block scratch(app);
        Range_i64 range = get_view_range(app, view);
        String_Const_u8 replace = push_buffer_range(app, scratch, buffer, range);
        if (replace.size != 0){
            query_replace_parameter(app, replace, range.min, true);
        }
    }
}



CUSTOM_COMMAND(jump_to_last_point, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1338, Normal)
CUSTOM_DOC("Read from the top of the point stack and jump there; if already there pop the top and go to the next option")
{
    View_ID view = get_active_view(app, Access_Visible);
    if (view != 0){
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        i64 pos = view_get_cursor_pos(app, view);

        for (;;){
            Buffer_ID stack_buffer = 0;
            i64 stack_pos = 0;
            if (point_stack_read_top(app, &stack_buffer, &stack_pos)){
                if (stack_buffer != 0 &&
                    (stack_buffer != buffer || stack_pos != pos)){
                    view_set_buffer(app, view, stack_buffer, 0);
                    view_set_cursor_and_preferred_x(app, view, seek_pos(stack_pos));
                    break;
                }
                point_stack_pop(app);
            }
            else{
                break;
            }
        }
    }
}



static void
delete_file_base(Application_Links *app, String_Const_u8 file_name, Buffer_ID buffer_id){
    String_Const_u8 path = string_remove_last_folder(file_name);
    Scratch_Block scratch(app);
    List_String_Const_u8 list = {};



    string_list_push((scratch), (&list), SCu8((u8*)("rm "), (u64)(sizeof("rm ") - 1)));



    string_list_pushf(scratch, &list, "\"%.*s\"", (i32)(file_name).size, (char*)(file_name).str);
    String_Const_u8 cmd = string_list_flatten(scratch, list, StringFill_NullTerminate);
    exec_system_command(app, 0, buffer_identifier(0), path, cmd, 0);
    buffer_kill(app, buffer_id, BufferKill_AlwaysKill);
}

CUSTOM_COMMAND(delete_file_query, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1385, Normal)
CUSTOM_DOC("Deletes the file of the current buffer if 4coder has the appropriate access rights. Will ask the user for confirmation first.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        Query_Bar_Group group(app);
        Query_Bar bar = {};
        bar.prompt = push_u8_stringf(scratch, "Delete '%.*s' (Y)es, (n)o", (i32)(file_name).size, (char*)(file_name).str);
        if (start_query_bar(app, &bar, 0) != 0){
            b32 cancelled = false;
            for (;!cancelled;){
                User_Input in = get_next_input(app, EventProperty_AnyKey, 0);
                if (in.abort){
                    cancelled = true;
                }
                else{
                    switch (in.event.key.code){
                        case KeyCode_Y:
                        {
                            delete_file_base(app, file_name, buffer);
                            cancelled = true;
                        }break;

                        case KeyCode_Shift:
                        case KeyCode_Control:
                        case KeyCode_Alt:
                        case KeyCode_Command:
                        case KeyCode_CapsLock:
                        {}break;

                        default:
                        {
                            cancelled = true;
                        }break;
                    }
                }
            }
        }
    }
}

CUSTOM_COMMAND(save_to_query, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1429, Normal)
CUSTOM_DOC("Queries the user for a file name and saves the contents of the current buffer, altering the buffer's name too.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);


    u8 name_space[4096];
    Query_Bar bar = {};
    bar.prompt = push_u8_stringf(scratch, "Save '%.*s' to: ", (i32)(buffer_name).size, (char*)(buffer_name).str);
    bar.string = SCu8(name_space, (u64)0);
    bar.string_capacity = sizeof(name_space);
    if (query_user_string(app, &bar)){
        if (bar.string.size != 0){
            List_String_Const_u8 new_file_name_list = {};
            string_list_push(scratch, &new_file_name_list, push_hot_directory(app, scratch));
            string_list_push(scratch, &new_file_name_list, bar.string);
            String_Const_u8 new_file_name = string_list_flatten(scratch, new_file_name_list);
            if (buffer_save(app, buffer, new_file_name, BufferSave_IgnoreDirtyFlag)){
                Buffer_ID new_buffer = create_buffer(app, new_file_name, BufferCreate_NeverNew|BufferCreate_JustChangedFile);
                if (new_buffer != 0 && new_buffer != buffer){
                    buffer_kill(app, buffer, BufferKill_AlwaysKill);
                    view_set_buffer(app, view, new_buffer, 0);
                }
            }
        }
    }
}

CUSTOM_COMMAND(rename_file_query, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1462, Normal)
CUSTOM_DOC("Queries the user for a new name and renames the file of the current buffer, altering the buffer's name too.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    Scratch_Block scratch(app);

    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){

        Query_Bar_Group group(app);
        String_Const_u8 front = string_front_of_path(file_name);
        u8 name_space[4096];
        Query_Bar bar = {};
        bar.prompt = push_u8_stringf(scratch, "Rename '%.*s' to: ", (i32)(front).size, (char*)(front).str);
        bar.string = SCu8(name_space, (u64)0);
        bar.string_capacity = sizeof(name_space);
        if (query_user_string(app, &bar) && bar.string.size != 0){

            List_String_Const_u8 new_file_name_list = {};
            string_list_push(scratch, &new_file_name_list, string_remove_front_of_path(file_name));
            string_list_push(scratch, &new_file_name_list, bar.string);
            String_Const_u8 new_file_name = string_list_flatten(scratch, new_file_name_list, StringFill_NullTerminate);
            if (buffer_save(app, buffer, new_file_name, BufferSave_IgnoreDirtyFlag)){
                Buffer_ID new_buffer = create_buffer(app, new_file_name, BufferCreate_NeverNew|BufferCreate_JustChangedFile);
                if (new_buffer != 0 && new_buffer != buffer){
                    delete_file_base(app, file_name, buffer);
                    view_set_buffer(app, view, new_buffer, 0);
                }
            }
        }
    }
}

CUSTOM_COMMAND(make_directory_query, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1497, Normal)
CUSTOM_DOC("Queries the user for a name and creates a new directory with the given name.")
{
    Scratch_Block scratch(app);

    String_Const_u8 hot = push_hot_directory(app, scratch);


    Query_Bar_Group group(app);
    u8 name_space[4096];
    Query_Bar bar = {};
    bar.prompt = push_u8_stringf(scratch, "Make directory at '%.*s': ", (i32)(hot).size, (char*)(hot).str);
    bar.string = SCu8(name_space, (u64)0);
    bar.string_capacity = sizeof(name_space);

    if (!query_user_string(app, &bar)) return;
    if (bar.string.size == 0) return;

    String_Const_u8 cmd = push_u8_stringf(scratch, "mkdir %.*s", (i32)(bar.string).size, (char*)(bar.string).str);
    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
}



static void
current_view_move_line(Application_Links *app, Scan_Direction direction){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    pos = move_line(app, buffer, line_number, direction);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(move_line_up, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1531, Normal)
CUSTOM_DOC("Swaps the line under the cursor with the line above it, and moves the cursor up with it.")
{
    current_view_move_line(app, Scan_Backward);
}

CUSTOM_COMMAND(move_line_down, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1537, Normal)
CUSTOM_DOC("Swaps the line under the cursor with the line below it, and moves the cursor down with it.")
{
    current_view_move_line(app, Scan_Forward);
}

CUSTOM_COMMAND(duplicate_line, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1543, Normal)
CUSTOM_DOC("Create a copy of the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    Scratch_Block scratch(app);
    String_Const_u8 s = push_buffer_line(app, scratch, buffer, line);
    s = push_u8_stringf(scratch, "%.*s\n", (i32)(s).size, (char*)(s).str);
    pos = get_line_side_pos(app, buffer, line, Side_Min);
    buffer_replace_range(app, buffer, Ii64(pos), s);
}

CUSTOM_COMMAND(delete_line, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1557, Normal)
CUSTOM_DOC("Delete the line the on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    Range_i64 range = get_line_pos_range(app, buffer, line);
    range.end += 1;
    i32 size = (i32)buffer_get_size(app, buffer);
    range.end = (((range.end)<(size))?(range.end):(size));
    if (range_size(range) == 0 ||
        buffer_get_char(app, buffer, range.end - 1) != '\n'){
        range.start -= 1;
        range.first = (((0)>(range.first))?(0):(range.first));
    }
    buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}



CUSTOM_COMMAND(open_file_in_quotes, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1578, Normal)
CUSTOM_DOC("Reads a filename from surrounding '\"' characters and attempts to open the corresponding file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer_exists(app, buffer)){
        Scratch_Block scratch(app);

        i64 pos = view_get_cursor_pos(app, view);

        Range_i64 range = enclose_pos_inside_quotes(app, buffer, pos);

        String_Const_u8 quoted_name = push_buffer_range(app, scratch, buffer, range);

        String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
        String_Const_u8 path = string_remove_last_folder(file_name);

        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }

        String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(quoted_name).size, (char*)(quoted_name).str);

        view = get_next_view_looped_primary_panels(app, view, Access_Always);
        if (view != 0){
            if (view_open_file(app, view, new_file_name, true)){
                view_set_active(app, view);
            }
        }
    }
}

static b32
get_cpp_matching_file(Application_Links *app, Buffer_ID buffer, Buffer_ID *buffer_out){
    b32 result = false;
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        String_Const_u8 extension = string_file_extension(file_name);
        String_Const_u8 new_extensions[2] = {};
        i32 new_extensions_count = 0;
        if (string_match(extension, SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1))) || string_match(extension, SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)))){
            new_extensions[0] = SCu8((u8*)("h"), (u64)(sizeof("h") - 1));
            new_extensions[1] = SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1));
            new_extensions_count = 2;
        }
        else if (string_match(extension, SCu8((u8*)("c"), (u64)(sizeof("c") - 1)))){
            new_extensions[0] = SCu8((u8*)("h"), (u64)(sizeof("h") - 1));
            new_extensions_count = 1;
        }
        else if (string_match(extension, SCu8((u8*)("h"), (u64)(sizeof("h") - 1)))){
            new_extensions[0] = SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1));
            new_extensions[1] = SCu8((u8*)("c"), (u64)(sizeof("c") - 1));
            new_extensions_count = 2;
        }
        else if (string_match(extension, SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1)))){
            new_extensions[0] = SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1));
            new_extensions_count = 1;
        }

        String_Const_u8 file_without_extension = string_file_without_extension(file_name);
        for (i32 i = 0; i < new_extensions_count; i += 1){
            Temp_Memory temp = begin_temp(scratch);
            String_Const_u8 new_extension = new_extensions[i];
            String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s.%.*s", (i32)(file_without_extension).size, (char*)(file_without_extension).str, (i32)(new_extension).size, (char*)(new_extension).str);
            if (open_file(app, buffer_out, new_file_name, false, true)){
                result = true;
                break;
            }
            end_temp(temp);
        }

        if (!result && new_extensions_count > 0){
            String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s.%.*s", (i32)(file_without_extension).size, (char*)(file_without_extension).str, (i32)(new_extensions[0]).size, (char*)(new_extensions[0]).str);
            if (open_file(app, buffer_out, new_file_name, false, false)){
                result = true;
            }
        }
    }

    return(result);
}

CUSTOM_COMMAND(open_matching_file_cpp, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1661, Normal)
CUSTOM_DOC("If the current file is a *.cpp or *.h, attempts to open the corresponding *.h or *.cpp file in the other view.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Buffer_ID new_buffer = 0;
    if (get_cpp_matching_file(app, buffer, &new_buffer)){
        view = get_next_view_looped_primary_panels(app, view, Access_Always);
        view_set_buffer(app, view, new_buffer, 0);
        view_set_active(app, view);
    }
}

CUSTOM_COMMAND(view_buffer_other_panel, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1674, Normal)
CUSTOM_DOC("Set the other non-active panel to view the buffer that the active panel views, and switch to that panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    change_active_panel(app);
    view = get_active_view(app, Access_Always);
    view_set_buffer(app, view, buffer, 0);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(swap_panels, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1686, Normal)
CUSTOM_DOC("Swaps the active panel with it's sibling.")
{
    View_ID view = get_active_view(app, Access_Always);
    Panel_ID panel = view_get_panel(app, view);
    Panel_ID parent = panel_get_parent(app, panel);
    for (;parent != 0;){
        Panel_ID child_1 = panel_get_child(app, parent, Side_Min);
        Panel_ID child_2 = panel_get_child(app, parent, Side_Max);

        View_ID view_1 = panel_get_view(app, child_1, Access_Always);
        View_ID view_2 = panel_get_view(app, child_2, Access_Always);

        if (!view_get_is_passive(app, view_1) && !view_get_is_passive(app, view_2)){
            panel_swap_children(app, parent);
            break;
        }

        parent = panel_get_parent(app, parent);
    }
}

CUSTOM_COMMAND(quick_swap_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1708, Normal)
CUSTOM_DOC("Change to the most recently used buffer in this view - or to the top of the buffer stack if the most recent doesn't exist anymore")
{
    View_ID view = get_active_view(app, Access_Visible);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Buffer_ID *prev_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_previous_buffer), sizeof(Buffer_ID)));
    b32 fallback = true;
    if (prev_buffer != 0 && *prev_buffer != 0){
        if (view_set_buffer(app, view, *prev_buffer, 0)){
            fallback = false;
        }
    }
    if (fallback){
        Buffer_ID top_buffer = get_buffer_next(app, 0, Access_Always);
        view_set_buffer(app, view, top_buffer, 0);
    }
}



CUSTOM_COMMAND(kill_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1728, Normal)
CUSTOM_DOC("Kills the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    try_buffer_kill(app, buffer, view, 0);
}

CUSTOM_COMMAND(save, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1736, Normal)
CUSTOM_DOC("Saves the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    buffer_save(app, buffer, file_name, 0);
}

CUSTOM_COMMAND(reopen, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1746, Normal)
CUSTOM_DOC("Reopen the current buffer from the hard drive.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    buffer_reopen(app, buffer, 0);
}



static i64
record_get_new_cursor_position_undo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index, Record_Info record){
    i64 new_edit_position = record.pos_before_edit;
# 1773 "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp"
    return(new_edit_position);
}

static i64
record_get_new_cursor_position_undo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    return(record_get_new_cursor_position_undo(app, buffer_id, index, record));
}

static i64
record_get_new_cursor_position_redo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index, Record_Info record){
    i64 new_edit_position = 0;
    switch (record.kind){
        default:
        case RecordKind_Single:
        {
            new_edit_position = record.single_first + record.single_string_forward.size;
        }break;
        case RecordKind_Group:
        {
            Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer_id, index, record.group_count - 1);
            new_edit_position = sub_record.single_first + sub_record.single_string_forward.size;
        }break;
    }
    return((i32)(new_edit_position));
}

static i64
record_get_new_cursor_position_redo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    return(record_get_new_cursor_position_redo(app, buffer_id, index, record));
}

static void
undo__fade_finish(Application_Links *app, Fade_Range *range){
    Buffer_ID buffer = range->buffer_id;
    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    if (current > 0){
        buffer_history_set_current_state_index(app, buffer, current - 1);
    }
}

static void
undo__flush_fades(Application_Links *app, Buffer_ID buffer){
    Fade_Range **prev_next = &buffer_fade_ranges.first;
    for (Fade_Range *node = buffer_fade_ranges.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (node->buffer_id == buffer &&
            node->finish_call == undo__fade_finish){
            undo__fade_finish(app, node);
            *prev_next = next;
            free_fade_range(node);
            buffer_fade_ranges.count -= 1;
        }
        else{
            prev_next = &node->next;
            buffer_fade_ranges.last = node;
        }
    }
}

CUSTOM_COMMAND(undo, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1836, Normal)
CUSTOM_DOC("Advances backwards through the undo history of the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    undo__flush_fades(app, buffer);

    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    if (current > 0){
        Record_Info record = buffer_history_get_record_info(app, buffer, current);
        i64 new_position = record_get_new_cursor_position_undo(app, buffer, current, record);

        b32 do_immedite_undo = true;
        f32 undo_fade_time = 0.33f;
        b32 enable_undo_fade_out = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_undo_fade_out"), (u64)(sizeof("enable_undo_fade_out") - 1))));
        if (enable_undo_fade_out &&
            undo_fade_time > 0.f &&
            record.kind == RecordKind_Single &&
            record.single_string_backward.size == 0){
            b32 has_hard_character = false;
            for (u64 i = 0; i < record.single_string_forward.size; i += 1){
                if (!character_is_whitespace(record.single_string_forward.str[i])){
                    has_hard_character = true;
                    break;
                }
            }
            if (has_hard_character){
                Range_i64 range = Ii64_size(record.single_first, record.single_string_forward.size);
                ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo)) & 0xFFFFFF;
                Fade_Range *fade = buffer_post_fade(app, buffer, undo_fade_time, range, color);
                fade->negate_fade_direction = true;
                fade->finish_call = undo__fade_finish;
                do_immedite_undo = false;
                if (new_position > range.max){
                    new_position -= range_size(range);
                }
            }
        }

        if (do_immedite_undo){
            buffer_history_set_current_state_index(app, buffer, current - 1);
            if (record.single_string_backward.size > 0){
                Range_i64 range = Ii64_size(record.single_first, record.single_string_backward.size);
                ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo));
                buffer_post_fade(app, buffer, undo_fade_time, range, color);
            }
        }

        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(redo, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1888, Normal)
CUSTOM_DOC("Advances forwards through the undo history of the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    undo__flush_fades(app, buffer);

    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
    if (current < max_index){
        Record_Info record = buffer_history_get_record_info(app, buffer, current);
        i64 new_position = record_get_new_cursor_position_redo(app, buffer, current + 1, record);

        buffer_history_set_current_state_index(app, buffer, current + 1);

        if (record.single_string_forward.size > 0){
            Range_i64 range = Ii64_size(record.single_first, record.single_string_forward.size);
            ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo));
            f32 undo_fade_time = 0.33f;
            buffer_post_fade(app, buffer, undo_fade_time, range, color);
        }

        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(undo_all_buffers, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1914, Normal)
CUSTOM_DOC("Advances backward through the undo history in the buffer containing the most recent regular edit.")
{
    Scratch_Block scratch(app);
    i32 highest_edit_number = -1;
    Buffer_ID first_buffer_match = 0;
    Buffer_ID last_buffer_match = 0;
    i32 match_count = 0;

    {
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
            if (index > 0){
                Record_Info record = buffer_history_get_record_info(app, buffer, index);
                if (record.edit_number > highest_edit_number){
                    highest_edit_number = record.edit_number;
                    first_buffer_match = buffer;
                    last_buffer_match = buffer;
                    match_count = 1;
                }
                else if (record.edit_number == highest_edit_number){
                    last_buffer_match = buffer;
                    match_count += 1;
                }
            }
        }
    }

    Buffer_ID *match_buffers = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(match_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1944" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1944" ":") - 1)))));
    i64 *new_positions = ((i64*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i64)*(match_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1945" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "1945" ":") - 1)))));
    match_count = 0;

    if (highest_edit_number != -1){
        for (Buffer_ID buffer = first_buffer_match;
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 did_match = false;
            i64 new_edit_position = 0;
            for (;;){
                History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
                if (index > 0){
                    Record_Info record = buffer_history_get_record_info(app, buffer, index);
                    if (record.edit_number == highest_edit_number){
                        did_match = true;
                        new_edit_position = record_get_new_cursor_position_undo(app, buffer, index, record);
                        buffer_history_set_current_state_index(app, buffer, index - 1);
                    }
                    else{
                        break;
                    }
                }
                else{
                    break;
                }
            }
            if (did_match){
                match_buffers[match_count] = buffer;
                new_positions[match_count] = new_edit_position;
                match_count += 1;
            }
            if (buffer == last_buffer_match){
                break;
            }
        }
    }

    view_buffer_set(app, match_buffers, new_positions, match_count);
}

CUSTOM_COMMAND(redo_all_buffers, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 1985, Normal)
CUSTOM_DOC("Advances forward through the undo history in the buffer containing the most recent regular edit.")
{
    Scratch_Block scratch(app);

    i32 lowest_edit_number = 0x7FFFFFFF;
    Buffer_ID first_buffer_match = 0;
    Buffer_ID last_buffer_match = 0;
    i32 match_count = 0;

    {
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
            History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
            if (index < max_index){
                Record_Info record = buffer_history_get_record_info(app, buffer, index + 1);
                if (record.edit_number < lowest_edit_number){
                    lowest_edit_number = record.edit_number;
                    first_buffer_match = buffer;
                    last_buffer_match = buffer;
                    match_count = 1;
                }
                else if (record.edit_number == lowest_edit_number){
                    last_buffer_match = buffer;
                    match_count += 1;
                }
            }
        }
    }

    Buffer_ID *match_buffers = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(match_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "2017" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "2017" ":") - 1)))));
    i64 *new_positions = ((i64*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i64)*(match_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "2018" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp" ":" "2018" ":") - 1)))));
    match_count = 0;

    if (lowest_edit_number != -1){
        for (Buffer_ID buffer = first_buffer_match;
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 did_match = false;
            i64 new_edit_position = 0;
            History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
            for (;;){
                History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
                if (index < max_index){
                    Record_Info record = buffer_history_get_record_info(app, buffer, index + 1);
                    if (record.edit_number == lowest_edit_number){
                        did_match = true;
                        new_edit_position = record_get_new_cursor_position_redo(app, buffer, index + 1, record);
                        buffer_history_set_current_state_index(app, buffer, index + 1);
                    }
                    else{
                        break;
                    }
                }
                else{
                    break;
                }
            }
            if (did_match){
                match_buffers[match_count] = buffer;
                new_positions[match_count] = new_edit_position;
                match_count += 1;
            }
            if (buffer == last_buffer_match){
                break;
            }
        }
    }

    view_buffer_set(app, match_buffers, new_positions, match_count);
}



CUSTOM_COMMAND(open_in_other, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 2061, Normal)
CUSTOM_DOC("Interactively opens a file in the other panel.")
{
    change_active_panel_send_command(app, interactive_open_or_new);
}

CUSTOM_COMMAND(default_file_externally_modified, "/home/tabletel/dev/4cc/code/custom/4coder_base_commands.cpp", 2067, Normal)
CUSTOM_DOC("Notes the external modification of attached files by printing a message.")
{
    User_Input input = get_current_input(app);
    if (match_core_code(&input, CoreCode_FileExternallyModified)){
        Scratch_Block scratch(app);
        Buffer_ID buffer_id = input.event.core.id;
        String_Const_u8 name = push_buffer_unique_name(app, scratch, buffer_id);
        String_Const_u8 str = push_u8_stringf(scratch, "Modified externally: %s\n", name.str);
        print_message(app, str);
    }
}
# 117 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 1






static Buffer_Insertion
begin_buffer_insertion_at(Application_Links *app, Buffer_ID buffer_id, i64 at){
    Buffer_Insertion result = {};
    result.app = app;
    result.buffer = buffer_id;
    result.at = at;
    return(result);
}

static Buffer_Insertion
begin_buffer_insertion_at_buffered(Application_Links *app, Buffer_ID buffer_id, i64 at, Cursor *cursor){
    Buffer_Insertion result = begin_buffer_insertion_at(app, buffer_id, at);
    result.buffering = true;
    result.cursor = cursor;
    result.temp = begin_temp(cursor);
    return(result);
}

static Buffer_Insertion
begin_buffer_insertion_at_buffered(Application_Links *app, Buffer_ID buffer_id, i64 at, Arena *buffer_memory, u64 buffer_memory_size){
    Cursor *cursor = ((Cursor*)linalloc_wrap_unintialized(linalloc_push((buffer_memory), sizeof(Cursor)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "27" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "27" ":") - 1)))));
    *cursor = make_cursor(((u8*)linalloc_wrap_unintialized(linalloc_push((buffer_memory), sizeof(u8)*(buffer_memory_size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "28" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "28" ":") - 1))))), buffer_memory_size);
    return(begin_buffer_insertion_at_buffered(app, buffer_id, at, cursor));
}

static Buffer_Insertion
begin_buffer_insertion(Application_Links *app){
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    Buffer_Insertion result = begin_buffer_insertion_at(app, buffer, cursor_pos);
    return(result);
}

static void
insert_string__no_buffering(Buffer_Insertion *insertion, String_Const_u8 string){
    buffer_replace_range(insertion->app, insertion->buffer, Ii64(insertion->at), string);
    insertion->at += string.size;
}

static void
insert__flush(Buffer_Insertion *insertion){
    Cursor *cursor = insertion->cursor;
    u64 pos = insertion->temp.temp_memory_cursor.pos;
    String_Const_u8 string = SCu8(cursor->base + pos, cursor->pos - pos);
    insert_string__no_buffering(insertion, string);
    end_temp(insertion->temp);
}

static char*
insert__reserve(Buffer_Insertion *insertion, u64 size){
    char *space = ((char*)linalloc_wrap_unintialized(linalloc_push((insertion->cursor), sizeof(char)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "58" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "58" ":") - 1)))));
    if (space == 0){
        insert__flush(insertion);
        space = ((char*)linalloc_wrap_unintialized(linalloc_push((insertion->cursor), sizeof(char)*(size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "61" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" ":" "61" ":") - 1)))));
    }
    return(space);
}

static void
end_buffer_insertion(Buffer_Insertion *insertion){
    if (insertion->buffering){
        insert__flush(insertion);
    }
}

static void
insert_string(Buffer_Insertion *insertion, String_Const_u8 string){
    if (!insertion->buffering){
        insert_string__no_buffering(insertion, string);
    }
    else{
        char *space = insert__reserve(insertion, string.size);
        if (space != 0){
            block_copy(space, string.str, string.size);
        }
        else{
            insert_string__no_buffering(insertion, string);
        }
    }
}

static u64
insertf(Buffer_Insertion *insertion, char *format, ...){
    Scratch_Block scratch(insertion->app);
    va_list args;
    
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 3 4
   __builtin_va_start(
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp"
   args
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 3 4
   ,
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp"
   format
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 3 4
   )
# 93 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp"
                         ;
    String_Const_u8 string = push_u8_stringfv(scratch, format, args);
    
# 95 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 3 4
   __builtin_va_end(
# 95 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp"
   args
# 95 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp" 3 4
   )
# 95 "/home/tabletel/dev/4cc/code/custom/4coder_insertion.cpp"
               ;
    insert_string(insertion, string);
    return(string.size);
}

static void
insertc(Buffer_Insertion *insertion, char C){
    insert_string(insertion, SCu8(&C, 1));
}

static b32
insert_line_from_buffer(Buffer_Insertion *insertion, Buffer_ID buffer_id, i32 line, i32 truncate_at){
    b32 success = is_valid_line(insertion->app, buffer_id, line);
    if (success){
        Scratch_Block scratch(insertion->app);
        insert_string(insertion, push_buffer_line(insertion->app, scratch, buffer_id, line));
    }
    return(success);
}

static b32
insert_line_from_buffer(Buffer_Insertion *insertion, Buffer_ID buffer_id, i32 line){
    return(insert_line_from_buffer(insertion, buffer_id, line, 0));
}
# 118 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" 1







static void
rewrite_lines_to_crlf(Application_Links *app, Buffer_ID buffer){
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("rewrite lines to crlf"), (u64)(sizeof("rewrite lines to crlf") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "10" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "10" ":") - 1)));
    Scratch_Block scratch(app);
    i64 size = buffer_get_size(app, buffer);

    Batch_Edit *first = 0;
    Batch_Edit *last = 0;

    Profile_Block profile_batch ((app), SCu8((u8*)("build batch edit"), (u64)(sizeof("build batch edit") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "17" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "17" ":") - 1)));
    i64 pos = -1;
    Character_Predicate pred_cr = character_predicate_from_character('\r');
    Character_Predicate pred_lf = character_predicate_from_character('\n');
    Character_Predicate pred = character_predicate_or(&pred_cr, &pred_lf);
    for (;;){
        String_Match match = buffer_seek_character_class(app, buffer, &pred,
                                                         Scan_Forward, pos);
        if (match.range.min == match.range.max){
            break;
        }
        pos = match.range.min;

        u8 c1 = buffer_get_char(app, buffer, pos);
        u8 c2 = buffer_get_char(app, buffer, pos + 1);
        if (c1 == '\r'){
            if (pos + 1 == size || c2 != '\n'){
                Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "34" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "34" ":") - 1)))));
                do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
                edit->edit.text = SCu8((u8*)(""), (u64)(sizeof("") - 1));
                edit->edit.range = match.range;
            }
            else{
                pos += 1;
            }
        }
        else{
            Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "44" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "44" ":") - 1)))));
            do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
            edit->edit.text = SCu8((u8*)("\r"), (u64)(sizeof("\r") - 1));
            edit->edit.range = Ii64(pos);
        }
    }
    ((profile_batch).close_now());

    buffer_batch_edit(app, buffer, first);
}

static void
rewrite_lines_to_lf(Application_Links *app, Buffer_ID buffer){
    Profile_Scope_Block profile_block_57 ((app), SCu8((u8*)("rewrite lines to lf"), (u64)(sizeof("rewrite lines to lf") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "57" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "57" ":") - 1)));
    Scratch_Block scratch(app);

    Batch_Edit *first = 0;
    Batch_Edit *last = 0;

    Profile_Block profile_batch ((app), SCu8((u8*)("build batch edit"), (u64)(sizeof("build batch edit") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "63" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "63" ":") - 1)));
    i64 pos = -1;
    Character_Predicate pred = character_predicate_from_character('\r');
    for (;;){
        String_Match match = buffer_seek_character_class(app, buffer, &pred,
                                                         Scan_Forward, pos);
        if (match.range.min == match.range.max){
            break;
        }
        pos = match.range.min;

        Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "74" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp" ":" "74" ":") - 1)))));
        do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
        edit->edit.text = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        edit->edit.range = match.range;
    }
    ((profile_batch).close_now());

 buffer_batch_edit(app, buffer, first);
}



CUSTOM_COMMAND(set_eol_mode_to_crlf, "/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp", 86, Normal)
CUSTOM_DOC("Puts the buffer in crlf line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
    *eol_setting = LineEndingKind_CRLF;
    }
}

CUSTOM_COMMAND(set_eol_mode_to_lf, "/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp", 99, Normal)
CUSTOM_DOC("Puts the buffer in lf line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
    *eol_setting = LineEndingKind_LF;
    }
}

CUSTOM_COMMAND(set_eol_mode_to_binary, "/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp", 112, Normal)
CUSTOM_DOC("Puts the buffer in bin line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
        *eol_setting = LineEndingKind_Binary;
    }
}

CUSTOM_COMMAND(set_eol_mode_from_contents, "/home/tabletel/dev/4cc/code/custom/4coder_eol.cpp", 125, Normal)
CUSTOM_DOC("Sets the buffer's line ending mode to match the contents of the buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
        *eol_setting = setting;
    }
}
# 119 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp" 1







static void
generate_all_buffers_list__output_buffer(Application_Links *app, Lister *lister,
                                         Buffer_ID buffer){
    Dirty_State dirty = buffer_get_dirty_state(app, buffer);
    String_Const_u8 status = {};
    switch (dirty){
        case DirtyState_UnsavedChanges: status = SCu8((u8*)("*"), (u64)(sizeof("*") - 1)); break;
        case DirtyState_UnloadedChanges: status = SCu8((u8*)("!"), (u64)(sizeof("!") - 1)); break;
        case DirtyState_UnsavedChangesAndUnloadedChanges: status = SCu8((u8*)("*!"), (u64)(sizeof("*!") - 1)); break;
    }
    Scratch_Block scratch(app, lister->arena);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);
    lister_add_item(lister, buffer_name, status, (void*)(((u8*)0) + buffer), 0);
}

static void
generate_all_buffers_list(Application_Links *app, Lister *lister){
    lister_begin_new_item_set(app, lister);

    Buffer_ID viewed_buffers[16];
    i32 viewed_buffer_count = 0;


    for (View_ID view = get_view_next(app, 0, Access_Always);
         view != 0;
         view = get_view_next(app, view, Access_Always)){
        Buffer_ID new_buffer_id = view_get_buffer(app, view, Access_Always);
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (new_buffer_id == viewed_buffers[i]){
                goto skip0;
            }
        }
        viewed_buffers[viewed_buffer_count++] = new_buffer_id;
        skip0:;
    }


    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (buffer == viewed_buffers[i]){
                goto skip1;
            }
        }
        if (!buffer_has_name_with_star(app, buffer)){
            generate_all_buffers_list__output_buffer(app, lister, buffer);
        }
        skip1:;
    }


    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (buffer == viewed_buffers[i]){
                goto skip2;
            }
        }
        if (buffer_has_name_with_star(app, buffer)){
            generate_all_buffers_list__output_buffer(app, lister, buffer);
        }
        skip2:;
    }


    for (i32 i = 0; i < viewed_buffer_count; i += 1){
        generate_all_buffers_list__output_buffer(app, lister, viewed_buffers[i]);
    }
}

static Buffer_ID
get_buffer_from_user(Application_Links *app, String_Const_u8 query){
    Lister_Handlers handlers = lister_get_default_handlers();
    handlers.refresh = generate_all_buffers_list;
    Lister_Result l_result = run_lister_with_refresh_handler(app, query, handlers);
    Buffer_ID result = 0;
    if (!l_result.canceled){
        result = (Buffer_ID)(((u8*)(l_result.user_data) - (u8*)(0)));
    }
    return(result);
}

static Buffer_ID
get_buffer_from_user(Application_Links *app, char *query){
    return(get_buffer_from_user(app, SCu8(query)));
}



typedef i32 Command_Lister_Status_Mode;
enum{
    CommandLister_None,
    CommandLister_Descriptions,
    CommandLister_Bindings
};

struct Command_Lister_Status_Rule{
    Command_Lister_Status_Mode mode;
    Mapping *mapping;
    Command_Map_ID map_id;
};

static Command_Lister_Status_Rule
command_lister_status_descriptions(void){
    Command_Lister_Status_Rule result = {};
    result.mode = CommandLister_Descriptions;
    return(result);
}

static Command_Lister_Status_Rule
command_lister_status_bindings(Mapping *mapping, Command_Map_ID map_id){
    Command_Lister_Status_Rule result = {};
    result.mode = CommandLister_Bindings;
    result.mapping = mapping;
    result.map_id = map_id;
    return(result);
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, String_Const_u8 query, i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){
    if (command_ids == 0){
        command_id_count = command_one_past_last_id;
    }

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    for (i32 i = 0; i < command_id_count; i += 1){
        i32 j = i;
        if (command_ids != 0){
            j = command_ids[i];
        }
        j = (((0)>(j))?(0):(((command_one_past_last_id)<(j))?(command_one_past_last_id):(j)));

        Custom_Command_Function *proc = fcoder_metacmd_table[j].proc;
        String_Const_u8 status = {};
        switch (status_rule->mode){
            case CommandLister_Descriptions:
            {
                status = SCu8(fcoder_metacmd_table[j].description);
            }break;
            case CommandLister_Bindings:
            {
                Command_Trigger_List triggers = map_get_triggers_recursive(scratch, status_rule->mapping, status_rule->map_id, proc);

                List_String_Const_u8 list = {};
                for (Command_Trigger *node = triggers.first;
                     node != 0;
                     node = node->next){
                    command_trigger_stringize(scratch, &list, node);
                    if (node->next != 0){
                        string_list_push(scratch, &list, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
                    }
                }

                status = string_list_flatten(scratch, list);
            }break;
        }

        lister_add_item(lister, SCu8(fcoder_metacmd_table[j].name), status,
                        (void*)proc, 0);
    }

    Lister_Result l_result = run_lister(app, lister);

    Custom_Command_Function *result = 0;
    if (!l_result.canceled){
        result = (Custom_Command_Function*)l_result.user_data;
    }
    return(result);
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, String_Const_u8 query, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, query, 0, 0, status_rule));
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, char *query,
                      i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, SCu8(query), command_ids, command_id_count, status_rule));
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, char *query, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, SCu8(query), 0, 0, status_rule));
}



static Color_Table*
get_color_table_from_user(Application_Links *app, String_Const_u8 query, Color_Table_List *color_table_list){
    if (color_table_list == 0){
        color_table_list = &global_theme_list;
    }

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    lister_add_item(lister, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)), SCu8((u8*)(""), (u64)(sizeof("") - 1)),
                    (void*)&default_color_table, 0);

    for (Color_Table_Node *node = color_table_list->first;
         node != 0;
         node = node->next){
        lister_add_item(lister, node->name, SCu8((u8*)(""), (u64)(sizeof("") - 1)),
                        (void*)&node->table, 0);
    }

    Lister_Result l_result = run_lister(app, lister);

    Color_Table *result = 0;
    if (!l_result.canceled){
        result = (Color_Table*)l_result.user_data;
    }
    return(result);
}

static Color_Table*
get_color_table_from_user(Application_Links *app){
    return(get_color_table_from_user(app, SCu8((u8*)("Theme:"), (u64)(sizeof("Theme:") - 1)), 0));
}



static Lister_Activation_Code
lister__write_character__file_path(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_this_ctx_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        String_Const_u8 string = to_writable(&in);
        if (string.str != 0 && string.size > 0){
            lister_append_text_field(lister, string);
            if (character_is_slash(string.str[0])){
                lister->out.text_field = lister->text_field.string;
                result = ListerActivation_Finished;
            }
            else{
                String_Const_u8 front_name = string_front_of_path(lister->text_field.string);
                lister_set_key(lister, front_name);
            }
            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
    return(result);
}

static void
lister__backspace_text_field__file_path(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        if (lister->text_field.size > 0){
            char last_char = lister->text_field.str[lister->text_field.size - 1];
            lister->text_field.string = backspace_utf8(lister->text_field.string);
            if (character_is_slash(last_char)){
                User_Input input = get_current_input(app);
                String_Const_u8 text_field = lister->text_field.string;
                String_Const_u8 new_hot = string_remove_last_folder(text_field);
                b32 is_modified = has_modifier(&input, KeyCode_Control);
                b32 whole_word_when_mod = def_get_config_b32(vars_save_string(SCu8((u8*)("lister_whole_word_backspace_when_modified"), (u64)(sizeof("lister_whole_word_backspace_when_modified") - 1))));
                b32 whole_word_backspace = (is_modified == whole_word_when_mod);
                if (whole_word_backspace){
                    lister->text_field.size = new_hot.size;
                }
                set_hot_directory(app, new_hot);


                String_u8 dingus = lister->text_field;
                lister_call_refresh_handler(app, lister);
                lister->text_field = dingus;
            }
            else{
                String_Const_u8 text_field = lister->text_field.string;
                String_Const_u8 new_key = string_front_of_path(text_field);
                lister_set_key(lister, new_key);
            }

            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
}

static void
generate_hot_directory_file_list(Application_Links *app, Lister *lister){
    Scratch_Block scratch(app, lister->arena);

    Temp_Memory temp = begin_temp(lister->arena);
    String_Const_u8 hot = push_hot_directory(app, lister->arena);
    if (!character_is_slash(string_get_character(hot, hot.size - 1))){
        hot = push_u8_stringf(lister->arena, "%.*s/", (i32)(hot).size, (char*)(hot).str);
    }
    lister_set_text_field(lister, hot);
    lister_set_key(lister, string_front_of_path(hot));

    File_List file_list = system_get_file_list(scratch, hot);
    end_temp(temp);

    File_Info **one_past_last = file_list.infos + file_list.count;

    lister_begin_new_item_set(app, lister);

    hot = push_hot_directory(app, lister->arena);
    (linalloc_align((lister->arena), (8)));
    if (hot.str != 0){
        String_Const_u8 empty_string = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        Lister_Prealloced_String empty_string_prealloced = lister_prealloced(empty_string);
        for (File_Info **info = file_list.infos;
             info < one_past_last;
             info += 1){
            if (!((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
            String_Const_u8 file_name = push_u8_stringf(lister->arena, "%.*s/",
                                                        (i32)((**info).file_name).size, (char*)((**info).file_name).str);
            lister_add_item(lister, lister_prealloced(file_name), empty_string_prealloced, file_name.str, 0);
        }

        for (File_Info **info = file_list.infos;
             info < one_past_last;
             info += 1){
            if (((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
            String_Const_u8 file_name = push_string_copy(lister->arena, (**info).file_name);
            char *is_loaded = "";
            char *status_flag = "";

            Buffer_ID buffer = {};

            {
                Temp_Memory path_temp = begin_temp(lister->arena);
                List_String_Const_u8 list = {};
                string_list_push(lister->arena, &list, hot);
                string_list_push_overlap(lister->arena, &list, '/', (**info).file_name);
                String_Const_u8 full_file_path = string_list_flatten(lister->arena, list);
                buffer = get_buffer_by_file_name(app, full_file_path, Access_Always);
                end_temp(path_temp);
            }

            if (buffer != 0){
                is_loaded = "LOADED";
                Dirty_State dirty = buffer_get_dirty_state(app, buffer);
                switch (dirty){
                    case DirtyState_UnsavedChanges: status_flag = " *"; break;
                    case DirtyState_UnloadedChanges: status_flag = " !"; break;
                    case DirtyState_UnsavedChangesAndUnloadedChanges: status_flag = " *!"; break;
                }
            }
            String_Const_u8 status = push_u8_stringf(lister->arena, "%s%s", is_loaded, status_flag);
            lister_add_item(lister, lister_prealloced(file_name), lister_prealloced(status), file_name.str, 0);
        }
    }
}

struct File_Name_Result{
    b32 canceled;
    b32 clicked;
    b32 is_folder;
    String_Const_u8 file_name_activated;
    String_Const_u8 file_name_in_text_field;
    String_Const_u8 path_in_text_field;
};

static File_Name_Result
get_file_name_from_user(Application_Links *app, Arena *arena, String_Const_u8 query, View_ID view){
    Lister_Handlers handlers = lister_get_default_handlers();
    handlers.refresh = generate_hot_directory_file_list;
    handlers.write_character = lister__write_character__file_path;
    handlers.backspace = lister__backspace_text_field__file_path;

    Lister_Result l_result = run_lister_with_refresh_handler(app, arena, query, handlers);

    File_Name_Result result = {};
    result.canceled = l_result.canceled;
    if (!l_result.canceled){
        result.clicked = l_result.activated_by_click;
        if (l_result.user_data != 0){
            String_Const_u8 name = SCu8((u8*)l_result.user_data);
            result.file_name_activated = name;
            result.is_folder = character_is_slash(string_get_character(name, name.size - 1));
        }
        result.file_name_in_text_field = string_front_of_path(l_result.text_field);

        String_Const_u8 path = {};
        if (l_result.user_data == 0 && result.file_name_in_text_field.size == 0 && l_result.text_field.size > 0){
            result.file_name_in_text_field = string_front_folder_of_path(l_result.text_field);
            path = string_remove_front_folder_of_path(l_result.text_field);
        }
        else{
            path = string_remove_front_of_path(l_result.text_field);
        }
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        result.path_in_text_field = path;
    }

    return(result);
}

static File_Name_Result
get_file_name_from_user(Application_Links *app, Arena *arena, char *query, View_ID view){
    return(get_file_name_from_user(app, arena, SCu8(query), view));
}



enum{
    SureToKill_NULL = 0,
    SureToKill_No = 1,
    SureToKill_Yes = 2,
    SureToKill_Save = 3,
};

static b32
do_buffer_kill_user_check(Application_Links *app, Buffer_ID buffer, View_ID view){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
    lister_choice(scratch, &list, "(S)ave", "", KeyCode_S, SureToKill_Save);

    Lister_Choice *choice = get_choice_from_user(app, "There are unsaved changes, close anyway?", list);

    b32 do_kill = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToKill_No:
            {}break;

            case SureToKill_Yes:
            {
                do_kill = true;
            }break;

            case SureToKill_Save:
            {
                String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
                if (buffer_save(app, buffer, file_name, BufferSave_IgnoreDirtyFlag)){
                    do_kill = true;
                }
                else{

                    String_Const_u8 str =
                        push_u8_stringf(scratch, "Did not close '%.*s' because it did not successfully save.", (i32)(file_name).size, (char*)(file_name).str);

                    print_message(app, str);
                }
            }break;
        }
    }

    return(do_kill);
}

static b32
do_4coder_close_user_check(Application_Links *app, View_ID view){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
    lister_choice(scratch, &list, "(S)ave all and close", "",
                  KeyCode_S, SureToKill_Save);


    Lister_Choice *choice = get_choice_from_user(app, "There are one or more buffers with unsave changes, close anyway?", list);


    b32 do_exit = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToKill_No:
            {}break;

            case SureToKill_Yes:
            {
                allow_immediate_close_without_checking_for_changes = true;
                do_exit = true;
            }break;

            case SureToKill_Save:
            {
                save_all_dirty_buffers(app);
                allow_immediate_close_without_checking_for_changes = true;
                do_exit = true;
            }break;
        }
    }

    return(do_exit);
}



CUSTOM_COMMAND(interactive_switch_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 511, UI)
CUSTOM_DOC("Interactively switch to an open buffer.")
{
    Buffer_ID buffer = get_buffer_from_user(app, "Switch:");
    if (buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        view_set_buffer(app, view, buffer, 0);
    }
}

CUSTOM_COMMAND(interactive_kill_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 521, UI)
CUSTOM_DOC("Interactively kill an open buffer.")
{
    Buffer_ID buffer = get_buffer_from_user(app, "Kill:");
    if (buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        try_buffer_kill(app, buffer, view, 0);
    }
}



enum{
    SureToCreateFolder_NULL = 0,
    SureToCreateFolder_No = 1,
    SureToCreateFolder_Yes = 2,
};

static b32
query_create_folder(Application_Links *app, String_Const_u8 folder_name){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);

    String_Const_u8 message = push_u8_stringf(scratch, "Create the folder %.*s?", (i32)(folder_name).size, (char*)(folder_name).str);
    Lister_Choice *choice = get_choice_from_user(app, message, list);

    b32 did_create_folder = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToCreateFolder_No:
            {}break;

            case SureToCreateFolder_Yes:
            {
                String_Const_u8 hot = push_hot_directory(app, scratch);
                String_Const_u8 fixed_folder_name = folder_name;
                for (;fixed_folder_name.size > 0 &&
                     character_is_slash(fixed_folder_name.str[fixed_folder_name.size - 1]);){
                    fixed_folder_name = string_chop(fixed_folder_name, 1);
                }
                if (fixed_folder_name.size > 0){
                    String_Const_u8 cmd = push_u8_stringf(scratch, "mkdir %.*s", (i32)(fixed_folder_name).size, (char*)(fixed_folder_name).str);
                    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
                    did_create_folder = true;
                }
            }break;
        }
    }

    return(did_create_folder);
}



static Lister_Activation_Code
activate_open_or_new__generic(Application_Links *app, View_ID view,
                              String_Const_u8 path, String_Const_u8 file_name, b32 is_folder,
                              Buffer_Create_Flag flags){
    Lister_Activation_Code result = 0;

    if (file_name.size == 0){

        print_message(app, SCu8((u8*)("Zero length file_name passed to activate_open_or_new__generic\n"), (u64)(sizeof("Zero length file_name passed to activate_open_or_new__generic\n") - 1)));

        result = ListerActivation_Finished;
    }
    else{
        Scratch_Block scratch(app);
        String_Const_u8 full_file_name = {};
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        full_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);
        if (is_folder){
            set_hot_directory(app, full_file_name);
            result = ListerActivation_ContinueAndRefresh;
        }
        else{
            Buffer_ID buffer = create_buffer(app, full_file_name, flags);
            if (buffer != 0){
                view_set_buffer(app, view, buffer, SetBuffer_KeepOriginalGUI);
            }
            result = ListerActivation_Finished;
        }
    }

    return(result);
}

CUSTOM_COMMAND(interactive_open_or_new, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 612, UI)
CUSTOM_DOC("Interactively open a file out of the file system.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "Open:", view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0){
            file_name = result.file_name_in_text_field;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                         (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
   }
   if (string_looks_like_drive_letter(file_name)){
    set_hot_directory(app, file_name);
    continue;
   }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_ID buffer = create_buffer(app, full_file_name, 0);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}

CUSTOM_COMMAND(interactive_new, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 661, UI)
CUSTOM_DOC("Interactively creates a new file.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "New:",
                                                          view);
        if (result.canceled) break;



        String_Const_u8 file_name = result.file_name_in_text_field;
        if (result.is_folder || result.clicked){
            file_name = result.file_name_activated;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name =
            push_u8_stringf(scratch, "%.*s/%.*s",
                            (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
   }
   if (string_looks_like_drive_letter(file_name)){
    set_hot_directory(app, file_name);
    continue;
   }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_Create_Flag flags = BufferCreate_AlwaysNew;
        Buffer_ID buffer = create_buffer(app, full_file_name, flags);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}

CUSTOM_COMMAND(interactive_open, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 715, UI)
CUSTOM_DOC("Interactively opens a file.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "Open:", view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name =
            push_u8_stringf(scratch, "%.*s/%.*s",
                            (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_Create_Flag flags = BufferCreate_NeverNew;
        Buffer_ID buffer = create_buffer(app, full_file_name, flags);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}



CUSTOM_COMMAND(command_lister, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 761, UI)
CUSTOM_DOC("Opens an interactive list of all registered commands.")
{
    View_ID view = get_this_ctx_view(app, Access_Always);
    if (view != 0){
        Command_Lister_Status_Rule rule = {};
        Buffer_ID buffer = view_get_buffer(app, view, Access_Visible);
        Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
        Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
        if (map_id_ptr != 0){
            rule = command_lister_status_bindings(&framework_mapping, *map_id_ptr);
        }
        else{
            rule = command_lister_status_descriptions();
        }
        Custom_Command_Function *func = get_command_from_user(app, "Command:", &rule);
        if (func != 0){
            view_enqueue_command_function(app, view, func);
        }
    }
}



CUSTOM_COMMAND(theme_lister, "/home/tabletel/dev/4cc/code/custom/4coder_lists.cpp", 785, UI)
CUSTOM_DOC("Opens an interactive list of all registered themes.")
{
    Color_Table *color_table = get_color_table_from_user(app);
    if (color_table != 0){
        active_color_table = *color_table;
    }
}
# 120 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" 1






static Batch_Edit*
make_batch_from_indentations(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, i64 *indentations, Indent_Flag flags, i32 tab_width){
    i64 *shifted_indentations = indentations - lines.first;

    Batch_Edit *batch_first = 0;
    Batch_Edit *batch_last = 0;

    for (i64 line_number = lines.first;
         line_number <= lines.max;
         ++line_number){
        i64 line_start_pos = get_line_start_pos(app, buffer, line_number);
        Indent_Info indent_info = get_indent_info_line_number_and_start(app, buffer, line_number, line_start_pos, tab_width);

        i64 correct_indentation = shifted_indentations[line_number];
        if (indent_info.is_blank && (((flags)&(Indent_ClearLine))!=0)){
            correct_indentation = 0;
        }
        if (correct_indentation <= -1){
            correct_indentation = indent_info.indent_pos;
        }

        if (correct_indentation != indent_info.indent_pos){
            u64 str_size = 0;
            u8 *str = 0;
            if ((((flags)&(Indent_UseTab))!=0)){
                i64 tab_count = correct_indentation/tab_width;
                i64 indent = tab_count*tab_width;
                i64 space_count = correct_indentation - indent;
                str_size = tab_count + space_count;
                str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(str_size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "36" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "36" ":") - 1)))));
                block_fill_u8(str, tab_count, '\t');
                block_fill_u8(str + tab_count, space_count, ' ');
            }
            else{
                str_size = correct_indentation;
                str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(str_size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "42" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "42" ":") - 1)))));
                block_fill_u8(str, str_size, ' ');
            }

            Batch_Edit *batch = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "46" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "46" ":") - 1)))));
            do{ if((batch)){if((batch_first)){(batch_last)->next=(batch);}else{(batch_first)=(batch);}(batch_last)=(batch);(batch_last)->next=0;} }while(0);
            batch->edit.text = SCu8(str, str_size);
            batch->edit.range = Ii64(line_start_pos, indent_info.first_char_pos);
        }
    }

    return(batch_first);
}

static void
set_line_indents(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, i64 *indentations, Indent_Flag flags, i32 tab_width){
    Batch_Edit *batch = make_batch_from_indentations(app, arena, buffer, lines, indentations, flags, tab_width);
    if (batch != 0){
        buffer_batch_edit(app, buffer, batch);
    }
}

static Token*
find_anchor_token(Application_Links *app, Buffer_ID buffer, Token_Array *tokens, i64 invalid_line){
    Profile_Scope_Block profile_block_66 ((app), SCu8((u8*)("find anchor token"), (u64)(sizeof("find anchor token") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "66" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "66" ":") - 1)));
    Token *result = 0;

    if (tokens != 0 && tokens->tokens != 0){
        result = tokens->tokens;
        i64 invalid_pos = get_line_start_pos(app, buffer, invalid_line);
        i32 scope_counter = 0;
        i32 paren_counter = 0;
        Token *token = tokens->tokens;
        for (;;token += 1){
            if (token->pos + token->size > invalid_pos){
                break;
            }
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                if (scope_counter == 0 && paren_counter == 0){
                    result = token;
                }
                switch (token->kind){
                    case TokenBaseKind_ScopeOpen:
                    {
                        scope_counter += 1;
                    }break;
                    case TokenBaseKind_ScopeClose:
                    {
                        paren_counter = 0;
                        if (scope_counter > 0){
                            scope_counter -= 1;
                        }
                    }break;
                    case TokenBaseKind_ParentheticalOpen:
                    {
                        paren_counter += 1;
                    }break;
                    case TokenBaseKind_ParentheticalClose:
                    {
                        if (paren_counter > 0){
                            paren_counter -= 1;
                        }
                    }break;
                }
            }
        }
    }

    return(result);
}

static Nest*
indent__new_nest(Arena *arena, Nest_Alloc *alloc){
    Nest *new_nest = alloc->free_nest;
    if (new_nest == 0){
        new_nest = ((Nest*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Nest)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "117" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "117" ":") - 1)))));
    }
    else{
        ((alloc->free_nest)=(alloc->free_nest)=(alloc->free_nest)->next);
    }
    return(new_nest);
}

static void
indent__free_nest(Nest_Alloc *alloc, Nest *nest){
    ((nest)->next=(alloc->free_nest),(alloc->free_nest)=(nest));
}

static b32
indent__unfinished_statement(Token *token, Nest *current_nest){
    b32 result = false;
    if (current_nest != 0 && current_nest->kind == TokenBaseKind_ScopeOpen){
        result = true;
        switch (token->kind){
            case TokenBaseKind_ScopeOpen:
            case TokenBaseKind_ScopeClose:
            case TokenBaseKind_StatementClose:
            {
                result = false;
            }break;
        }
        if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
            result = false;
        }
    }
    return(result);
}

static void
line_indent_cache_update(Application_Links *app, Buffer_ID buffer, i32 tab_width, Indent_Line_Cache *line_cache){
    if (line_cache->line_number_for_cached_indent != line_cache->where_token_starts){
        Profile_Scope_Block profile_block_153 ((app), SCu8((u8*)("get indent info"), (u64)(sizeof("get indent info") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "153" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "153" ":") - 1)));
        line_cache->line_number_for_cached_indent = line_cache->where_token_starts;
        line_cache->start_pos = get_line_start_pos(app, buffer, line_cache->where_token_starts);
        Range_i64 range = Ii64(line_cache->start_pos, line_cache->one_past_last_pos);
        line_cache->indent_info = get_indent_info_range(app, buffer, range, tab_width);
    }
}

static i64*
get_indentation_array(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, Indent_Flag flags, i32 tab_width, i32 indent_width){
    Profile_Scope_Block profile_block_163 ((app), SCu8((u8*)("get indentation array"), (u64)(sizeof("get indentation array") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "163" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "163" ":") - 1)));
    i64 count = lines.max - lines.min + 1;
    i64 *indentations = ((i64*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(i64)*(count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "165" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "165" ":") - 1)))));
    i64 *shifted_indentations = indentations - lines.first;
    block_fill_u64(indentations, sizeof(*indentations)*count, (u64)(-1));






    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Token_Array *tokens = &token_array;

    i64 anchor_line = (((1)>(lines.first - 1))?(1):(lines.first - 1));
    Token *anchor_token = find_anchor_token(app, buffer, tokens, anchor_line);
    if (anchor_token != 0 &&
        anchor_token >= tokens->tokens &&
        anchor_token < tokens->tokens + tokens->count){
        i64 line = get_line_number_from_pos(app, buffer, anchor_token->pos);
        line = (((line)<(lines.first))?(line):(lines.first));

        Token_Iterator_Array token_it = token_iterator(0, tokens, anchor_token);

        Scratch_Block scratch(app, arena);
        Nest *nest = 0;
        Nest_Alloc nest_alloc = {};

        i64 line_last_indented = line - 1;
        i64 last_indent = 0;
        i64 actual_indent = 0;
        b32 in_unfinished_statement = false;

        Indent_Line_Cache line_cache = {};

        for (;;){
            Token *token = token_it_read(&token_it);

            if (line_cache.where_token_starts == 0 ||
                token->pos >= line_cache.one_past_last_pos){
                Profile_Scope_Block profile_block_203 ((app), SCu8((u8*)("get line number"), (u64)(sizeof("get line number") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "203" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "203" ":") - 1)));
                line_cache.where_token_starts = get_line_number_from_pos(app, buffer, token->pos);
                line_cache.one_past_last_pos = get_line_end_pos(app, buffer, line_cache.where_token_starts);
            }

            i64 current_indent = 0;
            if (nest != 0){
                current_indent = nest->indent;
            }
            i64 this_indent = current_indent;
            i64 following_indent = current_indent;

            b32 shift_by_actual_indent = false;
            b32 ignore_unfinished_statement = false;
            if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                this_indent = 0;
            }
            else{
                switch (token->kind){
                    case TokenBaseKind_ScopeOpen:
                    {
                        Nest *new_nest = indent__new_nest(arena, &nest_alloc);
                        ((new_nest)->next=(nest),(nest)=(new_nest));
                        nest->kind = TokenBaseKind_ScopeOpen;
                        nest->indent = current_indent + indent_width;
                        following_indent = nest->indent;
                        ignore_unfinished_statement = true;
                    }break;

                    case TokenBaseKind_ScopeClose:
                    {
                        for (;nest != 0 && nest->kind != TokenBaseKind_ScopeOpen;){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        if (nest != 0 && nest->kind == TokenBaseKind_ScopeOpen){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        this_indent = 0;
                        if (nest != 0){
                            this_indent = nest->indent;
                        }
                        following_indent = this_indent;
                        ignore_unfinished_statement = true;
                    }break;

                    case TokenBaseKind_ParentheticalOpen:
                    {
                        Nest *new_nest = indent__new_nest(arena, &nest_alloc);
                        ((new_nest)->next=(nest),(nest)=(new_nest));
                        nest->kind = TokenBaseKind_ParentheticalOpen;
                        line_indent_cache_update(app, buffer, tab_width, &line_cache);
                        nest->indent = (token->pos - line_cache.indent_info.first_char_pos) + 1;
                        following_indent = nest->indent;
                        shift_by_actual_indent = true;
                        ignore_unfinished_statement = true;
                    }break;

                    case TokenBaseKind_ParentheticalClose:
                    {
                        if (nest != 0 && nest->kind == TokenBaseKind_ParentheticalOpen){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        following_indent = 0;
                        if (nest != 0){
                            following_indent = nest->indent;
                        }

                    }break;
                }

                if (token->sub_kind == TokenCppKind_BlockComment ||
                    token->sub_kind == TokenCppKind_LiteralStringRaw){
                    ignore_unfinished_statement = true;
                }

                if (in_unfinished_statement && !ignore_unfinished_statement){
                    this_indent += indent_width;
                }
            }






            i64 line_it = line_last_indented;
            if (lines.first <= line_cache.where_token_starts){
                for (;line_it < line_cache.where_token_starts;){
                    line_it += 1;
                    if (line_it == line_cache.where_token_starts){
                        do{ if (lines.first <= line_it){shifted_indentations[line_it]=this_indent;} if (line_it == lines.end){goto finished;} actual_indent = this_indent; }while(0);
                    }
                    else{
                        do{ if (lines.first <= line_it){shifted_indentations[line_it]=last_indent;} if (line_it == lines.end){goto finished;} actual_indent = last_indent; }while(0);
                    }
                }
            }
            else{
                actual_indent = this_indent;
                line_it = line_cache.where_token_starts;
            }

            i64 line_where_token_ends = get_line_number_from_pos(app, buffer, token->pos + token->size);
            if (lines.first <= line_where_token_ends){
                line_indent_cache_update(app, buffer, tab_width, &line_cache);
                i64 line_where_token_starts_shift = this_indent - line_cache.indent_info.indent_pos;
                for (;line_it < line_where_token_ends;){
                    line_it += 1;
                    i64 line_it_start_pos = get_line_start_pos(app, buffer, line_it);
                    Indent_Info line_it_indent_info = get_indent_info_line_number_and_start(app, buffer, line_it, line_it_start_pos, tab_width);
                    i64 new_indent = line_it_indent_info.indent_pos + line_where_token_starts_shift;
                    new_indent = (((0)>(new_indent))?(0):(new_indent));
                    do{ if (lines.first <= line_it){shifted_indentations[line_it]=new_indent;} if (line_it == lines.end){goto finished;} actual_indent = new_indent; }while(0);
                }
            }
            else{
                line_it = line_where_token_ends;
            }


            if (shift_by_actual_indent){
                nest->indent += actual_indent;
                following_indent += actual_indent;
            }

            if (token->kind != TokenBaseKind_Comment){
                in_unfinished_statement = indent__unfinished_statement(token, nest);
                if (in_unfinished_statement){
                    following_indent += indent_width;
                }
            }

            last_indent = following_indent;
            line_last_indented = line_it;

            if (!token_it_inc_non_whitespace(&token_it)){
                break;
            }
        }
    }

    finished:;
    return(indentations);
}

static b32
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos, Indent_Flag flags, i32 tab_width, i32 indent_width){
    Profile_Scope_Block profile_block_356 ((app), SCu8((u8*)("auto indent buffer"), (u64)(sizeof("auto indent buffer") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "356" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "356" ":") - 1)));
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Token_Array *tokens = &token_array;

    b32 result = false;
    if (tokens->tokens != 0){
        result = true;

        Scratch_Block scratch(app);
        Range_i64 line_numbers = {};
        if ((((flags)&(Indent_FullTokens))!=0)){
            i32 safety_counter = 0;
            for (;;){
                Range_i64 expanded = enclose_tokens(app, buffer, pos);
                expanded = enclose_whole_lines(app, buffer, expanded);
                if (expanded == pos){
                    break;
                }
                pos = expanded;
                safety_counter += 1;
                if (safety_counter == 20){
                    pos = buffer_range(app, buffer);
                    break;
                }
            }
        }
        line_numbers = get_line_range_from_pos_range(app, buffer, pos);

        i64 *indentations = get_indentation_array(app, scratch, buffer, line_numbers, flags, tab_width, indent_width);
        set_line_indents(app, scratch, buffer, line_numbers, indentations, flags, tab_width);
    }

    return(result);
}

static void
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos, Indent_Flag flags){
    i32 indent_width = (i32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("indent_width"), (u64)(sizeof("indent_width") - 1))));
    i32 tab_width = (i32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
    tab_width = (((1)>(tab_width))?(1):(tab_width));
    ((flags)|=(Indent_FullTokens));
    b32 indent_with_tabs = def_get_config_b32(vars_save_string(SCu8((u8*)("indent_with_tabs"), (u64)(sizeof("indent_with_tabs") - 1))));
    if (indent_with_tabs){
        ((flags)|=(Indent_UseTab));
    }
    auto_indent_buffer(app, buffer, pos, flags, indent_width, tab_width);
}

static void
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos){
    auto_indent_buffer(app, buffer, pos, 0);
}



CUSTOM_COMMAND(auto_indent_whole_file, "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp", 411, Normal)
CUSTOM_DOC("Audo-indents the entire current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 buffer_size = buffer_get_size(app, buffer);
    auto_indent_buffer(app, buffer, Ii64(0, buffer_size));
}

CUSTOM_COMMAND(auto_indent_line_at_cursor, "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp", 420, Normal)
CUSTOM_DOC("Auto-indents the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    auto_indent_buffer(app, buffer, Ii64(pos));
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(auto_indent_range, "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp", 430, Normal)
CUSTOM_DOC("Auto-indents the range between the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    auto_indent_buffer(app, buffer, range);
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(write_text_and_auto_indent, "/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp", 440, Normal)
CUSTOM_DOC("Inserts text and auto-indents the line on which the cursor sits if any of the text contains 'layout punctuation' such as ;:{}()[]# and new lines.")
{
    Profile_Scope_Block profile_block_443 ((app), SCu8((u8*)("write and auto indent"), (u64)(sizeof("write and auto indent") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "443" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_auto_indent.cpp" ":" "443" ":") - 1)));
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    if (insert.str != 0 && insert.size > 0){
        b32 do_auto_indent = false;
        for (u64 i = 0; !do_auto_indent && i < insert.size; i += 1){
            switch (insert.str[i]){
                case ';': case ':':
                case '{': case '}':
                case '(': case ')':
                case '[': case ']':
                case '#':
                case '\n': case '\t':
                {
                    do_auto_indent = true;
                }break;
            }
        }
        if (do_auto_indent){
            View_ID view = get_active_view(app, Access_ReadWriteVisible);
            Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

            Range_i64 pos = {};
            if (view_has_highlighted_range(app, view)){
                pos = get_view_range(app, view);
            }
            else{
                pos.min = pos.max = view_get_cursor_pos(app, view);
            }

            write_text_input(app);

            i64 end_pos = view_get_cursor_pos(app, view);
            pos.min = (((pos.min)<(end_pos))?(pos.min):(end_pos));
            pos.max = (((pos.max)>(end_pos))?(pos.max):(end_pos));

            auto_indent_buffer(app, buffer, pos, 0);
            move_past_lead_whitespace(app, view, buffer);
        }
        else{
            write_text_input(app);
        }
    }
}
# 121 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" 1







static String_Const_u8 search_name = SCu8((u8*)("*search*"), (u64)(sizeof("*search*") - 1));

static void
print_string_match_list_to_buffer(Application_Links *app, Buffer_ID out_buffer_id, String_Match_List matches){
    Scratch_Block scratch(app);
    clear_buffer(app, out_buffer_id);
    Buffer_Insertion out = begin_buffer_insertion_at_buffered(app, out_buffer_id, 0, scratch, ((64) << 10));
    buffer_set_setting(app, out_buffer_id, BufferSetting_ReadOnly, true);
    buffer_set_setting(app, out_buffer_id, BufferSetting_RecordsHistory, false);

    Temp_Memory buffer_name_restore_point = begin_temp(scratch);
    String_Const_u8 current_file_name = {};
    Buffer_ID current_buffer = 0;

    if (matches.first != 0){
        for (String_Match *node = matches.first;
             node != 0;
             node = node->next){
            if (node->buffer != out_buffer_id){
                if (current_buffer != 0 && current_buffer != node->buffer){
                    insertc(&out, '\n');
                }
                if (current_buffer != node->buffer){
                    end_temp(buffer_name_restore_point);
                    current_buffer = node->buffer;
                    current_file_name = push_buffer_file_name(app, scratch, current_buffer);
                    if (current_file_name.size == 0){
                        current_file_name = push_buffer_unique_name(app, scratch, current_buffer);
                    }
                }

                Buffer_Cursor cursor = buffer_compute_cursor(app, current_buffer, seek_pos(node->range.first));
                Temp_Memory line_temp = begin_temp(scratch);
                String_Const_u8 full_line_str = push_buffer_line(app, scratch, current_buffer, cursor.line);
                String_Const_u8 line_str = string_skip_chop_whitespace(full_line_str);
                insertf(&out, "%.*s:%d:%d: %.*s\n",
                        (i32)(current_file_name).size, (char*)(current_file_name).str, cursor.line, cursor.col,
                        (i32)(line_str).size, (char*)(line_str).str);
                end_temp(line_temp);
            }
        }
    }
    else{
        insertf(&out, "no matches");
    }

    end_buffer_insertion(&out);
}

static void
print_all_matches_all_buffers(Application_Links *app, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, Buffer_ID out_buffer_id){
    Scratch_Block scratch(app);
    String_Match_List matches = find_all_matches_all_buffers(app, scratch, match_patterns, must_have_flags, must_not_have_flags);
    string_match_list_filter_remove_buffer(&matches, out_buffer_id);
    string_match_list_filter_remove_buffer_predicate(app, &matches, buffer_has_name_with_star);
    print_string_match_list_to_buffer(app, out_buffer_id, matches);
}

static void
print_all_matches_all_buffers(Application_Links *app, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, Buffer_ID out_buffer_id){
    String_Const_u8_Array array = {&pattern, 1};
    print_all_matches_all_buffers(app, array, must_have_flags, must_not_have_flags, out_buffer_id);
}

static void
print_all_matches_all_buffers_to_search(Application_Links *app, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, View_ID default_target_view){
    Buffer_ID search_buffer = create_or_switch_to_buffer_and_clear_by_name(app, search_name, default_target_view);
    print_all_matches_all_buffers(app, match_patterns, must_have_flags, must_not_have_flags, search_buffer);
}

static void
print_all_matches_all_buffers_to_search(Application_Links *app, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, View_ID default_target_view){
    String_Const_u8_Array array = {&pattern, 1};
    print_all_matches_all_buffers_to_search(app, array, must_have_flags, must_not_have_flags, default_target_view);
}

static String_Const_u8
query_user_list_needle(Application_Links *app, Arena *arena){
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "86" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "86" ":") - 1)))));
    return(get_query_string(app, "List Locations For: ", space, ((1) << 10)));
}

static String_Const_u8_Array
user_list_definition_array(Application_Links *app, Arena *arena, String_Const_u8 base_needle){
    String_Const_u8_Array result = {};
    if (base_needle.size > 0){
        result.count = 12;
        result.vals = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(result.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "95" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "95" ":") - 1)))));
        i32 i = 0;
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s\n{", (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s\r\n{", (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s\r\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s\r\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        do{ if (!(i == result.count)) { (*((i32*)0) = 0xA11E); } }while(0);
    }
    return(result);
}

static String_Const_u8_Array
query_user_list_definition_needle(Application_Links *app, Arena *arena){
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "116" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "116" ":") - 1)))));
    String_Const_u8 base_needle = get_query_string(app, "List Definitions For: ", space, ((1) << 10));
    return(user_list_definition_array(app, arena, base_needle));
}

static void
list_all_locations__generic(Application_Links *app, String_Const_u8_Array needle, List_All_Locations_Flag flags){
    if (needle.count > 0){
        View_ID target_view = get_next_view_after_active(app, Access_Always);
        String_Match_Flag must_have_flags = 0;
        String_Match_Flag must_not_have_flags = 0;
        if ((((flags)&(ListAllLocationsFlag_CaseSensitive))!=0)){
            ((must_have_flags)|=(StringMatch_CaseSensitive));
        }
        if (!(((flags)&(ListAllLocationsFlag_MatchSubstring))!=0)){
            ((must_not_have_flags)|=(StringMatch_LeftSideSloppy));
            ((must_not_have_flags)|=(StringMatch_RightSideSloppy));
        }
        print_all_matches_all_buffers_to_search(app, needle, must_have_flags, must_not_have_flags, target_view);
    }
}

static void
list_all_locations__generic(Application_Links *app, String_Const_u8 needle, List_All_Locations_Flag flags){
    if (needle.size != 0){
        String_Const_u8_Array array = {&needle, 1};
        list_all_locations__generic(app, array, flags);
    }
}

static void
list_all_locations__generic_query(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "149" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "149" ":") - 1)))));
    String_Const_u8 needle = get_query_string(app, "List Locations For: ", space, ((1) << 10));
    list_all_locations__generic(app, needle, flags);
}

static void
list_all_locations__generic_identifier(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    String_Const_u8 needle = push_token_or_word_under_active_cursor(app, scratch);
    list_all_locations__generic(app, needle, flags);
}

static void
list_all_locations__generic_view_range(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    String_Const_u8 needle = push_view_range_string(app, scratch);
    list_all_locations__generic(app, needle, flags);
}

CUSTOM_COMMAND(list_all_locations, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 168, Normal)
CUSTOM_DOC("Queries the user for a string and lists all exact case-sensitive matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_substring_locations, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 174, Normal)
CUSTOM_DOC("Queries the user for a string and lists all case-sensitive substring matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_case_insensitive, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 180, Normal)
CUSTOM_DOC("Queries the user for a string and lists all exact case-insensitive matches found in all open buffers.")
{
    list_all_locations__generic_query(app, 0);
}

CUSTOM_COMMAND(list_all_substring_locations_case_insensitive, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 186, Normal)
CUSTOM_DOC("Queries the user for a string and lists all case-insensitive substring matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_identifier, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 192, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all exact case-sensitive mathces in all open buffers.")
{
    list_all_locations__generic_identifier(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_locations_of_identifier_case_insensitive, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 198, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all exact case-insensitive mathces in all open buffers.")
{
    list_all_locations__generic_identifier(app, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_selection, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 204, Normal)
CUSTOM_DOC("Reads the string in the selected range and lists all exact case-sensitive mathces in all open buffers.")
{
    list_all_locations__generic_view_range(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_locations_of_selection_case_insensitive, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 210, Normal)
CUSTOM_DOC("Reads the string in the selected range and lists all exact case-insensitive mathces in all open buffers.")
{
    list_all_locations__generic_view_range(app, 0);
}

CUSTOM_COMMAND(list_all_locations_of_type_definition, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 216, Normal)
CUSTOM_DOC("Queries user for string, lists all locations of strings that appear to define a type whose name matches the input string.")
{
    Scratch_Block scratch(app);
    String_Const_u8_Array array = query_user_list_definition_needle(app, scratch);
    list_all_locations__generic(app, array, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_type_definition_of_identifier, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 224, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all locations of strings that appear to define a type whose name matches it.")
{
    Scratch_Block scratch(app);
    String_Const_u8 base_needle = push_token_or_word_under_active_cursor(app, scratch);
    String_Const_u8_Array array = user_list_definition_array(app, scratch, base_needle);
    list_all_locations__generic(app, array, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

static Range_i64
get_word_complete_needle_range(Application_Links *app, Buffer_ID buffer, i64 pos){
    Range_i64 needle_range = {};
    needle_range.max = pos;
    needle_range.min = scan(app, boundary_alpha_numeric_underscore_utf8, buffer, Scan_Backward, pos);
    i64 e = scan(app, boundary_alpha_numeric_underscore_utf8, buffer, Scan_Forward, needle_range.min);
    if (pos > e){
        needle_range = Ii64(pos);
    }
    return(needle_range);
}

static void
string_match_list_enclose_all(Application_Links *app, String_Match_List list,
                              Enclose_Function *enclose){
    for (String_Match *node = list.first;
         node != 0;
         node = node->next){
        node->range = enclose(app, node->buffer, node->range);
    }
}

static String_Match_Flag complete_must = (StringMatch_CaseSensitive|
                                          StringMatch_RightSideSloppy);
static String_Match_Flag complete_must_not = StringMatch_LeftSideSloppy;

static String_Match_List
get_complete_list_raw(Application_Links *app, Arena *arena, Buffer_ID buffer,
                      Range_i64 needle_range, String_Const_u8 needle){
    static Character_Predicate *pred =
        &character_predicate_alpha_numeric_underscore_utf8;

    String_Match_List result = {};
    i64 size = buffer_get_size(app, buffer);
    if (range_size(needle_range) > 0){
        String_Match_List up = buffer_find_all_matches(app, arena, buffer, 0,
                                                       Ii64(0, needle_range.min),
                                                       needle, pred, Scan_Backward);
        String_Match_List down = buffer_find_all_matches(app, arena, buffer, 0,
                                                         Ii64(needle_range.max, size),
                                                         needle, pred, Scan_Forward);
        string_match_list_filter_flags(&up, complete_must, complete_must_not);
        string_match_list_filter_flags(&down, complete_must, complete_must_not);
        result = string_match_list_merge_nearest(&up, &down, needle_range);
    }
    else{
        result = buffer_find_all_matches(app, arena, buffer, 0,
                                         Ii64(0, size), needle, pred, Scan_Forward);
        string_match_list_filter_flags(&result, complete_must, complete_must_not);
    }

    string_match_list_enclose_all(app, result,
                                  right_enclose_alpha_numeric_underscore_utf8);
    return(result);
}

static void
word_complete_list_extend_from_raw(Application_Links *app, Arena *arena, String_Match_List *matches, List_String_Const_u8 *list, Table_Data_u64 *used_table){
    Profile_Scope_Block profile_block_291 ((app), SCu8((u8*)("word complete list extend from raw"), (u64)(sizeof("word complete list extend from raw") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "291" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "291" ":") - 1)));
    Scratch_Block scratch(app);
    for (String_Match *node = matches->first;
         node != 0;
         node = node->next){
        String_Const_u8 s = push_buffer_range(app, scratch, node->buffer, node->range);
        Table_Lookup lookup = table_lookup(used_table, s);
        if (!lookup.found_match){
            String_Const_u8 data = push_data_copy(arena, s);
            table_insert(used_table, data, 1);
            string_list_push(arena, list, data);
        }
    }
}

static void
word_complete_iter_init__inner(Buffer_ID buffer, String_Const_u8 needle, Range_i64 range, Word_Complete_Iterator *iter){
    Application_Links *app = iter->app;
    Arena *arena = iter->arena;

    Base_Allocator *allocator = get_base_allocator_system();
    if (iter->already_used_table.allocator != 0){
        end_temp(iter->arena_restore);
        table_clear(&iter->already_used_table);
    }

    block_zero((iter), sizeof(*(iter)));
    iter->app = app;
    iter->arena = arena;

    iter->arena_restore = begin_temp(arena);
    iter->needle = push_string_copy(arena, needle);
    iter->first_buffer = buffer;
    iter->current_buffer = buffer;

    Scratch_Block scratch(app, arena);
    String_Match_List list = get_complete_list_raw(app, scratch, buffer, range, needle);

    iter->already_used_table = make_table_Data_u64__inner((allocator),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "329" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "329" ":") - 1)));
    word_complete_list_extend_from_raw(app, arena, &list, &iter->list, &iter->already_used_table);

    iter->scan_all_buffers = true;
}

static void
word_complete_iter_init(Buffer_ID buffer, Range_i64 range, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        Application_Links *app = iter->app;
        Arena *arena = iter->arena;
        Scratch_Block scratch(app, arena);
        String_Const_u8 needle = push_buffer_range(app, scratch, buffer, range);
        word_complete_iter_init__inner(buffer, needle, range, iter);
    }
}

static void
word_complete_iter_init(Buffer_ID first_buffer, String_Const_u8 needle, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        word_complete_iter_init__inner(first_buffer, needle, Ii64(), iter);
    }
}

static void
word_complete_iter_init(String_Const_u8 needle, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        Application_Links *app = iter->app;
        Buffer_ID first_buffer = get_buffer_next(app, 0, Access_Read);
        word_complete_iter_init__inner(first_buffer, needle, Ii64(), iter);
    }
}

static void
word_complete_iter_stop_on_this_buffer(Word_Complete_Iterator *iter){
    iter->scan_all_buffers = false;
}

static void
word_complete_iter_next(Word_Complete_Iterator *it){
    for (;;){
        if (it->node == 0){
            it->node = it->list.first;
        }
        else{
            it->node = it->node->next;
        }

        if (it->node != 0){
            break;
        }

        if (!it->scan_all_buffers){
            break;
        }

        Application_Links *app = it->app;
        Buffer_ID next = get_buffer_next_looped(app, it->current_buffer, Access_Read);
        if (next == it->first_buffer){
            break;
        }

        it->node = it->list.last;
        it->current_buffer = next;
        Scratch_Block scratch(app);
        String_Match_List list = get_complete_list_raw(app, scratch,
                                                       next, Ii64(), it->needle);
        word_complete_list_extend_from_raw(app, it->arena, &list,
                                           &it->list, &it->already_used_table);
    }
}

static String_Const_u8
word_complete_iter_read(Word_Complete_Iterator *it){
    String_Const_u8 result = {};
    if (it->node == 0){
        result = it->needle;
    }
    else{
        result = it->node->string;
    }
    return(result);
}


static b32
word_complete_iter_is_at_base_slot(Word_Complete_Iterator *it){
    return(it->node == 0);
}

static Word_Complete_Iterator*
word_complete_get_shared_iter(Application_Links *app){
    static Arena completion_arena = {};
    static Word_Complete_Iterator it = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        completion_arena = make_arena_system();
    }
    it.app = app;
    it.arena = &completion_arena;
    return(&it);
}

CUSTOM_COMMAND(word_complete, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 433, Normal)
CUSTOM_DOC("Iteratively tries completing the word to the left of the cursor with other words in open buffers that have the same prefix string.")
{
    Profile_Scope_Block profile_block_436 ((app), SCu8((u8*)("word complete"), (u64)(sizeof("word complete") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "436" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "436" ":") - 1)));

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Managed_Scope scope = view_get_managed_scope(app, view);

        b32 first_completion = false;
        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (*rewrite != Rewrite_WordComplete){
            first_completion = true;
        }

        set_next_rewrite(app, view, Rewrite_WordComplete);

        Word_Complete_Iterator *it = word_complete_get_shared_iter(app);
        static b32 initialized = false;
        static Range_i64 range = {};

        if (first_completion || !initialized){
            Profile_Block profile_block_456 ((app), SCu8((u8*)("word complete state init"), (u64)(sizeof("word complete state init") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "456" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "456" ":") - 1)));
            initialized = false;
            i64 pos = view_get_cursor_pos(app, view);
            Range_i64 needle_range = get_word_complete_needle_range(app, buffer, pos);
            if (range_size(needle_range) > 0){
                initialized = true;
                range = needle_range;
                word_complete_iter_init(buffer, needle_range, it);
            }
        }

        if (initialized){
            Profile_Block profile_block_468 ((app), SCu8((u8*)("word complete apply"), (u64)(sizeof("word complete apply") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "468" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search.cpp" ":" "468" ":") - 1)));

            word_complete_iter_next(it);
            String_Const_u8 str = word_complete_iter_read(it);

            buffer_replace_range(app, buffer, range, str);

            range.max = range.min + str.size;
            view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
        }
    }
}

static Word_Complete_Menu
make_word_complete_menu(Render_Caller_Function *prev_render_caller, Word_Complete_Iterator *it){
    Word_Complete_Menu menu = {};
    menu.prev_render_caller = prev_render_caller;
    menu.it = it;
    return(menu);
}

static void
word_complete_menu_next(Word_Complete_Menu *menu){
    i32 count = 0;
    for (i32 i = 0; i < ((sizeof(menu->options))/(sizeof(*menu->options))); i += 1){
        word_complete_iter_next(menu->it);
        if (word_complete_iter_is_at_base_slot(menu->it)){
            break;
        }
        else{
            menu->options[i] = word_complete_iter_read(menu->it);
            count += 1;
        }
    }
    menu->count = count;
}

static void
word_complete_menu_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Word_Complete_Menu **menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
    Word_Complete_Menu *menu = *menu_ptr;

    if (menu != 0){
        menu->prev_render_caller(app, frame_info, view);

        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        Face_ID face = get_face_id(app, buffer);

        Scratch_Block scratch(app);

        Fancy_Block block = {};
        for (i32 i = 0; i < menu->count; i += 1){
            if (menu->options[i].size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, face);
                push_fancy_stringf(scratch, line, fcolor_id(defcolor_pop1), "F%d:", i + 1);
                push_fancy_string(scratch, line, fcolor_id(defcolor_text_default), menu->options[i]);
            }
        }

        Rect_f32 region = view_get_buffer_region(app, view);

        Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
        Buffer_Point buffer_point = scroll.position;
        i64 pos = view_get_cursor_pos(app, view);
        Vec2_f32 cursor_p = view_relative_xy_of_pos(app, view, buffer_point.line_number, pos);
        cursor_p -= buffer_point.pixel_shift;
        cursor_p += region.p0;

        Face_Metrics metrics = get_face_metrics(app, face);
        f32 x_padding = metrics.normal_advance;
        f32 x_half_padding = x_padding*0.5f;

        draw_drop_down(app, face, &block, cursor_p, region, x_padding, x_half_padding,
                       fcolor_id(defcolor_margin_hover), fcolor_id(defcolor_back));
    }
}

static Edit
get_word_complete_from_user_drop_down(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    Render_Caller_Function *prev_render_caller = ctx.render_caller;

    Edit result = {};

    Word_Complete_Iterator *it = word_complete_get_shared_iter(app);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_word_complete_needle_range(app, buffer, pos);
    if (range_size(range) != 0){
        word_complete_iter_init(buffer, range, it);
        Word_Complete_Menu menu = make_word_complete_menu(prev_render_caller, it);
        word_complete_menu_next(&menu);

        ctx.render_caller = word_complete_menu_render;
        View_Context_Block ctx_block(app, view, &ctx);

        Managed_Scope scope = view_get_managed_scope(app, view);
        Word_Complete_Menu **menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
        *menu_ptr = &menu;

        b32 keep_looping_menu = true;
        for (;keep_looping_menu;){
            User_Input in = get_next_input(app, EventPropertyGroup_Any,
                                           EventProperty_Escape);
            if (in.abort){
                break;
            }

            b32 handled = true;
            switch (in.event.kind){
                case InputEventKind_TextInsert:
                {
                    write_text_input(app);
                    pos = view_get_cursor_pos(app, view);
                    range = get_word_complete_needle_range(app, buffer, pos);
                    if (range_size(range) == 0){
                        keep_looping_menu = false;
                    }
                    else{
                        word_complete_iter_init(buffer, range, it);
                        menu = make_word_complete_menu(prev_render_caller, it);
                        word_complete_menu_next(&menu);
                        if (menu.count == 0){
                            keep_looping_menu = false;
                        }
                    }
                }break;

                case InputEventKind_KeyStroke:
                {
                    switch (in.event.key.code){
                        case KeyCode_Return:
                        {
                            result.text = menu.options[0];
                            result.range = range;
                            keep_looping_menu = false;
                        }break;

                        case KeyCode_Tab:
                        {
                            word_complete_menu_next(&menu);
                        }break;

                        case KeyCode_F1:
                        case KeyCode_F2:
                        case KeyCode_F3:
                        case KeyCode_F4:
                        case KeyCode_F5:
                        case KeyCode_F6:
                        case KeyCode_F7:
                        case KeyCode_F8:
                        {
                            i32 index = (in.event.key.code - KeyCode_F1);
                            result.text = menu.options[index];
                            result.range = range;
                            keep_looping_menu = false;
                        }break;

                        case KeyCode_Backspace:
                        {
                            backspace_char(app);
                            pos = view_get_cursor_pos(app, view);
                            range = get_word_complete_needle_range(app, buffer, pos);
                            if (range_size(range) == 0){
                                keep_looping_menu = false;
                            }
                            else{
                                word_complete_iter_init(buffer, range, it);
                                menu = make_word_complete_menu(prev_render_caller, it);
                                word_complete_menu_next(&menu);
                                if (menu.count == 0){
                                    keep_looping_menu = false;
                                }
                            }
                        }break;

                        default:
                        {
                            leave_current_input_unhandled(app);
                        }break;
                    }
                }break;

                case InputEventKind_MouseButton:
                {
                    leave_current_input_unhandled(app);
                    keep_looping_menu = false;
                }break;

                default:
                {
                    handled = false;
                }break;
            }

            if (!handled){
                leave_current_input_unhandled(app);
            }
        }

        scope = view_get_managed_scope(app, view);
        menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
        *menu_ptr = 0;
    }

    return(result);
}

CUSTOM_COMMAND(word_complete_drop_down, "/home/tabletel/dev/4cc/code/custom/4coder_search.cpp", 679, Normal)
CUSTOM_DOC("Word complete with drop down menu.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Edit edit = get_word_complete_from_user_drop_down(app);
        if (edit.text.size > 0){
            buffer_replace_range(app, buffer, edit.range, edit.text);
            view_set_cursor_and_preferred_x(app, view, seek_pos(edit.range.min + edit.text.size));
        }
    }
}
# 122 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jumping.cpp" 1






static b32
ms_style_verify(String_Const_u8 line, u64 left_paren_pos, u64 right_paren_pos){
    i32 result = false;
    String_Const_u8 line_part = string_skip(line, right_paren_pos);
    if (string_match(string_prefix(line_part, 4), SCu8((u8*)(") : "), (u64)(sizeof(") : ") - 1))) ||
        string_match(string_prefix(line_part, 3), SCu8((u8*)("): "), (u64)(sizeof("): ") - 1)))){
        result = true;
    }
    if (result){
        String_Const_u8 number = string_skip(string_prefix(line, right_paren_pos), left_paren_pos + 1);
        if (!string_is_integer(number, 10)){
            result = false;
            u64 comma_pos = string_find_first(number, ',');
            if (comma_pos < number.size){
                String_Const_u8 sub_number0 = string_prefix(number, comma_pos);
                String_Const_u8 sub_number1 = string_skip(number, comma_pos + 1);
                if (string_is_integer(sub_number0, 10) && string_is_integer(sub_number1, 10)){
                    result = true;
                }
            }
        }
    }
    return(result);
}

static u64
try_skip_rust_arrow(String_Const_u8 line){
    u64 pos = 0;
    if (string_match(string_prefix(line, 3), SCu8((u8*)("-->"), (u64)(sizeof("-->") - 1)))){
        String_Const_u8 sub = string_skip(line, 3);
        sub = string_skip_chop_whitespace(sub);
        pos = (u64)(sub.str - line.str);
    }
    return(pos);
}

static b32
check_is_note(String_Const_u8 line, u64 colon_pos){
    b32 is_note = false;
    u64 note_pos = colon_pos + string_find_first(string_skip(line, colon_pos), SCu8((u8*)("note"), (u64)(sizeof("note") - 1)));
    if (note_pos < line.size){
        b32 is_all_whitespace = true;
        for (u64 i = colon_pos + 1; i < note_pos; i += 1){
            if (!character_is_whitespace(line.str[i])){
                is_all_whitespace = false;
                break;
            }
        }
        if (is_all_whitespace){
            is_note = true;
        }
    }
    return(is_note);
}

static Parsed_Jump
parse_jump_location(String_Const_u8 line){
    Parsed_Jump jump = {};
    jump.sub_jump_indented = (string_get_character(line, 0) == ' ');

    String_Const_u8 reduced_line = string_skip_chop_whitespace(line);
    u64 whitespace_length = (u64)(reduced_line.str - line.str);
    line = reduced_line;

    u64 left_paren_pos = string_find_first(line, '(');
    u64 right_paren_pos = left_paren_pos + string_find_first(string_skip(line, left_paren_pos), ')');
    for (;!jump.is_ms_style && right_paren_pos < line.size;){
        if (ms_style_verify(line, left_paren_pos, right_paren_pos)){
            jump.is_ms_style = true;
            jump.colon_position = (i32)(right_paren_pos + string_find_first(string_skip(line, right_paren_pos), ':'));
            if (jump.colon_position < line.size){
                if (check_is_note(line, jump.colon_position)){
                    jump.sub_jump_note = true;
                }

                String_Const_u8 location_str = string_prefix(line, jump.colon_position);
                location_str = string_skip_chop_whitespace(location_str);

                i32 close_pos = (i32)right_paren_pos;
                i32 open_pos = (i32)left_paren_pos;

                if (0 < open_pos && open_pos < location_str.size){
                    String_Const_u8 file = SCu8(location_str.str, open_pos);
                    file = string_skip_chop_whitespace(file);

                    if (file.size > 0){
                        String_Const_u8 line_number = string_skip(string_prefix(location_str, close_pos), open_pos + 1);
                        line_number = string_skip_chop_whitespace(line_number);

                        if (line_number.size > 0){
                            u64 comma_pos = string_find_first(line_number, ',');
                            if (comma_pos < line_number.size){
                                String_Const_u8 column_number = string_skip(line_number, comma_pos + 1);
                                line_number = string_prefix(line_number, comma_pos);
                                jump.location.line = (i32)string_to_integer(line_number, 10);
                                jump.location.column = (i32)string_to_integer(column_number, 10);
                            }
                            else{
                                jump.location.line = (i32)string_to_integer(line_number, 10);
                                jump.location.column = 0;
                            }
                            jump.location.file = file;
                            jump.colon_position = jump.colon_position + (i32)whitespace_length;
                            jump.success = true;
                        }
                    }
                }
            }
        }
        else{
            left_paren_pos = string_find_first(string_skip(line, left_paren_pos + 1), '(') + left_paren_pos + 1;
            right_paren_pos = string_find_first(string_skip(line, left_paren_pos), ')') + left_paren_pos;
        }
    }

    if (!jump.is_ms_style){
        i32 start = (i32)try_skip_rust_arrow(line);
        if (start != 0){
            jump.has_rust_arrow = true;
        }

        u64 colon_pos1 = string_find_first(string_skip(line, start), ':') + start;
        if (line.size > colon_pos1 + 1){
            if (character_is_slash(string_get_character(line, colon_pos1 + 1))){
                colon_pos1 = string_find_first(string_skip(line, colon_pos1 + 1), ':') + colon_pos1 + 1;
            }
        }

        u64 colon_pos2 = string_find_first(string_skip(line, colon_pos1 + 1), ':') + colon_pos1 + 1;
        u64 colon_pos3 = string_find_first(string_skip(line, colon_pos2 + 1), ':') + colon_pos2 + 1;

        if (colon_pos3 < line.size){
            if (check_is_note(line, colon_pos3)){
                jump.sub_jump_note = true;
            }

            String_Const_u8 file_name = string_skip(string_prefix(line, colon_pos1), start);
            String_Const_u8 line_number = string_skip(string_prefix(line, colon_pos2), colon_pos1 + 1);
            String_Const_u8 column_number = string_skip(string_prefix(line, colon_pos3), colon_pos2 + 1);

            if (file_name.size > 0 && line_number.size > 0 && column_number.size > 0){
                jump.location.file = file_name;
                jump.location.line = (i32)string_to_integer(line_number, 10);
                jump.location.column = (i32)string_to_integer(column_number, 10);
                jump.colon_position = (i32)(colon_pos3 + whitespace_length);
                jump.success = true;
            }
        }
        else{
            if (colon_pos2 < line.size){
                if (check_is_note(line, colon_pos2)){
                    jump.sub_jump_note = true;
                }

                String_Const_u8 file_name = string_prefix(line, colon_pos1);
                String_Const_u8 line_number = string_skip(string_prefix(line, colon_pos2), colon_pos1 + 1);

                if (string_is_integer(line_number, 10)){
                    if (file_name.size > 0 && line_number.size > 0){
                        jump.location.file = file_name;
                        jump.location.line = (i32)string_to_integer(line_number, 10);
                        jump.location.column = 0;
                        jump.colon_position = (i32)(colon_pos3 + whitespace_length);
                        jump.success = true;
                    }
                }
            }
        }
    }

    if (!jump.success){
        block_zero((&jump), sizeof(*(&jump)));
    }
    else{
        jump.is_sub_jump = (jump.sub_jump_indented || jump.sub_jump_note);
    }
    return(jump);
}

static Parsed_Jump
parse_jump_location(String_Const_u8 line, Jump_Flag flags){
    Parsed_Jump jump = parse_jump_location(line);
    if ((((flags)&(JumpFlag_SkipSubs))!=0) && jump.is_sub_jump){
        block_zero((&jump), sizeof(*(&jump)));
    }
    return(jump);
}

static Parsed_Jump
parse_jump_from_buffer_line(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 line, Jump_Flag flags){
    Parsed_Jump jump = {};
    String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
    if (line_str.size > 0){
        jump = parse_jump_location(line_str, flags);
    }
    return(jump);
}



static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, Name_Line_Column_Location *location){
    return(open_file(app, buffer, location->file, false, true));
}

static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, ID_Pos_Jump_Location *location, Access_Flag access){
    *buffer = location->buffer_id;
    return(buffer_exists(app, *buffer));
}

static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, ID_Pos_Jump_Location *location){
    return(get_jump_buffer(app, buffer, location, Access_Always));
}

static View_ID
switch_to_existing_view(Application_Links *app, View_ID view, Buffer_ID buffer){
    Buffer_ID current_buffer = view_get_buffer(app, view, Access_Always);
    if (view != 0 || current_buffer != buffer){
        View_ID existing_view = get_first_view_with_buffer(app, buffer);
        if (existing_view != 0){
            view = existing_view;
        }
    }
    return(view);
}

static void
set_view_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, Buffer_Seek seek){
    Buffer_ID current_buffer = view_get_buffer(app, view, Access_Always);
    if (current_buffer != buffer){
        view_set_buffer(app, view, buffer, 0);
    }
    view_set_cursor_and_preferred_x(app, view, seek);
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, i64 pos){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_pos(pos));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer,
                 Name_Line_Column_Location location){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_line_col(location.line, location.column));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view,
                 Name_Line_Column_Location location){
    Buffer_ID buffer = 0;
    if (get_jump_buffer(app, &buffer, &location)){
        jump_to_location(app, view, buffer, location);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, ID_Pos_Jump_Location location){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_pos(location.pos));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, String_Const_u8 location){
    Parsed_Jump jump = parse_jump_location(location);
    if (jump.success){
        jump_to_location(app, view, jump.location);
    }
}




static Parsed_Jump
seek_next_jump_in_buffer(Application_Links *app, Arena *arena,
                         Buffer_ID buffer, i64 first_line, Jump_Flag flags, Scan_Direction direction,
                         i64 *line_out){
    do{ if (!(direction == 1 || direction == -1)) { (*((i32*)0) = 0xA11E); } }while(0);
    Parsed_Jump jump = {};
    i64 line = first_line;
    for (;;){
        if (is_valid_line(app, buffer, line)){
            String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
            jump = parse_jump_location(line_str, flags);
            if (jump.success){
                break;
            }
            line += direction;
        }
        else{
            break;
        }
    }
    if (jump.success){
        *line_out = (((line)>(0))?(line):(0));
    }
    return(jump);
}

static ID_Line_Column_Jump_Location
convert_name_based_to_id_based(Application_Links *app, Name_Line_Column_Location loc){
    ID_Line_Column_Jump_Location result = {};
    Buffer_ID buffer = get_buffer_by_name(app, loc.file, Access_Always);
    if (buffer != 0){
        result.buffer_id = buffer;
        result.line = loc.line;
        result.column = loc.column;
    }
    return(result);
}

static Parsed_Jump
seek_next_jump_in_view(Application_Links *app, Arena *arena, View_ID view, i32 skip_sub_errors, Scan_Direction direction, i64 *line_out){
    i64 cursor_position = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(cursor_position));
    i64 line = cursor.line;
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Parsed_Jump jump = seek_next_jump_in_buffer(app, arena, buffer, line + direction, skip_sub_errors, direction, &line);
    if (jump.success){
        *line_out = line;
    }
    return(jump);
}

static b32
skip_this_jump(ID_Line_Column_Jump_Location prev, ID_Line_Column_Jump_Location jump){
    b32 result = false;
    if (prev.buffer_id != 0 && prev.buffer_id == jump.buffer_id && prev.line == jump.line && prev.column <= jump.column){
        result = true;
    }
    return(result);
}
# 123 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" 1







static Marker_List_Node *marker_list_first = 0;
static Marker_List_Node *marker_list_last = 0;



static i32
binary_search(i64 *array, i32 stride, i32 count, i64 x){
    u8 *raw = (u8*)array;
    i32 i = 0;
    i32 first = 0;
    i32 last = count;
    if (first < last){
        for (;;){
            i = (first + last)/2;
            i64 k = *(i64*)(raw + stride*i);
            if (k < x){
                first = i;
            }
            else if (k > x){
                last = i;
            }
            else{
                break;
            }
            if (first + 1 >= last){
                i = first;
                break;
            }
        }
    }
    return(i);
}

static Sticky_Jump_Array
parse_buffer_to_jump_array(Application_Links *app, Arena *arena, Buffer_ID buffer){
    Sticky_Jump_Node *jump_first = 0;;
    Sticky_Jump_Node *jump_last = 0;
    i32 jump_count = 0;

    for (i32 line = 1;; line += 1){
        b32 output_jump = false;
        i32 colon_index = 0;
        b32 is_sub_error = false;
        Buffer_ID out_buffer_id = 0;
        i64 out_pos = 0;

        {
            Temp_Memory_Block line_auto_closer(arena);
            if (is_valid_line(app, buffer, line)){
                String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
                Parsed_Jump parsed_jump = parse_jump_location(line_str);
                if (parsed_jump.success){
                    Buffer_ID jump_buffer = {};
                    if (open_file(app, &jump_buffer, parsed_jump.location.file, false, true)){
                        if (buffer_exists(app, jump_buffer)){
                            Buffer_Cursor cursor = buffer_compute_cursor(app, jump_buffer, seek_jump(parsed_jump));
                            if (cursor.line > 0){
                                out_buffer_id = jump_buffer;
                                out_pos = cursor.pos;
                                output_jump = true;
                            }
                        }
                    }
                }
            }
            else{
                break;
            }
        }

        if (output_jump){
            Sticky_Jump_Node *jump = ((Sticky_Jump_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "79" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "79" ":") - 1)))));
            do{ if((jump)){if((jump_first)){(jump_last)->next=(jump);}else{(jump_first)=(jump);}(jump_last)=(jump);(jump_last)->next=0;} }while(0);
            jump_count += 1;
            jump->jump.list_line = line;
            jump->jump.list_colon_index = colon_index;
            jump->jump.is_sub_error = is_sub_error;
            jump->jump.jump_buffer_id = out_buffer_id;
            jump->jump.jump_pos = out_pos;
        }
    }

    Sticky_Jump_Array result = {};
    result.count = jump_count;
    result.jumps = ((Sticky_Jump*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump)*(result.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "92" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "92" ":") - 1)))));
    i32 index = 0;
    for (Sticky_Jump_Node *node = jump_first;
         node != 0;
         node = node->next){
        result.jumps[index] = node->jump;
        index += 1;
    }

    return(result);
}

static void
init_marker_list(Application_Links *app, Heap *heap, Buffer_ID buffer, Marker_List *list){
    Scratch_Block scratch(app);

    Sticky_Jump_Array jumps = parse_buffer_to_jump_array(app, scratch, buffer);
    Range_i32_Array buffer_ranges = get_ranges_of_duplicate_keys(scratch, &jumps.jumps->jump_buffer_id, sizeof(*jumps.jumps), jumps.count);
    Sort_Pair_i32 *range_index_buffer_id_pairs = ((Sort_Pair_i32*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Sort_Pair_i32)*(buffer_ranges.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "110" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "110" ":") - 1)))));
    for (i32 i = 0; i < buffer_ranges.count; i += 1){
        range_index_buffer_id_pairs[i].index = i;
        range_index_buffer_id_pairs[i].key = jumps.jumps[buffer_ranges.ranges[i].first].jump_buffer_id;
    }
    sort_pairs_by_key(range_index_buffer_id_pairs, buffer_ranges.count);
    Range_i32_Array scoped_buffer_ranges = get_ranges_of_duplicate_keys(scratch,
                                                                        &range_index_buffer_id_pairs->key,
                                                                        sizeof(*range_index_buffer_id_pairs),
                                                                        buffer_ranges.count);

    Sticky_Jump_Stored *stored = ((Sticky_Jump_Stored*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Sticky_Jump_Stored)*(jumps.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "121" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "121" ":") - 1)))));

    Managed_Scope scope_array[2] = {};
    scope_array[0] = buffer_get_managed_scope(app, buffer);

    for (i32 i = 0; i < scoped_buffer_ranges.count; i += 1){
        Range_i32 buffer_range_indices = scoped_buffer_ranges.ranges[i];

        u32 total_jump_count = 0;
        for (i32 j = buffer_range_indices.first;
             j < buffer_range_indices.one_past_last;
             j += 1){
            i32 range_index = range_index_buffer_id_pairs[j].index;
            Range_i32 range = buffer_ranges.ranges[range_index];
            total_jump_count += range_size(range);
        }

        Temp_Memory marker_temp = begin_temp(scratch);
        Marker *markers = ((Marker*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Marker)*(total_jump_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "139" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "139" ":") - 1)))));
        Buffer_ID target_buffer_id = 0;
        u32 marker_index = 0;
        for (i32 j = buffer_range_indices.first;
             j < buffer_range_indices.one_past_last;
             j += 1){
            i32 range_index = range_index_buffer_id_pairs[j].index;
            Range_i32 range = buffer_ranges.ranges[range_index];
            if (target_buffer_id == 0){
                target_buffer_id = jumps.jumps[range.first].jump_buffer_id;
            }
            for (i32 k = range.first; k < range.one_past_last; k += 1){
                markers[marker_index].pos = jumps.jumps[k].jump_pos;
                markers[marker_index].lean_right = false;
                stored[k].list_line = jumps.jumps[k].list_line;
                stored[k].list_colon_index = jumps.jumps[k].list_colon_index;
                stored[k].is_sub_error = jumps.jumps[k].is_sub_error;
                stored[k].jump_buffer_id = jumps.jumps[k].jump_buffer_id;
                stored[k].index_into_marker_array = marker_index;
                marker_index += 1;
            }
        }

        scope_array[1] = buffer_get_managed_scope(app, target_buffer_id);
        Managed_Scope scope = get_managed_scope_with_multiple_dependencies(app, scope_array, ((sizeof(scope_array))/(sizeof(*scope_array))));
        Managed_Object marker_handle = alloc_buffer_markers_on_buffer(app, target_buffer_id, total_jump_count, &scope);
        managed_object_store_data(app, marker_handle, 0, total_jump_count, markers);

        end_temp(marker_temp);

        do{ if (!(managed_object_get_item_size(app, marker_handle) == sizeof(Marker))) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(managed_object_get_item_count(app, marker_handle) == total_jump_count)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(managed_object_get_type(app, marker_handle) == ManagedObjectType_Markers)) { (*((i32*)0) = 0xA11E); } }while(0);

        Managed_Object *marker_handle_ptr = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));
        if (marker_handle_ptr != 0){
            *marker_handle_ptr = marker_handle;
        }
    }

    Managed_Object stored_jump_array = alloc_managed_memory_in_scope(app, scope_array[0], sizeof(Sticky_Jump_Stored), jumps.count);
    managed_object_store_data(app, stored_jump_array, 0, jumps.count, stored);

    list->jump_array = stored_jump_array;
    list->jump_count = jumps.count;
    list->previous_size = (i32)buffer_get_size(app, buffer);
    list->buffer_id = buffer;
}

static void
delete_marker_list(Marker_List_Node *node){
    (((marker_list_last)==(node))?((((marker_list_first)==(marker_list_last))?((marker_list_first)=(marker_list_last)=0):((marker_list_last)->prev->next=0,(marker_list_last)=(marker_list_last)->prev))) :((marker_list_first)==(node))?((((marker_list_last)==(marker_list_first))?((marker_list_last)=(marker_list_first)=0):((marker_list_first)->next->prev=0,(marker_list_first)=(marker_list_first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
}

static void
delete_marker_list(Marker_List *list){
    delete_marker_list((Marker_List_Node*)( (u8*)(list) - ((u8*)(&(((Marker_List_Node*)0)->list)) - (u8*)(0)) ));
}

static Marker_List*
make_new_marker_list_for_buffer(Heap *heap, i32 buffer_id){
    Marker_List_Node *new_node = (Marker_List_Node*)(heap_allocate((heap), sizeof(Marker_List_Node)*(1)));
    (((marker_list_first)==0)?((new_node)->next=(new_node)->prev=0,(marker_list_first)=(marker_list_last)=(new_node)):((new_node)->prev=(marker_list_last),(new_node)->next=0,(marker_list_last)->next=(new_node),(marker_list_last)=(new_node)));
    new_node->buffer_id = buffer_id;
    block_zero((&new_node->list), sizeof(*(&new_node->list)));
    Marker_List *result = &new_node->list;
    return(result);
}

static Marker_List*
get_marker_list_for_buffer(Buffer_ID buffer_id){
    for (Marker_List_Node *node = marker_list_first;
         node != 0;
         node = node->next){
        if (buffer_id == node->buffer_id){
            return(&node->list);
        }
    }
    return(0);
}

static Marker_List*
get_or_make_list_for_buffer(Application_Links *app, Heap *heap, Buffer_ID buffer_id){
    Marker_List *result = get_marker_list_for_buffer(buffer_id);
    if (result != 0){
        i32 buffer_size = (i32)buffer_get_size(app, buffer_id);

        if (result->previous_size != buffer_size){
            delete_marker_list(result);
            result = 0;
        }
    }
    if (result == 0){
        result = make_new_marker_list_for_buffer(heap, buffer_id);
        init_marker_list(app, heap, buffer_id, result);
        if (result->jump_count == 0){
            delete_marker_list(result);
            result = 0;
        }
    }
    return(result);
}

static b32
get_stored_jump_from_list(Application_Links *app, Marker_List *list, i32 index,
                          Sticky_Jump_Stored *stored_out){
    Sticky_Jump_Stored stored = {};
    if (list != 0){
        if (managed_object_load_data(app, list->jump_array, index, 1, &stored)){
            *stored_out = stored;
            return(true);
        }
    }
    return(false);
}

static Sticky_Jump_Stored*
get_all_stored_jumps_from_list(Application_Links *app, Arena *arena, Marker_List *list){
    Sticky_Jump_Stored *stored = 0;
    if (list != 0){
        Temp_Memory restore_point = begin_temp(arena);
        stored = ((Sticky_Jump_Stored*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump_Stored)*(list->jump_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "260" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp" ":" "260" ":") - 1)))));
        if (stored != 0){
            if (!managed_object_load_data(app, list->jump_array, 0, list->jump_count, stored)){
                stored = 0;
                end_temp(restore_point);
            }
        }
    }
    return(stored);
}

static b32
get_jump_from_list(Application_Links *app, Marker_List *list, i32 index, ID_Pos_Jump_Location *location){
    b32 result = false;
    Sticky_Jump_Stored stored = {};
    if (get_stored_jump_from_list(app, list, index, &stored)){
        Buffer_ID target_buffer_id = stored.jump_buffer_id;

        Managed_Scope scope_array[2] = {};
        scope_array[0] = buffer_get_managed_scope(app, list->buffer_id);
        scope_array[1] = buffer_get_managed_scope(app, target_buffer_id);
        Managed_Scope scope = get_managed_scope_with_multiple_dependencies(app, scope_array, ((sizeof(scope_array))/(sizeof(*scope_array))));

        Managed_Object *marker_array = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));
        if (marker_array != 0 && *marker_array != 0){
            Marker marker = {};
            managed_object_load_data(app, *marker_array, stored.index_into_marker_array, 1, &marker);
            location->buffer_id = target_buffer_id;
            location->pos = marker.pos;
            result = true;
        }
    }
    return(result);
}

static i64
get_line_from_list(Application_Links *app, Marker_List *list, i32 index){
    i64 result = 0;
    if (list != 0){
        Sticky_Jump_Stored stored = {};
        if (get_stored_jump_from_list(app, list, index, &stored)){
            result = stored.list_line;
        }
    }
    return(result);
}

static b32
get_is_sub_error_from_list(Application_Links *app, Marker_List *list, i32 index){
    b32 result = false;
    if (list != 0){
        Sticky_Jump_Stored stored = {};
        if (get_stored_jump_from_list(app, list, index, &stored)){
            result = stored.is_sub_error;
        }
    }
    return(result);
}

static i32
get_index_nearest_from_list(Application_Links *app, Marker_List *list, i64 line){
    i32 result = -1;
    if (list != 0){
        Scratch_Block scratch(app);
        Sticky_Jump_Stored *stored = get_all_stored_jumps_from_list(app, scratch, list);
        if (stored != 0){
            result = binary_search((i64*)&stored->list_line, sizeof(*stored), list->jump_count, line);
        }
    }
    return(result);
}

static i32
get_index_exact_from_list(Application_Links *app, Marker_List *list, i64 line){
    i32 result = -1;
    if (list != 0){
        Scratch_Block scratch(app);
        Sticky_Jump_Stored *stored = get_all_stored_jumps_from_list(app, scratch, list);
        if (stored != 0){
            i32 index = binary_search((i64*)&stored->list_line, sizeof(*stored), list->jump_count, line);
            if (stored[index].list_line == line){
                result = index;
            }
        }
    }
    return(result);
}

CUSTOM_COMMAND(goto_jump_at_cursor, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 348, Normal)
CUSTOM_DOC("If the cursor is found to be on a jump location, parses the jump location and brings up the file and position in another view and changes the active panel to the view containing the jump.")
{
    Heap *heap = &global_heap;

    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));

    i32 list_index = get_index_exact_from_list(app, list, cursor.line);

    if (list_index >= 0){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, list_index, &location)){
            if (get_jump_buffer(app, &buffer, &location)){
                change_active_panel(app);
                View_ID target_view = get_active_view(app, Access_Always);
                switch_to_existing_view(app, target_view, buffer);
                jump_to_location(app, target_view, buffer, location);
            }
        }
    }
}

CUSTOM_COMMAND(goto_jump_at_cursor_same_panel, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 375, Normal)
CUSTOM_DOC("If the cursor is found to be on a jump location, parses the jump location and brings up the file and position in this view, losing the compilation output or jump list.")
{
    Heap *heap = &global_heap;

    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));

    i32 list_index = get_index_exact_from_list(app, list, cursor.line);

    if (list_index >= 0){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, list_index, &location)){
            if (get_jump_buffer(app, &buffer, &location)){
                jump_to_location(app, view, buffer, location);
            }
        }
    }
}

static void
goto_jump_in_order(Application_Links *app, Marker_List *list, View_ID jump_view, ID_Pos_Jump_Location location){
    Buffer_ID buffer = {};
    if (get_jump_buffer(app, &buffer, &location)){
        View_ID target_view = get_active_view(app, Access_Always);
        if (target_view == jump_view){
            change_active_panel(app);
            target_view = get_active_view(app, Access_Always);
        }
        switch_to_existing_view(app, target_view, buffer);
        jump_to_location(app, target_view, buffer, location);
        prev_location = location;
    }
}

static b32
jump_is_repeat(ID_Pos_Jump_Location prev, ID_Pos_Jump_Location location){
    return(prev.buffer_id == location.buffer_id && prev.pos == location.pos);
}

static void
goto_next_filtered_jump(Application_Links *app, Marker_List *list, View_ID jump_view, i32 list_index, i32 direction, b32 skip_repeats, b32 skip_sub_errors){
    do{ if (!(direction == 1 || direction == -1)) { (*((i32*)0) = 0xA11E); } }while(0);

    if (list != 0){
        for (;list_index >= 0 && list_index < list->jump_count;){
            ID_Pos_Jump_Location location = {};
            if (get_jump_from_list(app, list, list_index, &location)){
                b32 skip_this = false;
                if (skip_repeats && jump_is_repeat(prev_location, location)){
                    skip_this = true;
                }
                else if (skip_sub_errors && get_is_sub_error_from_list(app, list, list_index)){
                    skip_this = true;
                }

                if (!skip_this){
                    goto_jump_in_order(app, list, jump_view, location);
                    i64 updated_line = get_line_from_list(app, list, list_index);
                    view_set_cursor_and_preferred_x(app, jump_view, seek_line_col(updated_line, 1));
                    break;
                }
            }

            list_index += direction;
        }
    }
}

static Locked_Jump_State
get_locked_jump_state(Application_Links *app, Heap *heap){
    Locked_Jump_State result = {};
    result.view = get_view_for_locked_jump_buffer(app);
    if (result.view != 0){
        Buffer_ID buffer = view_get_buffer(app, result.view, Access_Always);
        result.list = get_or_make_list_for_buffer(app, heap, buffer);

        i64 cursor_position = view_get_cursor_pos(app, result.view);
        Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(cursor_position));
        result.list_index = get_index_nearest_from_list(app, result.list, cursor.line);
    }
    return(result);
}

CUSTOM_COMMAND(goto_next_jump, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 464, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the next jump in the buffer, skipping sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i64 cursor_position = view_get_cursor_pos(app, jump_state.view);
        Buffer_Cursor cursor = view_compute_cursor(app, jump_state.view, seek_pos(cursor_position));
        i64 line = get_line_from_list(app, jump_state.list, jump_state.list_index);
        if (line <= cursor.line){
            jump_state.list_index += 1;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, 1, true, true);
    }
}

CUSTOM_COMMAND(goto_prev_jump, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 481, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the previous jump in the buffer, skipping sub jump locations."){
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        if (jump_state.list_index > 0){
            --jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, -1, true, true);
    }
}

CUSTOM_COMMAND(goto_next_jump_no_skips, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 494, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the next jump in the buffer, and does not skip sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i64 cursor_position = view_get_cursor_pos(app, jump_state.view);
        Buffer_Cursor cursor = view_compute_cursor(app, jump_state.view, seek_pos(cursor_position));
        i64 line = get_line_from_list(app, jump_state.list, jump_state.list_index);
        if (line <= cursor.line){
            ++jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, 1, true, false);
    }
}

CUSTOM_COMMAND(goto_prev_jump_no_skips, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 511, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the previous jump in the buffer, and does not skip sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        if (jump_state.list_index > 0){
            --jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, -1, true, false);
    }
}

CUSTOM_COMMAND(goto_first_jump, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 525, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the first jump in the buffer.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i32 list_index = 0;
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, jump_state.list, list_index, &location)){
            goto_jump_in_order(app, jump_state.list, jump_state.view, location);
            i64 updated_line = get_line_from_list(app, jump_state.list, list_index);
            view_set_cursor_and_preferred_x(app, jump_state.view, seek_line_col(updated_line, 1));
        }
    }
}

CUSTOM_COMMAND(goto_first_jump_same_panel_sticky, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 542, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the first jump in the buffer and views the buffer in the panel where the jump list was.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i32 list_index = 0;
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, jump_state.list, list_index, &location)){
            Buffer_ID buffer = {};
            if (get_jump_buffer(app, &buffer, &location)){
                jump_to_location(app, jump_state.view, buffer, location);
            }
        }
    }
}





CUSTOM_COMMAND(if_read_only_goto_position, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 564, Normal)
CUSTOM_DOC("If the buffer in the active view is writable, inserts a character, otherwise performs goto_jump_at_cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer == 0){
        buffer = view_get_buffer(app, view, Access_ReadVisible);
        if (buffer != 0){
            goto_jump_at_cursor(app);
            lock_jump_buffer(app, buffer);
        }
    }
    else{
        leave_current_input_unhandled(app);
    }
}

CUSTOM_COMMAND(if_read_only_goto_position_same_panel, "/home/tabletel/dev/4cc/code/custom/4coder_jump_sticky.cpp", 581, Normal)
CUSTOM_DOC("If the buffer in the active view is writable, inserts a character, otherwise performs goto_jump_at_cursor_same_panel.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer == 0){
        buffer = view_get_buffer(app, view, Access_ReadVisible);
        if (buffer != 0){
            goto_jump_at_cursor_same_panel(app);
            lock_jump_buffer(app, buffer);
        }
    }
    else{
        leave_current_input_unhandled(app);
    }
}





i32 default_end_buffer(Application_Links *app, Buffer_ID buffer_id);
i32 end_buffer_close_jump_list(Application_Links *app, Buffer_ID buffer_id){
    Marker_List *list = get_marker_list_for_buffer(buffer_id);
    if (list != 0){
        delete_marker_list(list);
    }
    default_end_buffer(app, buffer_id);
    return(0);
}
# 124 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_jump_lister.cpp" 1






static Jump_Lister_Result
get_jump_index_from_user(Application_Links *app, Marker_List *list,
                         String_Const_u8 query){
    Jump_Lister_Result result = {};
    if (list != 0){
        Scratch_Block scratch(app);
        Lister_Block lister(app, scratch);
        lister_set_query(lister, query);
        lister_set_default_handlers(lister);

        Buffer_ID list_buffer = list->buffer_id;

        i32 option_count = list->jump_count;
        Managed_Object stored_jumps = list->jump_array;
        for (i32 i = 0; i < option_count; i += 1){
            Sticky_Jump_Stored stored = {};
            managed_object_load_data(app, stored_jumps, i, 1, &stored);
            String_Const_u8 line = push_buffer_line(app, scratch, list_buffer,
                                                    stored.list_line);
            lister_add_item(lister, line, SCu8(), (void*)(((u8*)0) + i), 0);
        }

        Lister_Result l_result = run_lister(app, lister);
        if (!l_result.canceled){
            result.success = true;
            result.index = (i32)((u8*)(l_result.user_data) - (u8*)(0));
        }
    }

    return(result);
}

static Jump_Lister_Result
get_jump_index_from_user(Application_Links *app, Marker_List *list, char *query){
    return(get_jump_index_from_user(app, list, SCu8(query)));
}

static void
jump_to_jump_lister_result(Application_Links *app, View_ID view,
                           Marker_List *list, Jump_Lister_Result *jump){
    if (jump->success){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, jump->index, &location)){
            Buffer_ID jump_dst_buffer = {};
            if (get_jump_buffer(app, &jump_dst_buffer, &location)){
                view_set_active(app, view);
                jump_to_location(app, view, jump_dst_buffer, location);
            }
        }
    }
}

CUSTOM_COMMAND(view_jump_list_with_lister, "/home/tabletel/dev/4cc/code/custom/4coder_jump_lister.cpp", 59, Normal)
CUSTOM_DOC("When executed on a buffer with jumps, creates a persistent lister for all the jumps")
{
    Heap *heap = &global_heap;
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
    if (list != 0){
        Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Jump:");
        jump_to_jump_lister_result(app, view, list, &jump);
    }
}
# 125 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_code_index_listers.cpp" 1






struct Tiny_Jump{
    Buffer_ID buffer;
    i64 pos;
};

CUSTOM_COMMAND(jump_to_definition, "/home/tabletel/dev/4cc/code/custom/4coder_code_index_listers.cpp", 12, UI)
CUSTOM_DOC("List all definitions in the code index and jump to one chosen by the user.")
{
    char *query = "Definition:";

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    code_index_lock();
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        Code_Index_File *file = code_index_get_file(buffer);
        if (file != 0){
            for (i32 i = 0; i < file->note_array.count; i += 1){
                Code_Index_Note *note = file->note_array.ptrs[i];
                Tiny_Jump *jump = ((Tiny_Jump*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Tiny_Jump)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_code_index_listers.cpp" ":" "30" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_code_index_listers.cpp" ":" "30" ":") - 1)))));
                jump->buffer = buffer;
                jump->pos = note->pos.first;

                String_Const_u8 sort = {};
                switch (note->note_kind){
                    case CodeIndexNote_Type:
                    {
                        sort = SCu8((u8*)("type"), (u64)(sizeof("type") - 1));
                    }break;
                    case CodeIndexNote_Function:
                    {
                        sort = SCu8((u8*)("function"), (u64)(sizeof("function") - 1));
                    }break;
                    case CodeIndexNote_Macro:
                    {
                        sort = SCu8((u8*)("macro"), (u64)(sizeof("macro") - 1));
                    }break;
                }
                lister_add_item(lister, note->text, sort, jump, 0);
            }
        }
    }
    code_index_unlock();

    Lister_Result l_result = run_lister(app, lister);
    Tiny_Jump result = {};
    if (!l_result.canceled && l_result.user_data != 0){
        block_copy((&result), ((Tiny_Jump*)l_result.user_data), sizeof(*(&result)));
    }

    if (result.buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        point_stack_push_view_cursor(app, view);
        jump_to_location(app, view, result.buffer, result.pos);
    }
}

CUSTOM_COMMAND(jump_to_definition_at_cursor, "/home/tabletel/dev/4cc/code/custom/4coder_code_index_listers.cpp", 68, UI)
CUSTOM_DOC("Jump to the first definition in the code index matching an identifier at the cursor")
{
    View_ID view = get_active_view(app, Access_Visible);

    if (view != 0){
        Scratch_Block scratch(app);
        String_Const_u8 query = push_token_or_word_under_active_cursor(app, scratch);

        code_index_lock();
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            Code_Index_File *file = code_index_get_file(buffer);
            if (file != 0){
                for (i32 i = 0; i < file->note_array.count; i += 1){
                    Code_Index_Note *note = file->note_array.ptrs[i];
                    if (string_match(note->text, query)){
                        point_stack_push_view_cursor(app, view);
                        jump_to_location(app, view, buffer, note->pos.first);
                        goto done;
                    }
                }
            }
        }
        done:;
        code_index_unlock();
    }
}
# 126 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp"
static u64
log_parse__string_code(Log_Parse *parse, String_Const_u8 string, Log_String_Source string_source){
    u64 result = 0;
    if (string.size > 0){
        String_Const_u8 data = make_data(string.str, string.size);
        Table_Lookup lookup = table_lookup(&parse->string_to_id_table, data);
        if (lookup.found_match){
            table_read(&parse->string_to_id_table, lookup, &result);
        }
        else{
            if (string_source == LogParse_ExternalString){
                data = push_data_copy(parse->arena, data);
            }
            result = parse->string_id_counter;
            parse->string_id_counter += 1;
            table_insert(&parse->string_to_id_table, data, result);
            table_insert(&parse->id_to_string_table, result, data);
        }
    }
    return(result);
}

static String_Const_u8
log_parse__get_string(Log_Parse *parse, u64 code){
    Table_Lookup lookup = table_lookup(&parse->id_to_string_table, code);
    String_Const_u8 result = {};
    if (lookup.found_match){
        table_read(&parse->id_to_string_table, lookup, &result);
    }
    return(result);
}

static Log_Event*
log_parse__event(Log_Parse *parse,
                 String_Const_u8 file_name, String_Const_u8 line_number, String_Const_u8 event_name){
    Log_Event *new_event = ((Log_Event*)linalloc_wrap_unintialized(linalloc_push((parse->arena), sizeof(Log_Event)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "47" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "47" ":") - 1)))));
    do{ if((new_event)){if((parse->first_event)){(parse->last_event)->next=(new_event);}else{(parse->first_event)=(new_event);}(parse->last_event)=(new_event);(parse->last_event)->next=0;} }while(0);
    parse->event_count += 1;
    new_event->src_file_name = log_parse__string_code(parse, file_name, LogParse_ExternalString);
    new_event->event_name = log_parse__string_code(parse, event_name, LogParse_ExternalString);
    new_event->line_number = string_to_integer(line_number, 10);
    new_event->event_number = parse->event_count;
    return(new_event);
}

static Log_Tag*
log_parse__tag(Log_Parse *parse, Log_Event *event, String_Const_u8 tag_name, String_Const_u8 tag_value){
    Log_Tag *new_tag = ((Log_Tag*)linalloc_wrap_unintialized(linalloc_push((parse->arena), sizeof(Log_Tag)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "59" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "59" ":") - 1)))));
    do{ if((new_tag)){if((event->first_tag)){(event->last_tag)->next=(new_tag);}else{(event->first_tag)=(new_tag);}(event->last_tag)=(new_tag);(event->last_tag)->next=0;} }while(0);
    event->tag_count += 1;
    new_tag->name = log_parse__string_code(parse, tag_name, LogParse_ExternalString);
    if (tag_value.size == 0){
        new_tag->value.kind = LogTagKind_String;
        new_tag->value.value = 0;
    }
    else{
        if (tag_value.str[0] == '"'){
            if (tag_value.size == 1){
                new_tag->value.kind = LogTagKind_String;
                new_tag->value.value = 0;
            }
            else{
                tag_value = string_skip(tag_value, 1);
                if (tag_value.str[tag_value.size - 1] == '"'){
                    tag_value = string_chop(tag_value, 1);
                }
                String_Const_u8 escape = string_interpret_escapes(parse->arena, tag_value);
                new_tag->value.kind = LogTagKind_String;
                new_tag->value.value = log_parse__string_code(parse, escape, LogParse_PreAllocatedString);
            }
        }
        else{
            new_tag->value.kind = LogTagKind_Integer;
            b32 is_negative = false;
            if (string_match(string_prefix(tag_value, 1), SCu8((u8*)("-"), (u64)(sizeof("-") - 1)))){
                tag_value = string_skip(tag_value, 1);
                is_negative = true;
            }
            if (string_match(string_prefix(tag_value, 2), SCu8((u8*)("0x"), (u64)(sizeof("0x") - 1)))){
                tag_value = string_skip(tag_value, 2);
                new_tag->value.value_s = (i64)string_to_integer(tag_value, 16);
            }
            else{
                new_tag->value.value_s = (i64)string_to_integer(tag_value, 10);
            }
            if (is_negative){
                new_tag->value.value_s = -new_tag->value.value_s;
            }
        }
    }
    return(new_tag);
}

static Log_Event_List*
log_parse_get_list_tag_value(Log_Parse *parse, u64 name, Log_Tag_Value value){
    Log_Event_List *result = 0;
    Log_Tag_Name_Value key = {name, value};
    Table_Lookup lookup = table_lookup(&parse->tag_value_to_event_list_table, make_data((&key), sizeof(*(&key))));
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_value_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Log_Event_List*
log_parse__get_or_make_list_tag_value(Log_Parse *parse, Log_Tag *tag){
    Log_Event_List *result = 0;
    Log_Tag_Name_Value key = {tag->name, tag->value};
    String_Const_u8 data_key = make_data((&key), sizeof(*(&key)));
    Table_Lookup lookup = table_lookup(&parse->tag_value_to_event_list_table, data_key);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_value_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    else{
        result = ((Log_Event_List*)linalloc_wrap_zero(linalloc_push((parse->arena), sizeof(Log_Event_List)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "130" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "130" ":") - 1)))));
        table_insert(&parse->tag_value_to_event_list_table, push_data_copy(parse->arena, data_key),
                     (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static Log_Event_List*
log_parse_get_list_tag_name(Log_Parse *parse, u64 name){
    Log_Event_List *result = 0;
    Table_Lookup lookup = table_lookup(&parse->tag_name_to_event_list_table, name);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_name_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Log_Event_List*
log_parse__get_or_make_list_tag_name(Log_Parse *parse, Log_Tag *tag){
    Log_Event_List *result = 0;
    Table_Lookup lookup = table_lookup(&parse->tag_name_to_event_list_table, tag->name);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_name_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    else{
        result = ((Log_Event_List*)linalloc_wrap_zero(linalloc_push((parse->arena), sizeof(Log_Event_List)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "159" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "159" ":") - 1)))));
        table_insert(&parse->tag_name_to_event_list_table, tag->name, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static Log_Parse
make_log_parse(Arena *arena, String_Const_u8 source){
    Log_Parse parse = {};
    parse.arena = arena;
    parse.string_id_counter = 1;
    parse.string_to_id_table = make_table_Data_u64__inner((arena->base_allocator),(500),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "170" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "170" ":") - 1)));
    parse.id_to_string_table = make_table_u64_Data__inner((arena->base_allocator),(500),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "171" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "171" ":") - 1)));

    for (;source.size > 0;){
        u64 end_of_line = string_find_first(source, '\n');
        String_Const_u8 line = string_prefix(source, end_of_line);
        line = string_skip_chop_whitespace(line);
        source = string_skip(source, end_of_line + 1);

        String_Const_u8 src_file_name = {};
        String_Const_u8 src_line_number = {};
        b32 got_source_position = false;

        String_Const_u8 whole_line = line;

        {
            u64 colon1 = string_find_first(line, ':');
            src_file_name = string_prefix(line, colon1);
            line = string_skip(line, colon1 + 1);

            u64 colon2 = string_find_first(line, ':');
            src_line_number = string_prefix(line, colon2);
            line = string_skip(line, colon2 + 1);

            if (string_is_integer(src_line_number, 10)){
                got_source_position = true;
            }
        }

        if (!got_source_position){
            line = whole_line;

            u64 colon0 = string_find_first(line, ':');
            u64 colon1 = string_find_first(line, colon0 + 1, ':');
            src_file_name = string_prefix(line, colon1);
            line = string_skip(line, colon1 + 1);

            u64 colon2 = string_find_first(line, ':');
            src_line_number = string_prefix(line, colon2);
            line = string_skip(line, colon2 + 1);

            if (string_is_integer(src_line_number, 10)){
                got_source_position = true;
            }
        }

        if (got_source_position){
            u64 bracket_open = string_find_first(line, '[');
            String_Const_u8 event_name = string_prefix(line, bracket_open);
            event_name = string_skip_chop_whitespace(event_name);
            line = string_skip(line, bracket_open + 1);

            Log_Event *event = log_parse__event(&parse,
                                                src_file_name, src_line_number, event_name);

            for (;line.size > 0;){
                u64 bracket_close = string_find_first(line, ']');
                String_Const_u8 tag = string_prefix(line, bracket_close);
                line = string_skip(line, bracket_close + 1);
                bracket_open = string_find_first(line, '[');
                line = string_skip(line, bracket_open + 1);

                u64 equal_sign = string_find_first(tag, '=');
                String_Const_u8 tag_name = string_prefix(tag, equal_sign);
                String_Const_u8 tag_contents = string_skip(tag, equal_sign + 1);

                log_parse__tag(&parse, event, tag_name, tag_contents);
            }
        }
    }





    parse.tag_value_to_event_list_table = make_table_Data_u64__inner((arena->base_allocator),(((1)*1000)),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "245" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "245" ":") - 1)));
    parse.tag_name_to_event_list_table = make_table_u64_u64__inner((arena->base_allocator),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "246" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "246" ":") - 1)));

    for (Log_Event *event = parse.first_event;
         event != 0;
         event = event->next){
        for (Log_Tag *tag = event->first_tag;
             tag != 0;
             tag = tag->next){
            {
                Log_Event_List *list = log_parse__get_or_make_list_tag_value(&parse, tag);
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "256" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "256" ":") - 1)))));
                do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
                list->count += 1;
                node->event = event;
            }
            {
                Log_Event_List *list = log_parse__get_or_make_list_tag_name(&parse, tag);
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "263" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "263" ":") - 1)))));
                do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
                list->count += 1;
                node->event = event;
            }
        }
    }

    for (Log_Event *event = parse.first_event;
         event != 0;
         event = event->next){
        i32 slot_count = event->tag_count*3/2;
        event->tag_name_to_tag_ptr_table = make_table_u64_u64__inner((arena->base_allocator),(slot_count),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "275" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "275" ":") - 1)));
        for (Log_Tag *tag = event->first_tag;
             tag != 0;
             tag = tag->next){
            table_insert(&event->tag_name_to_tag_ptr_table, tag->name, (u64)((u8*)(tag) - (u8*)(0)));
        }
    }

    return(parse);
}



static void
log_events_sort_by_tag__inner(Log_Event **events, Log_Sort_Key *keys, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot_index = one_past_last - 1;
        Log_Sort_Key *pivot_key = keys + pivot_index;
        i32 j = first;
        for (i32 i = first; i < one_past_last; i += 1){
            Log_Sort_Key *key = keys + i;
            b32 key_is_less_than_pivot_key = false;
            if (key->value.kind < pivot_key->value.kind){
                key_is_less_than_pivot_key = true;
            }
            else if (key->value.kind == pivot_key->value.kind){
                if (key->value.value < pivot_key->value.value){
                    key_is_less_than_pivot_key = true;
                }
                else if (key->value.value == pivot_key->value.value){
                    if (key->number < pivot_key->number){
                        key_is_less_than_pivot_key = true;
                    }
                }
            }
            if (key_is_less_than_pivot_key){
                if (j < i){
                    do { Log_Event* hidden_temp_312 = events[i]; events[i] = events[j]; events[j] = hidden_temp_312; } while(0);
                    do { Log_Sort_Key hidden_temp_313 = keys[i]; keys[i] = keys[j]; keys[j] = hidden_temp_313; } while(0);
                }
                j += 1;
            }
        }
        do { Log_Event* hidden_temp_318 = events[pivot_index]; events[pivot_index] = events[j]; events[j] = hidden_temp_318; } while(0);
        do { Log_Sort_Key hidden_temp_319 = keys[pivot_index]; keys[pivot_index] = keys[j]; keys[j] = hidden_temp_319; } while(0);
        log_events_sort_by_tag__inner(events, keys, first, j);
        log_events_sort_by_tag__inner(events, keys, j + 1, one_past_last);
    }
}

static void
log_events_sort_by_tag(Arena *scratch, Log_Event_Ptr_Array array, u64 tag_name){
    Temp_Memory temp = begin_temp(scratch);
    Log_Sort_Key *keys = ((Log_Sort_Key*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Log_Sort_Key)*(array.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "328" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "328" ":") - 1)))));
    for (i32 i = 0; i < array.count; i += 1){
        Log_Event *event = array.events[i];
        Table_Lookup lookup = table_lookup(&event->tag_name_to_tag_ptr_table, tag_name);
        if (lookup.found_match){
            u64 read_val = 0;
            table_read(&event->tag_name_to_tag_ptr_table, lookup, &read_val);
            Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + read_val);
            keys[i].value = tag->value;
        }
        else{
            keys[i].value.kind = LogTagKind_Null;
            keys[i].value.value = 0;
        }
        keys[i].number = event->event_number;
    }

    log_events_sort_by_tag__inner(array.events, keys, 0, array.count);

    end_temp(temp);
}

static Log_Event_Ptr_Array
log_event_array_from_list(Arena *arena, Log_Event_List list){
    Log_Event_Ptr_Array array = {};
    array.count = list.count;
    array.events = ((Log_Event**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event*)*(array.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "354" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "354" ":") - 1)))));
    i32 counter = 0;
    for (Log_Event_Ptr_Node *node = list.first;
         node != 0;
         node = node->next){
        array.events[counter] = node->event;
        counter += 1;
    }
    return(array);
}



static View_ID log_view = 0;
static Arena log_arena = {};
static Log_Parse log_parse = {};
static Log_Graph log_graph = {};
static Log_Filter_Set log_filter_set = {};
static Log_Filter_Set log_preview_set = {};

static void
log_filter_set_init(Log_Filter_Set *set){
    block_zero((set), sizeof(*(set)));
    for (i32 i = ((sizeof(set->filters_memory))/(sizeof(*set->filters_memory))) - 1; i >= 0; i -= 1){
        ((&set->filters_memory[i])->next=(set->free_filters),(set->free_filters)=(&set->filters_memory[i]));
    }
}

static Log_Filter_Set*
log_filter_set_from_tab(Log_Graph_List_Tab tab){
    Log_Filter_Set *result = 0;
    switch (tab){
        case LogTab_Filters:
        {
            result = &log_filter_set;
        }break;
        case LogTab_Previews:
        {
            result = &log_preview_set;
        }break;
    }
    return(result);
}

static Log_Filter*
log_filter_set__new_filter(Log_Filter_Set *set, Log_Filter *prototype){
    Log_Filter *result = set->free_filters;
    if (result != 0){
        for (Log_Filter *filter = set->first;
             filter != 0;
             filter = filter->next){
            if (filter->kind == prototype->kind &&
                filter->tag_name_code == prototype->tag_name_code &&
                block_match((&filter->tag_value), (&prototype->tag_value), sizeof(*(&filter->tag_value)))){
                result = 0;
                break;
            }
        }
        if (result != 0){
            ((set->free_filters)=(set->free_filters)=(set->free_filters)->next);
            block_copy((result), (prototype), sizeof(*(result)));
            (((set->first)==0)?((result)->next=(result)->prev=0,(set->first)=(set->last)=(result)):((result)->prev=(set->last),(result)->next=0,(set->last)->next=(result),(set->last)=(result)));
            set->count += 1;
            set->alter_counter += 1;
        }
    }
    return(result);
}

static void
log_filter_set__free_filter(Log_Filter_Set *set, Log_Filter *filter){
    (((set->last)==(filter))?((((set->first)==(set->last))?((set->first)=(set->last)=0):((set->last)->prev->next=0,(set->last)=(set->last)->prev))) :((set->first)==(filter))?((((set->last)==(set->first))?((set->last)=(set->first)=0):((set->first)->next->prev=0,(set->first)=(set->first)->next))) : ((filter)->next->prev=(filter)->prev,(filter)->prev->next=(filter)->next,(filter)->next=(filter)->prev=0));
    set->count -= 1;
    set->alter_counter += 1;
    ((filter)->next=(set->free_filters),(set->free_filters)=(filter));
}

static void
log_graph_fill(Application_Links *app, Rect_f32 layout_region, Face_ID face_id){
    if (log_parse.arena != 0){
        if (log_graph.holding_temp){
            end_temp(log_graph.temp);
        }
        block_zero((&log_graph), sizeof(*(&log_graph)));
        log_graph.holding_temp = true;
        log_graph.temp = begin_temp(&log_arena);
        log_graph.layout_region = layout_region;
        log_graph.face_id = face_id;
        log_graph.filter_alter_counter = log_filter_set.alter_counter;
        log_graph.preview_alter_counter = log_preview_set.alter_counter;
        log_graph.tab = LogTab_Filters;

        f32 details_h = rect_height(layout_region)*.22f;
        details_h = (((details_h)<(250.f))?(details_h):(250.f));

        Rect_f32 details_region = Rf32(layout_region.x0, layout_region.y0,
                                       layout_region.x1, layout_region.y0 + details_h);
        Rect_f32 event_list_region = Rf32(layout_region.x0, layout_region.y0 + details_h,
                                          layout_region.x1, layout_region.y1);

        log_graph.details_region = details_region;
        log_graph.details_region.p0 -= layout_region.p0;
        log_graph.details_region.p1 -= layout_region.p0;

        u64 thread_code = log_parse__string_code(&log_parse, SCu8((u8*)("thread"), (u64)(sizeof("thread") - 1)),
                                                 LogParse_ExternalString);

        if (log_filter_set.count == 0){

            for (Log_Event *event = log_parse.first_event;
                 event != 0;
                 event = event->next){
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "466" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "466" ":") - 1)))));
                node->event = event;
                do{ if((node)){if((log_graph.filtered_list.first)){(log_graph.filtered_list.last)->next=(node);}else{(log_graph.filtered_list.first)=(node);}(log_graph.filtered_list.last)=(node);(log_graph.filtered_list.last)->next=0;} }while(0);
                log_graph.filtered_list.count += 1;
            }
        }
        else{
            for (Log_Filter *filter = log_filter_set.first;
                 filter != 0;
                 filter = filter->next){
                Log_Event_List *filter_list = 0;
                if (filter->kind == LogFilter_TagValue){
                    filter_list = log_parse_get_list_tag_value(&log_parse, filter->tag_name_code,
                                                               filter->tag_value);
                }
                else if (filter->kind == LogFilter_Tag){
                    filter_list = log_parse_get_list_tag_name(&log_parse, filter->tag_name_code);
                }


                if (filter == log_filter_set.first){
                    for (Log_Event_Ptr_Node *node = filter_list->first;
                         node != 0;
                         node = node->next){
                        Log_Event_Ptr_Node *new_node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "490" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "490" ":") - 1)))));
                        new_node->event = node->event;
                        do{ if((new_node)){if((log_graph.filtered_list.first)){(log_graph.filtered_list.last)->next=(new_node);}else{(log_graph.filtered_list.first)=(new_node);}(log_graph.filtered_list.last)=(new_node);(log_graph.filtered_list.last)->next=0;} }while(0);
                        log_graph.filtered_list.count += 1;
                    }
                }
                else{
                    Log_Event_Ptr_Node **fixup_ptr = &log_graph.filtered_list.first;
                    log_graph.filtered_list.last = 0;
                    for (Log_Event_Ptr_Node *node_a = log_graph.filtered_list.first, *next = 0;
                         node_a != 0;
                         node_a = next){
                        next = node_a->next;

                        b32 remove_node_a = true;
                        for (Log_Event_Ptr_Node *node_b = filter_list->first;
                             node_b != 0;
                             node_b = node_b->next){
                            if (node_a->event == node_b->event){
                                remove_node_a = false;
                                break;
                            }
                        }

                        if (remove_node_a){
                            *fixup_ptr = next;
                        }
                        else{
                            fixup_ptr = &node_a->next;
                            log_graph.filtered_list.last = node_a;
                        }
                    }
                }
            }
        }

        log_graph.event_array = log_event_array_from_list(&log_arena, log_graph.filtered_list);
        log_events_sort_by_tag(&log_arena, log_graph.event_array, thread_code);

        b32 had_a_tag = true;
        u64 thread_id_value = 0;
        Log_Graph_Thread_Bucket *prev_bucket = 0;

        for (i32 i = 0; i < log_graph.event_array.count; i += 1){
            Table_u64_u64 *tag_table = &log_graph.event_array.events[i]->tag_name_to_tag_ptr_table;
            Table_Lookup lookup = table_lookup(tag_table, thread_code);

            b32 emit_next_bucket = false;
            if (!lookup.found_match){
                if (had_a_tag){
                    had_a_tag = false;
                    thread_id_value = 0;
                    emit_next_bucket = true;
                }
            }
            else{
                u64 read_val = 0;
                table_read(tag_table, lookup, &read_val);
                Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + read_val);
                if (!had_a_tag){
                    had_a_tag = true;
                    thread_id_value = tag->value.value;
                    emit_next_bucket = true;
                }
                else if (thread_id_value != tag->value.value){
                    thread_id_value = tag->value.value;
                    emit_next_bucket = true;
                }
            }

            if (emit_next_bucket){
                Log_Graph_Thread_Bucket *bucket = ((Log_Graph_Thread_Bucket*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Graph_Thread_Bucket)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "561" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "561" ":") - 1)))));
                do{ if((bucket)){if((log_graph.first_bucket)){(log_graph.last_bucket)->next=(bucket);}else{(log_graph.first_bucket)=(bucket);}(log_graph.last_bucket)=(bucket);(log_graph.last_bucket)->next=0;} }while(0);
                log_graph.bucket_count += 1;
                bucket->range.first = i;
                bucket->had_a_tag = had_a_tag;
                bucket->thread_id_value = thread_id_value;
                if (prev_bucket != 0){
                    prev_bucket->range.one_past_last = i;
                }
                prev_bucket = bucket;
            }
        }
        if (prev_bucket != 0){
            prev_bucket->range.one_past_last = log_graph.event_array.count;
        }

        Face_Metrics metrics = get_face_metrics(app, face_id);
        f32 line_height = metrics.line_height;
        f32 box_h = f32_floor32(line_height*1.5f);
        f32 box_w = f32_floor32(rect_width(event_list_region)/log_graph.bucket_count);
        f32 y_cursor = event_list_region.y0 - layout_region.y0;

        if (log_graph.bucket_count > 0){
            f32 y_bottom = 0.f;

            for (;;){
                i32 smallest_event_number = max_i32;
                i32 bucket_with_next_event_index = -1;
                Log_Graph_Thread_Bucket *bucket_with_next_event = 0;
                Log_Event *next_event = 0;
                i32 iteration_counter = 0;
                for (Log_Graph_Thread_Bucket *bucket = log_graph.first_bucket;
                     bucket != 0;
                     bucket = bucket->next, iteration_counter += 1){
                    if (bucket->range.first < bucket->range.one_past_last){
                        Log_Event *event = log_graph.event_array.events[bucket->range.first];
                        if (event->event_number < smallest_event_number){
                            smallest_event_number = event->event_number;
                            bucket_with_next_event_index = iteration_counter;
                            bucket_with_next_event = bucket;
                            next_event = event;
                        }
                    }
                }

                if (bucket_with_next_event == 0){
                    break;
                }

                bucket_with_next_event->range.first += 1;

                Log_Graph_Box *box_node = ((Log_Graph_Box*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Graph_Box)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "612" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp" ":" "612" ":") - 1)))));
                do{ if((box_node)){if((log_graph.first_box)){(log_graph.last_box)->next=(box_node);}else{(log_graph.first_box)=(box_node);}(log_graph.last_box)=(box_node);(log_graph.last_box)->next=0;} }while(0);
                log_graph.box_count += 1;
                Rect_f32 rect = Rf32(box_w*bucket_with_next_event_index , y_cursor,
                                     box_w*(bucket_with_next_event_index + 1), y_cursor + box_h);
                box_node->rect = rect;
                box_node->event = next_event;

                y_bottom = (((y_bottom)>(rect.y1))?(y_bottom):(rect.y1));

                y_cursor += box_h;
            }

            log_graph.max_y_scroll = (((line_height)>(y_bottom - rect_height(event_list_region)*0.5f))?(line_height):(y_bottom - rect_height(event_list_region)*0.5f));
        }
    }
}

static void
log_parse_fill(Application_Links *app, Buffer_ID buffer){
    if (log_arena.base_allocator == 0){
        log_arena = make_arena_system();
    }

    linalloc_clear(&log_arena);
    block_zero((&log_graph), sizeof(*(&log_graph)));
    log_filter_set_init(&log_filter_set);
    log_filter_set_init(&log_preview_set);

    String_Const_u8 log_text = push_whole_buffer(app, &log_arena, buffer);
    log_parse = make_log_parse(&log_arena, log_text);
}

static void
log_graph_render__tag(Arena *arena, Fancy_Line *line,
                      Log_Parse *log, Log_Tag *tag){
    String_Const_u8 tag_name = log_parse__get_string(log, tag->name);
    push_fancy_stringf(arena, line, f_white, "[");
    push_fancy_string(arena, line, f_green, tag_name);
    push_fancy_stringf(arena, line, f_white, "=");
    if (tag->value.kind == LogTagKind_Integer){
        push_fancy_stringf(arena, line, f_pink, "0x%llx", tag->value.value_s);
    }
    else if (tag->value.kind == LogTagKind_String){
        String_Const_u8 value = log_parse__get_string(log, tag->value.value);
        push_fancy_string(arena, line, f_pink, value);
    }
    push_fancy_stringf(arena, line, f_white, "]");
}

static void
log_graph_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    if (log_parse.arena != 0){

        View_ID active_view = get_active_view(app, Access_Always);
        b32 is_active_view = (active_view == view);

        Rect_f32 view_rect = view_get_screen_rect(app, view);
        Rect_f32 inner = rect_inner(view_rect, 3);
        draw_rectangle_fcolor(app, view_rect, 0.f,
                              get_item_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None));
        draw_rectangle_fcolor(app, inner, 0.f, fcolor_id(defcolor_back));

        Rect_f32 prev_clip = draw_set_clip(app, inner);


        Face_ID face_id = get_face_id(app, 0);
        f32 y_scroll = log_graph.y_scroll;
        Log_Event *selected_event = log_graph.selected_event;
        if (!log_graph.holding_temp ||
            inner != log_graph.layout_region ||
            face_id != log_graph.face_id ||
            log_filter_set.alter_counter != log_graph.filter_alter_counter){
            log_graph_fill(app, inner, face_id);
        }
        log_graph.y_scroll = (((0.f)>(y_scroll))?(0.f):(((log_graph.max_y_scroll)<(y_scroll))?(log_graph.max_y_scroll):(y_scroll)));
        log_graph.selected_event = selected_event;

        Mouse_State mouse = get_mouse_state(app);
        Vec2_f32 m_p = V2f32(mouse.p) - inner.p0;

        Face_Metrics metrics = get_face_metrics(app, log_graph.face_id);
        f32 line_height = metrics.line_height;

        Log_Event *hover_event = 0;

        b32 in_details_region = (rect_contains_point(log_graph.details_region, m_p));

        for (Log_Graph_Box *box_node = log_graph.first_box;
             box_node != 0;
             box_node = box_node->next){
            Scratch_Block scratch(app);

            Rect_f32 box = box_node->rect;
            box.y0 -= log_graph.y_scroll;
            box.y1 -= log_graph.y_scroll;

            Rect_f32 box_inner = rect_inner(box, 3.f);

            FColor margin_color = f_dark_gray;
            if (!in_details_region && hover_event == 0 && rect_contains_point(box, m_p)){
                margin_color = f_gray;
                hover_event = box_node->event;
            }
            if (box_node->event == log_graph.selected_event){
                margin_color = f_light_gray;
            }

            draw_rectangle_fcolor(app, box , 0.f, margin_color);
            draw_rectangle_fcolor(app, box_inner, 0.f, f_black );

            Log_Event *event = box_node->event;

            String_Const_u8 event_name = log_parse__get_string(&log_parse, event->event_name);
            Fancy_Line line = {};
            push_fancy_string(scratch, &line, f_white, event_name);

            for (Log_Filter *filter = log_preview_set.first;
                 filter != 0;
                 filter = filter->next){
                Table_u64_u64 *table = &event->tag_name_to_tag_ptr_table;
                Table_Lookup lookup = table_lookup(table, filter->tag_name_code);
                if (lookup.found_match){
                    u64 val = 0;
                    table_read(table, lookup, &val);
                    Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + val);
                    push_fancy_string(scratch, &line, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
                    log_graph_render__tag(scratch, &line, &log_parse, tag);
                }
            }


            Vec2_f32 p = V2f32(box_inner.x0 + 3.f,
                               (f32_round32((box_inner.y0 + box_inner.y1 - line_height)*0.5f)));
            draw_fancy_line(app, log_graph.face_id, fcolor_zero(), &line, p);
        }

        {
            Scratch_Block scratch(app);

            Rect_f32 box = log_graph.details_region;
            Rect_f32 box_inner = rect_inner(box, 3.f);

            Log_Graph_List_Tab current_tab = log_graph.tab;
            Log_Filter_Set *viewing_filter_set = log_filter_set_from_tab(current_tab);

            draw_rectangle_fcolor(app, box , 0.f, f_dark_gray);
            draw_rectangle_fcolor(app, box_inner, 0.f, f_black );

            {
                f32 y_cursor = box_inner.y0 + 3.f;
                if (y_cursor + line_height > box_inner.y1) goto finish_list_display;

                {
                    f32 x_cursor = box_inner.x0 + 3.f;
                    for (i32 i = LogTab_ERROR + 1; i < LogTab_COUNT; i += 1){
                        FColor color = (i == current_tab)?f_white:f_gray;
                        Fancy_Line line = {};
                        switch (i){
                            case LogTab_Filters:
                            {
                                push_fancy_stringf(scratch, &line, color, "filters");
                            }break;
                            case LogTab_Previews:
                            {
                                push_fancy_stringf(scratch, &line, color, "previews");
                            }break;
                        }

                        Vec2_f32 p = V2f32(x_cursor, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id,
                                                         &line);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);
                        x_cursor += width + metrics.normal_advance;

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32_xy_wh(p.x, p.y,
                                                             width, line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                log_graph.tab = i;
                            }
                        }
                    }
                }

                if (viewing_filter_set != 0){
                    for (Log_Filter *filter = viewing_filter_set->first, *next = 0;
                         filter != 0;
                         filter = next){
                        next = filter->next;

                        y_cursor += line_height;
                        if (y_cursor + line_height > box_inner.y1) goto finish_list_display;

                        Fancy_Line line = {};

                        if (filter->kind == LogFilter_TagValue){
                            push_fancy_stringf(scratch, &line, f_white, "val  [");
                            String_Const_u8 tag_name = log_parse__get_string(&log_parse, filter->tag_name_code);
                            push_fancy_stringf(scratch, &line, f_green, "%.*s", (i32)(tag_name).size, (char*)(tag_name).str);
                            push_fancy_stringf(scratch, &line, f_white, "=");
                            if (filter->tag_value.kind == LogTagKind_Integer){
                                push_fancy_stringf(scratch, &line, f_pink, "0x%llx", filter->tag_value.value_s);
                            }
                            else if (filter->tag_value.kind == LogTagKind_String){
                                String_Const_u8 value = log_parse__get_string(&log_parse, filter->tag_value.value);
                                push_fancy_stringf(scratch, &line, f_pink, "%.*s", (i32)(value).size, (char*)(value).str);
                            }
                            push_fancy_stringf(scratch, &line, f_white, "]");
                        }
                        else{
                            push_fancy_stringf(scratch, &line, f_white, "name [");
                            String_Const_u8 tag_name = log_parse__get_string(&log_parse, filter->tag_name_code);
                            push_fancy_stringf(scratch, &line, f_green, "%.*s", (i32)(tag_name).size, (char*)(tag_name).str);
                            push_fancy_stringf(scratch, &line, f_white, "]");
                        }

                        Vec2_f32 p = V2f32(box_inner.x0 + 3.f, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id,
                                                         &line);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32_xy_wh(p.x, p.y,
                                                             width, line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                log_filter_set__free_filter(viewing_filter_set, filter);
                            }
                        }
                    }
                }

                finish_list_display:;
            }

            Log_Event *view_event = (hover_event!=0)?hover_event:log_graph.selected_event;
            if (view_event != 0){
                f32 y_cursor = box_inner.y0 + 3.f;
                if (y_cursor + line_height > box_inner.y1) goto finish_event_display;

                {
                    Fancy_Line line = {};
                    String_Const_u8 file_name = log_parse__get_string(&log_parse, view_event->src_file_name);
                    push_fancy_stringf(scratch, &line, f_green, "[%d]  ", view_event->event_number);
                    push_fancy_stringf(scratch, &line, f_white, "%.*s:", (i32)(file_name).size, (char*)(file_name).str);
                    push_fancy_stringf(scratch, &line, f_pink, "%llu", view_event->line_number);

                    Vec2_f32 right_p = V2f32(box_inner.x1 - 3.f, y_cursor);
                    f32 width = get_fancy_line_width(app, log_graph.face_id, &line);
                    Vec2_f32 p = V2f32(right_p.x - width, right_p.y);
                    draw_fancy_line(app, log_graph.face_id, fcolor_zero(), &line, p);
                }

                for (Log_Tag *tag = view_event->first_tag;
                     tag != 0;
                     tag = tag->next){
                    y_cursor += line_height;
                    if (y_cursor + line_height > box_inner.y1) goto finish_event_display;

                    {
                        Fancy_Line line = {};
                        log_graph_render__tag(scratch, &line, &log_parse, tag);

                        Vec2_f32 right_p = V2f32(box_inner.x1 - 3.f, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id, &line);
                        Vec2_f32 p = V2f32(right_p.x - width, right_p.y);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32(p.x, p.y, right_p.x, p.y + line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                Log_Filter filter = {};
                                switch (log_graph.tab){
                                    case LogTab_Filters:
                                    {
                                        filter.kind = LogFilter_TagValue;
                                        filter.tag_name_code = tag->name;
                                        filter.tag_value = tag->value;
                                    }break;
                                    case LogTab_Previews:
                                    {
                                        filter.kind = LogFilter_Tag;
                                        filter.tag_name_code = tag->name;
                                    }break;
                                }
                                if (filter.kind != LogTab_ERROR){
                                    log_filter_set__new_filter(viewing_filter_set, &filter);
                                    animate_in_n_milliseconds(app, 0);
                                }
                            }
                        }
                    }
                }

                finish_event_display:;
            }
        }

        log_graph.has_unused_click = false;
        draw_set_clip(app, prev_clip);
    }
}

static Log_Graph_Box*
log_graph__get_box_at_point(Log_Graph *graph, Vec2_f32 p){
    Log_Graph_Box *result = 0;
    if (!rect_contains_point(graph->details_region, p)){
        for (Log_Graph_Box *box_node = graph->first_box;
             box_node != 0;
             box_node = box_node->next){
            Rect_f32 box = box_node->rect;
            box.y0 -= graph->y_scroll;
            box.y1 -= graph->y_scroll;
            if (rect_contains_point(box, p)){
                result = box_node;
                break;
            }
        }
    }
    return(result);
}

static Log_Graph_Box*
log_graph__get_box_at_mouse_point(Application_Links *app, Log_Graph *graph){
    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p) - graph->layout_region.p0;
    return(log_graph__get_box_at_point(graph, m_p));
}

static void
log_graph__click_select_event(Application_Links *app, Vec2_f32 m_p)
{
    if (log_view != 0 && log_graph.holding_temp){
        Log_Graph_Box *box_node = log_graph__get_box_at_point(&log_graph, m_p);
        if (box_node != 0){
            log_graph.selected_event = box_node->event;
        }
        else{
            log_graph.has_unused_click = true;
            log_graph.unused_click = m_p;
        }
    }
}

static void
log_graph__click_jump_to_event_source(Application_Links *app, Vec2_f32 m_p){
    if (log_view != 0 && log_graph.holding_temp){
        Log_Graph_Box *box_node = log_graph__get_box_at_point(&log_graph, m_p);
        if (box_node != 0){
            Log_Event *event = box_node->event;
            log_graph.selected_event = event;

            View_ID target_view = get_next_view_looped_primary_panels(app, log_view,
                                                                      Access_ReadVisible);
            if (target_view != 0){
                String_Const_u8 file_name = log_parse__get_string(&log_parse, event->src_file_name);
                Buffer_ID target_buffer = get_buffer_by_file_name(app, file_name, Access_Always);
                if (target_buffer == 0){
                    target_buffer = get_buffer_by_name(app, file_name, Access_Always);
                }
                if (target_buffer != 0){
                    set_view_to_location(app, target_view, target_buffer,
                                         seek_line_col(event->line_number, 1));
                }
            }
        }
        else{
            log_graph.has_unused_click = true;
            log_graph.unused_click = m_p;
        }
    }
}

CUSTOM_COMMAND(show_the_log_graph, "/home/tabletel/dev/4cc/code/custom/4coder_log_parser.cpp", 991, UI)
CUSTOM_DOC("Parses *log* and displays the 'log graph' UI")
{
    if (log_view != 0){
        return;
    }

    Buffer_ID log_buffer = get_buffer_by_name(app, SCu8((u8*)("*log*"), (u64)(sizeof("*log*") - 1)), Access_Always);
    log_parse_fill(app, log_buffer);

    log_view = get_this_ctx_view(app, Access_Always);
    View_ID view = log_view;

    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = log_graph_render;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_AnyUserInput, KeyCode_Escape);
        if (in.abort){
            view = 0;
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_KeyStroke:
            {
                switch (in.event.key.code){
                    case KeyCode_PageUp:
                    {
                        log_graph.y_scroll -= get_page_jump(app, view);
                    }break;

                    case KeyCode_PageDown:
                    {
                        log_graph.y_scroll += get_page_jump(app, view);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseButton:
            {
                Vec2_f32 m_p = V2f32(in.event.mouse.p) - log_graph.layout_region.p0;
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        log_graph__click_jump_to_event_source(app, m_p);
                    }break;

                    case MouseCode_Right:
                    {
                        log_graph__click_select_event(app, m_p);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseWheel:
            {
                f32 value = in.event.mouse_wheel.value;
                log_graph.y_scroll += f32_round32(value);
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            if (ui_fallback_command_dispatch(app, view, &in)){
                break;
            }
        }
    }

    log_view = 0;
}
# 127 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_keyboard_macro.cpp" 1






static Buffer_ID
get_keyboard_log_buffer(Application_Links *app){
    return(get_buffer_by_name(app, SCu8((u8*)("*keyboard*"), (u64)(sizeof("*keyboard*") - 1)), Access_Always));
}

static void
keyboard_macro_play_single_line(Application_Links *app, String_Const_u8 macro_line){
    Scratch_Block scratch(app);
    Input_Event event = parse_keyboard_event(scratch, macro_line);
    if (event.kind != InputEventKind_None){
        enqueue_virtual_event(app, &event);
    }
}

static void
keyboard_macro_play(Application_Links *app, String_Const_u8 macro){
    Scratch_Block scratch(app);
    List_String_Const_u8 lines = string_split(scratch, macro, (u8*)"\n", 1);
    for (Node_String_Const_u8 *node = lines.first;
         node != 0;
         node = node->next){
        String_Const_u8 line = string_skip_chop_whitespace(node->string);
        keyboard_macro_play_single_line(app, line);
    }
}

static b32
get_current_input_is_virtual(Application_Links *app){
    User_Input input = get_current_input(app);
    return(input.event.virtual_event);
}



CUSTOM_COMMAND(keyboard_macro_start_recording, "/home/tabletel/dev/4cc/code/custom/4coder_keyboard_macro.cpp", 41, Normal)
CUSTOM_DOC("Start macro recording, do nothing if macro recording is already started")
{
    if (global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    global_keyboard_macro_is_recording = true;
    global_keyboard_macro_range.first = buffer_get_size(app, buffer);
}

CUSTOM_COMMAND(keyboard_macro_finish_recording, "/home/tabletel/dev/4cc/code/custom/4coder_keyboard_macro.cpp", 54, Normal)
CUSTOM_DOC("Stop macro recording, do nothing if macro recording is not already started")
{
    if (!global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    global_keyboard_macro_is_recording = false;
    i64 end = buffer_get_size(app, buffer);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(end));
    Buffer_Cursor back_cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line - 1, 1));
    global_keyboard_macro_range.one_past_last = back_cursor.pos;







}

CUSTOM_COMMAND(keyboard_macro_replay, "/home/tabletel/dev/4cc/code/custom/4coder_keyboard_macro.cpp", 77, Normal)
CUSTOM_DOC("Replay the most recently recorded keyboard macro")
{
    if (global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    Scratch_Block scratch(app);
    String_Const_u8 macro = push_buffer_range(app, scratch, buffer, global_keyboard_macro_range);
    keyboard_macro_play(app, macro);
}
# 128 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_cli_command.cpp" 1






CUSTOM_COMMAND(execute_previous_cli, "/home/tabletel/dev/4cc/code/custom/4coder_cli_command.cpp", 7, Normal)
CUSTOM_DOC("If the command execute_any_cli has already been used, this will execute a CLI reusing the most recent buffer name and command.")
{
    String_Const_u8 out_buffer = SCu8(out_buffer_space);
    String_Const_u8 cmd = SCu8(command_space);
    String_Const_u8 hot_directory = SCu8(hot_directory_space);

    if (out_buffer.size > 0 && cmd.size > 0 && hot_directory.size > 0){
        View_ID view = get_active_view(app, Access_Always);
        Buffer_Identifier id = buffer_identifier(out_buffer);
        exec_system_command(app, view, id, hot_directory, cmd, CLI_OverlapWithConflict|CLI_CursorAtEnd|CLI_SendEndSignal);
        lock_jump_buffer(app, out_buffer);
    }
}

CUSTOM_COMMAND(execute_any_cli, "/home/tabletel/dev/4cc/code/custom/4coder_cli_command.cpp", 22, Normal)
CUSTOM_DOC("Queries for an output buffer name and system command, runs the system command as a CLI and prints the output to the specified buffer."){
    Scratch_Block scratch(app);
    Query_Bar_Group group(app);

    Query_Bar bar_out = {};
    bar_out.prompt = SCu8((u8*)("Output Buffer: "), (u64)(sizeof("Output Buffer: ") - 1));
    bar_out.string = SCu8(out_buffer_space, (u64)0);
    bar_out.string_capacity = sizeof(out_buffer_space);
    if (!query_user_string(app, &bar_out)) return;
    bar_out.string.size = (((bar_out.string.size)<(sizeof(out_buffer_space) - 1))?(bar_out.string.size):(sizeof(out_buffer_space) - 1));
    out_buffer_space[bar_out.string.size] = 0;

    Query_Bar bar_cmd = {};
    bar_cmd.prompt = SCu8((u8*)("Command: "), (u64)(sizeof("Command: ") - 1));
    bar_cmd.string = SCu8(command_space, (u64)0);
    bar_cmd.string_capacity = sizeof(command_space);
    if (!query_user_string(app, &bar_cmd)) return;
    bar_cmd.string.size = (((bar_cmd.string.size)<(sizeof(command_space) - 1))?(bar_cmd.string.size):(sizeof(command_space) - 1));
    command_space[bar_cmd.string.size] = 0;

    String_Const_u8 hot = push_hot_directory(app, scratch);
    {
        u64 size = (((hot.size)<(sizeof(hot_directory_space)))?(hot.size):(sizeof(hot_directory_space)));
        block_copy(hot_directory_space, hot.str, size);
        hot_directory_space[hot.size] = 0;
    }

    execute_previous_cli(app);
}
# 129 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp" 1






static String_Const_u8
push_build_directory_at_file(Application_Links *app, Arena *arena, Buffer_ID buffer){
    String_Const_u8 result = {};
    String_Const_u8 file_name = push_buffer_file_name(app, arena, buffer);
    Temp_Memory restore_point = begin_temp(arena);
    String_Const_u8 base_name = push_buffer_base_name(app, arena, buffer);
    b32 is_match = string_match(file_name, base_name);
    end_temp(restore_point);
    if (!is_match){
        result = push_string_copy(arena, string_remove_last_folder(file_name));
    }
    return(result);
}
# 32 "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp"
static String_Const_u8 standard_build_file_name_array[] = {
    {(u8*)("build.sh"), sizeof("build.sh") - 1},
    {(u8*)("Makefile"), sizeof("Makefile") - 1},
};
static String_Const_u8 standard_build_cmd_string_array[] = {
    {(u8*)("build.sh"), sizeof("build.sh") - 1},
    {(u8*)("make"), sizeof("make") - 1},
};





static String_Const_u8
push_fallback_command(Arena *arena, String_Const_u8 file_name){
    return(push_u8_stringf(arena, "echo could not find %.*s", (i32)(file_name).size, (char*)(file_name).str));
}

static String_Const_u8
push_fallback_command(Arena *arena){
    return(push_fallback_command(arena, standard_build_file_name_array[0]));
}

static const Buffer_Identifier standard_build_build_buffer_identifier = buffer_identifier(SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));

static const u32 standard_build_exec_flags = CLI_OverlapWithConflict|CLI_SendEndSignal;

static void
standard_build_exec_command(Application_Links *app, View_ID view, String_Const_u8 dir, String_Const_u8 cmd){
    exec_system_command(app, view, standard_build_build_buffer_identifier,
                        dir, cmd,
                        standard_build_exec_flags);
}

static b32
standard_search_and_build_from_dir(Application_Links *app, View_ID view, String_Const_u8 start_dir){
    Scratch_Block scratch(app);


    String_Const_u8 full_file_path = {};
    String_Const_u8 cmd_string = {};
    for (i32 i = 0; i < ((sizeof(standard_build_file_name_array))/(sizeof(*standard_build_file_name_array))); i += 1){
        full_file_path = push_file_search_up_path(app, scratch, start_dir, standard_build_file_name_array[i]);
        if (full_file_path.size > 0){
            cmd_string = standard_build_cmd_string_array[i];
            break;
        }
    }

    b32 result = (full_file_path.size > 0);
    if (result){

        String_Const_u8 path = string_remove_last_folder(full_file_path);
        String_Const_u8 command = push_u8_stringf(scratch, "\"%.*s/%.*s\"",
                                                  (i32)(path).size, (char*)(path).str,
                                                  (i32)(cmd_string).size, (char*)(cmd_string).str);
        b32 auto_save = def_get_config_b32(vars_save_string(SCu8((u8*)("automatically_save_changes_on_build"), (u64)(sizeof("automatically_save_changes_on_build") - 1))));
        if (auto_save){
            save_all_dirty_buffers(app);
        }
        standard_build_exec_command(app, view, path, command);
        print_message(app, push_u8_stringf(scratch, "Building with: %.*s\n",
                                           (i32)(full_file_path).size, (char*)(full_file_path).str));
    }

    return(result);
}



static void
standard_search_and_build(Application_Links *app, View_ID view, Buffer_ID active_buffer){
    Scratch_Block scratch(app);
    b32 did_build = false;
    String_Const_u8 build_dir = push_build_directory_at_file(app, scratch, active_buffer);
    if (build_dir.size > 0){
        did_build = standard_search_and_build_from_dir(app, view, build_dir);
    }
    if (!did_build){
        build_dir = push_hot_directory(app, scratch);
        if (build_dir.size > 0){
            did_build = standard_search_and_build_from_dir(app, view, build_dir);
        }
    }
    if (!did_build){
        standard_build_exec_command(app, view,
                                    push_hot_directory(app, scratch),
                                    push_fallback_command(scratch));
    }
}

CUSTOM_COMMAND(build_search, "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp", 123, Normal)
CUSTOM_DOC("Looks for a build.bat, build.sh, or makefile in the current and parent directories.  Runs the first that it finds and prints the output to *compilation*.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    standard_search_and_build(app, view, buffer);
    block_zero((&prev_location), sizeof(*(&prev_location)));
    lock_jump_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));
}

static Buffer_ID
get_comp_buffer(Application_Links *app){
    return(get_buffer_by_name(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)), Access_Always));
}

static View_ID
get_or_open_build_panel(Application_Links *app){
    View_ID view = 0;
    Buffer_ID buffer = get_comp_buffer(app);
    if (buffer != 0){
        view = get_first_view_with_buffer(app, buffer);
    }
    if (view == 0){
        view = open_build_footer_panel(app);
    }
    return(view);
}

static void
set_fancy_compilation_buffer_font(Application_Links *app){
    Scratch_Block scratch(app);
    Buffer_ID buffer = get_comp_buffer(app);
    Font_Load_Location font = {};
    font.file_name = def_search_normal_full_path(scratch, {(u8*)("fonts/Inconsolata-Regular.ttf"), sizeof("fonts/Inconsolata-Regular.ttf") - 1});
    set_buffer_face_by_font_load_location(app, buffer, &font);
}

CUSTOM_COMMAND(build_in_build_panel, "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp", 160, Normal)
CUSTOM_DOC("Looks for a build.bat, build.sh, or makefile in the current and parent directories.  Runs the first that it finds and prints the output to *compilation*.  Puts the *compilation* buffer in a panel at the footer of the current view.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    View_ID build_view = get_or_open_build_panel(app);

    standard_search_and_build(app, build_view, buffer);
    set_fancy_compilation_buffer_font(app);

    block_zero((&prev_location), sizeof(*(&prev_location)));
    lock_jump_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));
}

CUSTOM_COMMAND(close_build_panel, "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp", 175, Normal)
CUSTOM_DOC("If the special build panel is open, closes it.")
{
    close_build_footer_panel(app);
}

CUSTOM_COMMAND(change_to_build_panel, "/home/tabletel/dev/4cc/code/custom/4coder_build_commands.cpp", 181, Normal)
CUSTOM_DOC("If the special build panel is open, makes the build panel the active panel.")
{
    View_ID view = get_or_open_build_panel(app);
    if (view != 0){
        view_set_active(app, view);
    }
}
# 130 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp"
static Prj_Pattern_List
prj_pattern_list_from_extension_array(Arena *arena, String8Array list){
    Prj_Pattern_List result = {};
    for (i32 i = 0;
         i < list.count;
         ++i){
        Prj_Pattern_Node *node = ((Prj_Pattern_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Prj_Pattern_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "16" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "16" ":") - 1)))));
        do{ if((node)){if((result.first)){(result.last)->next=(node);}else{(result.first)=(node);}(result.last)=(node);(result.last)->next=0;} }while(0);
        result.count += 1;

        String8 str = push_stringf(arena, "*.%.*s", (i32)(list.vals[i]).size, (char*)(list.vals[i]).str);
        node->pattern.absolutes = string_split_wildcards(arena, str);
    }
    return(result);
}

static Prj_Pattern_List
prj_pattern_list_from_var(Arena *arena, Variable_Handle var){
    Prj_Pattern_List result = {};
    for (Variable_Handle child_var = vars_first_child(var); !vars_is_nil(child_var); child_var = vars_next_sibling(child_var)){
        Prj_Pattern_Node *node = ((Prj_Pattern_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Prj_Pattern_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "30" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "30" ":") - 1)))));
        do{ if((node)){if((result.first)){(result.last)->next=(node);}else{(result.first)=(node);}(result.last)=(node);(result.last)->next=0;} }while(0);
        result.count += 1;

        String8 str = vars_string_from_var(arena, child_var);
        node->pattern.absolutes = string_split_wildcards(arena, str);
    }
    return(result);
}

static Prj_Pattern_List
prj_get_standard_blacklist(Arena *arena){
    String8 dot = SCu8((u8*)(".*"), (u64)(sizeof(".*") - 1));
    String8Array black_array = {};
    black_array.strings = &dot;
    black_array.count = 1;
    return(prj_pattern_list_from_extension_array(arena, black_array));
}

static b32
prj_match_in_pattern_list(String8 string, Prj_Pattern_List list){
    b32 found_match = false;
    for (Prj_Pattern_Node *node = list.first;
         node != 0;
         node = node->next){
        if (string_wildcard_match(node->pattern.absolutes, string, StringMatch_Exact)){
            found_match = true;
            break;
        }
    }
    return(found_match);
}

static void
prj_close_files_with_ext(Application_Links *app, String8Array extension_array){
    Scratch_Block scratch(app);

    i32 buffers_to_close_max = ((100)*1000);
    Buffer_ID *buffers_to_close = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(buffers_to_close_max), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "68" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "68" ":") - 1)))));

    b32 do_repeat = false;
    do{
        i32 buffers_to_close_count = 0;
        do_repeat = false;

        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 is_match = true;

            if (extension_array.count > 0){
                Temp_Memory name_temp = begin_temp(scratch);
                String8 file_name = push_buffer_file_name(app, scratch, buffer);
                is_match = false;
                if (file_name.size > 0){
                    String8 extension = string_file_extension(file_name);
                    for (i32 i = 0; i < extension_array.count; ++i){
                        if (string_match(extension, extension_array.strings[i])){
                            is_match = true;
                            break;
                        }
                    }
                }
                end_temp(name_temp);
            }

            if (is_match){
                if (buffers_to_close_count >= buffers_to_close_max){
                    do_repeat = true;
                    break;
                }
                buffers_to_close[buffers_to_close_count++] = buffer;
            }
        }

        for (i32 i = 0; i < buffers_to_close_count; ++i){
            buffer_kill(app, buffers_to_close[i], BufferKill_AlwaysKill);
        }
    }while(do_repeat);
}

static void
prj_open_files_pattern_filter__rec(Application_Links *app, String8 path, Prj_Pattern_List whitelist, Prj_Pattern_List blacklist, Prj_Open_File_Flags flags){
    Scratch_Block scratch(app);

    Profile_Scope_Block profile_get_file_list ((app), SCu8((u8*)("get file list"), (u64)(sizeof("get file list") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "115" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "115" ":") - 1)));
    File_List list = system_get_file_list(scratch, path);
    ((profile_get_file_list).close_now());

    File_Info **info = list.infos;
    for (u32 i = 0; i < list.count; ++i, ++info){
        String8 file_name = (**info).file_name;
        if (((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)){
            if ((flags & PrjOpenFileFlag_Recursive) == 0){
                continue;
            }
            if (prj_match_in_pattern_list(file_name, blacklist)){
                continue;
            }
            String8 new_path = push_u8_stringf(scratch, "%.*s%.*s/", (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);
            prj_open_files_pattern_filter__rec(app, new_path, whitelist, blacklist, flags);
        }
        else{
            if (!prj_match_in_pattern_list(file_name, whitelist)){
                continue;
            }
            if (prj_match_in_pattern_list(file_name, blacklist)){
                continue;
            }
            String8 full_path = push_u8_stringf(scratch, "%.*s%.*s", (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);
            create_buffer(app, full_path, 0);
        }
    }
}

static void
prj_open_files_pattern_filter(Application_Links *app, String8 dir, Prj_Pattern_List whitelist, Prj_Pattern_List blacklist, Prj_Open_File_Flags flags){
    Profile_Scope_Block profile_block_147 ((app), SCu8((u8*)("open all files in directory pattern"), (u64)(sizeof("open all files in directory pattern") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "147" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "147" ":") - 1)));
    Scratch_Block scratch(app);
    String8 directory = dir;
    if (!character_is_slash(string_get_character(directory, directory.size - 1))){
        directory = push_u8_stringf(scratch, "%.*s/", (i32)(dir).size, (char*)(dir).str);
    }
    prj_open_files_pattern_filter__rec(app, directory, whitelist, blacklist, flags);
}

static void
prj_open_all_files_with_ext_in_hot(Application_Links *app, String8Array array, Prj_Open_File_Flags flags){
    Scratch_Block scratch(app);
    String8 hot = push_hot_directory(app, scratch);
    String8 directory = hot;
    if (!character_is_slash(string_get_character(hot, hot.size - 1))){
        directory = push_u8_stringf(scratch, "%.*s/", (i32)(hot).size, (char*)(hot).str);
    }
    Prj_Pattern_List whitelist = prj_pattern_list_from_extension_array(scratch, array);
    Prj_Pattern_List blacklist = prj_get_standard_blacklist(scratch);
    prj_open_files_pattern_filter(app, hot, whitelist, blacklist, flags);
}




static void
prj_stringize__string_list(Application_Links *app, Arena *arena, String8 name, Variable_Handle list, String8List *out){
    Scratch_Block scratch(app, arena);
    string_list_pushf(arena, out, "%.*s = {\n", (i32)(name).size, (char*)(name).str);
    for (Variable_Handle child = vars_first_child(list); !vars_is_nil(child); child = vars_next_sibling(child)){
        String8 child_string = vars_string_from_var(scratch, child);
        if (child_string.size > 0){

            string_list_pushf(arena, out, "\"%.*s\",\n", (i32)(child_string).size, (char*)(child_string).str);
        }
    }
    string_list_pushf(arena, out, "};\n");
}

static void
prj_stringize_project(Application_Links *app, Arena *arena, Variable_Handle project, String8List *out){
    Scratch_Block scratch(app, arena);


    String_ID version_id = vars_save_string(SCu8((u8*)("version"), (u64)(sizeof("version") - 1)));
    String_ID project_name_id = vars_save_string(SCu8((u8*)("project_name"), (u64)(sizeof("project_name") - 1)));
    String_ID patterns_id = vars_save_string(SCu8((u8*)("patterns"), (u64)(sizeof("patterns") - 1)));
    String_ID blacklist_patterns_id = vars_save_string(SCu8((u8*)("blacklist_patterns"), (u64)(sizeof("blacklist_patterns") - 1)));

    String_ID load_paths_id = vars_save_string(SCu8((u8*)("load_paths"), (u64)(sizeof("load_paths") - 1)));
    String_ID path_id = vars_save_string(SCu8((u8*)("path"), (u64)(sizeof("path") - 1)));
    String_ID relative_id = vars_save_string(SCu8((u8*)("relative"), (u64)(sizeof("relative") - 1)));
    String_ID recursive_id = vars_save_string(SCu8((u8*)("recursive"), (u64)(sizeof("recursive") - 1)));

    String_ID commands_id = vars_save_string(SCu8((u8*)("commands"), (u64)(sizeof("commands") - 1)));
    String_ID out_id = vars_save_string(SCu8((u8*)("out"), (u64)(sizeof("out") - 1)));
    String_ID footer_panel_id = vars_save_string(SCu8((u8*)("footer_panel"), (u64)(sizeof("footer_panel") - 1)));
    String_ID save_dirty_files_id = vars_save_string(SCu8((u8*)("save_dirty_files"), (u64)(sizeof("save_dirty_files") - 1)));
    String_ID cursor_at_end_id = vars_save_string(SCu8((u8*)("cursor_at_end"), (u64)(sizeof("cursor_at_end") - 1)));

    String_ID fkey_command_id = vars_save_string(SCu8((u8*)("fkey_command"), (u64)(sizeof("fkey_command") - 1)));
    String_ID fkey_command_override_id = vars_save_string(SCu8((u8*)("fkey_command_override"), (u64)(sizeof("fkey_command_override") - 1)));

    String8 os_strings[] = { {(u8*)("win"), sizeof("win") - 1}, {(u8*)("linux"), sizeof("linux") - 1}, {(u8*)("mac"), sizeof("mac") - 1}, };
    static const i32 os_string_count = ((sizeof(os_strings))/(sizeof(*os_strings)));
    String_ID os_string_ids[os_string_count];
    for (i32 i = 0; i < os_string_count; i += 1){
        os_string_ids[i] = vars_save_string(os_strings[i]);
    }





    u64 version = vars_u64_from_var(app, vars_read_key(project, version_id));
    version = (((2)>(version))?(2):(version));
    string_list_pushf(arena, out, "version(%llu);\n", version);

    String8 project_name = vars_string_from_var(scratch, vars_read_key(project, project_name_id));
    if (project_name.size > 0){

        string_list_pushf(arena, out, "project_name = \"%.*s\";\n", (i32)(project_name).size, (char*)(project_name).str);
    }

    string_list_push(arena, out, {(u8*)("\n"), sizeof("\n") - 1});



    Variable_Handle patterns = vars_read_key(project, patterns_id);
    if (!vars_is_nil(patterns)){
        prj_stringize__string_list(app, arena, {(u8*)("patterns"), sizeof("patterns") - 1}, patterns, out);
    }

    Variable_Handle blacklist_patterns = vars_read_key(project, blacklist_patterns_id);
    if (!vars_is_nil(blacklist_patterns)){
        prj_stringize__string_list(app, arena, {(u8*)("blacklist_patterns"), sizeof("blacklist_patterns") - 1}, blacklist_patterns, out);
    }

    string_list_push(arena, out, {(u8*)("\n"), sizeof("\n") - 1});



    Variable_Handle load_paths = vars_read_key(project, load_paths_id);
    if (!vars_is_nil(load_paths)){
        string_list_push(arena, out, {(u8*)("load_paths = {\n"), sizeof("load_paths = {\n") - 1});
        for (i32 i = 0; i < os_string_count; i += 1){
            Variable_Handle os_paths = vars_read_key(load_paths, os_string_ids[i]);
            if (!vars_is_nil(os_paths)){
                String8 os_string = os_strings[i];
                string_list_pushf(arena, out, ".%.*s = {\n", (i32)(os_string).size, (char*)(os_string).str);
                for (Variable_Handle child = vars_first_child(os_paths); !vars_is_nil(child); child = vars_next_sibling(child)){
                    Variable_Handle path_var = vars_read_key(child, path_id);
                    Variable_Handle recursive_var = vars_read_key(child, recursive_id);
                    Variable_Handle relative_var = vars_read_key(child, relative_id);


                    String8 path_string = vars_string_from_var(scratch, path_var);
                    b32 recursive = vars_b32_from_var(recursive_var);
                    b32 relative = vars_b32_from_var(relative_var);

                    string_list_push(arena, out, {(u8*)("{ "), sizeof("{ ") - 1});
                    string_list_pushf(arena, out, ".path = \"%.*s\", ", (i32)(path_string).size, (char*)(path_string).str);
                    string_list_pushf(arena, out, ".recursive = %s, ", (recursive?"true":"false"));
                    string_list_pushf(arena, out, ".relative = %s, ", (relative?"true":"false"));
                    string_list_push(arena, out, {(u8*)("},\n"), sizeof("},\n") - 1});
                }
                string_list_push(arena, out, {(u8*)("},\n"), sizeof("},\n") - 1});
            }
        }
        string_list_push(arena, out, {(u8*)("};\n\n"), sizeof("};\n\n") - 1});
    }



    Variable_Handle commands = vars_read_key(project, commands_id);
    if (!vars_is_nil(commands)){
        string_list_push(arena, out, {(u8*)("commands = {\n"), sizeof("commands = {\n") - 1});
        for (Variable_Handle command = vars_first_child(commands); !vars_is_nil(command); command = vars_next_sibling(command)){
            String8 command_name = vars_key_from_var(scratch, command);
            string_list_pushf(arena, out, ".%.*s = {\n", (i32)(command_name).size, (char*)(command_name).str);

            for (i32 i = 0; i < os_string_count; i += 1){
                Variable_Handle os_cmd_var = vars_read_key(command, os_string_ids[i]);
                if (!vars_is_nil(os_cmd_var)){

                    String8 os_cmd_string = vars_string_from_var(scratch, os_cmd_var);
                    string_list_pushf(arena, out, ".%.*s = \"%.*s\",\n", (i32)(os_strings[i]).size, (char*)(os_strings[i]).str, (i32)(os_cmd_string).size, (char*)(os_cmd_string).str);
                }
            }

            Variable_Handle out_var = vars_read_key(command, out_id);
            Variable_Handle footer_panel_var = vars_read_key(command, footer_panel_id);
            Variable_Handle save_dirty_files_var = vars_read_key(command, save_dirty_files_id);
            Variable_Handle cursor_at_end_var = vars_read_key(command, cursor_at_end_id);


            String8 out_string = vars_string_from_var(scratch, out_var);
            b32 footer_panel = vars_b32_from_var(footer_panel_var);
            b32 save_dirty_files = vars_b32_from_var(save_dirty_files_var);
            b32 cursor_at_end = vars_b32_from_var(cursor_at_end_var);

            string_list_pushf(arena, out, ".out = \"%.*s\",\n", (i32)(out_string).size, (char*)(out_string).str);
            string_list_pushf(arena, out, ".footer_panel = %s,\n", (footer_panel?"true":"false"));
            string_list_pushf(arena, out, ".save_dirty_files = %s,\n", (save_dirty_files?"true":"false"));
            string_list_pushf(arena, out, ".cursor_at_end = %s,\n", (cursor_at_end?"true":"false"));
            string_list_push(arena, out, {(u8*)("},\n"), sizeof("},\n") - 1});
        }
        string_list_push(arena, out, {(u8*)("};\n\n"), sizeof("};\n\n") - 1});
    }



    Variable_Handle fkey_commands = vars_read_key(project, fkey_command_id);
    if (!vars_is_nil(fkey_commands)){
        string_list_push(arena, out, {(u8*)("fkey_command = {\n"), sizeof("fkey_command = {\n") - 1});
        for (Variable_Handle child = vars_first_child(fkey_commands); !vars_is_nil(child); child = vars_next_sibling(child)){
            String8 key = vars_key_from_var(scratch, child);
            String8 name = vars_string_from_var(scratch, child);
            string_list_pushf(arena, out, ".%.*s = \"%.*s\",\n",
                              (i32)(key).size, (char*)(key).str, (i32)(name).size, (char*)(name).str);
        }
        string_list_push(arena, out, {(u8*)("};\n\n"), sizeof("};\n\n") - 1});
    }



    Variable_Handle fkey_commands_overide = vars_read_key(project, fkey_command_override_id);
    if (!vars_is_nil(fkey_commands_overide)){
        string_list_push(arena, out, {(u8*)("fkey_command_override = {\n"), sizeof("fkey_command_override = {\n") - 1});
        for (Variable_Handle user_child = vars_first_child(fkey_commands_overide); !vars_is_nil(user_child); user_child = vars_next_sibling(user_child)){
            String8 user_key = vars_key_from_var(scratch, user_child);
            string_list_pushf(arena, out, ".%.*s = {\n", (i32)(user_key).size, (char*)(user_key).str);
            for (Variable_Handle child = vars_first_child(user_child); !vars_is_nil(child); child = vars_next_sibling(child)){
                String8 key = vars_key_from_var(scratch, child);
                String8 name = vars_string_from_var(scratch, child);
                string_list_pushf(arena, out, ".%.*s = \"%.*s\",\n",
                                  (i32)(key).size, (char*)(key).str, (i32)(name).size, (char*)(name).str);
            }
            string_list_pushf(arena, out, "},\n");
        }
        string_list_push(arena, out, {(u8*)("};\n\n"), sizeof("};\n\n") - 1});
    }
}

static Prj_Setup_Status
prj_file_is_setup(Application_Links *app, String8 script_path, String8 script_file){
    Prj_Setup_Status result = {};
    {
        Scratch_Block scratch(app);
        String8 bat_path = push_u8_stringf(scratch, "%.*s/%.*s.bat",
                                           (i32)(script_path).size, (char*)(script_path).str,
                                           (i32)(script_file).size, (char*)(script_file).str);
        result.bat_exists = file_exists(app, bat_path);
    }
    {
        Scratch_Block scratch(app);
        String8 sh_path = push_u8_stringf(scratch, "%.*s/%.*s.sh",
                                          (i32)(script_path).size, (char*)(script_path).str,
                                          (i32)(script_file).size, (char*)(script_file).str);
        result.sh_exists = file_exists(app, sh_path);
    }
    {
        Scratch_Block scratch(app);
        String8 project_path = push_u8_stringf(scratch, "%.*s/project.4coder",
                                               (i32)(script_path).size, (char*)(script_path).str);
        result.sh_exists = file_exists(app, project_path);
    }
    result.everything_exists = (result.bat_exists && result.sh_exists && result.project_exists);
    return(result);
}

static b32
prj_generate_bat(Arena *scratch, String8 opts, String8 compiler, String8 script_path, String8 script_file,
                 String8 code_file, String8 output_dir, String8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String8 cf = push_string_copy(scratch, code_file);
    String8 od = push_string_copy(scratch, output_dir);
    String8 bf = push_string_copy(scratch, binary_file);

    cf = string_mod_replace_character(cf, '/', '\\');
    od = string_mod_replace_character(od, '/', '\\');
    bf = string_mod_replace_character(bf, '/', '\\');

    String8 file_name = push_u8_stringf(scratch, "%.*s/%.*s.bat",
                                        (i32)(script_path).size, (char*)(script_path).str,
                                        (i32)(script_file).size, (char*)(script_file).str);

    FILE *bat_script = fopen((char*)file_name.str, "wb");
    if (bat_script != 0){
        fprintf(bat_script, "@echo off\n\n");
        fprintf(bat_script, "set opts=%.*s\n", (i32)opts.size, opts.str);
        fprintf(bat_script, "set code=%%cd%%\n");
        fprintf(bat_script, "pushd %.*s\n", (i32)od.size, od.str);
        fprintf(bat_script, "%.*s %%opts%% %%code%%\\%.*s -Fe%.*s\n",
                (i32)compiler.size, compiler.str, (i32)cf.size, cf.str, (i32)bf.size, bf.str);
        fprintf(bat_script, "popd\n");
        fclose(bat_script);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static b32
prj_generate_sh(Arena *scratch, String8 opts, String8 compiler, String8 script_path, String8 script_file, String8 code_file, String8 output_dir, String8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String8 cf = code_file;
    String8 od = output_dir;
    String8 bf = binary_file;

    String8 file_name = push_u8_stringf(scratch, "%.*s/%.*s.sh",
                                        (i32)(script_path).size, (char*)(script_path).str,
                                        (i32)(script_file).size, (char*)(script_file).str);

    FILE *sh_script = fopen((char*)file_name.str, "wb");
    if (sh_script != 0){
        fprintf(sh_script, "#!/bin/bash\n\n");
        fprintf(sh_script, "code=\"$PWD\"\n");
        fprintf(sh_script, "opts=%.*s\n", (i32)(opts).size, (char*)(opts).str);
        fprintf(sh_script, "cd %.*s > /dev/null\n", (i32)(od).size, (char*)(od).str);
        fprintf(sh_script, "%.*s $opts $code/%.*s -o %.*s\n", (i32)(compiler).size, (char*)(compiler).str, (i32)(cf).size, (char*)(cf).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(sh_script, "cd $code > /dev/null\n");
        fclose(sh_script);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static b32
prj_generate_project(Arena *scratch, String8 script_path, String8 script_file, String8 output_dir, String8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String8 od = output_dir;
    String8 bf = binary_file;

    String8 od_win = string_replace(scratch, od,
                                    SCu8((u8*)("/"), (u64)(sizeof("/") - 1)), SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)));
    String8 bf_win = string_replace(scratch, bf,
                                    SCu8((u8*)("/"), (u64)(sizeof("/") - 1)), SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)));

    String8 file_name = push_u8_stringf(scratch, "%.*s/project.4coder", (i32)(script_path).size, (char*)(script_path).str);

    FILE *out = fopen((char*)file_name.str, "wb");
    if (out != 0){
        fprintf(out, "version(2);\n");
        fprintf(out, "project_name = \"%.*s\";\n", (i32)(binary_file).size, (char*)(binary_file).str);
        fprintf(out, "patterns = {\n");
        fprintf(out, "\"*.c\",\n");
        fprintf(out, "\"*.cpp\",\n");
        fprintf(out, "\"*.h\",\n");
        fprintf(out, "\"*.m\",\n");
        fprintf(out, "\"*.bat\",\n");
        fprintf(out, "\"*.sh\",\n");
        fprintf(out, "\"*.4coder\",\n");
        fprintf(out, "};\n");
        fprintf(out, "blacklist_patterns = {\n");
        fprintf(out, "\".*\",\n");
        fprintf(out, "};\n");
        fprintf(out, "load_paths_base = {\n");
        fprintf(out, " { \".\", .relative = true, .recursive = true, },\n");
        fprintf(out, "};\n");
        fprintf(out, "load_paths = {\n");
        fprintf(out, " .win = load_paths_base,\n");
        fprintf(out, " .linux = load_paths_base,\n");
        fprintf(out, " .mac = load_paths_base,\n");
        fprintf(out, "};\n");

        fprintf(out, "\n");

        fprintf(out, "commands = {\n");
        fprintf(out, " .build = { .out = \"*compilation*\", .footer_panel = true, .save_dirty_files = true,\n");
        fprintf(out, "   .win = \"%.*s.bat\",\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, "   .linux = \"./%.*s.sh\",\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, "   .mac = \"./%.*s.sh\", },\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, " .run = { .out = \"*run*\", .footer_panel = false, .save_dirty_files = false,\n");
        fprintf(out, "   .win = \"%.*s\\\\%.*s\",\n", (i32)(od_win).size, (char*)(od_win).str, (i32)(bf_win).size, (char*)(bf_win).str);
        fprintf(out, "   .linux = \"%.*s/%.*s\",\n", (i32)(od).size, (char*)(od).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(out, "   .mac = \"%.*s/%.*s\", },\n", (i32)(od).size, (char*)(od).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(out, "};\n");

        fprintf(out, "fkey_command = {\n");
        fprintf(out, ".F1 = \"run\";\n");
        fprintf(out, ".F2 = \"run\";\n");
        fprintf(out, "};\n");

        fclose(out);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static void
prj_setup_scripts(Application_Links *app, Prj_Setup_Script_Flags flags){
    Scratch_Block scratch(app);
    String8 script_path = push_hot_directory(app, scratch);

    b32 do_project_file = (flags & PrjSetupScriptFlag_Project);
    b32 do_bat_script = (flags & PrjSetupScriptFlag_Bat);
    b32 do_sh_script = (flags & PrjSetupScriptFlag_Sh);

    b32 needs_to_do_work = false;
    Prj_Setup_Status status = {};
    if (do_project_file){
        status = prj_file_is_setup(app, script_path, SCu8((u8*)("build"), (u64)(sizeof("build") - 1)));
        needs_to_do_work =
            !status.project_exists ||
        (do_bat_script && !status.bat_exists) ||
        (do_sh_script && !status.sh_exists);
    }
    else{
        needs_to_do_work = true;
    }

    if (needs_to_do_work){


        b32 finished_queries = false;
        static const i32 text_field_cap = 1024;

        String8 script_file = {};
        String8 code_file = {};
        String8 output_dir = {};
        String8 binary_file = {};

        {
            Query_Bar_Group bar_group(app);

            Query_Bar script_file_bar = {};
            Query_Bar code_file_bar = {};
            Query_Bar output_dir_bar = {};
            Query_Bar binary_file_bar = {};

            b32 get_script_file = !do_project_file;
            b32 get_code_file = ((do_bat_script && !status.bat_exists) || (do_sh_script && !status.sh_exists));

            if (get_script_file){
                script_file_bar.prompt = SCu8((u8*)("Script Name: "), (u64)(sizeof("Script Name: ") - 1));
                script_file_bar.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(text_field_cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "560" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "560" ":") - 1)))));
                script_file_bar.string_capacity = text_field_cap;
                if (!query_user_string(app, &script_file_bar) ||
                    script_file_bar.string.size == 0){
                    goto fail_out;
                }
            }

            if (get_code_file){
                code_file_bar.prompt = SCu8((u8*)("Build Target: "), (u64)(sizeof("Build Target: ") - 1));
                code_file_bar.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(text_field_cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "570" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "570" ":") - 1)))));
                code_file_bar.string_capacity = text_field_cap;
                if (!query_user_string(app, &code_file_bar) ||
                    code_file_bar.string.size == 0){
                    goto fail_out;
                }
            }

            output_dir_bar.prompt = SCu8((u8*)("Output Directory: "), (u64)(sizeof("Output Directory: ") - 1));
            output_dir_bar.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(text_field_cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "579" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "579" ":") - 1)))));
            output_dir_bar.string_capacity = text_field_cap;
            if (!query_user_string(app, &output_dir_bar)){
                goto fail_out;
            }
            if (output_dir_bar.string.size == 0){
                output_dir_bar.string.str[0] = '.';
                output_dir_bar.string.size = 1;
            }

            binary_file_bar.prompt = SCu8((u8*)("Binary Output: "), (u64)(sizeof("Binary Output: ") - 1));
            binary_file_bar.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(text_field_cap), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "590" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "590" ":") - 1)))));
            binary_file_bar.string_capacity = text_field_cap;
            if (!query_user_string(app, &binary_file_bar) ||
                binary_file_bar.string.size == 0){
                goto fail_out;
            }

            finished_queries = true;
            script_file = script_file_bar.string;
            code_file = code_file_bar.string;
            output_dir = output_dir_bar.string;
            binary_file = binary_file_bar.string;

            fail_out:;
        }

        if (!finished_queries){
            return;
        }

        if (do_project_file){
            script_file = SCu8((u8*)("build"), (u64)(sizeof("build") - 1));
        }

        if (!do_project_file){
            status = prj_file_is_setup(app, script_path, script_file);
        }


        if (do_bat_script){
            if (!status.bat_exists){
                String8 default_flags_bat = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_flags_bat"), (u64)(sizeof("default_flags_bat") - 1))));
                String8 default_compiler_bat = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_compiler_bat"), (u64)(sizeof("default_compiler_bat") - 1))));

                if (!prj_generate_bat(scratch, default_flags_bat, default_compiler_bat, script_path,
                                      script_file, code_file, output_dir, binary_file)){
                    print_message(app, SCu8((u8*)("could not create build.bat for new project\n"), (u64)(sizeof("could not create build.bat for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("the batch script already exists, no changes made to it\n"), (u64)(sizeof("the batch script already exists, no changes made to it\n") - 1)));
            }
        }

        if (do_sh_script){
            if (!status.bat_exists){
                String8 default_flags_sh = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_flags_sh"), (u64)(sizeof("default_flags_sh") - 1))));
                String8 default_compiler_sh = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("default_compiler_sh"), (u64)(sizeof("default_compiler_sh") - 1))));
                if (!prj_generate_sh(scratch, default_flags_sh, default_compiler_sh,
                                     script_path, script_file, code_file, output_dir, binary_file)){
                    print_message(app, SCu8((u8*)("could not create build.sh for new project\n"), (u64)(sizeof("could not create build.sh for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("the shell script already exists, no changes made to it\n"), (u64)(sizeof("the shell script already exists, no changes made to it\n") - 1)));
            }
        }

        if (do_project_file){
            if (!status.project_exists){
                if (!prj_generate_project(scratch, script_path, script_file, output_dir, binary_file)){
                    print_message(app, SCu8((u8*)("could not create project.4coder for new project\n"), (u64)(sizeof("could not create project.4coder for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("project.4coder already exists, no changes made to it\n"), (u64)(sizeof("project.4coder already exists, no changes made to it\n") - 1)));
            }
        }
    }
    else{
        if (do_project_file){
            print_message(app, SCu8((u8*)("project already setup, no changes made\n"), (u64)(sizeof("project already setup, no changes made\n") - 1)));
        }
    }
}




static void
prj_exec_command(Application_Links *app, Variable_Handle cmd_var){
    Scratch_Block scratch(app);

    String_ID os_id = vars_save_string(SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));

    String8 cmd = vars_string_from_var(scratch, vars_read_key(cmd_var, os_id));
    if (cmd.size > 0){
        String_ID out_id = vars_save_string(SCu8((u8*)("out"), (u64)(sizeof("out") - 1)));
        String_ID footer_panel_id = vars_save_string(SCu8((u8*)("footer_panel"), (u64)(sizeof("footer_panel") - 1)));
        String_ID save_dirty_files_id = vars_save_string(SCu8((u8*)("save_dirty_files"), (u64)(sizeof("save_dirty_files") - 1)));
        String_ID cursor_at_end_id = vars_save_string(SCu8((u8*)("cursor_at_end"), (u64)(sizeof("cursor_at_end") - 1)));

        b32 save_dirty_files = vars_b32_from_var(vars_read_key(cmd_var, save_dirty_files_id));
        if (save_dirty_files){
            save_all_dirty_buffers(app);
        }

        u32 flags = CLI_OverlapWithConflict|CLI_SendEndSignal;
        b32 cursor_at_end = vars_b32_from_var(vars_read_key(cmd_var, cursor_at_end_id));
        if (cursor_at_end){
            flags |= CLI_CursorAtEnd;
        }

        View_ID view = 0;
        Buffer_Identifier buffer_id = {};
        b32 set_fancy_font = false;
        String8 out = vars_string_from_var(scratch, vars_read_key(cmd_var, out_id));
        if (out.size > 0){
            buffer_id = buffer_identifier(out);

            b32 footer_panel = vars_b32_from_var(vars_read_key(cmd_var, footer_panel_id));
            if (footer_panel){
                view = get_or_open_build_panel(app);
                if (string_match(out, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)))){
                    set_fancy_font = true;
                }
            }
            else{
                Buffer_ID buffer = buffer_identifier_to_id(app, buffer_id);
                view = get_first_view_with_buffer(app, buffer);
                if (view == 0){
                    view = get_active_view(app, Access_Always);
                }
            }

            block_zero((&prev_location), sizeof(*(&prev_location)));
            lock_jump_buffer(app, out);
        }
        else{

            buffer_id = buffer_identifier(SCu8((u8*)("*dump*"), (u64)(sizeof("*dump*") - 1)));
        }

        Variable_Handle command_list_var = vars_parent(cmd_var);
        Variable_Handle prj_var = vars_parent(command_list_var);
        String8 prj_dir = prj_path_from_project(scratch, prj_var);
        exec_system_command(app, view, buffer_id, prj_dir, cmd, flags);
        if (set_fancy_font){
            set_fancy_compilation_buffer_font(app);
        }
    }
}

static Variable_Handle
prj_command_from_name(Application_Links *app, String8 cmd_name){
    Scratch_Block scratch(app);

    Variable_Handle cmd_list = def_get_config_var(vars_save_string(SCu8((u8*)("commands"), (u64)(sizeof("commands") - 1))));
    Variable_Handle cmd = vars_read_key(cmd_list, vars_save_string(cmd_name));
    return(cmd);
}

static void
prj_exec_command_name(Application_Links *app, String8 cmd_name){
    Scratch_Block scratch(app);
    Variable_Handle cmd = prj_command_from_name(app, cmd_name);
    prj_exec_command(app, cmd);
}

static void
prj_exec_command_fkey_index(Application_Links *app, i32 fkey_index){

    Scratch_Block scratch(app);
    String8 fkey_index_str = push_stringf(scratch, "F%d", fkey_index + 1);
    String_ID fkey_index_id = vars_save_string(fkey_index_str);


    Variable_Handle cmd_name_var = vars_get_nil();


    {
        Variable_Handle fkey_override =
            def_get_config_var(vars_save_string(SCu8((u8*)("fkey_command_override"), (u64)(sizeof("fkey_command_override") - 1))));
        if (!vars_is_nil(fkey_override)){
            String_Const_u8 name = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("user_name"), (u64)(sizeof("user_name") - 1))));
            String_ID user_name_id = vars_save_string(name);
            Variable_Handle user_var = vars_read_key(fkey_override, user_name_id);
            cmd_name_var = vars_read_key(user_var, fkey_index_id);
        }
    }


    if (vars_is_nil(cmd_name_var)){
        Variable_Handle fkeys = def_get_config_var(vars_save_string(SCu8((u8*)("fkey_command"), (u64)(sizeof("fkey_command") - 1))));
        cmd_name_var = vars_read_key(fkeys, fkey_index_id);
    }

    String8 cmd_name = vars_string_from_var(scratch, cmd_name_var);
    prj_exec_command_name(app, cmd_name);
}

static String8
prj_full_file_path_from_project(Arena *arena, Variable_Handle project){
    String8 project_full_path = vars_string_from_var(arena, project);
    return(project_full_path);
}

static String8
prj_path_from_project(Arena *arena, Variable_Handle project){
    String8 project_full_path = prj_full_file_path_from_project(arena, project);
    String8 project_dir = string_remove_last_folder(project_full_path);
    return(project_dir);
}

static Variable_Handle
prj_cmd_from_user(Application_Links *app, Variable_Handle prj_var, String8 query){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    Variable_Handle cmd_list_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("commands"), (u64)(sizeof("commands") - 1))));
    String_ID os_id = vars_save_string(SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));

    for (Variable_Handle cmd = vars_first_child(cmd_list_var);
         !vars_is_nil(cmd);
         cmd = vars_next_sibling(cmd)){
        Variable_Handle os_cmd = vars_read_key(cmd, os_id);
        if (!vars_is_nil(os_cmd)){
            String8 cmd_name = vars_key_from_var(scratch, cmd);
            String8 os_cmd_str = vars_string_from_var(scratch, os_cmd);
            lister_add_item(lister, cmd_name, os_cmd_str, cmd.ptr, 0);
        }
    }

    Variable_Handle result = vars_get_nil();
    Lister_Result l_result = run_lister(app, lister);
    if (!l_result.canceled){
        if (l_result.user_data != 0){
            result.ptr = (Variable*)l_result.user_data;
        }
    }

    return(result);
}




CUSTOM_COMMAND(close_all_code, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 829, Normal)
CUSTOM_DOC("Closes any buffer with a filename ending with an extension configured to be recognized as a code file type.")
{
    Scratch_Block scratch(app);
    String8 treat_as_code = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
    String8Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code);
    prj_close_files_with_ext(app, extensions);
}

CUSTOM_COMMAND(open_all_code, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 838, Normal)
CUSTOM_DOC("Open all code in the current directory. File types are determined by extensions. An extension is considered code based on the extensions specified in 4coder.config.")
{
    Scratch_Block scratch(app);
    String8 treat_as_code = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
    String8Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code);
    prj_open_all_files_with_ext_in_hot(app, extensions, 0);
}

CUSTOM_COMMAND(open_all_code_recursive, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 847, Normal)
CUSTOM_DOC("Works as open_all_code but also runs in all subdirectories.")
{
    Scratch_Block scratch(app);
    String8 treat_as_code = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
    String8Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code);
    prj_open_all_files_with_ext_in_hot(app, extensions, PrjOpenFileFlag_Recursive);
}

CUSTOM_COMMAND(load_project, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 856, Normal)
CUSTOM_DOC("Looks for a project.4coder file in the current directory and tries to load it.  Looks in parent directories until a project file is found or there are no more parents.")
{


    Profile_Scope_Block profile_block_861 ((app), SCu8((u8*)("load project"), (u64)(sizeof("load project") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "861" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "861" ":") - 1)));
    save_all_dirty_buffers(app);
    Scratch_Block scratch(app);


    String8 project_path = push_hot_directory(app, scratch);
    File_Name_Data dump = dump_file_search_up_path(app, scratch, project_path, SCu8((u8*)("project.4coder"), (u64)(sizeof("project.4coder") - 1)));
    String8 project_root = string_remove_last_folder(dump.file_name);

    if (dump.data.str == 0){
        print_message(app, SCu8((u8*)("Did not find project.4coder.\n"), (u64)(sizeof("Did not find project.4coder.\n") - 1)));
    }


    Config *config_parse = 0;
    Variable_Handle prj_var = vars_get_nil();
    if (dump.data.str != 0){
        Token_Array array = token_array_from_text(app, scratch, dump.data);
        if (array.tokens != 0){
            config_parse = def_config_parse(app, scratch, dump.file_name, dump.data, array);
            if (config_parse != 0){
                i32 version = 0;
                if (config_parse->version != 0){
                    version = *config_parse->version;
                }

                switch (version){
                    case 0:
                    case 1:
                    {
                        prj_var = prj_v1_to_v2(app, project_root, config_parse);
                    }break;
                    default:
                    {
                        prj_var = def_fill_var_from_config(app, vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))), config_parse);
                    }break;
                }

            }
        }
    }


    if (!vars_is_nil(prj_var)){
        vars_print(app, prj_var);
        print_message(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
    }


    if (config_parse != 0){
        String8 error_text = config_stringize_errors(app, scratch, config_parse);
        if (error_text.size > 0){
            print_message(app, SCu8((u8*)("Project errors:\n"), (u64)(sizeof("Project errors:\n") - 1)));
            print_message(app, error_text);
            print_message(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }
    }


    Variable_Handle load_paths_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("load_paths"), (u64)(sizeof("load_paths") - 1))));
    Variable_Handle load_paths_os_var = vars_read_key(load_paths_var, vars_save_string(SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1))));

    String_ID path_id = vars_save_string(SCu8((u8*)("path"), (u64)(sizeof("path") - 1)));
    String_ID recursive_id = vars_save_string(SCu8((u8*)("recursive"), (u64)(sizeof("recursive") - 1)));
    String_ID relative_id = vars_save_string(SCu8((u8*)("relative"), (u64)(sizeof("relative") - 1)));

    Variable_Handle whitelist_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("patterns"), (u64)(sizeof("patterns") - 1))));
    Variable_Handle blacklist_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("blacklist_patterns"), (u64)(sizeof("blacklist_patterns") - 1))));

    Prj_Pattern_List whitelist = prj_pattern_list_from_var(scratch, whitelist_var);
    Prj_Pattern_List blacklist = prj_pattern_list_from_var(scratch, blacklist_var);

    for (Variable_Handle load_path_var = vars_first_child(load_paths_os_var);
         !vars_is_nil(load_path_var);
         load_path_var = vars_next_sibling(load_path_var)){
        Variable_Handle path_var = vars_read_key(load_path_var, path_id);
        Variable_Handle recursive_var = vars_read_key(load_path_var, recursive_id);
        Variable_Handle relative_var = vars_read_key(load_path_var, relative_id);

        String8 path = vars_string_from_var(scratch, path_var);
        b32 recursive = vars_b32_from_var(recursive_var);
        b32 relative = vars_b32_from_var(relative_var);


        u32 flags = 0;
        if (recursive){
            flags |= PrjOpenFileFlag_Recursive;
        }

        String8 file_dir = path;
        if (relative){
            String8 prj_dir = prj_path_from_project(scratch, prj_var);

            String8List file_dir_list = {};
            string_list_push(scratch, &file_dir_list, prj_dir);
            string_list_push_overlap(scratch, &file_dir_list, '/', path);
            string_list_push_overlap(scratch, &file_dir_list, '/', SCu8());
            file_dir = string_list_flatten(scratch, file_dir_list, StringFill_NullTerminate);
        }

        prj_open_files_pattern_filter(app, file_dir, whitelist, blacklist, flags);
    }


    Variable_Handle proj_name_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("project_name"), (u64)(sizeof("project_name") - 1))));
    String_ID proj_name_id = vars_string_id_from_var(proj_name_var);
    if (proj_name_id != 0){
        String8 proj_name = vars_read_string(scratch, proj_name_id);
        String8 title = push_u8_stringf(scratch, "4coder project: %.*s", (i32)(proj_name).size, (char*)(proj_name).str);
        set_window_title(app, title);
    }
}

CUSTOM_COMMAND(project_fkey_command, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 974, Normal)
CUSTOM_DOC("Run an 'fkey command' configured in a project.4coder file.  Determines the index of the 'fkey command' by which function key or numeric key was pressed to trigger the command.")
{
    Profile_Scope_Block profile_block_977 ((app), SCu8((u8*)("project fkey command"), (u64)(sizeof("project fkey command") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "977" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp" ":" "977" ":") - 1)));
    User_Input input = get_current_input(app);
    b32 got_ind = false;
    i32 ind = 0;
    if (input.event.kind == InputEventKind_KeyStroke){
        if (KeyCode_F1 <= input.event.key.code && input.event.key.code <= KeyCode_F16){
            ind = (input.event.key.code - KeyCode_F1);
            got_ind = true;
        }
        else if (KeyCode_1 <= input.event.key.code && input.event.key.code <= KeyCode_9){
            ind = (input.event.key.code - '1');
            got_ind = true;
        }
        else if (input.event.key.code == KeyCode_0){
            ind = 9;
            got_ind = true;
        }
        if (got_ind){
            prj_exec_command_fkey_index(app, ind);
        }
    }
}

CUSTOM_COMMAND(project_go_to_root_directory, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1000, Normal)
CUSTOM_DOC("Changes 4coder's hot directory to the root directory of the currently loaded project. With no loaded project nothing hapepns.")
{
    Scratch_Block scratch(app);
    Variable_Handle prj_var = vars_read_key(vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))));
    String8 prj_dir = prj_path_from_project(scratch, prj_var);
    if (prj_dir.size > 0){
        set_hot_directory(app, prj_dir);
    }
}

CUSTOM_COMMAND(setup_new_project, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1011, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new 4coder project with build scripts for every OS.")
{
    prj_setup_scripts(app, PrjSetupScriptFlag_Project|PrjSetupScriptFlag_Bat|PrjSetupScriptFlag_Sh);
    load_project(app);
}

CUSTOM_COMMAND(setup_build_bat, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1018, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build batch script.")
{
    prj_setup_scripts(app, PrjSetupScriptFlag_Bat);
}

CUSTOM_COMMAND(setup_build_sh, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1024, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build shell script.")
{
    prj_setup_scripts(app, PrjSetupScriptFlag_Sh);
}

CUSTOM_COMMAND(setup_build_bat_and_sh, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1030, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build batch script.")
{
    prj_setup_scripts(app, PrjSetupScriptFlag_Bat|PrjSetupScriptFlag_Sh);
}

CUSTOM_COMMAND(project_command_lister, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1036, Normal)
CUSTOM_DOC("Open a lister of all commands in the currently loaded project.")
{
    Variable_Handle prj_var = vars_read_key(vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))));
    Variable_Handle prj_cmd = prj_cmd_from_user(app, prj_var, SCu8((u8*)("Command:"), (u64)(sizeof("Command:") - 1)));
    if (!vars_is_nil(prj_cmd)){
        prj_exec_command(app, prj_cmd);
    }
}

CUSTOM_COMMAND(project_reprint, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1046, Normal)
CUSTOM_DOC("Prints the current project to the file it was loaded from; prints in the most recent project file version")
{
    Variable_Handle prj_var = vars_read_key(vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))));
    if (!vars_is_nil(prj_var)){
        Scratch_Block scratch(app);
        String8 prj_full_path = prj_full_file_path_from_project(scratch, prj_var);
        prj_full_path = push_string_copy(scratch, prj_full_path);
        String8 message = push_stringf(scratch, "Reprinting project file: %.*s\n", (i32)(prj_full_path).size, (char*)(prj_full_path).str);
        print_message(app, message);

        String8List prj_string = {};
        prj_stringize_project(app, scratch, prj_var, &prj_string);

        FILE *file = fopen((char*)prj_full_path.str, "wb");
        if (file == 0){
            print_message(app, {(u8*)("Could not open project file\n"), sizeof("Could not open project file\n") - 1});
        }
        else{
            for (String8Node *node = prj_string.first;
                 node != 0;
                 node = node->next){
                fwrite(node->string.str, 1, (size_t)node->string.size, file);
            }
            fclose(file);
            print_message(app, {(u8*)("Reloading project buffer\n"), sizeof("Reloading project buffer\n") - 1});

            Buffer_ID buffer = get_buffer_by_file_name(app, prj_full_path, Access_Always);
            if (buffer != 0){
                buffer_reopen(app, buffer, 0);
            }
            else{
                create_buffer(app, prj_full_path, 0);
            }
        }
    }
}

CUSTOM_COMMAND(project_command_F1, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1084, Normal)
CUSTOM_DOC("Run the command with index 1")
{
    prj_exec_command_fkey_index(app, 0);
}

CUSTOM_COMMAND(project_command_F2, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1090, Normal)
CUSTOM_DOC("Run the command with index 2")
{
    prj_exec_command_fkey_index(app, 1);
}

CUSTOM_COMMAND(project_command_F3, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1096, Normal)
CUSTOM_DOC("Run the command with index 3")
{
    prj_exec_command_fkey_index(app, 2);
}

CUSTOM_COMMAND(project_command_F4, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1102, Normal)
CUSTOM_DOC("Run the command with index 4")
{
    prj_exec_command_fkey_index(app, 3);
}

CUSTOM_COMMAND(project_command_F5, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1108, Normal)
CUSTOM_DOC("Run the command with index 5")
{
    prj_exec_command_fkey_index(app, 4);
}

CUSTOM_COMMAND(project_command_F6, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1114, Normal)
CUSTOM_DOC("Run the command with index 6")
{
    prj_exec_command_fkey_index(app, 5);
}

CUSTOM_COMMAND(project_command_F7, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1120, Normal)
CUSTOM_DOC("Run the command with index 7")
{
    prj_exec_command_fkey_index(app, 6);
}

CUSTOM_COMMAND(project_command_F8, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1126, Normal)
CUSTOM_DOC("Run the command with index 8")
{
    prj_exec_command_fkey_index(app, 7);
}

CUSTOM_COMMAND(project_command_F9, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1132, Normal)
CUSTOM_DOC("Run the command with index 9")
{
    prj_exec_command_fkey_index(app, 8);
}

CUSTOM_COMMAND(project_command_F10, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1138, Normal)
CUSTOM_DOC("Run the command with index 10")
{
    prj_exec_command_fkey_index(app, 9);
}

CUSTOM_COMMAND(project_command_F11, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1144, Normal)
CUSTOM_DOC("Run the command with index 11")
{
    prj_exec_command_fkey_index(app, 10);
}

CUSTOM_COMMAND(project_command_F12, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1150, Normal)
CUSTOM_DOC("Run the command with index 12")
{
    prj_exec_command_fkey_index(app, 11);
}

CUSTOM_COMMAND(project_command_F13, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1156, Normal)
CUSTOM_DOC("Run the command with index 13")
{
    prj_exec_command_fkey_index(app, 12);
}

CUSTOM_COMMAND(project_command_F14, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1162, Normal)
CUSTOM_DOC("Run the command with index 14")
{
    prj_exec_command_fkey_index(app, 13);
}

CUSTOM_COMMAND(project_command_F15, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1168, Normal)
CUSTOM_DOC("Run the command with index 15")
{
    prj_exec_command_fkey_index(app, 14);
}

CUSTOM_COMMAND(project_command_F16, "/home/tabletel/dev/4cc/code/custom/4coder_project_commands.cpp", 1174, Normal)
CUSTOM_DOC("Run the command with index 16")
{
    prj_exec_command_fkey_index(app, 15);
}
# 131 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp"
static void
prj_v1_parse_pattern_list(Arena *arena, Config *parsed, char *name, Prj_Pattern_List *list_out){
    Config_Compound *compound = 0;
    if (config_compound_var(parsed, name, 0, &compound)){
        Config_Get_Result_List list = typed_string_array_reference_list(arena, parsed, compound);
        for (Config_Get_Result_Node *cfg_node = list.first;
             cfg_node != 0;
             cfg_node = cfg_node->next){
            Prj_Pattern_Node *node = ((Prj_Pattern_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Prj_Pattern_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "18" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "18" ":") - 1)))));
            do{ if((node)){if((list_out->first)){(list_out->last)->next=(node);}else{(list_out->first)=(node);}(list_out->last)=(node);(list_out->last)->next=0;} }while(0);
            list_out->count += 1;
            String8 str = push_string_copy(arena, cfg_node->result.string);
            node->pattern.absolutes = string_split_wildcards(arena, str);
        }
    }
}

static Prj_V1_OS_Match_Level
prj_v1_parse_os_match(String8 str, String8 this_os_str){
    Prj_V1_OS_Match_Level result = PrjV1OSMatchLevel_NoMatch;
    if (string_match(str, this_os_str)){
        result = PrjV1OSMatchLevel_ActiveMatch;
    }
    else if (string_match(str, SCu8((u8*)("all"), (u64)(sizeof("all") - 1)))){
        result = PrjV1OSMatchLevel_ActiveMatch;
    }
    else if (string_match(str, SCu8((u8*)("default"), (u64)(sizeof("default") - 1)))){
        result = PrjV1OSMatchLevel_PassiveMatch;
    }
    return(result);
}

static Prj_V1*
prj_v1_parse_from_config(Application_Links *app, Arena *arena, String8 dir, Config *parsed){
    Prj_V1 *project = ((Prj_V1*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Prj_V1)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "44" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "44" ":") - 1)))));


    project->dir = push_string_copy(arena, dir);


    {
        String8 str = {};
        if (config_string_var(parsed, "project_name", 0, &str)){
            project->name = push_string_copy(arena, str);
        }
        else{
            project->name = SCu8("");
        }
    }


    prj_v1_parse_pattern_list(arena, parsed, "patterns", &project->pattern_list);


    prj_v1_parse_pattern_list(arena, parsed, "blacklist_patterns", &project->blacklist_pattern_list);


    {
        Config_Compound *compound = 0;
        if (config_compound_var(parsed, "load_paths", 0, &compound)){
            b32 found_match = false;
            Config_Compound *best_paths = 0;

            for (i32 i = 0;; ++i){
                Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, ConfigRValueType_Compound, i);
                if (result.step == Iteration_Skip){
                    continue;
                }
                else if (result.step == Iteration_Quit){
                    break;
                }
                Config_Compound *paths_option = result.get.compound;

                Config_Compound *paths = 0;
                if (config_compound_compound_member(parsed, paths_option, "paths", 0, &paths)){
                    String8 str = {};
                    if (config_compound_string_member(parsed, paths_option, "os", 1, &str)){
                        Prj_V1_OS_Match_Level r = prj_v1_parse_os_match(str, SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));
                        if (r == PrjV1OSMatchLevel_ActiveMatch){
                            found_match = true;
                            best_paths = paths;
                            break;
                        }
                        else if (r == PrjV1OSMatchLevel_PassiveMatch){
                            if (!found_match){
                                found_match = true;
                                best_paths = paths;
                            }
                        }
                    }
                }
            }

            if (found_match){
                Config_Get_Result_List list = typed_compound_array_reference_list(arena, parsed, best_paths);

                project->load_path_array.paths = ((Prj_V1_File_Load_Path*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Prj_V1_File_Load_Path)*(list.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "106" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "106" ":") - 1)))));
                project->load_path_array.count = list.count;

                Prj_V1_File_Load_Path *dst = project->load_path_array.paths;
                for (Config_Get_Result_Node *node = list.first;
                     node != 0;
                     node = node->next, ++dst){
                    Config_Compound *src = node->result.compound;
                    block_zero((dst), sizeof(*(dst)));
                    dst->recursive = true;
                    dst->relative = true;

                    String8 str = {};
                    if (config_compound_string_member(parsed, src, "path", 0, &str)){
                        dst->path = push_string_copy(arena, str);
                    }

                    config_compound_bool_member(parsed, src, "recursive", 1, &dst->recursive);
                    config_compound_bool_member(parsed, src, "relative", 2, &dst->relative);
                }
            }
        }
    }


    {
        Config_Compound *compound = 0;
        if (config_compound_var(parsed, "command_list", 0, &compound)){
            Config_Get_Result_List list = typed_compound_array_reference_list(arena, parsed, compound);

            project->command_array.commands = ((Prj_V1_Command*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Prj_V1_Command)*(list.count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "136" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "136" ":") - 1)))));
            project->command_array.count = list.count;

            Prj_V1_Command *dst = project->command_array.commands;
            for (Config_Get_Result_Node *node = list.first;
                 node != 0;
                 node = node->next, ++dst){
                u8 *pos = node->result.pos;
                Config_Compound *src = node->result.compound;
                block_zero((dst), sizeof(*(dst)));

                b32 can_emit_command = true;

                Config_Get_Result cmd_result = {};
                Config_Compound *cmd_set = 0;
                u8 *cmd_pos = 0;
                String8 cmd_str = {};
                String8 out = {};
                b32 footer_panel = false;
                b32 save_dirty_files = true;
                b32 cursor_at_end = false;
                String8 name = {};

                if (!config_compound_string_member(parsed, src, "name", 0, &name)){
                    can_emit_command = false;
                    def_config_push_error(arena, parsed, pos, "a command must have a string type name member");
                    goto finish_command;
                }

                cmd_result = config_compound_member(parsed, src, SCu8((u8*)("cmd"), (u64)(sizeof("cmd") - 1)), 1);
                if (cmd_result.success && cmd_result.type == ConfigRValueType_Compound){
                    cmd_set = cmd_result.compound;
                    cmd_pos = cmd_result.pos;
                }
                else{
                    can_emit_command = false;
                    def_config_push_error(arena, parsed, pos, "a command must have an array type cmd member");
                    goto finish_command;
                }

                can_emit_command = false;
                for (i32 j = 0;; ++j){
                    Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, cmd_set, ConfigRValueType_Compound, j);
                    if (result.step == Iteration_Skip){
                        continue;
                    }
                    else if (result.step == Iteration_Quit){
                        break;
                    }
                    Config_Compound *cmd_option = result.get.compound;

                    String8 cmd = {};
                    if (config_compound_string_member(parsed, cmd_option, "cmd", 0, &cmd)){
                        String8 str = {};
                        if (config_compound_string_member(parsed, cmd_option, "os", 1, &str)){
                            Prj_V1_OS_Match_Level r = prj_v1_parse_os_match(str, SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));
                            if (r == PrjV1OSMatchLevel_ActiveMatch){
                                can_emit_command = true;
                                cmd_str = cmd;
                                break;
                            }
                            else if (r == PrjV1OSMatchLevel_PassiveMatch){
                                if (!can_emit_command){
                                    can_emit_command = true;
                                    cmd_str = cmd;
                                }
                            }
                        }
                    }
                }

                if (!can_emit_command){
                    def_config_push_error(arena, parsed, cmd_pos, "no usable command strings found in cmd");
                    goto finish_command;
                }

                config_compound_string_member(parsed, src, "out", 2, &out);
                config_compound_bool_member(parsed, src, "footer_panel", 3, &footer_panel);
                config_compound_bool_member(parsed, src, "save_dirty_files", 4,
                                            &save_dirty_files);
                config_compound_bool_member(parsed, src, "cursor_at_end", 5,
                                            &cursor_at_end);

                dst->name = push_string_copy(arena, name);
                dst->cmd = push_string_copy(arena, cmd_str);
                dst->out = push_string_copy(arena, out);
                dst->footer_panel = footer_panel;
                dst->save_dirty_files = save_dirty_files;
                dst->cursor_at_end = cursor_at_end;

                finish_command:;
            }
        }
    }


    {
        for (i32 i = 1; i <= 16; ++i){
            String8 name = {};
            i32 index = -1;
            if (config_string_var(parsed, "fkey_command", i, &name)){
                i32 count = project->command_array.count;
                Prj_V1_Command *command_ptr = project->command_array.commands;
                for (i32 j = 0; j < count; ++j, ++command_ptr){
                    if (string_match(command_ptr->name, name)){
                        index = j;
                        break;
                    }
                }
            }
            project->fkey_commands[i - 1] = index;
        }
    }

    project->loaded = true;
    return(project);
}


static String8
prj_v1_join_pattern_string(Arena *arena, String8List list){
    String8 pattern_string = {};
    pattern_string.size = list.total_size + list.node_count - 1;
    pattern_string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(pattern_string.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "259" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "259" ":") - 1)))));
    u8 *ptr = pattern_string.str;
    String8Node *node = list.first;
    if (node != 0){
        for (;;){
            block_copy(ptr, node->string.str, node->string.size);
            ptr += node->string.size;
            node = node->next;
            if (node == 0){
                break;
            }
            *ptr = '*';
            ptr += 1;
        }
    }
    pattern_string.str[pattern_string.size] = 0;
    return(pattern_string);
}

static String8
prj_v1_sanitize_string(Arena *arena, String8 string){
    String8 result = {};

    if (string.size > 0){
        result.size = string.size;
        result.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(result.size + 2), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "284" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_prj_v1.cpp" ":" "284" ":") - 1)))));

        u8 *in = string.str;
        u8 *out = result.str;

        if (character_is_base10(*in)){
            *out = '_';
            out += 1;
            result.size += 1;
        }

        for (u64 i = 0; i < string.size; i += 1, in += 1, out += 1){
            u8 c = *in;
            if (!character_is_alpha_numeric(c)){
                c = '_';
            }
            *out = c;
        }

        result.str[result.size] = 0;
    }

    return(result);
}

static Variable_Handle
prj_v1_to_v2(Application_Links *app, String8 dir, Config *parsed){
    Scratch_Block scratch(app);

    Prj_V1 *project = prj_v1_parse_from_config(app, scratch, dir, parsed);

    String_ID project_id = vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1)));
    String_ID version_id = vars_save_string({(u8*)("version"), sizeof("version") - 1});
    String_ID project_name_id = vars_save_string({(u8*)("project_name"), sizeof("project_name") - 1});
    String_ID patterns_id = vars_save_string({(u8*)("patterns"), sizeof("patterns") - 1});
    String_ID blacklist_patterns_id = vars_save_string({(u8*)("blacklist_patterns"), sizeof("blacklist_patterns") - 1});

    String_ID load_paths_id = vars_save_string({(u8*)("load_paths"), sizeof("load_paths") - 1});
    String_ID path_id = vars_save_string({(u8*)("path"), sizeof("path") - 1});
    String_ID recursive_id = vars_save_string({(u8*)("recursive"), sizeof("recursive") - 1});
    String_ID relative_id = vars_save_string({(u8*)("relative"), sizeof("relative") - 1});
    String_ID true_id = vars_save_string({(u8*)("true"), sizeof("true") - 1});
    String_ID false_id = vars_save_string({(u8*)("false"), sizeof("false") - 1});
    String_ID commands_id = vars_save_string({(u8*)("commands"), sizeof("commands") - 1});

    String_ID out_id = vars_save_string({(u8*)("out"), sizeof("out") - 1});
    String_ID footer_panel_id = vars_save_string({(u8*)("footer_panel"), sizeof("footer_panel") - 1});
    String_ID save_dirty_files_id = vars_save_string({(u8*)("save_dirty_files"), sizeof("save_dirty_files") - 1});
    String_ID cursor_at_end_id = vars_save_string({(u8*)("cursor_at_end"), sizeof("cursor_at_end") - 1});

    String_ID fkey_command_id = vars_save_string({(u8*)("fkey_command"), sizeof("fkey_command") - 1});

    String_ID os_id = vars_save_string({(u8*)("linux"), sizeof("linux") - 1});;

    Variable_Handle proj_var = vars_new_variable(vars_get_root(), project_id, vars_save_string(parsed->file_name));

    if (parsed->version != 0){
        String8 version_str = push_stringf(scratch, "%d", *parsed->version);
        vars_new_variable(proj_var, version_id, vars_save_string(version_str));
    }

    vars_new_variable(proj_var, project_name_id, vars_save_string(project->name));


    struct PatternVars{
        String_ID id;
        Prj_Pattern_List list;
    };
    PatternVars pattern_vars[] = {
        { patterns_id, project-> pattern_list},
        {blacklist_patterns_id, project->blacklist_pattern_list},
    };

    PatternVars *pattern_var = pattern_vars;
    PatternVars *opl = pattern_vars + ((sizeof(pattern_vars))/(sizeof(*pattern_vars)));
    for (; pattern_var < opl; pattern_var += 1){
        Variable_Handle patterns = vars_new_variable(proj_var, pattern_var->id);

        i32 i = 0;
        for (Prj_Pattern_Node *node = pattern_var->list.first;
             node != 0;
             node = node->next, i += 1){
            String8 pattern_string = prj_v1_join_pattern_string(scratch, node->pattern.absolutes);
            String_ID key = vars_save_string(push_stringf(scratch, "%d", i));
            String_ID pattern_id = vars_save_string(pattern_string);
            vars_new_variable(patterns, key, pattern_id);
        }
    }


    {
        Variable_Handle load_paths = vars_new_variable(proj_var, load_paths_id);
        Variable_Handle os_var = vars_new_variable(load_paths, os_id);
        i32 count = project->load_path_array.count;
        Prj_V1_File_Load_Path *load_path = project->load_path_array.paths;
        for (i32 i = 0; i < count; i += 1, load_path += 1){
            String_ID key = vars_save_string(push_stringf(scratch, "%d", i));
            Variable_Handle path_var = vars_new_variable(os_var, key);
            vars_new_variable(path_var, path_id, vars_save_string(load_path->path));
            vars_new_variable(path_var, recursive_id, load_path->recursive?true_id:false_id);
            vars_new_variable(path_var, relative_id, load_path->relative?true_id:false_id);
        }
    }


    {
        Variable_Handle cmd_list_var = vars_new_variable(proj_var, commands_id);
        i32 count = project->command_array.count;
        Prj_V1_Command *cmd = project->command_array.commands;
        for (i32 i = 0; i < count; i += 1, cmd += 1){
            String8 cmd_name = prj_v1_sanitize_string(scratch, cmd->name);
            Variable_Handle cmd_var = vars_new_variable(cmd_list_var, vars_save_string(cmd_name));
            vars_new_variable(cmd_var, os_id, vars_save_string(cmd->cmd));
            vars_new_variable(cmd_var, out_id, vars_save_string(cmd->out));
            vars_new_variable(cmd_var, footer_panel_id, cmd->footer_panel?true_id:false_id);
            vars_new_variable(cmd_var, save_dirty_files_id, cmd->save_dirty_files?true_id:false_id);
            vars_new_variable(cmd_var, cursor_at_end_id, cmd->cursor_at_end?true_id:false_id);
        }
    }


    {
        Variable_Handle fkeys_var = vars_new_variable(proj_var, fkey_command_id);
        for (i32 i = 0; i < 16; i += 1){
            i32 cmd_index = project->fkey_commands[i];
            if (0 <= cmd_index && cmd_index < project->command_array.count){
                Prj_V1_Command *cmd = project->command_array.commands + cmd_index;
                if (cmd->name.size > 0){
                    String8 cmd_name = prj_v1_sanitize_string(scratch, cmd->name);
                    String_ID key = vars_save_string(push_stringf(scratch, "F%d", i + 1));
                    String_ID val = vars_save_string(cmd_name);
                    vars_new_variable(fkeys_var, key, val);
                }
            }
        }
    }

    return(proj_var);
}
# 132 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp" 1
# 14 "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp"
static Get_Positions_Results
get_function_positions(Application_Links *app, Buffer_ID buffer, i64 first_token_index, Function_Positions *positions_array, i64 positions_max){
    Get_Positions_Results result = {};

    Token_Array array = get_token_array_from_buffer(app, buffer);
    if (array.tokens != 0){
        Token_Iterator_Array it = token_iterator_index(buffer, &array, first_token_index);

        i32 nest_level = 0;
        i32 paren_nest_level = 0;

        Token_Iterator_Array first_paren_it = {};
        i64 first_paren_index = 0;
        i64 first_paren_position = 0;
        i64 last_paren_index = 0;


        mode1:
        do{ if (!(nest_level == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(paren_nest_level == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        first_paren_index = 0;
        first_paren_position = 0;
        last_paren_index = 0;
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                switch (token->sub_kind){
                    case TokenCppKind_BraceOp:
                    {
                        ++nest_level;
                    }break;

                    case TokenCppKind_BraceCl:
                    {
                        if (nest_level > 0){
                            --nest_level;
                        }
                    }break;

                    case TokenCppKind_ParenOp:
                    {
                        if (nest_level == 0){
                            first_paren_it = it;
                            first_paren_index = token_it_index(&it);
                            first_paren_position = token->pos;
                            goto paren_mode1;
                        }
                    }break;
                }
            }
            if (!token_it_inc(&it)){
                goto end;
            }
        }


        paren_mode1:
        paren_nest_level = 0;
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                switch (token->sub_kind){
                    case TokenCppKind_ParenOp:
                    {
                        ++paren_nest_level;
                    }break;

                    case TokenCppKind_ParenCl:
                    {
                        --paren_nest_level;
                        if (paren_nest_level == 0){
                            last_paren_index = token_it_index(&it);
                            goto paren_mode2;
                        }
                    }break;
                }
            }
            if (!token_it_inc(&it)){
                goto end;
            }
        }


        paren_mode2:
        {
            Token_Iterator_Array restore_point = it;
            it = first_paren_it;
            i64 signature_start_index = 0;
            for (;;){
                Token *token = token_it_read(&it);
                if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
                    token->sub_kind == TokenCppKind_BraceCl ||
                    token->sub_kind == TokenCppKind_Semicolon ||
                    token->sub_kind == TokenCppKind_ParenCl){
                    if (!token_it_inc(&it)){
                        signature_start_index = first_paren_index;
                    }
                    else{
                        signature_start_index = token_it_index(&it);
                    }
                    goto paren_mode2_done;
                }
                if (!token_it_dec(&it)){
                    break;
                }
            }



            signature_start_index = 0;

            paren_mode2_done:;
            {
                Function_Positions positions = {};
                positions.sig_start_index = signature_start_index;
                positions.sig_end_index = last_paren_index;
                positions.open_paren_pos = first_paren_position;
                positions_array[result.positions_count++] = positions;
            }

            it = restore_point;
            if (result.positions_count >= positions_max){
                result.next_token_index = token_it_index(&it);
                result.still_looping = true;
                goto end;
            }

            goto mode1;
        }
        end:;
    }

    return(result);
}

static void
print_positions_buffered(Application_Links *app, Buffer_Insertion *out, Buffer_ID buffer, Function_Positions *positions_array, i64 positions_count){
    Scratch_Block scratch(app);

    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);

    for (i32 i = 0; i < positions_count; ++i){
        Function_Positions *positions = &positions_array[i];

        i64 start_index = positions->sig_start_index;
        i64 end_index = positions->sig_end_index;
        i64 open_paren_pos = positions->open_paren_pos;
        i64 line_number = get_line_number_from_pos(app, buffer, open_paren_pos);

        do{ if (!(end_index > start_index)) { (*((i32*)0) = 0xA11E); } }while(0);

        Token_Array array = get_token_array_from_buffer(app, buffer);
        if (array.tokens != 0){
            insertf(out, "%.*s:%lld: ", (i32)(buffer_name).size, (char*)(buffer_name).str, line_number);

            Token prev_token = {};
            Token_Iterator_Array it = token_iterator_index(buffer, &array, start_index);
            for (;;){
                Token *token = token_it_read(&it);
                if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) &&
                    token->kind != TokenBaseKind_Comment &&
                    token->kind != TokenBaseKind_Whitespace){
                    if ((prev_token.sub_kind == TokenCppKind_Identifier ||
                         prev_token.sub_kind == TokenCppKind_Star ||
                         prev_token.sub_kind == TokenCppKind_Comma ||
                         prev_token.kind == TokenBaseKind_Keyword) &&
                        !(token->sub_kind == TokenCppKind_ParenOp ||
                          token->sub_kind == TokenCppKind_ParenCl ||
                          token->sub_kind == TokenCppKind_Comma)){
                        insertc(out, ' ');
                    }

                    Temp_Memory token_temp = begin_temp(scratch);
                    String_Const_u8 lexeme = push_token_lexeme(app, scratch, buffer, token);
                    insert_string(out, lexeme);
                    end_temp(token_temp);

                    prev_token = *token;
                }
                if (!token_it_inc(&it)){
                    break;
                }
                i64 index = token_it_index(&it);
                if (index > end_index){
                    break;
                }
            }

            insertc(out, '\n');
        }
    }
}

static void
list_all_functions(Application_Links *app, Buffer_ID optional_target_buffer){

    String_Const_u8 decls_name = SCu8((u8*)("*decls*"), (u64)(sizeof("*decls*") - 1));
    Buffer_ID decls_buffer = get_buffer_by_name(app, decls_name, Access_Always);
    if (!buffer_exists(app, decls_buffer)){
        decls_buffer = create_buffer(app, decls_name, BufferCreate_AlwaysNew);
        buffer_set_setting(app, decls_buffer, BufferSetting_Unimportant, true);
        buffer_set_setting(app, decls_buffer, BufferSetting_ReadOnly, true);

    }
    else{
        clear_buffer(app, decls_buffer);
        buffer_send_end_signal(app, decls_buffer);
    }

    Scratch_Block scratch(app);


    i32 positions_max = ((4) << 10)/sizeof(Function_Positions);
    Function_Positions *positions_array = ((Function_Positions*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Function_Positions)*(positions_max), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp" ":" "227" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp" ":" "227" ":") - 1)))));

    Cursor insertion_cursor = make_cursor(((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(((256) << 10)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp" ":" "229" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp" ":" "229" ":") - 1))))), ((256) << 10));
    Buffer_Insertion out = begin_buffer_insertion_at_buffered(app, decls_buffer, 0, &insertion_cursor);

    for (Buffer_ID buffer_it = get_buffer_next(app, 0, Access_Always);
         buffer_it != 0;
         buffer_it = get_buffer_next(app, buffer_it, Access_Always)){
        Buffer_ID buffer = buffer_it;
        if (optional_target_buffer != 0){
            buffer = optional_target_buffer;
        }

        Token_Array array = get_token_array_from_buffer(app, buffer);
        if (array.tokens != 0){
            i64 token_index = 0;
            b32 still_looping = false;
            do{
                Get_Positions_Results get_positions_results = get_function_positions(app, buffer, token_index, positions_array, positions_max);

                i64 positions_count = get_positions_results.positions_count;
                token_index = get_positions_results.next_token_index;
                still_looping = get_positions_results.still_looping;

                print_positions_buffered(app, &out, buffer, positions_array, positions_count);
            }while(still_looping);

            if (optional_target_buffer != 0){
                break;
            }
        }
    }

    end_buffer_insertion(&out);

    View_ID view = get_active_view(app, Access_Always);
    view_set_buffer(app, view, decls_buffer, 0);

    lock_jump_buffer(app, decls_name);
}

CUSTOM_COMMAND(list_all_functions_current_buffer, "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp", 268, Normal)
CUSTOM_DOC("Creates a jump list of lines of the current buffer that appear to define or declare functions.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer != 0){
        list_all_functions(app, buffer);
    }
}

CUSTOM_COMMAND(list_all_functions_current_buffer_lister, "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp", 278, UI)
CUSTOM_DOC("Creates a lister of locations that look like function definitions and declarations in the buffer.")
{
    Heap *heap = &global_heap;
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer != 0){
        list_all_functions(app, buffer);
        view = get_active_view(app, Access_Always);
        buffer = view_get_buffer(app, view, Access_Always);
        Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
        if (list != 0){
            Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Function:");
            jump_to_jump_lister_result(app, view, list, &jump);
        }
    }
}

CUSTOM_COMMAND(list_all_functions_all_buffers, "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp", 296, Normal)
CUSTOM_DOC("Creates a jump list of lines from all buffers that appear to define or declare functions.")
{
    list_all_functions(app, 0);
}

CUSTOM_COMMAND(list_all_functions_all_buffers_lister, "/home/tabletel/dev/4cc/code/custom/4coder_function_list.cpp", 302, UI)
CUSTOM_DOC("Creates a lister of locations that look like function definitions and declarations all buffers.")
{
    Heap *heap = &global_heap;
    list_all_functions(app, 0);
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
    if (list != 0){
        Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Function:");
        jump_to_jump_lister_result(app, view, list, &jump);
    }
}
# 133 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp" 1






static void
select_next_scope_after_pos(Application_Links *app, View_ID view, Buffer_ID buffer,
                            i64 pos){
    Find_Nest_Flag flags = FindNest_Scope;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos + 1, flags, Scan_Forward, NestDelim_Open,
                       &range) &&
        find_nest_side(app, buffer, range.end,
                       flags|FindNest_Balanced|FindNest_EndOfToken, Scan_Forward,
                       NestDelim_Close, &range.end)){
        select_scope(app, view, range);
    }
}

static b32
range_is_scope_selection(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return (buffer_get_char(app, buffer, range.min) == '{' &&
            buffer_get_char(app, buffer, range.max - 1) == '}');
}

CUSTOM_COMMAND(select_surrounding_scope, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 27, Normal)
CUSTOM_DOC("Finds the scope enclosed by '{' '}' surrounding the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = {};
    if (find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_surrounding_scope_maximal, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 39, Normal)
CUSTOM_DOC("Selects the top-most scope that surrounds the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = {};
    if (find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
        for (;;){
            pos = range.min;
            if (!find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
                break;
            }
        }
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_next_scope_absolute, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 57, Normal)
CUSTOM_DOC("Finds the first scope started by '{' after the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    select_next_scope_after_pos(app, view, buffer, pos);
}

CUSTOM_COMMAND(select_next_scope_after_current, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 66, Normal)
CUSTOM_DOC("If a scope is selected, find first scope that starts after the selected scope. Otherwise find the first scope that starts after the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    i64 mark_pos = view_get_mark_pos(app, view);
    Range_i64 range = Ii64(cursor_pos, mark_pos);
    if (range_is_scope_selection(app, buffer, range)){
        select_next_scope_after_pos(app, view, buffer, range.max);
    }
    else{
        select_next_scope_after_pos(app, view, buffer, cursor_pos);
    }
}

CUSTOM_COMMAND(select_prev_scope_absolute, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 82, Normal)
CUSTOM_DOC("Finds the first scope started by '{' before the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Find_Nest_Flag flags = FindNest_Scope;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos - 1,
                       flags, Scan_Backward, NestDelim_Open, &range) &&
        find_nest_side(app, buffer, range.end,
                       flags|FindNest_Balanced|FindNest_EndOfToken, Scan_Forward,
                       NestDelim_Close, &range.end)){
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_prev_top_most_scope, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 99, Normal)
CUSTOM_DOC("Finds the first scope that starts before the cursor, then finds the top most scope that contains that scope.")
{
    select_prev_scope_absolute(app);
    select_surrounding_scope_maximal(app);
}

CUSTOM_COMMAND(place_in_scope, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 106, Normal)
CUSTOM_DOC("Wraps the code contained in the range between cursor and mark with a new curly brace scope.")
{
    place_begin_and_end_on_own_lines(app, "{", "}");
}

CUSTOM_COMMAND(delete_current_scope, "/home/tabletel/dev/4cc/code/custom/4coder_scope_commands.cpp", 112, Normal)
CUSTOM_DOC("Deletes the braces surrounding the currently selected scope.  Leaves the contents within the scope.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    Range_i64 range = get_view_range(app, view);
    if (range_is_scope_selection(app, buffer, range)){
        i32 top_len = 1;
        i32 bot_len = 1;
        if (buffer_get_char(app, buffer, range.min - 1) == '\n'){
            top_len = 2;
        }
        if (buffer_get_char(app, buffer, range.max + 1) == '\n'){
            bot_len = 2;
        }

        Batch_Edit batch_first = {};
        Batch_Edit batch_last = {};

        batch_first.edit.text = SCu8();
        batch_first.edit.range = Ii64(range.min + 1 - top_len, range.min + 1);
        batch_first.next = &batch_last;
        batch_last.edit.text = SCu8();
        batch_last.edit.range = Ii64((i32)(range.max - 1), (i32)(range.max - 1 + bot_len));

        buffer_batch_edit(app, buffer, &batch_first);
    }
}
# 134 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp" 1






static void
write_string(Application_Links *app, View_ID view, Buffer_ID buffer, String_Const_u8 string){
    i64 pos = view_get_cursor_pos(app, view);
    buffer_replace_range(app, buffer, Ii64(pos), string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos + string.size));
}

static void
write_string(Application_Links *app, String_Const_u8 string){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    write_string(app, view, buffer, string);
}

static void
write_named_comment_string(Application_Links *app, char *type_string){
    Scratch_Block scratch(app);
    String_Const_u8 name = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("user_name"), (u64)(sizeof("user_name") - 1))));
    String_Const_u8 str = {};
    if (name.size > 0){
        str = push_u8_stringf(scratch, "// %s(%.*s): ", type_string, (i32)(name).size, (char*)(name).str);
    }
    else{
        str = push_u8_stringf(scratch, "// %s: ", type_string);
    }
    write_string(app, str);
}

static void
long_braces(Application_Links *app, char *text, i32 size){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    buffer_replace_range(app, buffer, Ii64(pos), SCu8(text, size));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos + 2));
    auto_indent_buffer(app, buffer, Ii64_size(pos, size));
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(open_long_braces, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 46, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '}' separated by a blank line.")
{
    char text[] = "{\n\n}";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(open_long_braces_semicolon, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 54, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '};' separated by a blank line.")
{
    char text[] = "{\n\n};";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(open_long_braces_break, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 62, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '}break;' separated by a blank line.")
{
    char text[] = "{\n\n}break;";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(if0_off, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 70, Normal)
CUSTOM_DOC("Surround the range between the cursor and mark with an '#if 0' and an '#endif'")
{
    place_begin_and_end_on_own_lines(app, "#if 0", "#endif");
}

CUSTOM_COMMAND(write_todo, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 76, Normal)
CUSTOM_DOC("At the cursor, insert a '// TODO' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "TODO");
}

CUSTOM_COMMAND(write_hack, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 82, Normal)
CUSTOM_DOC("At the cursor, insert a '// HACK' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "HACK");
}

CUSTOM_COMMAND(write_note, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 88, Normal)
CUSTOM_DOC("At the cursor, insert a '// NOTE' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "NOTE");
}

CUSTOM_COMMAND(write_block, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 94, Normal)
CUSTOM_DOC("At the cursor, insert a block comment.")
{
    place_begin_and_end_on_own_lines(app, "/* ", " */");
}

CUSTOM_COMMAND(write_zero_struct, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 100, Normal)
CUSTOM_DOC("At the cursor, insert a ' = {};'.")
{
    write_string(app, SCu8((u8*)(" = {};"), (u64)(sizeof(" = {};") - 1)));
}

static i64
get_start_of_line_at_cursor(Application_Links *app, View_ID view, Buffer_ID buffer){
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    return(get_pos_past_lead_whitespace_from_line_number(app, buffer, line));
}

static b32
c_line_comment_starts_at_position(Application_Links *app, Buffer_ID buffer, i64 pos){
    b32 alread_has_comment = false;
    u8 check_buffer[2];
    if (buffer_read_range(app, buffer, Ii64(pos, pos + 2), check_buffer)){
        if (check_buffer[0] == '/' && check_buffer[1] == '/'){
            alread_has_comment = true;
        }
    }
    return(alread_has_comment);
}

CUSTOM_COMMAND(comment_line, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 125, Normal)
CUSTOM_DOC("Insert '//' at the beginning of the line after leading whitespace.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (!alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
    }
}

CUSTOM_COMMAND(uncomment_line, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 137, Normal)
CUSTOM_DOC("If present, delete '//' at the beginning of the line after leading whitespace.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos, pos + 2), string_u8_empty);
    }
}

CUSTOM_COMMAND(comment_line_toggle, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 149, Normal)
CUSTOM_DOC("Turns uncommented lines into commented lines and vice versa for comments starting with '//'.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos, pos + 2), string_u8_empty);
    }
    else{
        buffer_replace_range(app, buffer, Ii64(pos), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
    }
}



static Snippet default_snippets[] = {

    {"if", "if (){\n\n}\n", 4, 7},
    {"ifelse", "if (){\n\n}\nelse{\n\n}", 4, 7},
    {"forn", "for (node = ;\nnode != 0;\nnode = node->next){\n\n}\n", 5, 38},
    {"fori", "for (i = 0; i < ; i += 1){\n\n}\n", 5, 16},
    {"forj", "for (j = 0; j < ; j += 1){\n\n}\n", 5, 16},
    {"fork", "for (k = 0; k < ; k += 1){\n\n}\n", 5, 16},
    {"for", "for (;;){\n\n}\n", 5, 10},
    {"///", "////////////////////////////////", 32, 32},
    {"#guard", "#if !defined(Z)\n#define Z\n#endif\n", 0, 26},

    {"op+", "Z\noperator+(Z a, Z b){\n,\n}\n", 0, 23},
    {"op-", "Z\noperator-(Z a, Z b){\n,\n}\n", 0, 23},
    {"op*", "Z\noperator*(Z a, Z b){\n,\n}\n", 0, 23},
    {"op/", "Z\noperator/(Z a, Z b){\n,\n}\n", 0, 23},
    {"op+=", "Z&\noperator+=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op-=", "Z&\noperator-=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op*=", "Z&\noperator*=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op/=", "Z&\noperator/=(Z &a, Z b){\n,\n}\n", 0, 26},


    {"4command", "CUSTOM_COMMAND_SIG()\nCUSTOM_DOC()\n{\n\n}\n", 19, 32},
    {"4app", "Application_Links *app", 22, 22},




};

static void
write_snippet(Application_Links *app, View_ID view, Buffer_ID buffer,
              i64 pos, Snippet *snippet){
    if (snippet != 0){
        String_Const_u8 snippet_text = SCu8(snippet->text);
        buffer_replace_range(app, buffer, Ii64(pos), snippet_text);
        i64 new_cursor = pos + snippet->cursor_offset;
        view_set_cursor_and_preferred_x(app, view, seek_pos(new_cursor));
        i64 new_mark = pos + snippet->mark_offset;
        view_set_mark(app, view, seek_pos(new_mark));
        auto_indent_buffer(app, buffer, Ii64_size(pos, snippet_text.size));
    }
}

static Snippet*
get_snippet_from_user(Application_Links *app, Snippet *snippets, i32 snippet_count,
                      String_Const_u8 query){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    Snippet *snippet = snippets;
    for (i32 i = 0; i < snippet_count; i += 1, snippet += 1){
        lister_add_item(lister, SCu8(snippet->name), SCu8(snippet->text), snippet, 0);
    }
    Lister_Result l_result = run_lister(app, lister);
    Snippet *result = 0;
    if (!l_result.canceled){
        result = (Snippet*)l_result.user_data;
    }
    return(result);
}


static Snippet*
get_snippet_from_user(Application_Links *app, Snippet *snippets, i32 snippet_count,
                      char *query){
    return(get_snippet_from_user(app, snippets, snippet_count, SCu8(query)));
}

CUSTOM_COMMAND(snippet_lister, "/home/tabletel/dev/4cc/code/custom/4coder_combined_write_commands.cpp", 237, UI)
CUSTOM_DOC("Opens a snippet lister for inserting whole pre-written snippets of text.")
{
    View_ID view = get_this_ctx_view(app, Access_ReadWrite);
    if (view != 0){
        Snippet *snippet = get_snippet_from_user(app, default_snippets,
                                                 ((sizeof(default_snippets))/(sizeof(*default_snippets))),
                                                 "Snippet:");

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 pos = view_get_cursor_pos(app, view);
        write_snippet(app, view, buffer, pos, snippet);
    }
}
# 135 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp" 1







struct Miblo_Number_Info{
    Range_i64 range;
    i64 x;
};

static b32
get_numeric_at_cursor(Application_Links *app, Buffer_ID buffer, i64 pos, Miblo_Number_Info *info){
    b32 result = false;
    Range_i64 range = enclose_pos_base10(app, buffer, pos);
    if (range_size(range) > 0){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_buffer_range(app, scratch, buffer, range);
        if (str.size > 0){
            info->range = range;
            info->x = string_to_integer(str, 10);
            result = true;
        }
    }
    return(result);
}

CUSTOM_COMMAND(miblo_increment_basic, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 29, Normal)
CUSTOM_DOC("Increment an integer under the cursor by one.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Miblo_Number_Info number = {};
    if (get_numeric_at_cursor(app, buffer, pos, &number)){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_u8_stringf(scratch, "%d", number.x + 1);
        buffer_replace_range(app, buffer, number.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(number.range.start + str.size - 1));
    }
}

CUSTOM_COMMAND(miblo_decrement_basic, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 44, Normal)
CUSTOM_DOC("Decrement an integer under the cursor by one.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Miblo_Number_Info number = {};
    if (get_numeric_at_cursor(app, buffer, pos, &number)){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_u8_stringf(scratch, "%d", number.x - 1);
        buffer_replace_range(app, buffer, number.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(number.range.start + str.size - 1));
    }
}




struct Miblo_Timestamp{
    i32 second;
    i32 minute;
    i32 hour;
};
static Miblo_Timestamp null_miblo_timestamp = {};

enum{
    MIBLO_SECOND,
    MIBLO_MINUTE,
    MIBLO_HOUR
};

static Miblo_Timestamp
increment_timestamp(Miblo_Timestamp t, i32 type, i32 amt){
    Miblo_Timestamp r = t;
    switch (type){
        case MIBLO_SECOND:
        r.second += amt;



        amt = 0;
        if (r.second < 0){
            i32 pos_second = -r.second;
            amt = -((pos_second + 59)/60);
            r.second = 60 - (pos_second % 60);
        }
        else if (r.second >= 60){
            amt = r.second/60;
            r.second = (r.second % 60);
        }

        case MIBLO_MINUTE:
        r.minute += amt;



        amt = 0;
        if (r.minute < 0){
            i32 pos_minute = -r.minute;
            amt = -((pos_minute + 59)/60);
            r.minute = 60 - (pos_minute % 60);
        }
        else if (r.minute >= 60){
            amt = r.minute/60;
            r.minute = (r.minute % 60);
        }

        case MIBLO_HOUR:
        r.hour += amt;
        if (r.hour < 0){
            r.second = 0;
            r.minute = 0;
            r.hour = 0;
        }
    }

    return(r);
}

static String_Const_u8
timestamp_to_string(Arena *arena, Miblo_Timestamp t){
    List_String_Const_u8 list = {};
    if (t.hour > 0){
        string_list_pushf(arena, &list, "%d:", t.hour);
    }
    i32 minute = (((0)>(t.minute))?(0):(t.minute));
    string_list_pushf(arena, &list, "%02d:", minute);
    i32 second = (((0)>(t.second))?(0):(t.second));
    string_list_pushf(arena, &list, "%02d", second);
    String_Const_u8 str = string_list_flatten(arena, list);
    return(str);
}

struct Miblo_Timestamp_Info{
    Range_i64 range;
    Miblo_Timestamp time;
};

static b32
get_timestamp_at_cursor(Application_Links *app, Buffer_ID buffer, i64 pos, Miblo_Timestamp_Info *info){
    b32 result = false;

    Scratch_Block scratch(app);

    Range_i64 time_stamp_range = enclose_pos_base10_colon(app, buffer, pos);
    if (range_size(time_stamp_range) > 0){
        String_Const_u8 string = push_buffer_range(app, scratch, buffer, time_stamp_range);
        if (string.size > 0){
            i32 count_colons = 0;
            for (u64 i = 0; i < string.size; ++i){
                if (string.str[i] == ':'){
                    count_colons += 1;
                }
            }

            if (count_colons == 1 || count_colons == 2){
                Miblo_Timestamp t = {};

                b32 success = false;

                Range_i64 number[3];
                i32 k = 0;
                number[0].min = 0;
                for (i64 i = 0; i < (i64)string.size; i += 1){
                    if (string.str[i] == ':'){
                        number[k].max = i;
                        k += 1;
                        number[k].min = i + 1;
                    }
                }
                number[k].max = (i64)string.size;

                if (count_colons == 2){
                    String_Const_u8 hour_str = string_substring(string, number[0]);
                    t.hour = (i32)string_to_integer(hour_str, 10);

                    if (range_size(number[1]) == 2){
                        String_Const_u8 minute_str = string_substring(string, number[1]);
                        t.minute = (i32)string_to_integer(minute_str, 10);
                        if (range_size(number[2]) == 2){
                            String_Const_u8 second_str = string_substring(string, number[2]);
                            t.second = (i32)string_to_integer(second_str, 10);
                            success = true;
                        }
                    }
                }
                else{
                    if (range_size(number[0]) == 2 || range_size(number[0]) == 1){
                        String_Const_u8 minute_str = string_substring(string, number[0]);
                        t.minute = (i32)string_to_integer(minute_str, 10);

                        if (range_size(number[1]) == 2){
                            String_Const_u8 second_str = string_substring(string, number[1]);
                            t.second = (i32)string_to_integer(second_str, 10);
                            success = true;
                        }
                    }
                }

                if (success){
                    info->range = time_stamp_range;
                    info->time = t;
                    result = true;
                }
            }
        }
    }

    return(result);
}

static void
miblo_time_stamp_alter(Application_Links *app, i32 unit_type, i32 amt){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);

    Miblo_Timestamp_Info timestamp = {};
    if (get_timestamp_at_cursor(app, buffer, pos, &timestamp)){
        Scratch_Block scratch(app);
        Miblo_Timestamp inc_timestamp = increment_timestamp(timestamp.time, unit_type, amt);
        String_Const_u8 str = timestamp_to_string(scratch, inc_timestamp);
        buffer_replace_range(app, buffer, timestamp.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(timestamp.range.start + str.size - 1));
    }
}

CUSTOM_COMMAND(miblo_increment_time_stamp, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 231, Normal)
CUSTOM_DOC("Increment a time stamp under the cursor by one second. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_SECOND, 1);
}

CUSTOM_COMMAND(miblo_decrement_time_stamp, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 237, Normal)
CUSTOM_DOC("Decrement a time stamp under the cursor by one second. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_SECOND, -1);
}

CUSTOM_COMMAND(miblo_increment_time_stamp_minute, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 243, Normal)
CUSTOM_DOC("Increment a time stamp under the cursor by one minute. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_MINUTE, 1);
}

CUSTOM_COMMAND(miblo_decrement_time_stamp_minute, "/home/tabletel/dev/4cc/code/custom/4coder_miblo_numbers.cpp", 249, Normal)
CUSTOM_DOC("Decrement a time stamp under the cursor by one minute. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_MINUTE, -1);
}
# 136 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" 1






static Profile_Slot*
profile_parse_get_slot(Arena *arena, Profile_Inspection *insp,
                       String_Const_u8 loc, String_Const_u8 name){
    Profile_Slot *result = 0;
    for (Profile_Slot *node = insp->first_slot;
         node != 0;
         node = node->next){
        if (string_match(node->location, loc) &&
            string_match(node->name, name)){
            result = node;
            break;
        }
    }
    if (result == 0){
        result = ((Profile_Slot*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Profile_Slot)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "21" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "21" ":") - 1)))));
        do{ if((result)){if((insp->first_slot)){(insp->last_slot)->next=(result);}else{(insp->first_slot)=(result);}(insp->last_slot)=(result);(insp->last_slot)->next=0;} }while(0);
        insp->slot_count += 1;
        result->location = loc;
        result->name = name;
    }
    return(result);
}

static void
profile_parse_error(Arena *arena, Profile_Inspection *insp, String_Const_u8 message,
                    String_Const_u8 location){
    Profile_Error *error = ((Profile_Error*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Error)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "33" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "33" ":") - 1)))));
    do{ if((error)){if((insp->first_error)){(insp->last_error)->next=(error);}else{(insp->first_error)=(error);}(insp->last_error)=(error);(insp->last_error)->next=0;} }while(0);
    insp->error_count += 1;
    error->message = message;
    error->location = location;
}

static Profile_Record*
profile_parse_record(Arena *arena, Profile_Inspection *insp,
                     Profile_Node *parent, Profile_Record *record,
                     Range_u64 *total_time_range){
    for (;record != 0;){
        if (record->id <= parent->id){
            break;
        }

        Profile_ID id = record->id;
        Profile_Node *node = ((Profile_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "50" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "50" ":") - 1)))));
        do{ if((node)){if((parent->first_child)){(parent->last_child)->next=(node);}else{(parent->first_child)=(node);}(parent->last_child)=(node);(parent->last_child)->next=0;} }while(0);
        parent->child_count += 1;
        node->parent = parent;
        node->thread = parent->thread;

        String_Const_u8 location = record->location;
        String_Const_u8 name = record->name;

        node->time.min = record->time;
        node->time.max = max_u64;
        node->id = id;
        node->first_child = 0;
        node->last_child = 0;
        node->child_count = 0;
        node->closed = false;

        record = profile_parse_record(arena, insp, node, record->next,
                                      total_time_range);

        b32 quit_loop = false;
        Profile_Slot *slot = 0;
        if (record == 0 || record->id < id){
            if (record == 0){

                profile_parse_error(arena, insp, SCu8((u8*)("List ended before all nodes closed"), (u64)(sizeof("List ended before all nodes closed") - 1)), location);

            }
            else{

                String_Const_u8 str = push_u8_stringf(arena, "Node '%.*s' closed by parent ending (or higher priority sibling starting)", (i32)(name).size, (char*)(name).str);
                profile_parse_error(arena, insp, str, location);

                if (parent->id != 0){
                    quit_loop = true;
                }
            }
            slot = profile_parse_get_slot(arena, insp, location, name);
        }
        else if (record->id == id){
            slot = profile_parse_get_slot(arena, insp, location, name);
            node->time.max = record->time;
            node->closed = true;
            total_time_range->min = (((total_time_range->min)<(node->time.min))?(total_time_range->min):(node->time.min));
            total_time_range->max = (((total_time_range->max)>(node->time.max))?(total_time_range->max):(node->time.max));
            record = record->next;
        }
        else{


            (*((i32*)0) = 0xA11E);
        }

        node->slot = slot;
        if (!slot->corrupted_time){
            if (node->closed){
                slot->total_time += range_size(node->time);
            }
            else{
                slot->corrupted_time = true;
            }
        }
        {
            Profile_Node_Ptr *node_ptr = ((Profile_Node_Ptr*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Node_Ptr)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "113" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "113" ":") - 1)))));
            do{ if((node_ptr)){if((slot->first_hit)){(slot->last_hit)->next=(node_ptr);}else{(slot->first_hit)=(node_ptr);}(slot->last_hit)=(node_ptr);(slot->last_hit)->next=0;} }while(0);
            slot->hit_count += 1;
            node_ptr->ptr = node;
            node->unique_counter = (u64)slot->hit_count;
        }

        if (quit_loop){
            break;
        }
    }
    return(record);
}

static Profile_Inspection
profile_parse(Arena *arena, Profile_Global_List *src){
    Mutex_Lock lock(src->mutex);

    Profile_Inspection result = {};

    result.thread_count = src->thread_count;
    result.threads = ((Profile_Inspection_Thread*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Profile_Inspection_Thread)*(result.thread_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "134" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "134" ":") - 1)))))
                                                         ;

    i32 counter = 0;
    Profile_Inspection_Thread *insp_thread = result.threads;
    for (Profile_Thread *node = src->first_thread;
         node != 0;
         node = node->next, counter += 1, insp_thread += 1){
        insp_thread->thread_id = node->thread_id;
        insp_thread->name = node->name;




        Range_u64 time_range = {max_u64, 0};
        insp_thread->root.thread = insp_thread;
        profile_parse_record(arena, &result, &insp_thread->root, node->first_record, &time_range);
        insp_thread->root.time = time_range;
        insp_thread->root.closed = true;

        for (Profile_Node *prof_node = insp_thread->root.first_child;
             prof_node != 0;
             prof_node = prof_node->next){
            insp_thread->active_time += range_size(prof_node->time);
        }
    }

    return(result);
}



struct Tab_State{
    Vec2_f32 p;
    Range_f32 tabs_y;
    Face_ID face_id;
    f32 x_half_padding;
    Vec2_f32 m_p;
};

static void
profile_draw_tab(Application_Links *app, Tab_State *state, Profile_Inspection *insp,
                 String_Const_u8 string, Profile_Inspection_Tab tab_id){
    Scratch_Block scratch(app);

    state->p.x += state->x_half_padding;

    Fancy_String *fstring = push_fancy_string(scratch, 0, string);

    b32 hover = false;
    f32 width = get_fancy_string_width(app, state->face_id, fstring);
    Rect_f32 box = Rf32(If32_size(state->p.x, width), state->tabs_y);
    if (rect_contains_point(box, state->m_p)){
        hover = true;
        insp->tab_id_hovered = tab_id;
    }

    FColor text = fcolor_id(defcolor_text_default);
    if (insp->tab_id == tab_id){
        text = fcolor_id(defcolor_pop2);
    }
    else if (hover){
        text = fcolor_id(defcolor_pop1);
    }

    Vec2_f32 np = draw_fancy_string(app, state->face_id, text, fstring, state->p);
    state->p = np;
    state->p.x += state->x_half_padding;
}

static void
profile_select_thread(Profile_Inspection *inspect, Profile_Inspection_Thread *thread){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = thread;
    inspect->selected_slot = 0;
    inspect->selected_node = 0;
}

static void
profile_select_slot(Profile_Inspection *inspect, Profile_Slot *slot){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = 0;
    inspect->selected_slot = slot;
    inspect->selected_node = 0;
}

static void
profile_select_node(Profile_Inspection *inspect, Profile_Node *node){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = 0;
    inspect->selected_slot = 0;
    inspect->selected_node = node;
}

static String_Const_u8
profile_node_thread_name(Profile_Node *node){
    String_Const_u8 result = {};
    if (node->thread != 0){
        result = node->thread->name;
    }
    return(result);
}

static String_Const_u8
profile_node_name(Profile_Node *node){
    String_Const_u8 result = SCu8((u8*)("*root*"), (u64)(sizeof("*root*") - 1));
    if (node->slot != 0){
        result = node->slot->name;
    }
    return(result);
}

static String_Const_u8
profile_node_location(Profile_Node *node){
    String_Const_u8 result = {};
    if (node->slot != 0){
        result = node->slot->location;
    }
    return(result);
}

static void
profile_qsort_nodes(Profile_Node **nodes, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot_index = one_past_last - 1;
        Profile_Node *pivot = nodes[pivot_index];
        u64 pivot_time = range_size(pivot->time);
        i32 j = first;
        for (i32 i = first; i < one_past_last; i += 1){
            Profile_Node *node = nodes[i];
            u64 node_time = range_size(node->time);
            if (node_time > pivot_time){
                do { Profile_Node* hidden_temp_266 = nodes[i]; nodes[i] = nodes[j]; nodes[j] = hidden_temp_266; } while(0);
                j += 1;
            }
        }
        do { Profile_Node* hidden_temp_270 = nodes[pivot_index]; nodes[pivot_index] = nodes[j]; nodes[j] = hidden_temp_270; } while(0);
        profile_qsort_nodes(nodes, first, j);
        profile_qsort_nodes(nodes, j + 1, one_past_last);
    }
}

static void
profile_draw_node(Application_Links *app, View_ID view, Face_ID face_id,
                  Profile_Node *node, Rect_f32 rect,
                  Profile_Inspection *insp, Vec2_f32 m_p){
    Range_f32 x = rect_range_x(rect);
    Range_f32 y = rect_range_y(rect);


    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 normal_advance = metrics.normal_advance;
    f32 block_height = line_height*2.f;
    f32 x_padding = normal_advance*1.5f;
    f32 x_half_padding = x_padding*0.5f;

    Color_Array colors = finalize_color_array(defcolor_back_cycle);

    Scratch_Block scratch(app);

    f32 x_pos = x.min + x_half_padding;
    f32 nav_bar_w = 0.f;
    Range_f32 nav_bar_y = {};
    nav_bar_y.min = y.min;

    String_Const_u8 thread_name = profile_node_thread_name(node);
    if (thread_name.size > 0){
        Fancy_String *fstr =
            push_fancy_string(scratch, 0, fcolor_id(defcolor_pop1), thread_name);
        Vec2_f32 p = V2f32(x_pos, y.min + 1.f);
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
        f32 w = get_fancy_string_width(app, face_id, fstr);
        nav_bar_w = (((nav_bar_w)>(w))?(nav_bar_w):(w));
    }
    y.min += line_height + 2.f;

    String_Const_u8 name = profile_node_name(node);
    if (name.size > 0){
        Fancy_String *fstr =
            push_fancy_string(scratch, 0, fcolor_id(defcolor_text_default), name);
        Vec2_f32 p = V2f32(x_pos, y.min + 1.f);
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
        f32 w = get_fancy_string_width(app, face_id, fstr);
        nav_bar_w = (((nav_bar_w)>(w))?(nav_bar_w):(w));
    }
    y.min += line_height + 2.f;

    nav_bar_y.max = y.min;

    x_pos += nav_bar_w + x_half_padding;
    if (node->parent != 0){
        Fancy_String *fstr = push_fancy_string(scratch, 0, fcolor_zero(),
                                               SCu8((u8*)("to parent"), (u64)(sizeof("to parent") - 1)));
        f32 w = get_fancy_string_width(app, face_id, fstr) + x_padding;
        Range_f32 btn_x = If32_size(x_pos, w);
        Rect_f32 box = Rf32(btn_x, nav_bar_y);

        FColor color = fcolor_id(defcolor_text_default);
        if (rect_contains_point(box, m_p)){
            draw_rectangle_fcolor(app, box, 0.f, fcolor_id(defcolor_margin));
            color = fcolor_id(defcolor_pop1);
            insp->hover_node = node->parent;
        }

        Vec2_f32 p = V2f32(box.x0 + x_half_padding,
                           (box.y0 + box.y1 - line_height)*0.5f);
        draw_fancy_string(app, face_id, color, fstr, p);

        x_pos = btn_x.max;
    }

    Range_u64 top_time = node->time;

    Rect_f32_Pair side_by_side = rect_split_left_right_lerp(Rf32(x, y), 0.5f);

    Rect_f32 time_slice_box = side_by_side.min;
    time_slice_box = rect_inner(time_slice_box, 3.f);
    draw_rectangle_outline_fcolor(app, time_slice_box, 0.f, 3.f, f_white);
    time_slice_box = rect_inner(time_slice_box, 3.f);

    if (node->closed){
        draw_set_clip(app, time_slice_box);

        x = rect_range_x(time_slice_box);
        y = rect_range_y(time_slice_box);

        i32 cycle_counter = 0;
        for (Profile_Node *child = node->first_child;
             child != 0;
             child = child->next){
            if (!child->closed){
                continue;
            }

            Range_u64 child_time = child->time;
            Range_f32 child_y = {};
            child_y.min = unlerp(top_time.min, child_time.min, top_time.max);
            child_y.max = unlerp(top_time.min, child_time.max, top_time.max);
            child_y.min = lerp(y.min, child_y.min, y.max);
            child_y.max = lerp(y.min, child_y.max, y.max);

            Rect_f32 box = Rf32(x, child_y);
            ARGB_Color argb = finalize_color(colors, cycle_counter);
            draw_rectangle(app, box, 0.f, argb);
            cycle_counter += 1;

            if (rect_contains_point(box, m_p)){
                insp->full_name_hovered = profile_node_name(child);
                insp->unique_counter_hovered = child->unique_counter;
                insp->location_jump_hovered = profile_node_location(child);
                insp->hover_node = child;
            }

            if (range_size(child_y) >= line_height){
                String_Const_u8 child_name = profile_node_name(child);
                Fancy_Line line = {};
                push_fancy_string(scratch, &line, fcolor_id(defcolor_pop1),
                                  child_name);
                push_fancy_stringf(scratch, &line, fcolor_id(defcolor_text_default),
                                   0.5f, 0.f, "#%4llu", child->unique_counter);

                Vec2_f32 p = V2f32(x.min + x_half_padding,
                                   child_y.min);
                draw_fancy_line(app, face_id, fcolor_zero(),
                                &line, p);
            }
        }
    }

    Rect_f32 info_box = side_by_side.max;

    {
        draw_set_clip(app, info_box);

        x = rect_range_x(info_box);

        x_pos = x.min + x_half_padding;
        f32 y_pos = info_box.y0;


        {
            f32 duration = ((f32)range_size(node->time))/1000000.f;
            Fancy_Line list = {};
            push_fancy_stringf(scratch, &list, fcolor_id(defcolor_text_default),
                               "time: %11.9f", duration);
            draw_fancy_line(app, face_id, fcolor_zero(),
                            &list, V2f32(x_pos, y_pos + 1.f));
            y_pos += line_height + 2.f;
        }

        i32 child_count = node->child_count;
        Profile_Node **children_array = ((Profile_Node**)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Profile_Node*)*(child_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "426" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "426" ":") - 1)))));
        i32 counter = 0;
        for (Profile_Node *child = node->first_child;
             child != 0;
             child = child->next){
            children_array[counter] = child;
            counter += 1;
        }

        profile_qsort_nodes(children_array, 0, child_count);

        Profile_Node **child_ptr = children_array;
        for (i32 i = 0; i < child_count; i += 1, child_ptr += 1){
            Profile_Node *child = *child_ptr;
            y = If32_size(y_pos, block_height);

            f32 child_duration = ((f32)range_size(child->time))/1000000.f;

            String_Const_u8 child_name = profile_node_name(child);
            Fancy_Line line = {};
            push_fancy_string_trunc(scratch, &line, child_name, 20);
            push_fancy_stringf(scratch, &line, fcolor_id(defcolor_text_default), 0.5f, 0.f,
                               "#%4llu", child->unique_counter);
            push_fancy_stringf(scratch, &line, fcolor_id(defcolor_pop2),
                               0.5f, 0.f, "%6.4f", child_duration);

            Vec2_f32 p = V2f32(x.min + x_half_padding,
                               (y.min + y.max - line_height)*0.5f);
            draw_fancy_line(app, face_id, fcolor_id(defcolor_pop1), &line, p);

            Rect_f32 box = Rf32(x, y);
            FColor margin = fcolor_id(defcolor_margin);
            if (rect_contains_point(box, m_p)){
                insp->full_name_hovered = child_name;
                insp->unique_counter_hovered = child->unique_counter;
                insp->location_jump_hovered = profile_node_location(child);
                insp->hover_node = child;
                margin = fcolor_id(defcolor_margin_hover);
            }
            draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

            y_pos = y.max;
            if (y_pos >= info_box.y1){
                break;
            }
        }
    }
}

static void
profile_memory_sort_by_count(Memory_Bucket **buckets, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot = one_past_last - 1;
        i32 pivot_key = buckets[pivot]->annotation.count;
        i32 j = first;
        for (i32 i = first; i < pivot; i += 1){
            i32 key = buckets[i]->annotation.count;
            if (key <= pivot_key){
                do { Memory_Bucket* hidden_temp_484 = buckets[j]; buckets[j] = buckets[i]; buckets[i] = hidden_temp_484; } while(0);
                j += 1;
            }
        }
        do { Memory_Bucket* hidden_temp_488 = buckets[j]; buckets[j] = buckets[pivot]; buckets[pivot] = hidden_temp_488; } while(0);
        profile_memory_sort_by_count(buckets, first, j);
        profile_memory_sort_by_count(buckets, j + 1, one_past_last);
    }
}

static void
profile_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);

    Rect_f32 region = draw_background_and_margin(app, view);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    Face_ID face_id = get_face_id(app, 0);

    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 normal_advance = metrics.normal_advance;
    f32 block_height = line_height*2.f;
    f32 x_padding = normal_advance*1.5f;
    f32 x_half_padding = x_padding*0.5f;

    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p);

    Profile_Inspection *inspect = &global_profile_inspection;

    if (inspect->thread_count == 0){
        Fancy_String *fstr = push_fancy_string(scratch, 0, fcolor_id(defcolor_pop2),
                                               SCu8((u8*)("no profile data"), (u64)(sizeof("no profile data") - 1)));
        f32 width = get_fancy_string_width(app, face_id, fstr);
        Vec2_f32 view_center = (region.p0 + region.p1)*0.5f;
        Vec2_f32 half_dim = V2f32(width, line_height)*0.5f;
        Vec2_f32 p = view_center - half_dim;
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
    }
    else{
        Rect_f32_Pair tabs_body = rect_split_top_bottom(region, line_height + 2.f);
        Range_f32 tabs_y = rect_range_y(tabs_body.min);

        inspect->tab_id_hovered = ProfileInspectTab_None;
        block_zero((&inspect->full_name_hovered), sizeof(*(&inspect->full_name_hovered)));
        inspect->unique_counter_hovered = 0;
        block_zero((&inspect->location_jump_hovered), sizeof(*(&inspect->location_jump_hovered)));
        inspect->hover_thread = 0;
        inspect->hover_slot = 0;
        inspect->hover_node = 0;


        {
            f32 y = (tabs_y.min + tabs_y.max - line_height)*0.5f;
            f32 x = region.x0;

            Tab_State tab_state = {};
            tab_state.p = V2f32(x, y);
            tab_state.tabs_y = tabs_y;
            tab_state.face_id = face_id;
            tab_state.x_half_padding = x_half_padding;
            tab_state.m_p = m_p;

            draw_rectangle_fcolor(app, tabs_body.min, 0.f, fcolor_id(defcolor_margin_hover));

            if (inspect->tab_id == ProfileInspectTab_None){
                inspect->tab_id = ProfileInspectTab_Threads;
            }

            profile_draw_tab(app, &tab_state, inspect,
                             SCu8((u8*)("threads"), (u64)(sizeof("threads") - 1)),
                             ProfileInspectTab_Threads);

            if (inspect->slot_count > 0){
                profile_draw_tab(app, &tab_state, inspect,
                                 SCu8((u8*)("blocks"), (u64)(sizeof("blocks") - 1)),
                                 ProfileInspectTab_Blocks);
            }

            if (inspect->error_count > 0){
                profile_draw_tab(app, &tab_state, inspect,
                                 SCu8((u8*)("errors"), (u64)(sizeof("errors") - 1)),
                                 ProfileInspectTab_Errors);
            }

            profile_draw_tab(app, &tab_state, inspect,
                             SCu8((u8*)("memory"), (u64)(sizeof("memory") - 1)),
                             ProfileInspectTab_Memory);

            if (inspect->tab_id == ProfileInspectTab_Selection){
                String_Const_u8 string = {};
                if (inspect->selected_thread != 0){
                    String_Const_u8 name = inspect->selected_thread->name;
                    string = push_u8_stringf(scratch, "%.*s (%d)",
                                             (i32)(name).size, (char*)(name).str,
                                             inspect->selected_thread->thread_id);
                }
                else if (inspect->selected_slot != 0){
                    String_Const_u8 name = inspect->selected_slot->name;
                    string = push_u8_stringf(scratch, "block %.*s",
                                             (i32)(name).size, (char*)(name).str);
                }
                else if (inspect->selected_node != 0){
                    String_Const_u8 name = profile_node_name(inspect->selected_node);
                    string = push_u8_stringf(scratch, "node %.*s",
                                             (i32)(name).size, (char*)(name).str);
                }
                else{
                    inspect->tab_id = ProfileInspectTab_Threads;
                }
                if (string.str != 0){
                    profile_draw_tab(app, &tab_state, inspect,
                                     string, ProfileInspectTab_Selection);
                }
            }
        }

        draw_set_clip(app, tabs_body.max);
        switch (inspect->tab_id){
            case ProfileInspectTab_Threads:
            {
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                i32 count = inspect->thread_count;
                Profile_Inspection_Thread *thread = inspect->threads;
                for (i32 i = 0; i < count; i += 1, thread += 1){
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop1),
                                       "%-20.*s (%6d) ",
                                       (i32)(thread->name).size, (char*)(thread->name).str,
                                       thread->thread_id);

                    f32 active_time = ((f32)thread->active_time)/1000000.f;
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2),
                                       "active time %11.9f",
                                       active_time);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->hover_thread = thread;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Blocks:
            {
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                for (Profile_Slot *node = inspect->first_slot;
                     node != 0;
                     node = node->next){
                    Range_f32 y = If32_size(y_pos, block_height);

                    u32 name_width = 45;
                    b32 name_too_long = (node->name.size > name_width);
                    Fancy_Line list = {};
                    push_fancy_string_fixed(scratch, &list, fcolor_id(defcolor_pop1),
                                            node->name, name_width);

                    if (node->corrupted_time){
                        push_fancy_string(scratch, &list, fcolor_id(defcolor_pop2),
                                          SCu8((u8*)("timing error "), (u64)(sizeof("timing error ") - 1)));
                    }
                    else{
                        push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2),
                                           "%11.9fs ",
                                           ((f32)node->total_time)/1000000.f);
                    }

                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_keyword),
                                       "hit # %5d", node->hit_count);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        if (name_too_long){
                            inspect->full_name_hovered = node->name;
                        }
                        inspect->location_jump_hovered = node->location;
                        inspect->hover_slot = node;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Errors:
            {
                draw_set_clip(app, tabs_body.max);
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                for (Profile_Error *node = inspect->first_error;
                     node != 0;
                     node = node->next){
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_string(scratch, &list, fcolor_id(defcolor_pop2),
                                      node->message);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->location_jump_hovered = node->location;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Memory:
            {
                draw_set_clip(app, tabs_body.max);
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                Memory_Annotation annotation = system_memory_annotation(scratch);

                Base_Allocator *allocator = get_base_allocator_system();

                Memory_Bucket *first_bucket = 0;
                Memory_Bucket *last_bucket = 0;
                i32 bucket_count = 0;
                Table_Data_u64 table = make_table_Data_u64__inner((allocator),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "739" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "739" ":") - 1)));

                for (Memory_Annotation_Node *node = annotation.first, *next = 0;
                     node != 0;
                     node = next){
                    next = node->next;
                    String_Const_u8 key = make_data(node->location.str, node->location.size);
                    Table_Lookup lookup = table_lookup(&table, key);
                    Memory_Bucket *bucket = 0;
                    if (lookup.found_match){
                        u64 val = 0;
                        table_read(&table, lookup, &val);
                        bucket = (Memory_Bucket*)(void*)(((u8*)0) + val);
                    }
                    else{
                        bucket = ((Memory_Bucket*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(Memory_Bucket)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "754" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "754" ":") - 1)))));
                        do{ if((bucket)){if((first_bucket)){(last_bucket)->next=(bucket);}else{(first_bucket)=(bucket);}(last_bucket)=(bucket);(last_bucket)->next=0;} }while(0);
                        bucket_count += 1;
                        bucket->location = node->location;
                        table_insert(&table, key, ((u8*)(bucket) - (u8*)(0)));
                    }
                    do{ if((node)){if((bucket->annotation.first)){(bucket->annotation.last)->next=(node);}else{(bucket->annotation.first)=(node);}(bucket->annotation.last)=(node);(bucket->annotation.last)->next=0;} }while(0);
                    bucket->annotation.count += 1;
                    bucket->total_memory += node->size;
                }

                Memory_Bucket **buckets = ((Memory_Bucket**)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Memory_Bucket*)*(bucket_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "765" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp" ":" "765" ":") - 1)))));
                i32 counter = 0;
                for (Memory_Bucket *node = first_bucket;
                     node != 0;
                     node = node->next){
                    buckets[counter] = node;
                    counter += 1;
                }

                profile_memory_sort_by_count(buckets, 0, bucket_count);

                for (i32 i = bucket_count - 1; i >= 0; i -= 1){
                    Memory_Bucket *node = buckets[i];
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2), "[%12llu] / %6d ",
                                       node->total_memory, node->annotation.count);
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop1), "%.*s",
                                       (i32)(node->location).size, (char*)(node->location).str);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->location_jump_hovered = node->location;
                        margin = fcolor_id(defcolor_margin_hover);
                    }

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }

                table_free(&table);
            }break;

            case ProfileInspectTab_Selection:
            {
                if (inspect->selected_thread != 0){
                    profile_draw_node(app, view, face_id,
                                      &inspect->selected_thread->root, tabs_body.max,
                                      inspect, m_p);
                }
                else if (inspect->selected_slot != 0){

                }
                else if (inspect->selected_node != 0){
                    profile_draw_node(app, view, face_id,
                                      inspect->selected_node, tabs_body.max,
                                      inspect, m_p);
                }
            }break;
        }

        if (!rect_contains_point(region, m_p)){

        }
        else if (inspect->tab_id_hovered != ProfileInspectTab_None){

        }
        else{
            Fancy_Block block = {};
            FColor text_color = fcolor_change_alpha(f_white, 0.5f);
            FColor back_color = fcolor_change_alpha(f_black, 0.5f);

            if (inspect->full_name_hovered.size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, text_color);
                push_fancy_stringf(scratch, line, "%.*s",
                                   (i32)(inspect->full_name_hovered).size, (char*)(inspect->full_name_hovered).str);
                if (inspect->unique_counter_hovered > 0){
                    push_fancy_stringf(scratch, line, text_color, 0.5f, 0.f,
                                       "#%4llu", inspect->unique_counter_hovered);
                }
            }
            if (inspect->location_jump_hovered.size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, text_color);
                push_fancy_stringf(scratch, line, "[shift] '%.*s'",
                                   (i32)(inspect->location_jump_hovered).size, (char*)(inspect->location_jump_hovered).str);
            }

            draw_tool_tip(app, face_id, &block, m_p, region,
                          x_padding, x_half_padding, back_color);
        }
    }

    draw_set_clip(app, prev_clip);
}

static void
profile_inspect__left_click(Application_Links *app, View_ID view,
                            Profile_Inspection *insp, Input_Event *event){
    if (has_modifier(event, KeyCode_Shift)){
        if (insp->location_jump_hovered.size != 0){
            View_ID target_view = view;
            target_view = get_next_view_looped_primary_panels(app, target_view,
                                                              Access_Always);
            String_Const_u8 location = insp->location_jump_hovered;
            jump_to_location(app, target_view, location);
        }
    }
    else{
        if (insp->tab_id_hovered != ProfileInspectTab_None){
            insp->tab_id = insp->tab_id_hovered;
        }
        else if (insp->hover_thread != 0){
            profile_select_thread(insp, insp->hover_thread);
        }
        else if (insp->hover_slot != 0){
            profile_select_slot(insp, insp->hover_slot);
        }
        else if (insp->hover_node != 0){
            profile_select_node(insp, insp->hover_node);
        }
    }
}

CUSTOM_COMMAND(profile_inspect, "/home/tabletel/dev/4cc/code/custom/4coder_profile_inspect.cpp", 886, UI)
CUSTOM_DOC("Inspect all currently collected profiling information in 4coder's self profiler.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    if ((((list->disable_bits)&(ProfileEnable_InspectBit))!=0)){
        return;
    }

    profile_set_enabled(list, false, ProfileEnable_InspectBit);

    Scratch_Block scratch(app);
    global_profile_inspection = profile_parse(scratch, list);
    Profile_Inspection *insp = &global_profile_inspection;

    View_ID view = get_active_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = profile_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_MouseButton:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        profile_inspect__left_click(app, view, insp, &in.event);
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            if (ui_fallback_command_dispatch(app, view, &in)){
                break;
            }
        }
    }

    profile_set_enabled(list, true, ProfileEnable_InspectBit);
}
# 137 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.cpp" 1






static Tutorial_State tutorial = {};

CUSTOM_COMMAND(kill_tutorial, "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.cpp", 9, Normal)
CUSTOM_DOC("If there is an active tutorial, kill it.")
{
    if (!tutorial.in_tutorial){
        return;
    }

    tutorial.in_tutorial = false;
    view_close(app, tutorial.view);
}

CUSTOM_COMMAND(tutorial_maximize, "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.cpp", 20, Normal)
CUSTOM_DOC("Expand the tutorial window")
{
    if (!tutorial.in_tutorial){
        return;
    }

    Panel_ID panel = view_get_panel(app, tutorial.view);
    Panel_ID parent = panel_get_parent(app, panel);
    panel_set_split(app, parent, PanelSplitKind_Ratio_Min, 0.5f);

    tutorial.is_active = true;
}

CUSTOM_COMMAND(tutorial_minimize, "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.cpp", 34, Normal)
CUSTOM_DOC("Shrink the tutorial window")
{
    if (!tutorial.in_tutorial){
        return;
    }

    Face_ID face = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face);
    f32 line_height = metrics.line_height;

    Panel_ID panel = view_get_panel(app, tutorial.view);
    Panel_ID parent = panel_get_parent(app, panel);
    panel_set_split(app, parent, PanelSplitKind_FixedPixels_Min, line_height*4.f);

    tutorial.is_active = false;
}

static void
tutorial_action(Application_Links *app, Tutorial_Action action){
    switch (action){
        case TutorialAction_Minimize:
        {
            tutorial_minimize(app);
        }break;

        case TutorialAction_Maximize:
        {
            tutorial_maximize(app);
        }break;

        case TutorialAction_Prev:
        {
            tutorial.slide_index -= 1;
        }break;

        case TutorialAction_Next:
        {
            tutorial.slide_index += 1;
        }break;

        case TutorialAction_Exit:
        {
            kill_tutorial(app);
        }break;

        case TutorialAction_Restart:
        {
            tutorial.slide_index = 0;
        }break;
    }
}

static void
tutorial_init_title_face(Application_Links *app){
    if (tutorial.face == 0){
        Face_ID face = get_face_id(app, 0);
        Face_Description face_description = get_face_description(app, face);
        face_description.parameters.pt_size *= 2;
        tutorial.face = try_create_new_face(app, &face_description);
        if (tutorial.face == 0){
            tutorial.face = face;
        }
    }
}

static void
tutorial_render(Application_Links *app, Frame_Info frame_info, View_ID view_id){
    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);
    Face_Metrics metrics = get_face_metrics(app, face);



    Scratch_Block scratch(app);
    tutorial.slide_index = (((0)>(tutorial.slide_index))?(0):(((tutorial.slide_count - 1)<(tutorial.slide_index))?(tutorial.slide_count - 1):(tutorial.slide_index)));
    Tutorial_Slide_Function *slide_func = tutorial.slide_func_ptrs[tutorial.slide_index];
    Tutorial_Slide slide = slide_func(app, scratch);



    f32 h0 = get_fancy_line_height(app, 0, &slide.short_details);
    f32 h1 = get_fancy_line_height(app, 0, slide.long_details.first);
    f32 title_height = (((h0)>(h1))?(h0):(h1));



    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    Rect_f32 region = draw_background_and_margin(app, view_id, margin_color, margin_color);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    f32 panel_y0 = region.y0 - 3.f;

    region = rect_inner(region, 3.f);
    draw_rectangle_fcolor(app, region, 20.f, fcolor_id(defcolor_back));
    region = rect_inner(region, 10.f);

    Vec2_f32 title_p = V2f32(region.x0, panel_y0 + (metrics.line_height*2.f) - title_height*0.5f);

    tutorial.hover_action = TutorialAction_None;
    if (tutorial.is_active){
        draw_fancy_block(app, 0, fcolor_zero(), &slide.long_details, title_p);


        Rect_f32_Pair footer_pair = rect_split_top_bottom_neg(region, metrics.line_height*2.f);
        Rect_f32 footer = footer_pair.max;
        footer.x0 += 10.f;
        footer.y0 -= 10.f;
        footer.y1 -= 10.f;

        f32 b_width = metrics.normal_advance*10.f;
        Mouse_State mouse = get_mouse_state(app);
        Vec2_f32 m_p = V2f32(mouse.p);

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("minimize"), (u64)(sizeof("minimize") - 1)))){
                tutorial.hover_action = TutorialAction_Minimize;
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (tutorial.slide_index > 0){
                if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("prev"), (u64)(sizeof("prev") - 1)))){
                    tutorial.hover_action = TutorialAction_Prev;
                }
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (tutorial.slide_index < tutorial.slide_count - 1){
                if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("next"), (u64)(sizeof("next") - 1)))){
                    tutorial.hover_action = TutorialAction_Next;
                }
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            Rect_f32 exit_box = pair.min;
            pair = rect_split_left_right(footer, b_width);
            Rect_f32 restart_box = pair.min;

            if (tutorial.slide_index == tutorial.slide_count - 1){
                if (draw_button(app, exit_box, m_p, face, SCu8((u8*)("end"), (u64)(sizeof("end") - 1)))){
                    tutorial.hover_action = TutorialAction_Exit;
                }

                if (draw_button(app, restart_box, m_p, face, SCu8((u8*)("restart"), (u64)(sizeof("restart") - 1)))){
                    tutorial.hover_action = TutorialAction_Restart;
                }
            }
        }
    }
    else{
        draw_fancy_line(app, 0, fcolor_zero(), &slide.short_details, title_p);
    }

    draw_set_clip(app, prev_clip);
}

static void
tutorial_run_loop(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = tutorial_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    tutorial.in_tutorial = true;
    tutorial.view = view;
    tutorial_maximize(app);

    change_active_panel(app);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, 0);
        if (in.abort){
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_MouseButton:
            {
                tutorial_maximize(app);
                if (in.event.mouse.code == MouseCode_Left){
                    tutorial_action(app, tutorial.hover_action);
                }
            }break;

            case InputEventKind_Core:
            {
                switch (in.event.core.code){
                    case CoreCode_ClickActivateView:
                    {
                        tutorial_maximize(app);
                        tutorial_action(app, tutorial.hover_action);
                        change_active_panel(app);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            Mapping *mapping = ctx.mapping;
            Command_Map *map = mapping_get_map(mapping, ctx.map_id);

            Fallback_Dispatch_Result disp_result =
                fallback_command_dispatch(app, mapping, map, &in);
            if (disp_result.code == FallbackDispatch_DelayedUICall){
                call_after_ctx_shutdown(app, view, disp_result.func);
                break;
            }
            if (disp_result.code == FallbackDispatch_Unhandled){
                leave_current_input_unhandled(app);
            }
        }
    }

    tutorial.in_tutorial = false;
}

static void
run_tutorial(Application_Links *app, Tutorial_Slide_Function **slides, i32 slide_count){
    if (slide_count > 0){
        kill_tutorial(app);
        Panel_ID root_panel = panel_get_root(app);
        if (panel_split(app, root_panel, Dimension_Y)){
            panel_swap_children(app, root_panel);
            Panel_ID tutorial_panel = panel_get_child(app, root_panel, Side_Min);
            tutorial.view = panel_get_view(app, tutorial_panel, Access_Always);
            view_set_passive(app, tutorial.view, true);
            tutorial.slide_index = 0;
            tutorial.slide_func_ptrs = slides;
            tutorial.slide_count = slide_count;
            view_enqueue_command_function(app, tutorial.view, tutorial_run_loop);
        }
    }
}



static String_Const_u8 hms_title = SCu8((u8*)("Handmade Seattle Demo"), (u64)(sizeof("Handmade Seattle Demo") - 1));

static void
hms_demo_tutorial_short_details(Application_Links *app, Arena *arena, Fancy_Line *short_details){
    Face_ID face = get_face_id(app, 0);
    push_fancy_string(arena, short_details, tutorial.face, fcolor_id(defcolor_pop1), hms_title);
    push_fancy_string(arena, short_details, face, fcolor_id(defcolor_text_default), 8.f, 8.f, SCu8((u8*)("Welcome to Handmade Seattle and to this 4coder demo!"), (u64)(sizeof("Welcome to Handmade Seattle and to this 4coder demo!") - 1)));
    push_fancy_string(arena, short_details, face, fcolor_id(defcolor_pop2), SCu8((u8*)("Click here to see more."), (u64)(sizeof("Click here to see more.") - 1)));
}

static void
hms_demo_tutorial_long_start(Application_Links *app, Arena *arena, Fancy_Block *long_details){
    Fancy_Line *line = push_fancy_line(arena, long_details, tutorial.face, fcolor_id(defcolor_pop1), hms_title);

    Face_ID face = get_face_id(app, 0);

    line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));

    push_fancy_string(arena, line, SCu8((u8*)("If you want more information than what you can find here, please "), (u64)(sizeof("If you want more information than what you can find here, please ") - 1)));

    push_fancy_string(arena, line, fcolor_id(defcolor_pop2), SCu8((u8*)("ask!"), (u64)(sizeof("ask!") - 1)));


    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}

static void
hms_demo_tutorial_binding_line(Application_Links *app, Arena *arena, Fancy_Block *long_details, Face_ID face, char *modifiers, char *key, char *description){
    String_Const_u8 m = SCu8(modifiers);
    String_Const_u8 k = SCu8(key);

    f32 fill_size = (f32)k.size;
    if (m.size > 0){
        fill_size += (f32)m.size + 0.5f;
    }
    f32 pad_size = 0.f;
    if (fill_size < 40.f){
        pad_size = 40.f - fill_size;
    }

    Fancy_Line *line = line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
    push_fancy_stringf(arena, line, pad_size, 0.5f, "<");
    if (m.size > 0){
        push_fancy_stringf(arena, line, fcolor_id(defcolor_keyword), 0.f, 0.5f, "%s", modifiers);
    }
    push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "%s", key);
    push_fancy_stringf(arena, line, 0.5f, 1.f, ">");
    push_fancy_stringf(arena, line, "%s", description);
}

static Tutorial_Slide
hms_demo_tutorial_slide_1(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Let's start with a few navigation commands:"), (u64)(sizeof("Let's start with a few navigation commands:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Comma", "change active panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "*AnyArrow*", "move cursor one character or line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "*AnyArrow*", "move cursor by 'chunks'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Home/End", "move cursor to the first/last character of the line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "PageUp/PageDown", "move cursor by full pages up/down");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Available in code files:"), (u64)(sizeof("Available in code files:") - 1)));


    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "LeftBracket", "move cursor and mark to surrounding scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "RightBracket", "move cursor and mark to previous scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "Quote", "move cursor and mark to next scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "RightBracket", "move cursor and mark to previous top-level scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "Quote", "move cursor and mark to next scope at the same level as the current scope");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_2(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Now a look at basic editing:"), (u64)(sizeof("Now a look at basic editing:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "TextInsert", "non-modal text insertion works in any user-writable buffers at the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Backspace/Delete", "delete the previous/next character from the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Z", "undo the last edit");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Y", "redo the last undone edit");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "L", "duplicate the current line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "Up/Down", "move the current line");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Range commands based on a cursor and mark (emacs style):"), (u64)(sizeof("Range commands based on a cursor and mark (emacs style):") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Space", "moves the mark to the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "D", "delete the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "C", "copy the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "X", "cut the range");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Paste options with a multi-stage clipboard:"), (u64)(sizeof("Paste options with a multi-stage clipboard:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "V", "paste the clipboard to the buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "V", "paste the clipboard to the buffer cycling through the clipboard's 'clips'");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_3(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Now try beginning a file lister:"), (u64)(sizeof("Now try beginning a file lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "N", "begin a file lister for exploring the file system - always creating a new file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "O", "begin a file lister for exploring the file system - ultimiately opening or creating a file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "O", "same as previous option but opens in the other panel");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Inside a file lister:"), (u64)(sizeof("Inside a file lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "TextInsert", "narrows the lister down to options with substrings matching the text field");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Backspace", "backspace the end of the text field");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Up/Down", "move the highlighted option up/down");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "PageUp/PageDown", "move the highlighted option up/down by a 'large chunk'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Return/Tab", "select the highlighted option;  when a folder is highlighted it is opened in the lister");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Escape", "cancel the operation");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("There are also buffer listers for operations on buffers that are already open:"), (u64)(sizeof("There are also buffer listers for operations on buffers that are already open:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "I", "begin a buffer lister and switch to the selected buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "K", "begin a buffer lister and try to kill the selected buffer");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_4(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("The command lister makes all commands available in one place:"), (u64)(sizeof("The command lister makes all commands available in one place:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "X", "a lister of all commands");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Try some of these commands from the command lister:"), (u64)(sizeof("Try some of these commands from the command lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "toggle_filebar", "toggle the panel's filebar");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "toggle_line_numbers", "toggle the panel's line number");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "set_eol_mode_*", "change how a buffer prefers to fixup it's line endings");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "close_panel", "close the current panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "open_panel_vsplit", "create a vertical split in the current panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "open_panel_hsplit", "create a horizontal split in the current panel");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_5(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Fast navigation by jump lists:"), (u64)(sizeof("Fast navigation by jump lists:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "after the user answers a query for a string generate a jump list of matches");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "T", "extract an identifier from the text under cursor and generate a jump list of matches");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "I", "parse the current buffer as a C/C++ source and generate a jump list of functions");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("After generating a jump list it is bound as the active jump list enabling these commands:"), (u64)(sizeof("After generating a jump list it is bound as the active jump list enabling these commands:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "N", "jump to the next jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "N", "jump to the previous jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "M", "jump to the first jump");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_6(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Virtual whitespace:"), (u64)(sizeof("Virtual whitespace:") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tBuffers that are indexed with information about nest structures can be equiped with the virtual whitespace layout algorithm."), (u64)(sizeof("\tBuffers that are indexed with information about nest structures can be equiped with the virtual whitespace layout algorithm.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tThe on screen layout of text is independent of the actual whitespace contents of the underlying text."), (u64)(sizeof("\tThe on screen layout of text is independent of the actual whitespace contents of the underlying text.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_keyword),
                    SCu8((u8*)("\tTry inserting new scopes and parenthetical sections in a code file."), (u64)(sizeof("\tTry inserting new scopes and parenthetical sections in a code file.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\t\tObserve that indentation is updated automatically."), (u64)(sizeof("\t\tObserve that indentation is updated automatically.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_keyword),
                    SCu8((u8*)("\tTry creating a line that is long enough to wrap around the edge."), (u64)(sizeof("\tTry creating a line that is long enough to wrap around the edge.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\t\tObserve that wrapped lines obey the same indentation rules as literal lines."), (u64)(sizeof("\t\tObserve that wrapped lines obey the same indentation rules as literal lines.") - 1)));

    {
        Fancy_Line *line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
        push_fancy_stringf(arena, line, "\tUse the command ");
        push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "toggle_virtual_whitespace");
        push_fancy_stringf(arena, line, " to turn this feature on and off");
    }

    {
        Fancy_Line *line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
        push_fancy_stringf(arena, line, "\tUse the command ");
        push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "toggle_line_wrap");
        push_fancy_stringf(arena, line, " to see how layout changes with line wrapping on and off");
    }

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Auto Indentation:"), (u64)(sizeof("Auto Indentation:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Tab", "auto indent the lines marked by the range; the effect is only visible with virtual whitespace off.");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_7(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Builds, scripts, and projects:"), (u64)(sizeof("Builds, scripts, and projects:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "M", "searches for and runs a build script (windows -> 'build.bat'; unix -> 'build.sh')");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "execute_any_cli", "queries the user for a buffer name and a system command then runs the command and pipes output to the buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "execute_previous_cli", "repeats an execute_any_cli command with the same command and ouptut buffer");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("If a script/command generates output that can be parsed as jumps (e.g. compilation errors) then it becomes the active jump buffer:"), (u64)(sizeof("If a script/command generates output that can be parsed as jumps (e.g. compilation errors) then it becomes the active jump buffer:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "N", "jump to the next jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "N", "jump to the previous jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "M", "jump to the first jump");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("The project system enables rich bindings of arbitrary system scripts (when a project is loaded):"), (u64)(sizeof("The project system enables rich bindings of arbitrary system scripts (when a project is loaded):") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "F#", "run a script bound to the corresponding index in the loaded project");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "project_command_lister", "use a lister to examine all system commands encoded in the loaded project");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "load_project", "searches for and loads a 'project.4coder' file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "setup_new_project", "command to generate a new 'project.4coder' file and build scripts");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tCheckout 'project.4coder' to see more about what is in a project."), (u64)(sizeof("\tCheckout 'project.4coder' to see more about what is in a project.") - 1)));

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_8(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("Probably the biggest feature in 4coder is that so many things about it can be customized."), (u64)(sizeof("Probably the biggest feature in 4coder is that so many things about it can be customized.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("The project loaded for this demo is the 'default custom layer' everything here could be done differently, as you see fit."), (u64)(sizeof("The project loaded for this demo is the 'default custom layer' everything here could be done differently, as you see fit.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Search for these commands to see some of the features available to customization:"), (u64)(sizeof("Search for these commands to see some of the features available to customization:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "(hint!) this is the default binding for search, use it to find these functions");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "write_text_input", "the default implementation for text insertion");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "copy", "the default implementation copying to clipboard");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "goto_line", "jump to a line specified by the user (which you should try by the way!)");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "interactive_switch_buffer", "see how this command encodes it's use of a lister with the call 'get_buffer_from_user'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "project_command_lister", "again see how this command encodes a lister with a call, this time 'prj_cmd_from_user'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "setup_default_mapping", "defines the mapping of commands to bindings");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)("\tThe macros CUSTOM_COMMAND_SIG and CUSTOM_DOC markup the commands to create the list of all available commands."), (u64)(sizeof("\tThe macros CUSTOM_COMMAND_SIG and CUSTOM_DOC markup the commands to create the list of all available commands.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)("\tThis means that user written commands that use the same markup automatically appear in the command_lister along side built in commands!"), (u64)(sizeof("\tThis means that user written commands that use the same markup automatically appear in the command_lister along side built in commands!") - 1)));

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_9(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("The customization system exposes much more than just commands to be customized..."), (u64)(sizeof("The customization system exposes much more than just commands to be customized...") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "(hint!) this is the default binding for search, use it to find these functions");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write completely custom GUIs:"), (u64)(sizeof("Write completely custom GUIs:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "run_lister/lister_render", "the input handling loop for listers; and the render handler for listers");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "tutorial_run_loop/tutorial_render", "underlying implementation for the tutorial system powering this demo!");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom text coloring and highlighting in buffers:"), (u64)(sizeof("Write custom text coloring and highlighting in buffers:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "draw_cpp_token_colors", "syntax highlighting for C++ tokens.");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "draw_line_number_margin", "draws a line number margin");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "default_render_buffer", "puts together all the default markup in buffer rendering");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom line layout rules:"), (u64)(sizeof("Write custom line layout rules:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "layout_unwrapped_small_blank_lines", "a funky layout that makes blank lines half height");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "layout_index_unwrapped__inner", "the unwrapped version of the virtual whitespace layout logic");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom smoothing rules that interact with buffer and UI scrolling:"), (u64)(sizeof("Write custom smoothing rules that interact with buffer and UI scrolling:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "snap_delta", "a delta rule that snaps to the destination point instantly");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "fixed_time_cubic_delta", "the smooth scrolling enabled in this build");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_10(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Some miscellaneous things to try:"), (u64)(sizeof("Some miscellaneous things to try:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Tab", "in a code file this triggers the cyclic word complete, often a handy command");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "F/R", "forward/reverse iterative search");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "A", "replace all instances of a string in the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "0", "insert an assignment to an empty struct or array");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "0", "insert a #if 0 / #endif pair at the cursor and mark");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "2", "open the corresponding .h/.cpp file to the current buffer in the second panel");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_11(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("\t\tThanks for checking out the demo!"), (u64)(sizeof("\t\tThanks for checking out the demo!") - 1)));

    return(result);
}

CUSTOM_COMMAND(hms_demo_tutorial, "/home/tabletel/dev/4cc/code/custom/4coder_tutorial.cpp", 869, Normal)
CUSTOM_DOC("Tutorial for built in 4coder bindings and features.")
{
    static Tutorial_Slide_Function *slides[] = {

        hms_demo_tutorial_slide_1,

        hms_demo_tutorial_slide_2,

        hms_demo_tutorial_slide_3,

        hms_demo_tutorial_slide_4,

        hms_demo_tutorial_slide_5,

        hms_demo_tutorial_slide_6,

        hms_demo_tutorial_slide_7,

        hms_demo_tutorial_slide_8,

        hms_demo_tutorial_slide_9,

        hms_demo_tutorial_slide_10,

        hms_demo_tutorial_slide_11,
    };
    run_tutorial(app, slides, ((sizeof(slides))/(sizeof(*slides))));
}
# 138 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 73 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 26 "/usr/include/bits/timex.h" 3 4

# 26 "/usr/include/bits/timex.h" 3 4
struct timex
{
# 58 "/usr/include/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) noexcept (true) __attribute__ ((__nonnull__ (2)));
# 90 "/usr/include/bits/time.h" 3 4
}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) noexcept (true);



extern time_t time (time_t *__timer) noexcept (true);


extern double difftime (time_t __time1, time_t __time0)
     noexcept (true) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) noexcept (true);
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     noexcept (true);






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) noexcept (true);






extern struct tm *gmtime (const time_t *__timer) noexcept (true);



extern struct tm *localtime (const time_t *__timer) noexcept (true);
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) noexcept (true);



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) noexcept (true);
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) noexcept (true);



extern char *ctime (const time_t *__timer) noexcept (true);
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) noexcept (true);



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) noexcept (true);
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) noexcept (true);



extern int daylight;
extern long int timezone;
# 246 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) noexcept (true);
# 263 "/usr/include/time.h" 3 4
extern time_t timelocal (struct tm *__tp) noexcept (true);







extern int dysize (int __year) noexcept (true) __attribute__ ((__const__));
# 281 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) noexcept (true);


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 323 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 338 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) noexcept (true);




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) noexcept (true);


extern int timer_delete (timer_t __timerid) noexcept (true);



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) noexcept (true);


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     noexcept (true);
# 376 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) noexcept (true);






extern int timespec_get (struct timespec *__ts, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 399 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     noexcept (true);
# 425 "/usr/include/time.h" 3 4
extern int getdate_err;
# 434 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 448 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 13 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 2


# 14 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
static Doc_Date
doc_date_now(void){
    time_t t = time(0);
    tm *time = localtime(&t);
    Doc_Date date = {};
    date.day = time->tm_mday;
    date.month = time->tm_mon + 1;
    date.year = 1900 + time->tm_year;
    return(date);
             }



static Doc_Content*
doc_content_push(Arena *arena, Doc_Content_List *list, String_Const_u8 text, Doc_Content_Emphasis emphasis){
    Doc_Content *content = ((Doc_Content*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Content)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "29" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "29" ":") - 1)))));
    do{ if((content)){if((list->first)){(list->last)->next=(content);}else{(list->first)=(content);}(list->last)=(content);(list->last)->next=0;} }while(0);
    list->total_size += text.size;
    list->node_count += 1;
    content->text = text;
    content->emphasis = emphasis;
    return(content);
}

static Doc_Content*
doc_content_push(Arena *arena, Doc_Content_List *list, String_Const_u8 text){
    return(doc_content_push(arena, list, text, DocContentEmphasis_Normal));
}

static void
doc_code_list_push(Arena *arena, Doc_Code_Sample_List *list, String_Const_u8 contents, Doc_Code_Language language){
    Doc_Code_Sample *sample = ((Doc_Code_Sample*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Code_Sample)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "45" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "45" ":") - 1)))));
    do{ if((sample)){if((list->first)){(list->last)->next=(sample);}else{(list->first)=(sample);}(list->last)=(sample);(list->last)->next=0;} }while(0);
    list->count += 1;
    sample->contents = contents;
    sample->language = language;
}



static Doc_Cluster*
new_doc_cluster(Arena *arena, char *title, char *name, Doc_Date *date){
    Doc_Cluster *result = ((Doc_Cluster*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Cluster)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "56" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "56" ":") - 1)))));
    result->title = SCu8(title);
    result->name = SCu8(name);
    result->gen_date = *date;
    return(result);
}

static Doc_Cluster*
new_doc_cluster(Arena *arena, char *title, char *name){
    Doc_Date date = doc_date_now();
    return(new_doc_cluster(arena, title, name, &date));
}

static Doc_Page*
new_doc_page(Arena *arena, Doc_Cluster *cluster, char *title, char *name){
    Doc_Page *result = ((Doc_Page*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Page)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "71" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "71" ":") - 1)))));

    result->owner = cluster;
    do{ if((result)){if((cluster->first_page)){(cluster->last_page)->next=(result);}else{(cluster->first_page)=(result);}(cluster->last_page)=(result);(cluster->last_page)->next=0;} }while(0);
    cluster->page_count += 1;

    result->title = SCu8(title);
    result->name = SCu8(name);

    return(result);
}

static Doc_Page*
new_doc_page_normal_title(Arena *arena, Doc_Cluster *cluster, char *title, char *name){
    String_Const_u8 full_title = push_u8_stringf(arena, "%s - %.*s", title, (i32)(cluster->title).size, (char*)(cluster->title).str);
    return(new_doc_page(arena, cluster, (char*)full_title.str, name));
}

static Doc_Page*
new_doc_page_function(Arena *arena, Doc_Cluster *cluster, char *name){
    return(new_doc_page_normal_title(arena, cluster, name, name));
}

static Doc_Page*
new_doc_page_function(Arena *arena, Doc_Cluster *cluster, String_Const_u8 name){
    name = push_string_copy(arena, name);
    char *c_name = (char*)name.str;
    return(new_doc_page_function(arena, cluster, c_name));
}

 static Doc_Block*
new_doc_block(Arena *arena, Doc_Page *page, char *name){
    Doc_Block *result = ((Doc_Block*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Block)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "103" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "103" ":") - 1)))));
    result->owner = page;
    do{ if((result)){if((page->first_block)){(page->last_block)->next=(result);}else{(page->first_block)=(result);}(page->last_block)=(result);(page->last_block)->next=0;} }while(0);
    page->block_count += 1;
    result->name = SCu8(name);
    return(result);
}

static void
new_doc_block_jump(Arena *arena, Doc_Page *page, Doc_Block *block){
    Doc_Block_Ptr *node = ((Doc_Block_Ptr*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Block_Ptr)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "113" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "113" ":") - 1)))));
    do{ if((node)){if((page->quick_jumps.first)){(page->quick_jumps.last)->next=(node);}else{(page->quick_jumps.first)=(node);}(page->quick_jumps.last)=(node);(page->quick_jumps.last)->next=0;} }while(0);
    page->quick_jumps.count += 1;
    node->block = block;
}

static Doc_Paragraph*
new_doc_par(Arena *arena, Doc_Block *block){
    Doc_Paragraph *result = ((Doc_Paragraph*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Paragraph)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "121" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "121" ":") - 1)))));
    do{ if((result)){if((block->first_par)){(block->last_par)->next=(result);}else{(block->first_par)=(result);}(block->last_par)=(result);(block->last_par)->next=0;} }while(0);
    block->par_count += 1;
    return(result);
}

static void
new_doc_par_single_code(Arena *arena, Doc_Block *block, String_Const_u8 contents, Doc_Code_Language language){
    Doc_Paragraph *paragraph = new_doc_par(arena, block);
    paragraph->kind = DocParagraphKind_Code;
    doc_code_list_push(arena, &paragraph->code, contents, language);
}

static Doc_Paragraph*
new_doc_par_table(Arena *arena, Doc_Block *block){
    Doc_Paragraph *result = new_doc_par(arena, block);
    result->kind = DocParagraphKind_Table;
    return(result);
}



static void
doc_log(Arena *arena, Doc_Cluster *cluster, String_Const_u8 string){
    Doc_Log *log = ((Doc_Log*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Log)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "145" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" ":" "145" ":") - 1)))));
    do{ if((log)){if((cluster->first_log)){(cluster->last_log)->next=(log);}else{(cluster->first_log)=(log);}(cluster->last_log)=(log);(cluster->last_log)->next=0;} }while(0);
    log->content = string;
}

static void
doc_log(Arena *arena, Doc_Cluster *cluster, char *str){
    doc_log(arena, cluster, SCu8(str));
}

static void
doc_logfv(Arena *arena, Doc_Cluster *cluster, char *format, va_list args){
    String_Const_u8 str = push_u8_stringfv(arena, format, args);
    doc_log(arena, cluster, str);
}

static void
doc_logf(Arena *arena, Doc_Cluster *cluster, char *format, ...){
    va_list args;
    
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 3 4
   __builtin_va_start(
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
   args
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 3 4
   ,
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
   format
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 3 4
   )
# 164 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
                         ;
    doc_logfv(arena, cluster, format, args);
    
# 166 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 3 4
   __builtin_va_end(
# 166 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
   args
# 166 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp" 3 4
   )
# 166 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
               ;
}
# 179 "/home/tabletel/dev/4cc/code/custom/4coder_doc_content_types.cpp"
static Doc_Content*
doc_text(Arena *arena, Doc_Block *block, char *str){
    Doc_Paragraph *par = block->last_par;
    if (par != 0){
        if (par->kind != DocParagraphKind_Text){
            par = 0;
        }
    }

    if (par == 0){
        par = new_doc_par(arena, block);
        par->kind = DocParagraphKind_Text;
    }

    return(doc_content_push(arena, &par->text, SCu8(str)));
}

static Doc_Content*
doc_text(Arena *arena, Doc_Content_List *list, char *string){
    return(doc_content_push(arena, list, SCu8(string)));
}

static void
doc_paragraph(Arena *arena, Doc_Block *block){
    Doc_Paragraph *par = new_doc_par(arena, block);
    par->kind = DocParagraphKind_Text;
}



static Doc_Page*
doc_get_page(Doc_Cluster *cluster, String_Const_u8 name){
    Doc_Page *result = 0;
    for (Doc_Page *page = cluster->first_page;
         page != 0;
         page = page->next){
        if (string_match(name, page->name)){
            result = page;
            break;
        }
    }
    return(result);
}
# 139 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" 1
# 12 "/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp"
static Doc_Cluster*
doc_commands(Arena *arena){
    Doc_Cluster *cluster = new_doc_cluster(arena, "Commands", "commands");
    for (i32 i = 0; i < ((sizeof(fcoder_metacmd_table))/(sizeof(*fcoder_metacmd_table))); i += 1){
        String_Const_u8 cmd_name = SCu8(fcoder_metacmd_table[i].name,
                                        fcoder_metacmd_table[i].name_len);
        String_Const_u8 title = push_u8_stringf(arena, "Command %.*s", (i32)(cmd_name).size, (char*)(cmd_name).str);
        Doc_Page *page = new_doc_page(arena, cluster, (char*)title.str, (char*)cmd_name.str);
        Doc_Block *block = new_doc_block(arena, page, "brief");
        doc_text(arena, block, fcoder_metacmd_table[i].description);
    }
    return(cluster);
}

static Doc_Cluster*
doc_default_bindings(Arena *arena, i32 map_count, Mapping *mapping_array, char **page_titles, char **page_names,
                     i64 global_id, i64 file_id, i64 code_id){
    Doc_Cluster *cluster = new_doc_cluster(arena, "Bindings", "bindings");

    for (i32 i = 0; i < map_count; i += 1){
        Mapping *mapping = &mapping_array[i];
        Doc_Page *page = new_doc_page(arena, cluster, page_titles[i], page_names[i]);
        for (Command_Map *map = mapping->first_map;
             map != 0;
             map = map->next){
            char *map_name = "";
            if (map->id == global_id){
                map_name = "Global";
            }
            else if (map->id == file_id){
                map_name = "File";
            }
            else if (map->id == code_id){
                map_name = "Code";
            }

            Doc_Block *block = new_doc_block(arena, page, map_name);
            Doc_Paragraph *par = new_doc_par_table(arena, block);

            struct Bind_Node{
                Bind_Node *next;
                Input_Event_Kind kind;
                u32 sub_code;
                Input_Modifier_Set mods;
                Command_Binding binding;
                u32 j;
            };

            Bind_Node *first = 0;
            Bind_Node *last = 0;
            i32 node_count = 0;

            if (map->text_input_command.name != 0){
                Bind_Node *node = ((Bind_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Bind_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "65" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "65" ":") - 1)))));
                do{ if((node)){if((first)){(last)->next=(node);}else{(first)=(node);}(last)=(node);(last)->next=0;} }while(0);
                node_count += 1;
                node->binding = map->text_input_command;
                node->j = max_u32;
            }

            u32 counts[] = {
                KeyCode_COUNT,
                KeyCode_COUNT,
                MouseCode_COUNT,
                MouseCode_COUNT,
                1,
                1,
                CoreCode_COUNT,
            };

            u32 event_codes[] = {
                InputEventKind_KeyStroke,
                InputEventKind_KeyRelease,
                InputEventKind_MouseButton,
                InputEventKind_MouseButtonRelease,
                InputEventKind_MouseWheel,
                InputEventKind_MouseMove,
                InputEventKind_Core,
            };

            char *mouse_wheel_name[] = {"MoveWheel"};
            char *mouse_move_name[] = {"MoveMove"};

            char **event_names[] = {
                key_code_name,
                key_code_name,
                mouse_code_name,
                mouse_code_name,
                mouse_wheel_name,
                mouse_move_name,
                core_code_name,
            };

            b32 is_release[] = {
                false,
                true,
                false,
                true,
                false,
                false,
                false,
            };

            for (u32 j = 0; j < ((sizeof(counts))/(sizeof(*counts))); j += 1){
                for (u32 code = 0; code < counts[j]; code += 1){
                    u64 key = mapping__key(event_codes[j], code);
                    Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, key);
                    if (lookup.found_match){
                        u64 val = 0;
                        table_read(&map->event_code_to_binding_list, lookup, &val);
                        Command_Binding_List *list = (Command_Binding_List*)(void*)(((u8*)0) + val);
                        for (SNode *snode = list->first;
                             snode != 0;
                             snode = snode->next){
                            Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(snode) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );

                            Bind_Node *node = ((Bind_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Bind_Node)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "128" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "128" ":") - 1)))));
                            do{ if((node)){if((first)){(last)->next=(node);}else{(first)=(node);}(last)=(node);(last)->next=0;} }while(0);
                            node_count += 1;
                            node->kind = event_codes[j];
                            node->sub_code = code;
                            node->mods = mod_binding->mods;
                            node->binding = mod_binding->binding;
                            node->j = j;
                        }
                    }
                }
            }

            Vec2_i32 table_dims = V2i32(2, node_count);
            Doc_Content_List *vals = ((Doc_Content_List*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Content_List)*(table_dims.x*table_dims.y), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "142" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_doc_commands.cpp" ":" "142" ":") - 1)))));
            Bind_Node *bnode = first;
            for (i32 y = 0; y < table_dims.y; y += 1, bnode = bnode->next){
                Doc_Content_List *line = &vals[y*table_dims.x];
                doc_text(arena, &line[0], "[");
                if (bnode->j != max_u32){
                    doc_text(arena, &line[0], event_names[bnode->j][bnode->sub_code]);
                    if (is_release[bnode->j]){
                        doc_text(arena, &line[0], "Release");
                    }

                    Input_Modifier_Set *mods = &bnode->mods;
                    for (i32 k = 0; k < mods->count; k += 1){
                        doc_text(arena, &line[0], key_code_name[mods->mods[k]]);
                    }
                }
                else{
                    doc_text(arena, &line[0], "TextInput");
                }
                doc_text(arena, &line[0], "]");

                Doc_Content *content = doc_text(arena, &line[1], bnode->binding.name);
                content->page_link = SCu8(bnode->binding.name);
            }

            par->table.dim = table_dims;
            par->table.vals = vals;
        }
    }

    return(cluster);
}
# 140 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_docs.cpp" 1






static Doc_Page*
get_doc_page_from_user(Application_Links *app, Doc_Cluster *doc, String_Const_u8 query){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    for (Doc_Page *page = doc->first_page;
         page != 0;
         page = page->next){
        lister_add_item(lister, page->name, SCu8(""), page, 0);
    }
    Lister_Result l_result = run_lister(app, lister);
    Doc_Page *result = 0;
    if (!l_result.canceled){
        result = (Doc_Page*)l_result.user_data;
    }
    return(result);
}

static Doc_Page*
get_doc_page_from_user(Application_Links *app, Doc_Cluster *doc, char *query){
    return(get_doc_page_from_user(app, doc, SCu8(query)));
}

static void
render_doc_page__content(Application_Links *app, Buffer_Insertion *insert, Doc_Content_List *list){
    for (Doc_Content *content = list->first;
         content != 0;
         content = content->next){


        if (content->emphasis == DocContentEmphasis_SmallHeader){
            insertf(insert, "\n");
        }
        if (content->emphasis == DocContentEmphasis_Heavy){
            insertf(insert, "_");
        }
        if (content->emphasis == DocContentEmphasis_Stylish){
            insertf(insert, "*");
        }

        insertf(insert, "%.*s", (i32)(content->text).size, (char*)(content->text).str);
        if (content->page_link.size > 0){
            insertf(insert, " (link page %.*s)", (i32)(content->page_link).size, (char*)(content->page_link).str);
        }
        else if (content->block_link.size > 0){
            insertf(insert, " (link block %.*s)", (i32)(content->block_link).size, (char*)(content->block_link).str);
        }

        if (content->emphasis == DocContentEmphasis_Heavy){
            insertf(insert, "_");
        }
        if (content->emphasis == DocContentEmphasis_Stylish){
            insertf(insert, "*");
        }
        if (content->emphasis == DocContentEmphasis_SmallHeader){
            insertf(insert, "\n");
        }
        else{
            if (content->next != 0){
                insertf(insert, " ");
            }
        }
    }
}

static void
render_doc_page__code(Application_Links *app, Buffer_Insertion *insert, Doc_Code_Sample_List *code){
    for (Doc_Code_Sample *sample = code->first;
         sample != 0;
         sample = sample->next){
        insertf(insert, "language: ");
        switch (sample->language){
            case DocCodeLanguage_Cpp:
            {
                insertf(insert, "C++\n");
            }break;
            case DocCodeLanguage_Bat:
            {
                insertf(insert, "Batch\n\n");
            }break;
        }
        insertf(insert, "\n%.*s\n", (i32)(sample->contents).size, (char*)(sample->contents).str);
    }
}

static void
render_doc_page__table(Application_Links *app, Buffer_Insertion *insert, Vec2_i32 dim, Doc_Content_List *vals){

    Doc_Content_List *val = vals;
    for (i32 y = 0; y < dim.y; y += 1){
        for (i32 x = 0; x < dim.x; x += 1){
            render_doc_page__content(app, insert, val);
            insertf(insert, "; ");
            val += 1;
        }
        insertf(insert, "\n");
    }
}

static Buffer_ID
render_doc_page(Application_Links *app, Doc_Page *page){
    Scratch_Block scratch(app);

    String_Const_u8 doc_buffer_name = push_u8_stringf(scratch, "*doc: %.*s*",
                                                      (i32)(page->name).size, (char*)(page->name).str);

    Buffer_Create_Flag flags = BufferCreate_NeverAttachToFile;
    Buffer_ID buffer = create_buffer(app, doc_buffer_name, flags);
    if (buffer != 0){
        buffer_set_setting(app, buffer, BufferSetting_RecordsHistory, false);
        buffer_set_setting(app, buffer, BufferSetting_ReadOnly, true);
        buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);

        i64 size = buffer_get_size(app, buffer);
        if (size != 0){
            buffer_replace_range(app, buffer, Ii64(0, size), SCu8(""));
        }
        Buffer_Insertion insert = begin_buffer_insertion_at_buffered(app, buffer, 0, scratch, ((16) << 10));

        char dashes[] =
            "----------------------------------------------------------------"
            "----------------------------------------------------------------"
            "----------------------------------------------------------------"
            "----------------------------------------------------------------";

        insertf(&insert, "%.*s\n%.*s\n",
                (i32)(page->title).size, (char*)(page->title).str,
                page->title.size, dashes);

        for (Doc_Block *block = page->first_block;
             block != 0;
             block = block->next){
            insertf(&insert, "%.*s\n\n", (i32)(block->name).size, (char*)(block->name).str);

            for (Doc_Paragraph *par = block->first_par;
                 par != 0;
                 par = par->next){
                switch (par->kind){
                    case DocParagraphKind_Text:
                    {
                        render_doc_page__content(app, &insert, &par->text);
                    }break;

                    case DocParagraphKind_Code:
                    {
                        render_doc_page__code(app, &insert, &par->code);
                    }break;

                    case DocParagraphKind_Table:
                    {
                        render_doc_page__table(app, &insert, par->table.dim, par->table.vals);
                    }break;
                }

                insert_string(&insert, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
            }

            insertf(&insert, "%.*s\n", page->title.size, dashes);
        }

        end_buffer_insertion(&insert);
    }

    return(buffer);
}

CUSTOM_COMMAND(custom_api_documentation, "/home/tabletel/dev/4cc/code/custom/4coder_docs.cpp", 175, UI)
CUSTOM_DOC("Prompts the user to select a Custom API item then loads a doc buffer for that item")
{
    View_ID view = get_this_ctx_view(app, Access_ReadWrite);
    if (view != 0){
        Scratch_Block scratch(app);
        Doc_Cluster *docs = get_custom_layer_boundary_docs(app, scratch);
        Doc_Page *page = get_doc_page_from_user(app, docs, "Doc Page:");
  if (page != 0){
            Buffer_ID buffer = render_doc_page(app, page);
            view_set_buffer(app, view, buffer, 0);
        }
    }
}

CUSTOM_COMMAND(command_documentation, "/home/tabletel/dev/4cc/code/custom/4coder_docs.cpp", 190, UI)
CUSTOM_DOC("Prompts the user to select a command then loads a doc buffer for that item")
{
    View_ID view = get_this_ctx_view(app, Access_Always);
    if (view != 0){
        Scratch_Block scratch(app);
        Doc_Cluster *docs = doc_commands(scratch);
        Doc_Page *page = get_doc_page_from_user(app, docs, "Doc Page:");
        if (page != 0){
            Buffer_ID buffer = render_doc_page(app, page);
            view_set_buffer(app, view, buffer, 0);
        }
    }
}
# 141 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp"
static Arena vars_arena = {};
static Table_Data_u64 vars_string_to_id = {};
static Table_u64_Data vars_id_to_string = {};
static String_ID vars_string_id_counter = 0;

static void
_vars_init(void){
    static b32 did_init = false;
    if (!did_init){
        did_init = true;
        Base_Allocator *base = get_base_allocator_system();
        vars_arena = make_arena(base);
        vars_string_to_id = make_table_Data_u64__inner((base),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "22" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "22" ":") - 1)));
        vars_id_to_string = make_table_u64_Data__inner((base),(100),SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "23" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "23" ":") - 1)));
    }
}

static String_ID
vars_save_string(String_Const_u8 string){
    _vars_init();

    String_ID result = 0;
    String_Const_u8 string_data = make_data(string.str, string.size);
    Table_Lookup location = table_lookup(&vars_string_to_id, string_data);
    if (location.found_match){
        table_read(&vars_string_to_id, location, &result);
    }
    else{
        vars_string_id_counter += 1;
        result = vars_string_id_counter;
        string_data = push_data_copy(&vars_arena, string_data);
        table_insert(&vars_string_to_id, string_data, result);
        table_insert(&vars_id_to_string, result, string_data);
    }
    return(result);
}

static String_Const_u8
vars_read_string(Arena *arena, String_ID id){
    _vars_init();

    String_Const_u8 result = {};
    Table_Lookup location = table_lookup(&vars_id_to_string, id);
    if (location.found_match){
        String_Const_u8 data = {};
        table_read(&vars_id_to_string, location, &data);
        result.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(data.size), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "56" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "56" ":") - 1)))));
        block_copy(result.str, data.str, data.size);
        result.size = data.size;
    }
    return(result);
}




static Variable vars_global_root = {};
static Variable vars_nil = {};
static Variable *vars_free_variables = 0;

static Variable_Handle
vars_get_root(void){
    Variable_Handle handle = {&vars_global_root};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        Variable *nil = vars_get_nil().ptr;
        vars_global_root.parent = nil;
        vars_global_root.next = nil;
        vars_global_root.first = nil;
        vars_global_root.last = nil;
    }
    return(handle);
}

static Variable_Handle
vars_get_nil(void){
    Variable_Handle handle = {&vars_nil};
    if (vars_nil.parent == 0){
        vars_nil.parent = &vars_nil;
        vars_nil.next = &vars_nil;
        vars_nil.first = &vars_nil;
        vars_nil.last = &vars_nil;
    }
    return(handle);
}

static b32
vars_is_nil(Variable_Handle var){
    return(var.ptr == &vars_nil);
}

static b32
vars_is_nil(Variable* ptr) {
 return(ptr == &vars_nil);
}

static b32
vars_match(Variable_Handle a, Variable_Handle b){
    return(a.ptr == b.ptr);
}

static Variable_Handle
vars_first_child(Variable_Handle var){
    Variable_Handle result = {var.ptr->first};
    return(result);
}

static Variable_Handle
vars_next_sibling(Variable_Handle var){
    Variable_Handle result = {var.ptr->next};
    return(result);
}

static Variable_Handle
vars_parent(Variable_Handle var){
    Variable_Handle result = {var.ptr->parent};
    return(result);
}

static String_ID
vars_key_id_from_var(Variable_Handle var){
    return(var.ptr->key);
}

static String_Const_u8
vars_key_from_var(Arena *arena, Variable_Handle var){
    String_ID id = vars_key_id_from_var(var);
    String_Const_u8 result = vars_read_string(arena, id);
    return(result);
}

static String_ID
vars_string_id_from_var(Variable_Handle var){
    return(var.ptr->string);
}

static String_Const_u8
vars_string_from_var(Arena *arena, Variable_Handle var){
    String_ID id = vars_string_id_from_var(var);
    String_Const_u8 result = vars_read_string(arena, id);
    return(result);
}

static b32
vars_b32_from_var(Variable_Handle var){
    String_ID val = vars_string_id_from_var(var);
    b32 result = (val != 0 && val != vars_save_string(SCu8((u8*)("false"), (u64)(sizeof("false") - 1))));
    return(result);
}

static u64
vars_u64_from_var(Application_Links *app, Variable_Handle var){
    Scratch_Block scratch(app);
    String_ID val = vars_string_id_from_var(var);
    String_Const_u8 string = vars_read_string(scratch, val);
    u64 result = 0;
    if (string_match(string_prefix(string, 2), {(u8*)("0x"), sizeof("0x") - 1})){
        String_Const_u8 string_hex = string_skip(string, 2);
        if (string_is_integer(string_hex, 0x10)){
            result = string_to_integer(string_hex, 0x10);
        }
    }
    else{
        if (string_is_integer(string, 10)){
            result = string_to_integer(string, 10);
        }
    }
    return(result);
}

static Variable_Handle
vars_read_key(Variable_Handle var, String_ID key){
    Variable_Handle result = vars_get_nil();
    for (Variable *node = var.ptr->first;
         !vars_is_nil(node);
         node = node->next){
        if (node->key == key){
            result.ptr = node;
            break;
        }
    }
    return(result);
}

static Variable_Handle
vars_read_key(Variable_Handle var, String_Const_u8 key){
    String_ID id = vars_save_string(key);
    Variable_Handle result = vars_read_key(var, id);
    return(result);
}

static void
vars_set_string(Variable_Handle var, String_ID string){
    if (var.ptr != &vars_nil){
        var.ptr->string = string;
    }
}

static void
vars_set_string(Variable_Handle var, String_Const_u8 string){
    String_ID id = vars_save_string(string);
    vars_set_string(var, id);
}

static void
_vars_free_variable_children(Variable *var){
    for (Variable *node = var->first;
         !vars_is_nil(node);
         node = node->next){
        _vars_free_variable_children(node);
    }

    if (!vars_is_nil(var->first)){
        var->last->next = vars_free_variables;
        vars_free_variables = var->first;
    }
}

static void
vars_erase(Variable_Handle var, String_ID key){
    if (var.ptr != &vars_nil){
        Variable *prev = vars_get_nil().ptr;
        Variable *node = var.ptr->first;
        for (; vars_is_nil(node);
             node = node->next){
            if (node->key == key){
                break;
            }
            prev = node;
        }

        if (!vars_is_nil(node)){
            _vars_free_variable_children(node);
            if (!vars_is_nil(prev)){
                prev->next = node->next;
            }
            if (var.ptr->first == node){
                var.ptr->first = node->next;
            }
            if (var.ptr->last == node){
                var.ptr->last = prev;
            }
            ((node)->next=(vars_free_variables),(vars_free_variables)=(node));
        }
    }
}

static Variable_Handle
vars_new_variable(Variable_Handle var, String_ID key){
    Variable_Handle handle = vars_get_nil();
    if (var.ptr != &vars_nil){
        Variable *prev = vars_get_nil().ptr;
        Variable *node = var.ptr->first;
        for (; !vars_is_nil(node);
             node = node->next){
            if (node->key == key){
                break;
            }
            prev = node;
        }

        if (!vars_is_nil(node)){
            handle.ptr = node;
            _vars_free_variable_children(node);
        }
        else{
            handle.ptr = vars_free_variables;
            if (handle.ptr != 0){
                ((vars_free_variables)=(vars_free_variables)=(vars_free_variables)->next);
            }
            else{
                handle.ptr = ((Variable*)linalloc_wrap_unintialized(linalloc_push((&vars_arena), sizeof(Variable)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "282" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_variables.cpp" ":" "282" ":") - 1)))));
            }
   if (vars_is_nil(var.ptr->first)){
    var.ptr->first = var.ptr->last = handle.ptr;
            }
   else{
    var.ptr->last->next = handle.ptr;
    var.ptr->last = handle.ptr;
   }
            handle.ptr->parent = var.ptr;
   handle.ptr->next = vars_get_nil().ptr;
            handle.ptr->key = key;
        }

        handle.ptr->string = 0;
        handle.ptr->first = handle.ptr->last = vars_get_nil().ptr;
    }
    return(handle);
}

static Variable_Handle
vars_new_variable(Variable_Handle var, String_ID key, String_ID string){
    Variable_Handle result = vars_new_variable(var, key);
    vars_set_string(result, string);
    return(result);
}

static void
vars_clear_keys(Variable_Handle var){
    if (var.ptr != &vars_nil){
        _vars_free_variable_children(var.ptr);
    }
}

static void
vars_print_indented(Application_Links *app, Variable_Handle var, i32 indent){
    Scratch_Block scratch(app);
    static char spaces[] =
        "                                                                "
        "                                                                "
        "                                                                "
        "                                                                ";

    String_Const_u8 var_key = vars_key_from_var(scratch, var);
    String_Const_u8 var_val = vars_string_from_var(scratch, var);

    String_Const_u8 line = push_stringf(scratch, "%.*s%.*s: \"%.*s\"\n",
                                        (((indent)<(sizeof(spaces)))?(indent):(sizeof(spaces))), spaces,
                                        (i32)(var_key).size, (char*)(var_key).str,
                                        (i32)(var_val).size, (char*)(var_val).str);
    print_message(app, line);

    i32 sub_indent = indent + 1;
    for (Variable_Handle sub = vars_first_child(var);
         !vars_is_nil(sub);
         sub = vars_next_sibling(sub)){
        vars_print_indented(app, sub, sub_indent);
    }
}

static void
vars_print(Application_Links *app, Variable_Handle var){
    vars_print_indented(app, var, 0);
}
# 142 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_audio.cpp" 1





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 1 3 4
# 27 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("general-regs-only")



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/ia32intrin.h" 1 3 4
# 29 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/ia32intrin.h" 3 4

# 29 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/ia32intrin.h" 3 4
extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bsfd (int __X)
{
  return __builtin_ctz (__X);
}


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bsrd (int __X)
{
  return __builtin_ia32_bsrsi (__X);
}


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bswapd (int __X)
{
  return __builtin_bswap32 (__X);
}




#pragma GCC push_options
#pragma GCC target("crc32")




extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__crc32b (unsigned int __C, unsigned char __V)
{
  return __builtin_ia32_crc32qi (__C, __V);
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__crc32w (unsigned int __C, unsigned short __V)
{
  return __builtin_ia32_crc32hi (__C, __V);
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__crc32d (unsigned int __C, unsigned int __V)
{
  return __builtin_ia32_crc32si (__C, __V);
}



#pragma GCC pop_options





extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__popcntd (unsigned int __X)
{
  return __builtin_popcount (__X);
}




extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdpmc (int __S)
{
  return __builtin_ia32_rdpmc (__S);
}




extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
}




extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtscp (unsigned int *__A)
{
  return __builtin_ia32_rdtscp (__A);
}




extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rolb (unsigned char __X, int __C)
{
  return __builtin_ia32_rolqi (__X, __C);
}


extern __inline unsigned short
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rolw (unsigned short __X, int __C)
{
  return __builtin_ia32_rolhi (__X, __C);
}


extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rold (unsigned int __X, int __C)
{
  __C &= 31;
  return (__X << __C) | (__X >> (-__C & 31));
}


extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rorb (unsigned char __X, int __C)
{
  return __builtin_ia32_rorqi (__X, __C);
}


extern __inline unsigned short
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rorw (unsigned short __X, int __C)
{
  return __builtin_ia32_rorhi (__X, __C);
}


extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rord (unsigned int __X, int __C)
{
  __C &= 31;
  return (__X >> __C) | (__X << (-__C & 31));
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__pause (void)
{
  __builtin_ia32_pause ();
}



extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bsfq (long long __X)
{
  return __builtin_ctzll (__X);
}


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bsrq (long long __X)
{
  return __builtin_ia32_bsrdi (__X);
}


extern __inline long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bswapq (long long __X)
{
  return __builtin_bswap64 (__X);
}


#pragma GCC push_options
#pragma GCC target("crc32")




extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__crc32q (unsigned long long __C, unsigned long long __V)
{
  return __builtin_ia32_crc32di (__C, __V);
}



#pragma GCC pop_options



extern __inline long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__popcntq (unsigned long long __X)
{
  return __builtin_popcountll (__X);
}


extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rolq (unsigned long long __X, int __C)
{
  __C &= 63;
  return (__X << __C) | (__X >> (-__C & 63));
}


extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rorq (unsigned long long __X, int __C)
{
  __C &= 63;
  return (__X >> __C) | (__X << (-__C & 63));
}


extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__readeflags (void)
{
  return __builtin_ia32_readeflags_u64 ();
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__writeeflags (unsigned long long __X)
{
  __builtin_ia32_writeeflags_u64 (__X);
}
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 424 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 435 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 38 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/adxintrin.h" 1 3 4
# 31 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/adxintrin.h" 3 4
extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_subborrow_u32 (unsigned char __CF, unsigned int __X,
  unsigned int __Y, unsigned int *__P)
{
  return __builtin_ia32_sbb_u32 (__CF, __X, __Y, __P);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_addcarry_u32 (unsigned char __CF, unsigned int __X,
        unsigned int __Y, unsigned int *__P)
{
  return __builtin_ia32_addcarryx_u32 (__CF, __X, __Y, __P);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_addcarryx_u32 (unsigned char __CF, unsigned int __X,
  unsigned int __Y, unsigned int *__P)
{
  return __builtin_ia32_addcarryx_u32 (__CF, __X, __Y, __P);
}


extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_subborrow_u64 (unsigned char __CF, unsigned long long __X,
  unsigned long long __Y, unsigned long long *__P)
{
  return __builtin_ia32_sbb_u64 (__CF, __X, __Y, __P);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_addcarry_u64 (unsigned char __CF, unsigned long long __X,
        unsigned long long __Y, unsigned long long *__P)
{
  return __builtin_ia32_addcarryx_u64 (__CF, __X, __Y, __P);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_addcarryx_u64 (unsigned char __CF, unsigned long long __X,
  unsigned long long __Y, unsigned long long *__P)
{
  return __builtin_ia32_addcarryx_u64 (__CF, __X, __Y, __P);
}
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/bmiintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/bmiintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("bmi")



extern __inline unsigned short __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__tzcnt_u16 (unsigned short __X)
{
  return __builtin_ia32_tzcnt_u16 (__X);
}

extern __inline unsigned short __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tzcnt_u16 (unsigned short __X)
{
  return __builtin_ia32_tzcnt_u16 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__andn_u32 (unsigned int __X, unsigned int __Y)
{
  return ~__X & __Y;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_andn_u32 (unsigned int __X, unsigned int __Y)
{
  return __andn_u32 (__X, __Y);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bextr_u32 (unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bextr_u32 (__X, __Y);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_bextr_u32 (unsigned int __X, unsigned int __Y, unsigned __Z)
{
  return __builtin_ia32_bextr_u32 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsi_u32 (unsigned int __X)
{
  return __X & -__X;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsi_u32 (unsigned int __X)
{
  return __blsi_u32 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsmsk_u32 (unsigned int __X)
{
  return __X ^ (__X - 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsmsk_u32 (unsigned int __X)
{
  return __blsmsk_u32 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsr_u32 (unsigned int __X)
{
  return __X & (__X - 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsr_u32 (unsigned int __X)
{
  return __blsr_u32 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__tzcnt_u32 (unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tzcnt_u32 (unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32 (__X);
}



extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return ~__X & __Y;
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return __andn_u64 (__X, __Y);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__bextr_u64 (unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bextr_u64 (__X, __Y);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_bextr_u64 (unsigned long long __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u64 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsi_u64 (unsigned long long __X)
{
  return __X & -__X;
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsi_u64 (unsigned long long __X)
{
  return __blsi_u64 (__X);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsmsk_u64 (unsigned long long __X)
{
  return __X ^ (__X - 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsmsk_u64 (unsigned long long __X)
{
  return __blsmsk_u64 (__X);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsr_u64 (unsigned long long __X)
{
  return __X & (__X - 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_blsr_u64 (unsigned long long __X)
{
  return __blsr_u64 (__X);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__tzcnt_u64 (unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64 (__X);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tzcnt_u64 (unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64 (__X);
}





#pragma GCC pop_options
# 42 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/bmi2intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/bmi2intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("bmi2")



extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_bzhi_u32 (unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bzhi_si (__X, __Y);
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_pdep_u32 (unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pdep_si (__X, __Y);
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_pext_u32 (unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pext_si (__X, __Y);
}



extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_bzhi_u64 (unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bzhi_di (__X, __Y);
}

extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_pdep_u64 (unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pdep_di (__X, __Y);
}

extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_pext_u64 (unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pext_di (__X, __Y);
}

extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mulx_u64 (unsigned long long __X, unsigned long long __Y,
    unsigned long long *__P)
{
  unsigned __int128 __res = (unsigned __int128) __X * __Y;
  *__P = (unsigned long long) (__res >> 64);
  return (unsigned long long) __res;
}
# 106 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/bmi2intrin.h" 3 4
#pragma GCC pop_options
# 44 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/cetintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/cetintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target ("shstk")




extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_get_ssp (void)
{
  return __builtin_ia32_rdsspq ();
}
# 53 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/cetintrin.h" 3 4
extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_inc_ssp (unsigned int __B)
{

  __builtin_ia32_incsspq ((unsigned long long) __B);



}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_saveprevssp (void)
{
  __builtin_ia32_saveprevssp ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rstorssp (void *__B)
{
  __builtin_ia32_rstorssp (__B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wrssd (unsigned int __B, void *__C)
{
  __builtin_ia32_wrssd (__B, __C);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wrssq (unsigned long long __B, void *__C)
{
  __builtin_ia32_wrssq (__B, __C);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wrussd (unsigned int __B, void *__C)
{
  __builtin_ia32_wrussd (__B, __C);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wrussq (unsigned long long __B, void *__C)
{
  __builtin_ia32_wrussq (__B, __C);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_setssbsy (void)
{
  __builtin_ia32_setssbsy ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_clrssbsy (void *__B)
{
  __builtin_ia32_clrssbsy (__B);
}



#pragma GCC pop_options
# 46 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/cldemoteintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/cldemoteintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("cldemote")


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_cldemote (void *__A)
{
  __builtin_ia32_cldemote (__A);
}


#pragma GCC pop_options
# 48 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clflushoptintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clflushoptintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("clflushopt")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflushopt (void *__A)
{
  __builtin_ia32_clflushopt (__A);
}



#pragma GCC pop_options
# 50 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clwbintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clwbintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("clwb")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clwb (void *__A)
{
  __builtin_ia32_clwb (__A);
}



#pragma GCC pop_options
# 52 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clzerointrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/clzerointrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("clzero")



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clzero (void * __I)
{
  __builtin_ia32_clzero (__I);
}



#pragma GCC pop_options
# 54 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/enqcmdintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/enqcmdintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target ("enqcmd")



extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_enqcmd (void * __P, const void * __Q)
{
  return __builtin_ia32_enqcmd (__P, __Q);
}

extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_enqcmds (void * __P, const void * __Q)
{
  return __builtin_ia32_enqcmds (__P, __Q);
}



#pragma GCC pop_options
# 56 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/fxsrintrin.h" 1 3 4
# 37 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/fxsrintrin.h" 3 4
extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_fxsave (void *__P)
{
  __builtin_ia32_fxsave (__P);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_fxrstor (void *__P)
{
  __builtin_ia32_fxrstor (__P);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_fxsave64 (void *__P)
{
  __builtin_ia32_fxsave64 (__P);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_fxrstor64 (void *__P)
{
  __builtin_ia32_fxrstor64 (__P);
}
# 58 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/lzcntintrin.h" 1 3 4
# 33 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/lzcntintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("lzcnt")



extern __inline unsigned short __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__lzcnt16 (unsigned short __X)
{
  return __builtin_ia32_lzcnt_u16 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__lzcnt32 (unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32 (__X);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_lzcnt_u32 (unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32 (__X);
}


extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__lzcnt64 (unsigned long long __X)
{
  return __builtin_ia32_lzcnt_u64 (__X);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_lzcnt_u64 (unsigned long long __X)
{
  return __builtin_ia32_lzcnt_u64 (__X);
}




#pragma GCC pop_options
# 60 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/lwpintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/lwpintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("lwp")



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__llwpcb (void *__pcbAddress)
{
  __builtin_ia32_llwpcb (__pcbAddress);
}

extern __inline void * __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__slwpcb (void)
{
  return __builtin_ia32_slwpcb ();
}
# 104 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/lwpintrin.h" 3 4
#pragma GCC pop_options
# 62 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/movdirintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/movdirintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target ("movdiri")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_directstoreu_u32 (void * __P, unsigned int __A)
{
  __builtin_ia32_directstoreu_u32 ((unsigned int *)__P, __A);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_directstoreu_u64 (void * __P, unsigned long long __A)
{
  __builtin_ia32_directstoreu_u64 ((unsigned long long *)__P, __A);
}




#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target ("movdir64b")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_movdir64b (void * __P, const void * __Q)
{
  __builtin_ia32_movdir64b (__P, __Q);
}



#pragma GCC pop_options
# 64 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mwaitintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mwaitintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("mwait")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_monitor (void const * __P, unsigned int __E, unsigned int __H)
{
  __builtin_ia32_monitor (__P, __E, __H);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mwait (unsigned int __E, unsigned int __H)
{
  __builtin_ia32_mwait (__E, __H);
}



#pragma GCC pop_options
# 66 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mwaitxintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mwaitxintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("mwaitx")



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_monitorx (void const * __P, unsigned int __E, unsigned int __H)
{
  __builtin_ia32_monitorx (__P, __E, __H);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mwaitx (unsigned int __E, unsigned int __H, unsigned int __C)
{
  __builtin_ia32_mwaitx (__E, __H, __C);
}



#pragma GCC pop_options
# 68 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pconfigintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pconfigintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("pconfig")
# 49 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pconfigintrin.h" 3 4
extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_pconfig_u32 (const unsigned int __L, size_t __D[])
{
  enum __pconfig_type
  {
    __PCONFIG_KEY_PROGRAM = 0x01,
  };

  unsigned int __R = 0;

  if (!__builtin_constant_p (__L))
    __asm__ __volatile__ ("pconfig\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
  else switch (__L)
    {
    case __PCONFIG_KEY_PROGRAM:
      __asm__ __volatile__ ("pconfig\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]) : "cc");
      break;
    default:
      __asm__ __volatile__ ("pconfig\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
    }
  return __R;
}



#pragma GCC pop_options
# 70 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/popcntintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/popcntintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("popcnt")




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_u32 (unsigned int __X)
{
  return __builtin_popcount (__X);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_u64 (unsigned long long __X)
{
  return __builtin_popcountll (__X);
}




#pragma GCC pop_options
# 72 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pkuintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pkuintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("pku")



extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdpkru_u32 (void)
{
  return __builtin_ia32_rdpkru ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wrpkru (unsigned int __key)
{
  __builtin_ia32_wrpkru (__key);
}



#pragma GCC pop_options
# 74 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rdseedintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rdseedintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("rdseed")




extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdseed16_step (unsigned short *__p)
{
  return __builtin_ia32_rdseed_hi_step (__p);
}

extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdseed32_step (unsigned int *__p)
{
  return __builtin_ia32_rdseed_si_step (__p);
}


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdseed64_step (unsigned long long *__p)
{
  return __builtin_ia32_rdseed_di_step (__p);
}




#pragma GCC pop_options
# 76 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rtmintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rtmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("rtm")
# 48 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rtmintrin.h" 3 4
extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xbegin (void)
{
  return __builtin_ia32_xbegin ();
}





extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xend (void)
{
  __builtin_ia32_xend ();
}
# 81 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rtmintrin.h" 3 4
#pragma GCC pop_options
# 78 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/serializeintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/serializeintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("serialize")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_serialize (void)
{
  __builtin_ia32_serialize ();
}



#pragma GCC pop_options
# 80 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/sgxintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/sgxintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("sgx")
# 110 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/sgxintrin.h" 3 4
extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_encls_u32 (const unsigned int __L, size_t __D[])
{
  enum __encls_type
  {
    __SGX_ECREATE = 0x00,
    __SGX_EADD = 0x01,
    __SGX_EINIT = 0x02,
    __SGX_EREMOVE = 0x03,
    __SGX_EDBGRD = 0x04,
    __SGX_EDBGWR = 0x05,
    __SGX_EEXTEND = 0x06,
    __SGX_ELDB = 0x07,
    __SGX_ELDU = 0x08,
    __SGX_EBLOCK = 0x09,
    __SGX_EPA = 0x0A,
    __SGX_EWB = 0x0B,
    __SGX_ETRACK = 0x0C,
    __SGX_EAUG = 0x0D,
    __SGX_EMODPR = 0x0E,
    __SGX_EMODT = 0x0F,
    __SGX_ERDINFO = 0x10,
    __SGX_ETRACKC = 0x11,
    __SGX_ELDBC = 0x12,
    __SGX_ELDUC = 0x13
  };
  enum __encls_type __T = (enum __encls_type)__L;
  unsigned int __R = 0;
  if (!__builtin_constant_p (__T))
    __asm__ __volatile__("encls\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
  else switch (__T)
    {
    case __SGX_ECREATE:
    case __SGX_EADD:
    case __SGX_EDBGWR:
    case __SGX_EEXTEND:
    case __SGX_EPA:
    case __SGX_EMODPR:
    case __SGX_EMODT:
    case __SGX_EAUG:
    case __SGX_ERDINFO:
      __asm__ __volatile__ ("encls\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]), "c" (__D[1]) : "cc");
      break;
    case __SGX_EINIT:
    case __SGX_ELDB:
    case __SGX_ELDU:
    case __SGX_EWB:
    case __SGX_ELDBC:
    case __SGX_ELDUC:
      __asm__ __volatile__("encls\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
      break;
    case __SGX_EREMOVE:
    case __SGX_EBLOCK:
    case __SGX_ETRACK:
    case __SGX_ETRACKC:
      __asm__ __volatile__("encls\n\t" : "=a" (__R) : "a" (__L), "c" (__D[1]) : "cc");
      break;
    case __SGX_EDBGRD:
      __asm__ __volatile__("encls\n\t" : "=a" (__R), "=b" (__D[0]) : "a" (__L), "c" (__D[1]));
      break;
    default:
      __asm__ __volatile__("encls\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
    }
  return __R;
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_enclu_u32 (const unsigned int __L, size_t __D[])
{
  enum __enclu_type
  {
    __SGX_EREPORT = 0x00,
    __SGX_EGETKEY = 0x01,
    __SGX_EENTER = 0x02,
    __SGX_ERESUME = 0x03,
    __SGX_EEXIT = 0x04,
    __SGX_EACCEPT = 0x05,
    __SGX_EMODPE = 0x06,
    __SGX_EACCEPTCOPY = 0x07
  };
  enum __enclu_type __T = (enum __enclu_type) __L;
  unsigned int __R = 0;
  if (!__builtin_constant_p (__T))
    __asm__ __volatile__("enclu\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
  else switch (__T)
    {
    case __SGX_EREPORT:
    case __SGX_EACCEPTCOPY:
      __asm__ __volatile__("enclu\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
      break;
    case __SGX_EGETKEY:
    case __SGX_ERESUME:
    case __SGX_EACCEPT:
    case __SGX_EMODPE:
      __asm__ __volatile__("enclu\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]), "c" (__D[1]) : "cc");
      break;
    case __SGX_EENTER:
      __asm__ __volatile__("enclu\n\t" : "=a" (__R), "=c" (__D[1]) : "a" (__L), "b" (__D[0]), "c" (__D[1]) : "cc");
      break;
    case __SGX_EEXIT:
      __asm__ __volatile__("enclu\n\t" : "=a" (__R), "=c" (__D[1]) : "a" (__L), "b" (__D[0]) : "cc");
      break;
    default:
      __asm__ __volatile__("enclu\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[1]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
    }
  return __R;
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_enclv_u32 (const unsigned int __L, size_t __D[])
{
  enum __enclv_type
  {
    __SGX_EDECVIRTCHILD = 0x00,
    __SGX_EINCVIRTCHILD = 0x01,
    __SGX_ESETCONTEXT = 0x02
  };
  unsigned int __R = 0;
  if (!__builtin_constant_p (__L))
    __asm__ __volatile__("enclv\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[0]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
  else switch (__L)
    {
    case __SGX_EDECVIRTCHILD:
    case __SGX_EINCVIRTCHILD:
      __asm__ __volatile__("enclv\n\t" : "=a" (__R) : "a" (__L), "b" (__D[0]), "c" (__D[1]) : "cc");
      break;
    case __SGX_ESETCONTEXT:
      __asm__ __volatile__("enclv\n\t" : "=a" (__R) : "a" (__L), "c" (__D[1]), "d" (__D[2]) : "cc");
      break;
    default:
      __asm__ __volatile__("enclv\n\t" : "=a" (__R), "=b" (__D[0]), "=c" (__D[0]), "=d" (__D[2]) : "a" (__L), "b" (__D[0]), "c" (__D[1]), "d" (__D[2]) : "cc");
    }
  return __R;
}



#pragma GCC pop_options
# 82 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tbmintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tbmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("tbm")
# 49 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tbmintrin.h" 3 4
extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcfill_u32 (unsigned int __X)
{
  return __X & (__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blci_u32 (unsigned int __X)
{
  return __X | ~(__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcic_u32 (unsigned int __X)
{
  return ~__X & (__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcmsk_u32 (unsigned int __X)
{
  return __X ^ (__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcs_u32 (unsigned int __X)
{
  return __X | (__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsfill_u32 (unsigned int __X)
{
  return __X | (__X - 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsic_u32 (unsigned int __X)
{
  return ~__X | (__X - 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__t1mskc_u32 (unsigned int __X)
{
  return ~__X | (__X + 1);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__tzmsk_u32 (unsigned int __X)
{
  return ~__X & (__X - 1);
}
# 118 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tbmintrin.h" 3 4
extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcfill_u64 (unsigned long long __X)
{
  return __X & (__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blci_u64 (unsigned long long __X)
{
  return __X | ~(__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcic_u64 (unsigned long long __X)
{
  return ~__X & (__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcmsk_u64 (unsigned long long __X)
{
  return __X ^ (__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blcs_u64 (unsigned long long __X)
{
  return __X | (__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsfill_u64 (unsigned long long __X)
{
  return __X | (__X - 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__blsic_u64 (unsigned long long __X)
{
  return ~__X | (__X - 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__t1mskc_u64 (unsigned long long __X)
{
  return ~__X | (__X + 1);
}

extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
__tzmsk_u64 (unsigned long long __X)
{
  return ~__X & (__X - 1);
}






#pragma GCC pop_options
# 84 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tsxldtrkintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tsxldtrkintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("tsxldtrk")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsusldtrk (void)
{
  __builtin_ia32_xsusldtrk ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xresldtrk (void)
{
  __builtin_ia32_xresldtrk ();
}



#pragma GCC pop_options
# 86 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/uintrintrin.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/uintrintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target ("uintr")



struct __uintr_frame
{

  unsigned long long rip;

  unsigned long long rflags;

  unsigned long long rsp;
};

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_clui (void)
{
  __builtin_ia32_clui ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_stui (void)
{
  __builtin_ia32_stui ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_senduipi (unsigned long long __R)
{
  __builtin_ia32_senduipi (__R);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_testui (void)
{
  return __builtin_ia32_testui ();
}



#pragma GCC pop_options
# 88 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/waitpkgintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/waitpkgintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("waitpkg")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_umonitor (void *__A)
{
  __builtin_ia32_umonitor (__A);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_umwait (unsigned int __A, unsigned long long __B)
{
  return __builtin_ia32_umwait (__A, __B);
}

extern __inline unsigned char
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tpause (unsigned int __A, unsigned long long __B)
{
  return __builtin_ia32_tpause (__A, __B);
}



#pragma GCC pop_options
# 90 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wbnoinvdintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wbnoinvdintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("wbnoinvd")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wbnoinvd (void)
{
  __builtin_ia32_wbnoinvd ();
}



#pragma GCC pop_options
# 92 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsaveintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsaveintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("xsave")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsave (void *__P, long long __M)
{
  __builtin_ia32_xsave (__P, __M);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xrstor (void *__P, long long __M)
{
  __builtin_ia32_xrstor (__P, __M);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsetbv (unsigned int __A, long long __V)
{
  __builtin_ia32_xsetbv (__A, __V);
}

extern __inline long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xgetbv (unsigned int __A)
{
  return __builtin_ia32_xgetbv (__A);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsave64 (void *__P, long long __M)
{
  __builtin_ia32_xsave64 (__P, __M);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xrstor64 (void *__P, long long __M)
{
  __builtin_ia32_xrstor64 (__P, __M);
}




#pragma GCC pop_options
# 94 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsavecintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsavecintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("xsavec")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsavec (void *__P, long long __M)
{
  __builtin_ia32_xsavec (__P, __M);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsavec64 (void *__P, long long __M)
{
  __builtin_ia32_xsavec64 (__P, __M);
}




#pragma GCC pop_options
# 96 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsaveoptintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsaveoptintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("xsaveopt")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsaveopt (void *__P, long long __M)
{
  __builtin_ia32_xsaveopt (__P, __M);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsaveopt64 (void *__P, long long __M)
{
  __builtin_ia32_xsaveopt64 (__P, __M);
}




#pragma GCC pop_options
# 98 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsavesintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xsavesintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("xsaves")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsaves (void *__P, long long __M)
{
  __builtin_ia32_xsaves (__P, __M);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xrstors (void *__P, long long __M)
{
  __builtin_ia32_xrstors (__P, __M);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xrstors64 (void *__P, long long __M)
{
  __builtin_ia32_xrstors64 (__P, __M);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xsaves64 (void *__P, long long __M)
{
  __builtin_ia32_xsaves64 (__P, __M);
}




#pragma GCC pop_options
# 100 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xtestintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xtestintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("rtm")





extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_xtest (void)
{
  return __builtin_ia32_xtest ();
}



#pragma GCC pop_options
# 102 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/hresetintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/hresetintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target ("hreset")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_hreset (unsigned int __EAX)
{
  __builtin_ia32_hreset (__EAX);
}



#pragma GCC pop_options
# 104 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/x86gprintrin.h" 2 3 4

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_wbinvd (void)
{
  __builtin_ia32_wbinvd ();
}


#pragma GCC push_options
#pragma GCC target("rdrnd")


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdrand16_step (unsigned short *__P)
{
  return __builtin_ia32_rdrand16_step (__P);
}

extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdrand32_step (unsigned int *__P)
{
  return __builtin_ia32_rdrand32_step (__P);
}


#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("rdpid")


extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdpid_u32 (void)
{
  return __builtin_ia32_rdpid ();
}


#pragma GCC pop_options





#pragma GCC push_options
#pragma GCC target("fsgsbase")


extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_readfsbase_u32 (void)
{
  return __builtin_ia32_rdfsbase32 ();
}

extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_readfsbase_u64 (void)
{
  return __builtin_ia32_rdfsbase64 ();
}

extern __inline unsigned int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_readgsbase_u32 (void)
{
  return __builtin_ia32_rdgsbase32 ();
}

extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_readgsbase_u64 (void)
{
  return __builtin_ia32_rdgsbase64 ();
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_writefsbase_u32 (unsigned int __B)
{
  __builtin_ia32_wrfsbase32 (__B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_writefsbase_u64 (unsigned long long __B)
{
  __builtin_ia32_wrfsbase64 (__B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_writegsbase_u32 (unsigned int __B)
{
  __builtin_ia32_wrgsbase32 (__B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_writegsbase_u64 (unsigned long long __B)
{
  __builtin_ia32_wrgsbase64 (__B);
}


#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("rdrnd")


extern __inline int
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_rdrand64_step (unsigned long long *__P)
{
  return __builtin_ia32_rdrand64_step (__P);
}


#pragma GCC pop_options





#pragma GCC push_options
#pragma GCC target("ptwrite")




extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_ptwrite64 (unsigned long long __B)
{
  __builtin_ia32_ptwrite64 (__B);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_ptwrite32 (unsigned __B)
{
  __builtin_ia32_ptwrite32 (__B);
}


#pragma GCC pop_options






#pragma GCC pop_options
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mmintrin.h" 1 3 4
# 44 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mmintrin.h" 3 4
typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));
typedef int __m32 __attribute__ ((__vector_size__ (4), __may_alias__));
typedef short __m16 __attribute__ ((__vector_size__ (2), __may_alias__));


typedef int __m64_u __attribute__ ((__vector_size__ (8), __may_alias__, __aligned__ (1)));
typedef int __m32_u __attribute__ ((__vector_size__ (4),
        __may_alias__, __aligned__ (1)));
typedef short __m16_u __attribute__ ((__vector_size__ (2),
          __may_alias__, __aligned__ (1)));


typedef int __v2si __attribute__ ((__vector_size__ (8)));
typedef short __v4hi __attribute__ ((__vector_size__ (8)));
typedef char __v8qi __attribute__ ((__vector_size__ (8)));
typedef long long __v1di __attribute__ ((__vector_size__ (8)));
typedef float __v2sf __attribute__ ((__vector_size__ (8)));


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_empty (void)
{
  __builtin_ia32_emms ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_empty (void)
{
  _mm_empty ();
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si64 (int __i)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int (int __i)
{
  return _mm_cvtsi32_si64 (__i);
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_m64 (long long __i)
{
  return (__m64) __i;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi64x (long long __i)
{
  return (__m64) __i;
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si32 (__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int (__m64 __i)
{
  return _mm_cvtsi64_si32 (__i);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int64 (__m64 __i)
{
  return (long long)__i;
}

extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtm64_si64 (__m64 __i)
{
  return (long long)__i;
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si64x (__m64 __i)
{
  return (long long)__i;
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packsswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packssdw (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi32 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packuswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pu16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhdq (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckldq (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddb (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddw (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddd (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi32 (__m1, __m2);
}
# 334 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
}







extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubb (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubw (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubd (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi32 (__m1, __m2);
}
# 450 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
}







extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaddwd (__m64 __m1, __m64 __m2)
{
  return _mm_madd_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhw (__m64 __m1, __m64 __m2)
{
  return _mm_mulhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmullw (__m64 __m1, __m64 __m2)
{
  return _mm_mullo_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllw (__m64 __m, __m64 __count)
{
  return _mm_sll_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllwi (__m64 __m, int __count)
{
  return _mm_slli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslld (__m64 __m, __m64 __count)
{
  return _mm_sll_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_pslldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslldi (__m64 __m, int __count)
{
  return _mm_slli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllq (__m64 __m, __m64 __count)
{
  return _mm_sll_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllqi (__m64 __m, int __count)
{
  return _mm_slli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psraw (__m64 __m, __m64 __count)
{
  return _mm_sra_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrawi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrawi (__m64 __m, int __count)
{
  return _mm_srai_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrad (__m64 __m, __m64 __count)
{
  return _mm_sra_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psradi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psradi (__m64 __m, int __count)
{
  return _mm_srai_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlw (__m64 __m, __m64 __count)
{
  return _mm_srl_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlwi (__m64 __m, int __count)
{
  return _mm_srli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrld (__m64 __m, __m64 __count)
{
  return _mm_srl_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrldi (__m64 __m, int __count)
{
  return _mm_srli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlq (__m64 __m, __m64 __count)
{
  return _mm_srl_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlqi (__m64 __m, int __count)
{
  return _mm_srli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pand (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pand (__m64 __m1, __m64 __m2)
{
  return _mm_and_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pandn (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pandn (__m64 __m1, __m64 __m2)
{
  return _mm_andnot_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_por (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_por (__m64 __m1, __m64 __m2)
{
  return _mm_or_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pxor (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pxor (__m64 __m1, __m64 __m2)
{
  return _mm_xor_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi8 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi16 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi32 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si64 (void)
{
  return (__m64)0LL;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi32 (int __i1, int __i0)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
{
  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
      char __b3, char __b2, char __b1, char __b0)
{
  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,
            __b4, __b5, __b6, __b7);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi32 (int __i0, int __i1)
{
  return _mm_set_pi32 (__i1, __i0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)
{
  return _mm_set_pi16 (__w3, __w2, __w1, __w0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
       char __b4, char __b5, char __b6, char __b7)
{
  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi32 (int __i)
{
  return _mm_set_pi32 (__i, __i);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi16 (short __w)
{
  return _mm_set_pi16 (__w, __w, __w, __w);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi8 (char __b)
{
  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
}
# 30 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mm_malloc.h" 1 3 4
# 27 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mm_malloc.h" 3 4
# 1 "/usr/include/c++/12.2.1/stdlib.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/mm_malloc.h" 2 3 4






extern "C" int posix_memalign (void **, size_t, size_t) throw ();


static __inline void *
_mm_malloc (size_t __size, size_t __alignment)
{
  void *__ptr;
  if (__alignment == 1)
    return malloc (__size);
  if (__alignment == 2 || (sizeof (void *) == 8 && __alignment == 4))
    __alignment = sizeof (void *);
  if (posix_memalign (&__ptr, __alignment, __size) == 0)
    return __ptr;
  else
    return __null;
}

static __inline void
_mm_free (void *__ptr)
{
  free (__ptr);
}
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 2 3 4


enum _mm_hint
{

  _MM_HINT_ET0 = 7,
  _MM_HINT_ET1 = 6,
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
# 69 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));


typedef float __m128_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));


typedef float __v4sf __attribute__ ((__vector_size__ (16)));
# 109 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_ps (void)
{
  __m128 __Y = __Y;
  return __Y;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ps (void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A + (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A - (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A * (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A / (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andnps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_orps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_xorps (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpltss ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpless ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnltss ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnless ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);
}




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si32 (__m128 __A)
{
  return __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ss2si (__m128 __A)
{
  return _mm_cvtss_si32 (__A);
}






extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64 (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64x (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ps2pi (__m128 __A)
{
  return _mm_cvtps_pi32 (__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si32 (__m128 __A)
{
  return __builtin_ia32_cvttss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ss2si (__m128 __A)
{
  return _mm_cvttss_si32 (__A);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64 (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64x (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ps2pi (__m128 __A)
{
  return _mm_cvttps_pi32 (__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_si2ss (__m128 __A, int __B)
{
  return _mm_cvtsi32_ss (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_ps (__m128 __A, __m64 __B)
{
  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_pi2ps (__m128 __A, __m64 __B)
{
  return _mm_cvtpi32_ps (__A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi16_ps (__m64 __A)
{
  __v4hi __sign;
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;




  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu16_ps (__m64 __A)
{
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi8_ps (__m64 __A)
{
  __v8qi __sign;




  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);


  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);

  return _mm_cvtpi16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu8_ps(__m64 __A)
{
  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);
  return _mm_cvtpu16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)
{
  __v4sf __zero = (__v4sf) _mm_setzero_ps ();
  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);
  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);
  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi16(__m128 __A)
{
  __v4sf __hisf = (__v4sf)__A;
  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);
  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);
  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);
  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi8(__m128 __A)
{
  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);
  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);
}
# 755 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehl_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movelh_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_ps (__m128 __A)
{
  return __builtin_ia32_movmskps ((__v4sf)__A);
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_getcsr (void)
{
  return __builtin_ia32_stmxcsr ();
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_STATE (void)
{
  return _mm_getcsr() & 0x003f;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_MASK (void)
{
  return _mm_getcsr() & 0x1f80;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_ROUNDING_MODE (void)
{
  return _mm_getcsr() & 0x6000;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_FLUSH_ZERO_MODE (void)
{
  return _mm_getcsr() & 0x8000;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setcsr (unsigned int __I)
{
  __builtin_ia32_ldmxcsr (__I);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x003f) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_MASK (unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x1f80) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_ROUNDING_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x6000) | __mode);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x8000) | __mode);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ss (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ps (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps1 (float __F)
{
  return _mm_set1_ps (__F);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ss (float const *__P)
{
  return _mm_set_ss (*__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_ps (float const *__P)
{
  return _mm_set1_ps (*__P);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps1 (float const *__P)
{
  return _mm_load1_ps (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps (float const *__P)
{
  return *(__m128 *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ps (float const *__P)
{
  return *(__m128_u *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_ps (float const *__P)
{
  __v4sf __tmp = *(__v4sf *)__P;
  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)
{
  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ps (float __Z, float __Y, float __X, float __W)
{
  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ss (float *__P, __m128 __A)
{
  *__P = ((__v4sf)__A)[0];
}

extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_f32 (__m128 __A)
{
  return ((__v4sf)__A)[0];
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__m128 *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ps (float *__P, __m128 __A)
{
  *(__m128_u *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((0) << 4) | ((0) << 2) | (0)));
  _mm_storeu_ps (__P, __tmp);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps1 (float *__P, __m128 __A)
{
  _mm_store1_ps (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
  _mm_store_ps (__P, __tmp);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_shuffle ((__v4sf)__A, (__v4sf)__B,
                                     __extension__
                                     (__attribute__((__vector_size__ (16))) int)
                                     {4,1,2,3});
}
# 1063 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxsw (__m64 __A, __m64 __B)
{
  return _mm_max_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxub (__m64 __A, __m64 __B)
{
  return _mm_max_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminsw (__m64 __A, __m64 __B)
{
  return _mm_min_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminub (__m64 __A, __m64 __B)
{
  return _mm_min_pu8 (__A, __B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pi8 (__m64 __A)
{
  return __builtin_ia32_pmovmskb ((__v8qi)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmovmskb (__m64 __A)
{
  return _mm_movemask_pi8 (__A);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhuw (__m64 __A, __m64 __B)
{
  return _mm_mulhi_pu16 (__A, __B);
}
# 1165 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
{



  typedef long long __v2di __attribute__ ((__vector_size__ (16)));
  typedef char __v16qi __attribute__ ((__vector_size__ (16)));

  __v2di __A128 = __extension__ (__v2di) { ((__v1di) __A)[0], 0 };
  __v2di __N128 = __extension__ (__v2di) { ((__v1di) __N)[0], 0 };


  long unsigned int offset = ((long unsigned int) __P) & 0xf;
  if (offset)
    {


      if (offset > 8)
 offset = 8;
      __P = (char *) (((long unsigned int) __P) - offset);


      switch (offset)
 {
 case 1:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 8);
   break;
 case 2:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 2 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 2 * 8);
   break;
 case 3:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 3 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 3 * 8);
   break;
 case 4:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 4 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 4 * 8);
   break;
 case 5:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 5 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 5 * 8);
   break;
 case 6:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 6 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 6 * 8);
   break;
 case 7:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 7 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 7 * 8);
   break;
 case 8:
   __A128 = __builtin_ia32_pslldqi128 (__A128, 8 * 8);
   __N128 = __builtin_ia32_pslldqi128 (__N128, 8 * 8);
   break;
 default:
   break;
 }
    }
  __builtin_ia32_maskmovdqu ((__v16qi)__A128, (__v16qi)__N128, __P);



}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_maskmovq (__m64 __A, __m64 __N, char *__P)
{
  _mm_maskmove_si64 (__A, __N, __P);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgb (__m64 __A, __m64 __B)
{
  return _mm_avg_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgw (__m64 __A, __m64 __B)
{
  return _mm_avg_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psadbw (__m64 __A, __m64 __B)
{
  return _mm_sad_pu8 (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pi (__m64 *__P, __m64 __A)
{
  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_ps (float *__P, __m128 __A)
{
  __builtin_ia32_movntps (__P, (__v4sf)__A);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sfence (void)
{
  __builtin_ia32_sfence ();
}
# 1316 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 1 3 4
# 31 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 2 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));
typedef int __v4si __attribute__ ((__vector_size__ (16)));
typedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__ ((__vector_size__ (16)));
typedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));
typedef char __v16qi __attribute__ ((__vector_size__ (16)));
typedef signed char __v16qs __attribute__ ((__vector_size__ (16)));
typedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));



typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));


typedef long long __m128i_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));
typedef double __m128d_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sd (double __F)
{
  return __extension__ (__m128d){ __F, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pd (double __F)
{
  return __extension__ (__m128d){ __F, __F };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd1 (double __F)
{
  return _mm_set1_pd (__F);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __X, __W };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __W, __X };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_pd (void)
{
  __m128d __Y = __Y;
  return __Y;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_pd (void)
{
  return __extension__ (__m128d){ 0.0, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sd (__m128d __A, __m128d __B)
{
  return __extension__ (__m128d) __builtin_shuffle ((__v2df)__A, (__v2df)__B, (__v2di){2, 1});
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd (double const *__P)
{
  return *(__m128d *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_pd (double const *__P)
{
  return *(__m128d_u *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_pd (double const *__P)
{
  return _mm_set1_pd (*__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sd (double const *__P)
{
  return _mm_set_sd (*__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd1 (double const *__P)
{
  return _mm_load1_pd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_pd (double const *__P)
{
  __m128d __tmp = _mm_load_pd (__P);
  return __builtin_ia32_shufpd (__tmp, __tmp, (((0) << 1) | (1)));
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd (double *__P, __m128d __A)
{
  *(__m128d *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_pd (double *__P, __m128d __A)
{
  *(__m128d_u *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sd (double *__P, __m128d __A)
{
  *__P = ((__v2df)__A)[0];
}

extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_f64 (__m128d __A)
{
  return ((__v2df)__A)[0];
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pd (double *__P, __m128d __A)
{
  _mm_store_sd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pd (double *__P, __m128d __A)
{
  *__P = ((__v2df)__A)[1];
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (0))));
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd1 (double *__P, __m128d __A)
{
  _mm_store1_pd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (1))));
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si32 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64 (__m128i __A)
{
  return ((__v2di)__A)[0];
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64x (__m128i __A)
{
  return ((__v2di)__A)[0];
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A + (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A - (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A * (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A / (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_pd (__m128d __A)
{
  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sd (__m128d __A, __m128d __B)
{
  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpltsd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmplesd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnltsd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnlesd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64x (long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64 (__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x ((long long)__q1, (long long)__q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
{
  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        short __q3, short __q2, short __q1, short __q0)
{
  return __extension__ (__m128i)(__v8hi){
    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
       char __q11, char __q10, char __q09, char __q08,
       char __q07, char __q06, char __q05, char __q04,
       char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m128i)(__v16qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64x (long long __A)
{
  return _mm_set_epi64x (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64 (__m64 __A)
{
  return _mm_set_epi64 (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi32 (int __A)
{
  return _mm_set_epi32 (__A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi16 (short __A)
{
  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi8 (char __A)
{
  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
         __A, __A, __A, __A, __A, __A, __A, __A);
}




extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi64 (__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64 (__q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)
{
  return _mm_set_epi32 (__q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,
         short __q4, short __q5, short __q6, short __q7)
{
  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,
        char __q04, char __q05, char __q06, char __q07,
        char __q08, char __q09, char __q10, char __q11,
        char __q12, char __q13, char __q14, char __q15)
{
  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
         __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_si128 (__m128i const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si128 (__m128i_u const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_epi64 (__m128i_u const *__P)
{
  return _mm_set_epi64 ((__m64)0LL, *(__m64_u *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si64 (void const *__P)
{
  return _mm_loadl_epi64 ((__m128i_u *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si32 (void const *__P)
{
  return _mm_set_epi32 (0, 0, 0, (*(__m32_u *)__P)[0]);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si16 (void const *__P)
{
  return _mm_set_epi16 (0, 0, 0, 0, 0, 0, 0, (*(__m16_u *)__P)[0]);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si128 (__m128i_u *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_epi64 (__m128i_u *__P, __m128i __B)
{
  *(__m64_u *)__P = (__m64) ((__v2di)__B)[0];
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si64 (void *__P, __m128i __B)
{
  _mm_storel_epi64 ((__m128i_u *)__P, __B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si32 (void *__P, __m128i __B)
{
  *(__m32_u *)__P = (__m32) ((__v4si)__B)[0];
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si16 (void *__P, __m128i __B)
{
  *(__m16_u *)__P = (__m16) ((__v8hi)__B)[0];
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_pi64 (__m128i __B)
{
  return (__m64) ((__v2di)__B)[0];
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movpi64_epi64 (__m64 __A)
{
  return _mm_set_epi64 ((__m64)0LL, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_epi64 (__m128i __A)
{
  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_si128 (void)
{
  __m128i __Y = __Y;
  return __Y;
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_pd (__m128i __A)
{
  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ps (__m128i __A)
{
  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ps (__m128d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_pd (__m64 __A)
{
  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pd (__m128 __A)
{
  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_ss (__m128 __A, __m128d __B)
{
  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_sd (__m128d __A, int __B)
{
  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}



extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sd (__m128d __A, __m128 __B)
{
  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);
}
# 955 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pd (__m128d __A)
{
  return __builtin_ia32_movmskpd ((__v2df)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qu)__A + (__v16qu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A + (__v8hu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A + (__v4su)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A + (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qu)__A - (__v16qu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A - (__v8hu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A - (__v4su)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A - (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A * (__v8hu)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_su32 (__m64 __A, __m64 __B)
{
  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
}
# 1242 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A & (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A | (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A ^ (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A == (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A == (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qs)__A < (__v16qs)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A < (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A < (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qs)__A > (__v16qs)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A > (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A > (__v4si)__B);
}
# 1406 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_epi8 (__m128i __A)
{
  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);
}
# 1469 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/emmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si32 (int *__A, int __B)
{
  __builtin_ia32_movnti (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si64 (long long int *__A, long long int __B)
{
  __builtin_ia32_movnti64 (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si128 (__m128i *__A, __m128i __B)
{
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pd (double *__A, __m128d __B)
{
  __builtin_ia32_movntpd (__A, (__v2df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflush (void const *__A)
{
  __builtin_ia32_clflush (__A);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lfence (void)
{
  __builtin_ia32_lfence ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si128 (int __A)
{
  return _mm_set_epi32 (0, 0, 0, __A);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ps(__m128d __A)
{
  return (__m128) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_si128(__m128d __A)
{
  return (__m128i) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_pd(__m128 __A)
{
  return (__m128d) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_si128(__m128 __A)
{
  return (__m128i) __A;
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ps(__m128i __A)
{
  return (__m128) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_pd(__m128i __A)
{
  return (__m128d) __A;
}
# 1317 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 2 3 4
# 1328 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_pause (void)
{
  __builtin_ia32_pause ();
}
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pmmintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pmmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("sse3")
# 50 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/pmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_addsub_ps (__m128 __X, __m128 __Y)
{
  return (__m128) __builtin_ia32_addsubps ((__v4sf)__X, (__v4sf)__Y);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_ps (__m128 __X, __m128 __Y)
{
  return (__m128) __builtin_ia32_haddps ((__v4sf)__X, (__v4sf)__Y);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_ps (__m128 __X, __m128 __Y)
{
  return (__m128) __builtin_ia32_hsubps ((__v4sf)__X, (__v4sf)__Y);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehdup_ps (__m128 __X)
{
  return (__m128) __builtin_ia32_movshdup ((__v4sf)__X);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_moveldup_ps (__m128 __X)
{
  return (__m128) __builtin_ia32_movsldup ((__v4sf)__X);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_addsub_pd (__m128d __X, __m128d __Y)
{
  return (__m128d) __builtin_ia32_addsubpd ((__v2df)__X, (__v2df)__Y);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_pd (__m128d __X, __m128d __Y)
{
  return (__m128d) __builtin_ia32_haddpd ((__v2df)__X, (__v2df)__Y);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_pd (__m128d __X, __m128d __Y)
{
  return (__m128d) __builtin_ia32_hsubpd ((__v2df)__X, (__v2df)__Y);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loaddup_pd (double const *__P)
{
  return _mm_load1_pd (__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movedup_pd (__m128d __X)
{
  return ((__m128d)__builtin_ia32_shufpd ((__v2df)(__m128d)(__X), (__v2df)(__m128d)(__X), (int)((((0) << 1) | (0)))));
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lddqu_si128 (__m128i const *__P)
{
  return (__m128i) __builtin_ia32_lddqu ((char const *)__P);
}



#pragma GCC pop_options
# 36 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tmmintrin.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tmmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("ssse3")



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phaddw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phaddd128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadds_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phaddsw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phaddw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadd_pi32 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phaddd ((__v2si)__X, (__v2si)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hadds_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phaddsw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phsubw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phsubd128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsubs_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_phsubsw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phsubw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsub_pi32 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phsubd ((__v2si)__X, (__v2si)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_hsubs_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_phsubsw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maddubs_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaddubsw128 ((__v16qi)__X, (__v16qi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maddubs_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_pmaddubsw ((__v8qi)__X, (__v8qi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhrs_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmulhrsw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhrs_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_pmulhrsw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pshufb128 ((__v16qi)__X, (__v16qi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_pi8 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_pshufb ((__v8qi)__X, (__v8qi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psignb128 ((__v16qi)__X, (__v16qi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_epi16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psignw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psignd128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_pi8 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_psignb ((__v8qi)__X, (__v8qi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_pi16 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_psignw ((__v4hi)__X, (__v4hi)__Y);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sign_pi32 (__m64 __X, __m64 __Y)
{
  return (__m64) __builtin_ia32_psignd ((__v2si)__X, (__v2si)__Y);
}
# 208 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/tmmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_epi8 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pabsb128 ((__v16qi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_epi16 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pabsw128 ((__v8hi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pabsd128 ((__v4si)__X);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_pi8 (__m64 __X)
{
  return (__m64) __builtin_ia32_pabsb ((__v8qi)__X);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_pi16 (__m64 __X)
{
  return (__m64) __builtin_ia32_pabsw ((__v4hi)__X);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_pi32 (__m64 __X)
{
  return (__m64) __builtin_ia32_pabsd ((__v2si)__X);
}



#pragma GCC pop_options
# 38 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("sse4.1")
# 66 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testz_si128 (__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestz128 ((__v2di)__M, (__v2di)__V);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testc_si128 (__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestc128 ((__v2di)__M, (__v2di)__V);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testnzc_si128 (__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestnzc128 ((__v2di)__M, (__v2di)__V);
}
# 178 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_blendv_epi8 (__m128i __X, __m128i __Y, __m128i __M)
{
  return (__m128i) __builtin_ia32_pblendvb128 ((__v16qi)__X,
            (__v16qi)__Y,
            (__v16qi)__M);
}
# 203 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_blendv_ps (__m128 __X, __m128 __Y, __m128 __M)
{
  return (__m128) __builtin_ia32_blendvps ((__v4sf)__X,
        (__v4sf)__Y,
        (__v4sf)__M);
}
# 228 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_blendv_pd (__m128d __X, __m128d __Y, __m128d __M)
{
  return (__m128d) __builtin_ia32_blendvpd ((__v2df)__X,
         (__v2df)__Y,
         (__v2df)__M);
}
# 267 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi64 (__m128i __X, __m128i __Y)
{
  return (__m128i) ((__v2di)__X == (__v2di)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pminsb128 ((__v16qi)__X, (__v16qi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaxsb128 ((__v16qi)__X, (__v16qi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pminuw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu16 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaxuw128 ((__v8hi)__X, (__v8hi)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pminsd128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaxsd128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pminud128 ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaxud128 ((__v4si)__X, (__v4si)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) ((__v4su)__X * (__v4su)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuldq128 ((__v4si)__X, (__v4si)__Y);
}
# 474 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_minpos_epu16 (__m128i __X)
{
  return (__m128i) __builtin_ia32_phminposuw128 ((__v8hi)__X);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi8_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxbd128 ((__v16qi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi16_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxwd128 ((__v8hi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi8_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxbq128 ((__v16qi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxdq128 ((__v4si)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi16_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxwq128 ((__v8hi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi8_epi16 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxbw128 ((__v16qi)__X);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu8_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxbd128 ((__v16qi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu16_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxwd128 ((__v8hi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu8_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxbq128 ((__v16qi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu32_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxdq128 ((__v4si)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu16_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxwq128 ((__v8hi)__X);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu8_epi16 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxbw128 ((__v16qi)__X);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_packusdw128 ((__v4si)__X, (__v4si)__Y);
}
# 582 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_load_si128 (__m128i *__X)
{
  return (__m128i) __builtin_ia32_movntdqa ((__v2di *) __X);
}


#pragma GCC push_options
#pragma GCC target("sse4.2")
# 796 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/smmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi64 (__m128i __X, __m128i __Y)
{
  return (__m128i) ((__v2di)__X > (__v2di)__Y);
}



#pragma GCC pop_options




#pragma GCC pop_options





#pragma GCC push_options
#pragma GCC target("crc32")




extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_crc32_u8 (unsigned int __C, unsigned char __V)
{
  return __builtin_ia32_crc32qi (__C, __V);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_crc32_u16 (unsigned int __C, unsigned short __V)
{
  return __builtin_ia32_crc32hi (__C, __V);
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_crc32_u32 (unsigned int __C, unsigned int __V)
{
  return __builtin_ia32_crc32si (__C, __V);
}


extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_crc32_u64 (unsigned long long __C, unsigned long long __V)
{
  return __builtin_ia32_crc32di (__C, __V);
}




#pragma GCC pop_options
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wmmintrin.h" 1 3 4
# 36 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wmmintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("aes,sse2")





extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdec_si128 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_aesdec128 ((__v2di)__X, (__v2di)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdeclast_si128 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_aesdeclast128 ((__v2di)__X,
       (__v2di)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesenc_si128 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_aesenc128 ((__v2di)__X, (__v2di)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesenclast_si128 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_aesenclast128 ((__v2di)__X, (__v2di)__Y);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesimc_si128 (__m128i __X)
{
  return (__m128i) __builtin_ia32_aesimc128 ((__v2di)__X);
}
# 99 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wmmintrin.h" 3 4
#pragma GCC pop_options





#pragma GCC push_options
#pragma GCC target("pclmul,sse2")
# 129 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/wmmintrin.h" 3 4
#pragma GCC pop_options
# 42 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx")




typedef double __v4df __attribute__ ((__vector_size__ (32)));
typedef float __v8sf __attribute__ ((__vector_size__ (32)));
typedef long long __v4di __attribute__ ((__vector_size__ (32)));
typedef unsigned long long __v4du __attribute__ ((__vector_size__ (32)));
typedef int __v8si __attribute__ ((__vector_size__ (32)));
typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
typedef short __v16hi __attribute__ ((__vector_size__ (32)));
typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
typedef char __v32qi __attribute__ ((__vector_size__ (32)));
typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));
typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));



typedef float __m256 __attribute__ ((__vector_size__ (32),
         __may_alias__));
typedef long long __m256i __attribute__ ((__vector_size__ (32),
       __may_alias__));
typedef double __m256d __attribute__ ((__vector_size__ (32),
           __may_alias__));


typedef float __m256_u __attribute__ ((__vector_size__ (32),
           __may_alias__,
           __aligned__ (1)));
typedef long long __m256i_u __attribute__ ((__vector_size__ (32),
         __may_alias__,
         __aligned__ (1)));
typedef double __m256d_u __attribute__ ((__vector_size__ (32),
      __may_alias__,
      __aligned__ (1)));
# 140 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_pd (__m256d __A, __m256d __B)
{
  return (__m256d) ((__v4df)__A + (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_ps (__m256 __A, __m256 __B)
{
  return (__m256) ((__v8sf)__A + (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_addsub_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_addsubpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_addsub_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_addsubps256 ((__v8sf)__A, (__v8sf)__B);
}


extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_and_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_andpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_and_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_andps256 ((__v8sf)__A, (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_andnot_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_andnpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_andnot_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_andnps256 ((__v8sf)__A, (__v8sf)__B);
}
# 218 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_blendv_pd (__m256d __X, __m256d __Y, __m256d __M)
{
  return (__m256d) __builtin_ia32_blendvpd256 ((__v4df)__X,
            (__v4df)__Y,
            (__v4df)__M);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_blendv_ps (__m256 __X, __m256 __Y, __m256 __M)
{
  return (__m256) __builtin_ia32_blendvps256 ((__v8sf)__X,
           (__v8sf)__Y,
           (__v8sf)__M);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_div_pd (__m256d __A, __m256d __B)
{
  return (__m256d) ((__v4df)__A / (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_div_ps (__m256 __A, __m256 __B)
{
  return (__m256) ((__v8sf)__A / (__v8sf)__B);
}
# 263 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hadd_pd (__m256d __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_haddpd256 ((__v4df)__X, (__v4df)__Y);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hadd_ps (__m256 __X, __m256 __Y)
{
  return (__m256) __builtin_ia32_haddps256 ((__v8sf)__X, (__v8sf)__Y);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hsub_pd (__m256d __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_hsubpd256 ((__v4df)__X, (__v4df)__Y);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hsub_ps (__m256 __X, __m256 __Y)
{
  return (__m256) __builtin_ia32_hsubps256 ((__v8sf)__X, (__v8sf)__Y);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_maxpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_maxps256 ((__v8sf)__A, (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_minpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_minps256 ((__v8sf)__A, (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mul_pd (__m256d __A, __m256d __B)
{
  return (__m256d) ((__v4df)__A * (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mul_ps (__m256 __A, __m256 __B)
{
  return (__m256) ((__v8sf)__A * (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_or_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_orpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_or_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_orps256 ((__v8sf)__A, (__v8sf)__B);
}
# 359 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_pd (__m256d __A, __m256d __B)
{
  return (__m256d) ((__v4df)__A - (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_ps (__m256 __A, __m256 __B)
{
  return (__m256) ((__v8sf)__A - (__v8sf)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_xor_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_xorpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_xor_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_xorps256 ((__v8sf)__A, (__v8sf)__B);
}
# 447 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsi256_si32 (__m256i __A)
{
  __v8si __B = (__v8si) __A;
  return __B[0];
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_pd (__m128i __A)
{
  return (__m256d)__builtin_ia32_cvtdq2pd256 ((__v4si) __A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_ps (__m256i __A)
{
  return (__m256)__builtin_ia32_cvtdq2ps256 ((__v8si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_ps (__m256d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps256 ((__v4df) __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtps_epi32 (__m256 __A)
{
  return (__m256i)__builtin_ia32_cvtps2dq256 ((__v8sf) __A);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtps_pd (__m128 __A)
{
  return (__m256d)__builtin_ia32_cvtps2pd256 ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttpd_epi32 (__m256d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq256 ((__v4df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_epi32 (__m256d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq256 ((__v4df) __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttps_epi32 (__m256 __A)
{
  return (__m256i)__builtin_ia32_cvttps2dq256 ((__v8sf) __A);
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsd_f64 (__m256d __A)
{
  return __A[0];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtss_f32 (__m256 __A)
{
  return __A[0];
}
# 608 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zeroall (void)
{
  __builtin_ia32_vzeroall ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zeroupper (void)
{
  __builtin_ia32_vzeroupper ();
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutevar_pd (__m128d __A, __m128i __C)
{
  return (__m128d) __builtin_ia32_vpermilvarpd ((__v2df)__A,
      (__v2di)__C);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutevar_pd (__m256d __A, __m256i __C)
{
  return (__m256d) __builtin_ia32_vpermilvarpd256 ((__v4df)__A,
         (__v4di)__C);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutevar_ps (__m128 __A, __m128i __C)
{
  return (__m128) __builtin_ia32_vpermilvarps ((__v4sf)__A,
            (__v4si)__C);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutevar_ps (__m256 __A, __m256i __C)
{
  return (__m256) __builtin_ia32_vpermilvarps256 ((__v8sf)__A,
        (__v8si)__C);
}
# 727 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcast_ss (float const *__X)
{
  return (__m128) __builtin_ia32_vbroadcastss (__X);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_sd (double const *__X)
{
  return (__m256d) __builtin_ia32_vbroadcastsd256 (__X);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_ss (float const *__X)
{
  return (__m256) __builtin_ia32_vbroadcastss256 (__X);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_pd (__m128d const *__X)
{
  return (__m256d) __builtin_ia32_vbroadcastf128_pd256 (__X);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_ps (__m128 const *__X)
{
  return (__m256) __builtin_ia32_vbroadcastf128_ps256 (__X);
}
# 866 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_pd (double const *__P)
{
  return *(__m256d *)__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_pd (double *__P, __m256d __A)
{
  *(__m256d *)__P = __A;
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_ps (float const *__P)
{
  return *(__m256 *)__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_ps (float *__P, __m256 __A)
{
  *(__m256 *)__P = __A;
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_pd (double const *__P)
{
  return *(__m256d_u *)__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_pd (double *__P, __m256d __A)
{
  *(__m256d_u *)__P = __A;
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_ps (float const *__P)
{
  return *(__m256_u *)__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_ps (float *__P, __m256 __A)
{
  *(__m256_u *)__P = __A;
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_si256 (__m256i const *__P)
{
  return *__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_si256 (__m256i *__P, __m256i __A)
{
  *__P = __A;
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_si256 (__m256i_u const *__P)
{
  return *__P;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_si256 (__m256i_u *__P, __m256i __A)
{
  *__P = __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskload_pd (double const *__P, __m128i __M)
{
  return (__m128d) __builtin_ia32_maskloadpd ((const __v2df *)__P,
           (__v2di)__M);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskstore_pd (double *__P, __m128i __M, __m128d __A)
{
  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2di)__M, (__v2df)__A);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskload_pd (double const *__P, __m256i __M)
{
  return (__m256d) __builtin_ia32_maskloadpd256 ((const __v4df *)__P,
       (__v4di)__M);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskstore_pd (double *__P, __m256i __M, __m256d __A)
{
  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4di)__M, (__v4df)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskload_ps (float const *__P, __m128i __M)
{
  return (__m128) __builtin_ia32_maskloadps ((const __v4sf *)__P,
          (__v4si)__M);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskstore_ps (float *__P, __m128i __M, __m128 __A)
{
  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4si)__M, (__v4sf)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskload_ps (float const *__P, __m256i __M)
{
  return (__m256) __builtin_ia32_maskloadps256 ((const __v8sf *)__P,
      (__v8si)__M);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskstore_ps (float *__P, __m256i __M, __m256 __A)
{
  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8si)__M, (__v8sf)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movehdup_ps (__m256 __X)
{
  return (__m256) __builtin_ia32_movshdup256 ((__v8sf)__X);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_moveldup_ps (__m256 __X)
{
  return (__m256) __builtin_ia32_movsldup256 ((__v8sf)__X);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movedup_pd (__m256d __X)
{
  return (__m256d) __builtin_ia32_movddup256 ((__v4df)__X);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_lddqu_si256 (__m256i const *__P)
{
  return (__m256i) __builtin_ia32_lddqu256 ((char const *)__P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_stream_si256 (__m256i *__A, __m256i __B)
{
  __builtin_ia32_movntdq256 ((__v4di *)__A, (__v4di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_stream_pd (double *__A, __m256d __B)
{
  __builtin_ia32_movntpd256 (__A, (__v4df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_stream_ps (float *__P, __m256 __A)
{
  __builtin_ia32_movntps256 (__P, (__v8sf)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rcp_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rcpps256 ((__v8sf)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rsqrt_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rsqrtps256 ((__v8sf)__A);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sqrt_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_sqrtpd256 ((__v4df)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sqrt_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_sqrtps256 ((__v8sf)__A);
}
# 1081 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxintrin.h" 3 4
extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_unpckhpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_unpcklpd256 ((__v4df)__A, (__v4df)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_unpckhps256 ((__v8sf)__A, (__v8sf)__B);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_unpcklps256 ((__v8sf)__A, (__v8sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testz_pd (__m128d __M, __m128d __V)
{
  return __builtin_ia32_vtestzpd ((__v2df)__M, (__v2df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testc_pd (__m128d __M, __m128d __V)
{
  return __builtin_ia32_vtestcpd ((__v2df)__M, (__v2df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testnzc_pd (__m128d __M, __m128d __V)
{
  return __builtin_ia32_vtestnzcpd ((__v2df)__M, (__v2df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testz_ps (__m128 __M, __m128 __V)
{
  return __builtin_ia32_vtestzps ((__v4sf)__M, (__v4sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testc_ps (__m128 __M, __m128 __V)
{
  return __builtin_ia32_vtestcps ((__v4sf)__M, (__v4sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_testnzc_ps (__m128 __M, __m128 __V)
{
  return __builtin_ia32_vtestnzcps ((__v4sf)__M, (__v4sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testz_pd (__m256d __M, __m256d __V)
{
  return __builtin_ia32_vtestzpd256 ((__v4df)__M, (__v4df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testc_pd (__m256d __M, __m256d __V)
{
  return __builtin_ia32_vtestcpd256 ((__v4df)__M, (__v4df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testnzc_pd (__m256d __M, __m256d __V)
{
  return __builtin_ia32_vtestnzcpd256 ((__v4df)__M, (__v4df)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testz_ps (__m256 __M, __m256 __V)
{
  return __builtin_ia32_vtestzps256 ((__v8sf)__M, (__v8sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testc_ps (__m256 __M, __m256 __V)
{
  return __builtin_ia32_vtestcps256 ((__v8sf)__M, (__v8sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testnzc_ps (__m256 __M, __m256 __V)
{
  return __builtin_ia32_vtestnzcps256 ((__v8sf)__M, (__v8sf)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testz_si256 (__m256i __M, __m256i __V)
{
  return __builtin_ia32_ptestz256 ((__v4di)__M, (__v4di)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testc_si256 (__m256i __M, __m256i __V)
{
  return __builtin_ia32_ptestc256 ((__v4di)__M, (__v4di)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testnzc_si256 (__m256i __M, __m256i __V)
{
  return __builtin_ia32_ptestnzc256 ((__v4di)__M, (__v4di)__V);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movemask_pd (__m256d __A)
{
  return __builtin_ia32_movmskpd256 ((__v4df)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movemask_ps (__m256 __A)
{
  return __builtin_ia32_movmskps256 ((__v8sf)__A);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_undefined_pd (void)
{
  __m256d __Y = __Y;
  return __Y;
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_undefined_ps (void)
{
  __m256 __Y = __Y;
  return __Y;
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_undefined_si256 (void)
{
  __m256i __Y = __Y;
  return __Y;
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setzero_pd (void)
{
  return __extension__ (__m256d){ 0.0, 0.0, 0.0, 0.0 };
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setzero_ps (void)
{
  return __extension__ (__m256){ 0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0 };
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setzero_si256 (void)
{
  return __extension__ (__m256i)(__v4di){ 0, 0, 0, 0 };
}


extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_pd (double __A, double __B, double __C, double __D)
{
  return __extension__ (__m256d){ __D, __C, __B, __A };
}


extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_ps (float __A, float __B, float __C, float __D,
        float __E, float __F, float __G, float __H)
{
  return __extension__ (__m256){ __H, __G, __F, __E,
     __D, __C, __B, __A };
}


extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_epi32 (int __A, int __B, int __C, int __D,
    int __E, int __F, int __G, int __H)
{
  return __extension__ (__m256i)(__v8si){ __H, __G, __F, __E,
       __D, __C, __B, __A };
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_epi16 (short __q15, short __q14, short __q13, short __q12,
    short __q11, short __q10, short __q09, short __q08,
    short __q07, short __q06, short __q05, short __q04,
    short __q03, short __q02, short __q01, short __q00)
{
  return __extension__ (__m256i)(__v16hi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_epi8 (char __q31, char __q30, char __q29, char __q28,
    char __q27, char __q26, char __q25, char __q24,
    char __q23, char __q22, char __q21, char __q20,
    char __q19, char __q18, char __q17, char __q16,
    char __q15, char __q14, char __q13, char __q12,
    char __q11, char __q10, char __q09, char __q08,
    char __q07, char __q06, char __q05, char __q04,
    char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m256i)(__v32qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15,
    __q16, __q17, __q18, __q19, __q20, __q21, __q22, __q23,
    __q24, __q25, __q26, __q27, __q28, __q29, __q30, __q31
  };
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_epi64x (long long __A, long long __B, long long __C,
     long long __D)
{
  return __extension__ (__m256i)(__v4di){ __D, __C, __B, __A };
}


extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_pd (double __A)
{
  return __extension__ (__m256d){ __A, __A, __A, __A };
}


extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_ps (float __A)
{
  return __extension__ (__m256){ __A, __A, __A, __A,
     __A, __A, __A, __A };
}


extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_epi32 (int __A)
{
  return __extension__ (__m256i)(__v8si){ __A, __A, __A, __A,
       __A, __A, __A, __A };
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_epi16 (short __A)
{
  return _mm256_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A,
      __A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_epi8 (char __A)
{
  return _mm256_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
     __A, __A, __A, __A, __A, __A, __A, __A,
     __A, __A, __A, __A, __A, __A, __A, __A,
     __A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_epi64x (long long __A)
{
  return __extension__ (__m256i)(__v4di){ __A, __A, __A, __A };
}




extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_pd (double __A, double __B, double __C, double __D)
{
  return _mm256_set_pd (__D, __C, __B, __A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_ps (float __A, float __B, float __C, float __D,
  float __E, float __F, float __G, float __H)
{
  return _mm256_set_ps (__H, __G, __F, __E, __D, __C, __B, __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_epi32 (int __A, int __B, int __C, int __D,
     int __E, int __F, int __G, int __H)
{
  return _mm256_set_epi32 (__H, __G, __F, __E, __D, __C, __B, __A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_epi16 (short __q15, short __q14, short __q13, short __q12,
     short __q11, short __q10, short __q09, short __q08,
     short __q07, short __q06, short __q05, short __q04,
     short __q03, short __q02, short __q01, short __q00)
{
  return _mm256_set_epi16 (__q00, __q01, __q02, __q03,
      __q04, __q05, __q06, __q07,
      __q08, __q09, __q10, __q11,
      __q12, __q13, __q14, __q15);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_epi8 (char __q31, char __q30, char __q29, char __q28,
     char __q27, char __q26, char __q25, char __q24,
     char __q23, char __q22, char __q21, char __q20,
     char __q19, char __q18, char __q17, char __q16,
     char __q15, char __q14, char __q13, char __q12,
     char __q11, char __q10, char __q09, char __q08,
     char __q07, char __q06, char __q05, char __q04,
     char __q03, char __q02, char __q01, char __q00)
{
  return _mm256_set_epi8 (__q00, __q01, __q02, __q03,
     __q04, __q05, __q06, __q07,
     __q08, __q09, __q10, __q11,
     __q12, __q13, __q14, __q15,
     __q16, __q17, __q18, __q19,
     __q20, __q21, __q22, __q23,
     __q24, __q25, __q26, __q27,
     __q28, __q29, __q30, __q31);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_epi64x (long long __A, long long __B, long long __C,
      long long __D)
{
  return _mm256_set_epi64x (__D, __C, __B, __A);
}



extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castpd_ps (__m256d __A)
{
  return (__m256) __A;
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castpd_si256 (__m256d __A)
{
  return (__m256i) __A;
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castps_pd (__m256 __A)
{
  return (__m256d) __A;
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castps_si256(__m256 __A)
{
  return (__m256i) __A;
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castsi256_ps (__m256i __A)
{
  return (__m256) __A;
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castsi256_pd (__m256i __A)
{
  return (__m256d) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castpd256_pd128 (__m256d __A)
{
  return (__m128d) __builtin_ia32_pd_pd256 ((__v4df)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castps256_ps128 (__m256 __A)
{
  return (__m128) __builtin_ia32_ps_ps256 ((__v8sf)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castsi256_si128 (__m256i __A)
{
  return (__m128i) __builtin_ia32_si_si256 ((__v8si)__A);
}






extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castpd128_pd256 (__m128d __A)
{
  return (__m256d) __builtin_ia32_pd256_pd ((__v2df)__A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castps128_ps256 (__m128 __A)
{
  return (__m256) __builtin_ia32_ps256_ps ((__v4sf)__A);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castsi128_si256 (__m128i __A)
{
  return (__m256i) __builtin_ia32_si256_si ((__v4si)__A);
}



extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zextpd128_pd256 (__m128d __A)
{
  return ((__m256d) __builtin_ia32_vinsertf128_pd256 ((__v4df)(__m256d)(_mm256_setzero_pd ()), (__v2df)(__m128d)(__A), (int)(0)));
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zextps128_ps256 (__m128 __A)
{
  return ((__m256) __builtin_ia32_vinsertf128_ps256 ((__v8sf)(__m256)(_mm256_setzero_ps ()), (__v4sf)(__m128)(__A), (int)(0)));
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zextsi128_si256 (__m128i __A)
{
  return ((__m256i) __builtin_ia32_vinsertf128_si256 ((__v8si)(__m256i)(_mm256_setzero_si256 ()), (__v4si)(__m128i)(__A), (int)(0)));
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_m128 ( __m128 __H, __m128 __L)
{
  return ((__m256) __builtin_ia32_vinsertf128_ps256 ((__v8sf)(__m256)(_mm256_castps128_ps256 (__L)), (__v4sf)(__m128)(__H), (int)(1)));
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_m128d (__m128d __H, __m128d __L)
{
  return ((__m256d) __builtin_ia32_vinsertf128_pd256 ((__v4df)(__m256d)(_mm256_castpd128_pd256 (__L)), (__v2df)(__m128d)(__H), (int)(1)));
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_m128i (__m128i __H, __m128i __L)
{
  return ((__m256i) __builtin_ia32_vinsertf128_si256 ((__v8si)(__m256i)(_mm256_castsi128_si256 (__L)), (__v4si)(__m128i)(__H), (int)(1)));
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_m128 (__m128 __L, __m128 __H)
{
  return _mm256_set_m128 (__H, __L);
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_m128d (__m128d __L, __m128d __H)
{
  return _mm256_set_m128d (__H, __L);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_m128i (__m128i __L, __m128i __H)
{
  return _mm256_set_m128i (__H, __L);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu2_m128 (float const *__PH, float const *__PL)
{
  return ((__m256) __builtin_ia32_vinsertf128_ps256 ((__v8sf)(__m256)(_mm256_castps128_ps256 (_mm_loadu_ps (__PL))), (__v4sf)(__m128)(_mm_loadu_ps (__PH)), (int)(1)))
                                 ;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu2_m128 (float *__PH, float *__PL, __m256 __A)
{
  _mm_storeu_ps (__PL, _mm256_castps256_ps128 (__A));
  _mm_storeu_ps (__PH, ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__A), (int)(1))));
}

extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu2_m128d (double const *__PH, double const *__PL)
{
  return ((__m256d) __builtin_ia32_vinsertf128_pd256 ((__v4df)(__m256d)(_mm256_castpd128_pd256 (_mm_loadu_pd (__PL))), (__v2df)(__m128d)(_mm_loadu_pd (__PH)), (int)(1)))
                                 ;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu2_m128d (double *__PH, double *__PL, __m256d __A)
{
  _mm_storeu_pd (__PL, _mm256_castpd256_pd128 (__A));
  _mm_storeu_pd (__PH, ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__A), (int)(1))));
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu2_m128i (__m128i_u const *__PH, __m128i_u const *__PL)
{
  return ((__m256i) __builtin_ia32_vinsertf128_si256 ((__v8si)(__m256i)(_mm256_castsi128_si256 (_mm_loadu_si128 (__PL))), (__v4si)(__m128i)(_mm_loadu_si128 (__PH)), (int)(1)))
                                ;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu2_m128i (__m128i_u *__PH, __m128i_u *__PL, __m256i __A)
{
  _mm_storeu_si128 (__PL, _mm256_castsi256_si128 (__A));
  _mm_storeu_si128 (__PH, ((__m128i) __builtin_ia32_vextractf128_si256 ((__v8si)(__m256i)(__A), (int)(1))));
}



#pragma GCC pop_options
# 44 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxvnniintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avxvnniintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avxvnni")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_dpbusd_avx_epi32(__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpdpbusd_v8si ((__v8si) __A,
         (__v8si) __B,
         (__v8si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_dpbusd_avx_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpdpbusd_v4si ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_dpbusds_avx_epi32(__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpdpbusds_v8si ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_dpbusds_avx_epi32(__m128i __A,__m128i __B,__m128i __C)
{
  return (__m128i) __builtin_ia32_vpdpbusds_v4si ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_dpwssd_avx_epi32(__m256i __A,__m256i __B,__m256i __C)
{
  return (__m256i) __builtin_ia32_vpdpwssd_v8si ((__v8si) __A,
       (__v8si) __B,
       (__v8si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_dpwssd_avx_epi32(__m128i __A,__m128i __B,__m128i __C)
{
  return (__m128i) __builtin_ia32_vpdpwssd_v4si ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_dpwssds_avx_epi32(__m256i __A,__m256i __B,__m256i __C)
{
  return (__m256i) __builtin_ia32_vpdpwssds_v8si ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_dpwssds_avx_epi32(__m128i __A,__m128i __B,__m128i __C)
{
  return (__m128i) __builtin_ia32_vpdpwssds_v4si ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __C);
}



#pragma GCC pop_options
# 46 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx2")
# 54 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_abs_epi8 (__m256i __A)
{
  return (__m256i)__builtin_ia32_pabsb256 ((__v32qi)__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_abs_epi16 (__m256i __A)
{
  return (__m256i)__builtin_ia32_pabsw256 ((__v16hi)__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_abs_epi32 (__m256i __A)
{
  return (__m256i)__builtin_ia32_pabsd256 ((__v8si)__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_packs_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_packssdw256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_packs_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_packsswb256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_packus_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_packusdw256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_packus_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_packuswb256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v32qu)__A + (__v32qu)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v16hu)__A + (__v16hu)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8su)__A + (__v8su)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A + (__v4du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_adds_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_paddsb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_adds_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_paddsw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_adds_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_paddusb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_adds_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_paddusw256 ((__v16hi)__A, (__v16hi)__B);
}
# 177 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_and_si256 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A & (__v4du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_andnot_si256 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_andnotsi256 ((__v4di)__A, (__v4di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_avg_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pavgb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_avg_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pavgw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_blendv_epi8 (__m256i __X, __m256i __Y, __m256i __M)
{
  return (__m256i) __builtin_ia32_pblendvb256 ((__v32qi)__X,
            (__v32qi)__Y,
            (__v32qi)__M);
}
# 229 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v32qi)__A == (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v16hi)__A == (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8si)__A == (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4di)__A == (__v4di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v32qs)__A > (__v32qs)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v16hi)__A > (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8si)__A > (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4di)__A > (__v4di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hadd_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phaddw256 ((__v16hi)__X,
          (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hadd_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phaddd256 ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hadds_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phaddsw256 ((__v16hi)__X,
           (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hsub_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phsubw256 ((__v16hi)__X,
          (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hsub_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phsubd256 ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_hsubs_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_phsubsw256 ((__v16hi)__X,
           (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maddubs_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmaddubsw256 ((__v32qi)__X,
      (__v32qi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_madd_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaddwd256 ((__v16hi)__A,
          (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxsb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxsw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxsd256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxub256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxuw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epu32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmaxud256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminsb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminsw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminsd256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminub256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminuw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epu32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pminud256 ((__v8si)__A, (__v8si)__B);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movemask_epi8 (__m256i __A)
{
  return __builtin_ia32_pmovmskb256 ((__v32qi)__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi8_epi16 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxbw256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi8_epi32 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxbd256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi8_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxbq256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi16_epi32 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxwd256 ((__v8hi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi16_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxwq256 ((__v8hi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxdq256 ((__v4si)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu8_epi16 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxbw256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu8_epi32 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxbd256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu8_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxbq256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu16_epi32 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxwd256 ((__v8hi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu16_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxwq256 ((__v8hi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu32_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxdq256 ((__v4si)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mul_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuldq256 ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mulhrs_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmulhrsw256 ((__v16hi)__X,
            (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mulhi_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmulhuw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mulhi_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmulhw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mullo_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v16hu)__A * (__v16hu)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mullo_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8su)__A * (__v8su)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mul_epu32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_pmuludq256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_or_si256 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A | (__v4du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sad_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psadbw256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shuffle_epi8 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pshufb256 ((__v32qi)__X,
          (__v32qi)__Y);
}
# 624 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sign_epi8 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psignb256 ((__v32qi)__X, (__v32qi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sign_epi16 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psignw256 ((__v16hi)__X, (__v16hi)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sign_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psignd256 ((__v8si)__X, (__v8si)__Y);
}
# 666 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_slli_epi16 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psllwi256 ((__v16hi)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sll_epi16 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psllw256((__v16hi)__A, (__v8hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_slli_epi32 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_pslldi256 ((__v8si)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sll_epi32 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_pslld256((__v8si)__A, (__v4si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_slli_epi64 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psllqi256 ((__v4di)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sll_epi64 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psllq256((__v4di)__A, (__v2di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srai_epi16 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psrawi256 ((__v16hi)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sra_epi16 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psraw256 ((__v16hi)__A, (__v8hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srai_epi32 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psradi256 ((__v8si)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sra_epi32 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psrad256 ((__v8si)__A, (__v4si)__B);
}
# 757 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srli_epi16 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psrlwi256 ((__v16hi)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srl_epi16 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psrlw256((__v16hi)__A, (__v8hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srli_epi32 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psrldi256 ((__v8si)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srl_epi32 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psrld256((__v8si)__A, (__v4si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srli_epi64 (__m256i __A, int __B)
{
  return (__m256i)__builtin_ia32_psrlqi256 ((__v4di)__A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srl_epi64 (__m256i __A, __m128i __B)
{
  return (__m256i)__builtin_ia32_psrlq256((__v4di)__A, (__v2di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v32qu)__A - (__v32qu)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v16hu)__A - (__v16hu)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8su)__A - (__v8su)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A - (__v4du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_subs_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psubsb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_subs_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psubsw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_subs_epu8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psubusb256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_subs_epu16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_psubusw256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpckhbw256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpckhwd256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpckhdq256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpackhi_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpckhqdq256 ((__v4di)__A, (__v4di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpcklbw256 ((__v32qi)__A, (__v32qi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpcklwd256 ((__v16hi)__A, (__v16hi)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpckldq256 ((__v8si)__A, (__v8si)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_unpacklo_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_punpcklqdq256 ((__v4di)__A, (__v4di)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_xor_si256 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A ^ (__v4du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_stream_load_si256 (__m256i const *__X)
{
  return (__m256i) __builtin_ia32_movntdqa256 ((__v4di *) __X);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastss_ps (__m128 __X)
{
  return (__m128) __builtin_ia32_vbroadcastss_ps ((__v4sf)__X);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastss_ps (__m128 __X)
{
  return (__m256) __builtin_ia32_vbroadcastss_ps256 ((__v4sf)__X);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastsd_pd (__m128d __X)
{
  return (__m256d) __builtin_ia32_vbroadcastsd_pd256 ((__v2df)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastsi128_si256 (__m128i __X)
{
  return (__m256i) __builtin_ia32_vbroadcastsi256 ((__v2di)__X);
}
# 986 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastb_epi8 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pbroadcastb256 ((__v16qi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastw_epi16 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pbroadcastw256 ((__v8hi)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastd_epi32 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pbroadcastd256 ((__v4si)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastq_epi64 (__m128i __X)
{
  return (__m256i) __builtin_ia32_pbroadcastq256 ((__v2di)__X);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastb_epi8 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pbroadcastb128 ((__v16qi)__X);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastw_epi16 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pbroadcastw128 ((__v8hi)__X);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastd_epi32 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pbroadcastd128 ((__v4si)__X);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastq_epi64 (__m128i __X)
{
  return (__m128i) __builtin_ia32_pbroadcastq128 ((__v2di)__X);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutevar8x32_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256 ((__v8si)__X, (__v8si)__Y);
}
# 1061 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutevar8x32_ps (__m256 __X, __m256i __Y)
{
  return (__m256) __builtin_ia32_permvarsf256 ((__v8sf)__X, (__v8si)__Y);
}
# 1119 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskload_epi32 (int const *__X, __m256i __M )
{
  return (__m256i) __builtin_ia32_maskloadd256 ((const __v8si *)__X,
      (__v8si)__M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskload_epi64 (long long const *__X, __m256i __M )
{
  return (__m256i) __builtin_ia32_maskloadq256 ((const __v4di *)__X,
      (__v4di)__M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskload_epi32 (int const *__X, __m128i __M )
{
  return (__m128i) __builtin_ia32_maskloadd ((const __v4si *)__X,
          (__v4si)__M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskload_epi64 (long long const *__X, __m128i __M )
{
  return (__m128i) __builtin_ia32_maskloadq ((const __v2di *)__X,
          (__v2di)__M);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskstore_epi32 (int *__X, __m256i __M, __m256i __Y )
{
  __builtin_ia32_maskstored256 ((__v8si *)__X, (__v8si)__M, (__v8si)__Y);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskstore_epi64 (long long *__X, __m256i __M, __m256i __Y )
{
  __builtin_ia32_maskstoreq256 ((__v4di *)__X, (__v4di)__M, (__v4di)__Y);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskstore_epi32 (int *__X, __m128i __M, __m128i __Y )
{
  __builtin_ia32_maskstored ((__v4si *)__X, (__v4si)__M, (__v4si)__Y);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskstore_epi64 (long long *__X, __m128i __M, __m128i __Y )
{
  __builtin_ia32_maskstoreq (( __v2di *)__X, (__v2di)__M, (__v2di)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sllv_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv8si ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sllv_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv4si ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sllv_epi64 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv4di ((__v4di)__X, (__v4di)__Y);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sllv_epi64 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv2di ((__v2di)__X, (__v2di)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srav_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrav8si ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srav_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrav4si ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srlv_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv8si ((__v8si)__X, (__v8si)__Y);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srlv_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv4si ((__v4si)__X, (__v4si)__Y);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srlv_epi64 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv4di ((__v4di)__X, (__v4di)__Y);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srlv_epi64 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv2di ((__v2di)__X, (__v2di)__Y);
}
# 1920 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx2intrin.h" 3 4
#pragma GCC pop_options
# 48 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512f")




typedef double __v8df __attribute__ ((__vector_size__ (64)));
typedef float __v16sf __attribute__ ((__vector_size__ (64)));
typedef long long __v8di __attribute__ ((__vector_size__ (64)));
typedef unsigned long long __v8du __attribute__ ((__vector_size__ (64)));
typedef int __v16si __attribute__ ((__vector_size__ (64)));
typedef unsigned int __v16su __attribute__ ((__vector_size__ (64)));
typedef short __v32hi __attribute__ ((__vector_size__ (64)));
typedef unsigned short __v32hu __attribute__ ((__vector_size__ (64)));
typedef char __v64qi __attribute__ ((__vector_size__ (64)));
typedef unsigned char __v64qu __attribute__ ((__vector_size__ (64)));



typedef float __m512 __attribute__ ((__vector_size__ (64), __may_alias__));
typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));


typedef float __m512_u __attribute__ ((__vector_size__ (64), __may_alias__, __aligned__ (1)));
typedef long long __m512i_u __attribute__ ((__vector_size__ (64), __may_alias__, __aligned__ (1)));
typedef double __m512d_u __attribute__ ((__vector_size__ (64), __may_alias__, __aligned__ (1)));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_int2mask (int __M)
{
  return (__mmask16) __M;
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2int (__mmask16 __M)
{
  return (int) __M;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_epi64 (long long __A, long long __B, long long __C,
    long long __D, long long __E, long long __F,
    long long __G, long long __H)
{
  return __extension__ (__m512i) (__v8di)
  { __H, __G, __F, __E, __D, __C, __B, __A };
}


extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_epi32 (int __A, int __B, int __C, int __D,
    int __E, int __F, int __G, int __H,
    int __I, int __J, int __K, int __L,
    int __M, int __N, int __O, int __P)
{
  return __extension__ (__m512i)(__v16si)
  { __P, __O, __N, __M, __L, __K, __J, __I,
    __H, __G, __F, __E, __D, __C, __B, __A };
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_epi16 (short __q31, short __q30, short __q29, short __q28,
    short __q27, short __q26, short __q25, short __q24,
    short __q23, short __q22, short __q21, short __q20,
    short __q19, short __q18, short __q17, short __q16,
    short __q15, short __q14, short __q13, short __q12,
    short __q11, short __q10, short __q09, short __q08,
    short __q07, short __q06, short __q05, short __q04,
    short __q03, short __q02, short __q01, short __q00)
{
  return __extension__ (__m512i)(__v32hi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15,
    __q16, __q17, __q18, __q19, __q20, __q21, __q22, __q23,
    __q24, __q25, __q26, __q27, __q28, __q29, __q30, __q31
  };
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_epi8 (char __q63, char __q62, char __q61, char __q60,
   char __q59, char __q58, char __q57, char __q56,
   char __q55, char __q54, char __q53, char __q52,
   char __q51, char __q50, char __q49, char __q48,
   char __q47, char __q46, char __q45, char __q44,
   char __q43, char __q42, char __q41, char __q40,
   char __q39, char __q38, char __q37, char __q36,
   char __q35, char __q34, char __q33, char __q32,
   char __q31, char __q30, char __q29, char __q28,
   char __q27, char __q26, char __q25, char __q24,
   char __q23, char __q22, char __q21, char __q20,
   char __q19, char __q18, char __q17, char __q16,
   char __q15, char __q14, char __q13, char __q12,
   char __q11, char __q10, char __q09, char __q08,
   char __q07, char __q06, char __q05, char __q04,
   char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m512i)(__v64qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15,
    __q16, __q17, __q18, __q19, __q20, __q21, __q22, __q23,
    __q24, __q25, __q26, __q27, __q28, __q29, __q30, __q31,
    __q32, __q33, __q34, __q35, __q36, __q37, __q38, __q39,
    __q40, __q41, __q42, __q43, __q44, __q45, __q46, __q47,
    __q48, __q49, __q50, __q51, __q52, __q53, __q54, __q55,
    __q56, __q57, __q58, __q59, __q60, __q61, __q62, __q63
  };
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_pd (double __A, double __B, double __C, double __D,
        double __E, double __F, double __G, double __H)
{
  return __extension__ (__m512d)
  { __H, __G, __F, __E, __D, __C, __B, __A };
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_ps (float __A, float __B, float __C, float __D,
        float __E, float __F, float __G, float __H,
        float __I, float __J, float __K, float __L,
        float __M, float __N, float __O, float __P)
{
  return __extension__ (__m512)
  { __P, __O, __N, __M, __L, __K, __J, __I,
    __H, __G, __F, __E, __D, __C, __B, __A };
}
# 184 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_undefined_ps (void)
{
  __m512 __Y = __Y;
  return __Y;
}



extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_undefined_pd (void)
{
  __m512d __Y = __Y;
  return __Y;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_undefined_epi32 (void)
{
  __m512i __Y = __Y;
  return __Y;
}



extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_epi8 (char __A)
{
  return __extension__ (__m512i)(__v64qi)
  { __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_epi16 (short __A)
{
  return __extension__ (__m512i)(__v32hi)
  { __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A,
    __A, __A, __A, __A, __A, __A, __A, __A };
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_pd (double __A)
{
  return __extension__ (__m512d)(__v8df)
    { __A, __A, __A, __A, __A, __A, __A, __A };
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_ps (float __A)
{
  return __extension__ (__m512)(__v16sf)
    { __A, __A, __A, __A, __A, __A, __A, __A,
      __A, __A, __A, __A, __A, __A, __A, __A };
}


extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set4_epi32 (int __A, int __B, int __C, int __D)
{
  return __extension__ (__m512i)(__v16si)
  { __D, __C, __B, __A, __D, __C, __B, __A,
    __D, __C, __B, __A, __D, __C, __B, __A };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set4_epi64 (long long __A, long long __B, long long __C,
     long long __D)
{
  return __extension__ (__m512i) (__v8di)
  { __D, __C, __B, __A, __D, __C, __B, __A };
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set4_pd (double __A, double __B, double __C, double __D)
{
  return __extension__ (__m512d)
  { __D, __C, __B, __A, __D, __C, __B, __A };
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set4_ps (float __A, float __B, float __C, float __D)
{
  return __extension__ (__m512)
  { __D, __C, __B, __A, __D, __C, __B, __A,
    __D, __C, __B, __A, __D, __C, __B, __A };
}
# 303 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero_ps (void)
{
  return __extension__ (__m512){ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero (void)
{
  return _mm512_setzero_ps ();
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero_pd (void)
{
  return __extension__ (__m512d) { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero_epi32 (void)
{
  return __extension__ (__m512i)(__v8di){ 0, 0, 0, 0, 0, 0, 0, 0 };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero_si512 (void)
{
  return __extension__ (__m512i)(__v8di){ 0, 0, 0, 0, 0, 0, 0, 0 };
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_movapd512_mask ((__v8df) __A,
        (__v8df) __W,
        (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_movapd512_mask ((__v8df) __A,
        (__v8df)
        _mm512_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movaps512_mask ((__v16sf) __A,
       (__v16sf) __W,
       (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movaps512_mask ((__v16sf) __A,
       (__v16sf)
       _mm512_setzero_ps (),
       (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_pd (void const *__P)
{
  return *(__m512d *) __P;
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_load_pd (__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *) __P,
         (__v8df) __W,
         (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_load_pd (__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *) __P,
         (__v8df)
         _mm512_setzero_pd (),
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_pd (void *__P, __m512d __A)
{
  *(__m512d *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_store_pd (void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeapd512_mask ((__v8df *) __P, (__v8df) __A,
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_ps (void const *__P)
{
  return *(__m512 *) __P;
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_load_ps (__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *) __P,
        (__v16sf) __W,
        (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_load_ps (__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *) __P,
        (__v16sf)
        _mm512_setzero_ps (),
        (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_ps (void *__P, __m512 __A)
{
  *(__m512 *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_store_ps (void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeaps512_mask ((__v16sf *) __P, (__v16sf) __A,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdqa64_512_mask ((__v8di) __A,
           (__v8di) __W,
           (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdqa64_512_mask ((__v8di) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_epi64 (void const *__P)
{
  return *(__m512i *) __P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_load_epi64 (__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa64load512_mask ((const __v8di *) __P,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa64load512_mask ((const __v8di *) __P,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_epi64 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_store_epi64 (void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_movdqa64store512_mask ((__v8di *) __P, (__v8di) __A,
     (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdqa32_512_mask ((__v16si) __A,
           (__v16si) __W,
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdqa32_512_mask ((__v16si) __A,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_si512 (void const *__P)
{
  return *(__m512i *) __P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_epi32 (void const *__P)
{
  return *(__m512i *) __P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_load_epi32 (__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa32load512_mask ((const __v16si *) __P,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_load_epi32 (__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_movdqa32load512_mask ((const __v16si *) __P,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_si512 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_epi32 (void *__P, __m512i __A)
{
  *(__m512i *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_store_epi32 (void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_movdqa32store512_mask ((__v16si *) __P, (__v16si) __A,
     (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mullo_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A * (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mullo_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulld512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mullo_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulld512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mullox_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A * (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mullox_epi64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return _mm512_mask_mov_epi64 (__W, __M, _mm512_mullox_epi64 (__A, __B));
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sllv_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sllv_epi32 (__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sllv_epi32 (__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srav_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srav_epi32 (__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srav_epi32 (__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srlv_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srlv_epi32 (__m512i __W, __mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srlv_epi32 (__mmask16 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv16si_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A + (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A - (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sllv_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_undefined_pd (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sllv_epi64 (__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sllv_epi64 (__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psllv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srav_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srav_epi64 (__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srav_epi64 (__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrav8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srlv_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srlv_epi64 (__m512i __W, __mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srlv_epi64 (__mmask8 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_psrlv8di_mask ((__v8di) __X,
       (__v8di) __Y,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A + (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mul_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mul_epi32 (__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mul_epi32 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
        (__v16si) __Y,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A - (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mul_epu32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
         (__v16si) __Y,
         (__v8di)
         _mm512_undefined_epi32 (),
         (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mul_epu32 (__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
         (__v16si) __Y,
         (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mul_epu32 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
         (__v16si) __Y,
         (__v8di)
         _mm512_setzero_si512 (),
         __M);
}
# 1047 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sll_epi64 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psllq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sll_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psllq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sll_epi64 (__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psllq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}
# 1126 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srl_epi64 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srl_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srl_epi64 (__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}
# 1205 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sra_epi64 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psraq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sra_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psraq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sra_epi64 (__mmask8 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psraq512_mask ((__v8di) __A,
       (__v2di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}
# 1284 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sll_epi32 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_pslld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sll_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_pslld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sll_epi32 (__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_pslld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}
# 1363 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srl_epi32 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srl_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srl_epi32 (__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrld512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}
# 1442 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sra_epi32 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrad512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sra_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrad512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sra_epi32 (__mmask16 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrad512_mask ((__v16si) __A,
       (__v4si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}
# 1644 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
typedef enum
{
  _MM_TERNLOG_A = 0xF0,
  _MM_TERNLOG_B = 0xCC,
  _MM_TERNLOG_C = 0xAA
} _MM_TERNLOG_ENUM;
# 1774 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rcp14_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
         (__v8df)
         _mm512_undefined_pd (),
         (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rcp14_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
         (__v8df) __W,
         (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rcp14_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
         (__v8df)
         _mm512_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rcp14_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
        (__v16sf)
        _mm512_undefined_ps (),
        (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rcp14_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
        (__v16sf) __W,
        (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rcp14_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
        (__v16sf)
        _mm512_setzero_ps (),
        (__mmask16) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp14_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rcp14sd ((__v2df) __B,
        (__v2df) __A);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp14_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rcp14sd_mask ((__v2df) __B,
      (__v2df) __A,
      (__v2df) __W,
      (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp14_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rcp14sd_mask ((__v2df) __B,
      (__v2df) __A,
      (__v2df) _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp14_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rcp14ss ((__v4sf) __B,
       (__v4sf) __A);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp14_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rcp14ss_mask ((__v4sf) __B,
      (__v4sf) __A,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp14_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rcp14ss_mask ((__v4sf) __B,
      (__v4sf) __A,
      (__v4sf) _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rsqrt14_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
           (__v8df)
           _mm512_undefined_pd (),
           (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rsqrt14_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
           (__v8df) __W,
           (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rsqrt14_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rsqrt14_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
          (__v16sf)
          _mm512_undefined_ps (),
          (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rsqrt14_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
          (__v16sf) __W,
          (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rsqrt14_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
          (__v16sf)
          _mm512_setzero_ps (),
          (__mmask16) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt14_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rsqrt14sd ((__v2df) __B,
          (__v2df) __A);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt14_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rsqrt14sd_mask ((__v2df) __B,
       (__v2df) __A,
       (__v2df) __W,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt14_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rsqrt14sd_mask ((__v2df) __B,
       (__v2df) __A,
       (__v2df) _mm_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt14_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rsqrt14ss ((__v4sf) __B,
         (__v4sf) __A);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt14_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rsqrt14ss_mask ((__v4sf) __B,
       (__v4sf) __A,
       (__v4sf) __W,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt14_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rsqrt14ss_mask ((__v4sf) __B,
      (__v4sf) __A,
      (__v4sf) _mm_setzero_ps (),
      (__mmask8) __U);
}
# 2181 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi8_epi32 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbd512_mask ((__v16qi) __A,
          (__v16si)
          _mm512_undefined_epi32 (),
          (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi8_epi32 (__m512i __W, __mmask16 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbd512_mask ((__v16qi) __A,
          (__v16si) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi8_epi32 (__mmask16 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbd512_mask ((__v16qi) __A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi8_epi64 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbq512_mask ((__v16qi) __A,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi8_epi64 (__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbq512_mask ((__v16qi) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbq512_mask ((__v16qi) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi16_epi32 (__m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwd512_mask ((__v16hi) __A,
          (__v16si)
          _mm512_undefined_epi32 (),
          (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi16_epi32 (__m512i __W, __mmask16 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwd512_mask ((__v16hi) __A,
          (__v16si) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi16_epi32 (__mmask16 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwd512_mask ((__v16hi) __A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi16_epi64 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwq512_mask ((__v8hi) __A,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi16_epi64 (__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwq512_mask ((__v8hi) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovsxwq512_mask ((__v8hi) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_epi64 (__m256i __X)
{
  return (__m512i) __builtin_ia32_pmovsxdq512_mask ((__v8si) __X,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_epi64 (__m512i __W, __mmask8 __U, __m256i __X)
{
  return (__m512i) __builtin_ia32_pmovsxdq512_mask ((__v8si) __X,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_epi64 (__mmask8 __U, __m256i __X)
{
  return (__m512i) __builtin_ia32_pmovsxdq512_mask ((__v8si) __X,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu8_epi32 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbd512_mask ((__v16qi) __A,
          (__v16si)
          _mm512_undefined_epi32 (),
          (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu8_epi32 (__m512i __W, __mmask16 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbd512_mask ((__v16qi) __A,
          (__v16si) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu8_epi32 (__mmask16 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbd512_mask ((__v16qi) __A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu8_epi64 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbq512_mask ((__v16qi) __A,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu8_epi64 (__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbq512_mask ((__v16qi) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbq512_mask ((__v16qi) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu16_epi32 (__m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwd512_mask ((__v16hi) __A,
          (__v16si)
          _mm512_undefined_epi32 (),
          (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu16_epi32 (__m512i __W, __mmask16 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwd512_mask ((__v16hi) __A,
          (__v16si) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu16_epi32 (__mmask16 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwd512_mask ((__v16hi) __A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu16_epi64 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwq512_mask ((__v8hi) __A,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu16_epi64 (__m512i __W, __mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwq512_mask ((__v8hi) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m512i) __builtin_ia32_pmovzxwq512_mask ((__v8hi) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu32_epi64 (__m256i __X)
{
  return (__m512i) __builtin_ia32_pmovzxdq512_mask ((__v8si) __X,
          (__v8di)
          _mm512_undefined_epi32 (),
          (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu32_epi64 (__m512i __W, __mmask8 __U, __m256i __X)
{
  return (__m512i) __builtin_ia32_pmovzxdq512_mask ((__v8si) __X,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu32_epi64 (__mmask8 __U, __m256i __X)
{
  return (__m512i) __builtin_ia32_pmovzxdq512_mask ((__v8si) __X,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U);
}
# 4026 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
       (__v8di)
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_abs_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_abs_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastss_ps (__m128 __A)
{
  return (__m512) __builtin_ia32_broadcastss512 ((__v4sf) __A,
       (__v16sf)
       _mm512_undefined_ps (),
       (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastss_ps (__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastss512 ((__v4sf) __A,
       (__v16sf) __O, __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastss_ps (__mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastss512 ((__v4sf) __A,
       (__v16sf)
       _mm512_setzero_ps (),
       __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastsd_pd (__m128d __A)
{
  return (__m512d) __builtin_ia32_broadcastsd512 ((__v2df) __A,
        (__v8df)
        _mm512_undefined_pd (),
        (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastsd_pd (__m512d __O, __mmask8 __M, __m128d __A)
{
  return (__m512d) __builtin_ia32_broadcastsd512 ((__v2df) __A,
        (__v8df) __O, __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastsd_pd (__mmask8 __M, __m128d __A)
{
  return (__m512d) __builtin_ia32_broadcastsd512 ((__v2df) __A,
        (__v8df)
        _mm512_setzero_pd (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastd_epi32 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512 ((__v4si) __A,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastd_epi32 (__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512 ((__v4si) __A,
        (__v16si) __O, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastd_epi32 (__mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512 ((__v4si) __A,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_epi32 (int __A)
{
  return (__m512i)(__v16si)
    { __A, __A, __A, __A, __A, __A, __A, __A,
      __A, __A, __A, __A, __A, __A, __A, __A };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_set1_epi32 (__m512i __O, __mmask16 __M, int __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512_gpr_mask (__A, (__v16si) __O,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_set1_epi32 (__mmask16 __M, int __A)
{
  return (__m512i)
  __builtin_ia32_pbroadcastd512_gpr_mask (__A,
       (__v16si) _mm512_setzero_si512 (),
       __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastq_epi64 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512 ((__v2di) __A,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastq_epi64 (__m512i __O, __mmask8 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512 ((__v2di) __A,
        (__v8di) __O, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512 ((__v2di) __A,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_epi64 (long long __A)
{
  return (__m512i)(__v8di) { __A, __A, __A, __A, __A, __A, __A, __A };
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_set1_epi64 (__m512i __O, __mmask8 __M, long long __A)
{
  return (__m512i) __builtin_ia32_pbroadcastq512_gpr_mask (__A, (__v8di) __O,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_set1_epi64 (__mmask8 __M, long long __A)
{
  return (__m512i)
  __builtin_ia32_pbroadcastq512_gpr_mask (__A,
       (__v8di) _mm512_setzero_si512 (),
       __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_f32x4 (__m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x4_512 ((__v4sf) __A,
           (__v16sf)
           _mm512_undefined_ps (),
           (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_f32x4 (__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x4_512 ((__v4sf) __A,
           (__v16sf) __O,
           __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_f32x4 (__mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x4_512 ((__v4sf) __A,
           (__v16sf)
           _mm512_setzero_ps (),
           __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_i32x4 (__m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x4_512 ((__v4si) __A,
            (__v16si)
            _mm512_undefined_epi32 (),
            (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_i32x4 (__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x4_512 ((__v4si) __A,
            (__v16si) __O,
            __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_i32x4 (__mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x4_512 ((__v4si) __A,
            (__v16si)
            _mm512_setzero_si512 (),
            __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_f64x4 (__m256d __A)
{
  return (__m512d) __builtin_ia32_broadcastf64x4_512 ((__v4df) __A,
            (__v8df)
            _mm512_undefined_pd (),
            (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_f64x4 (__m512d __O, __mmask8 __M, __m256d __A)
{
  return (__m512d) __builtin_ia32_broadcastf64x4_512 ((__v4df) __A,
            (__v8df) __O,
            __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_f64x4 (__mmask8 __M, __m256d __A)
{
  return (__m512d) __builtin_ia32_broadcastf64x4_512 ((__v4df) __A,
            (__v8df)
            _mm512_setzero_pd (),
            __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_i64x4 (__m256i __A)
{
  return (__m512i) __builtin_ia32_broadcasti64x4_512 ((__v4di) __A,
            (__v8di)
            _mm512_undefined_epi32 (),
            (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_i64x4 (__m512i __O, __mmask8 __M, __m256i __A)
{
  return (__m512i) __builtin_ia32_broadcasti64x4_512 ((__v4di) __A,
            (__v8di) __O,
            __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_i64x4 (__mmask8 __M, __m256i __A)
{
  return (__m512i) __builtin_ia32_broadcasti64x4_512 ((__v4di) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            __M);
}

typedef enum
{
  _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
  _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
  _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
  _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
  _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
  _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
  _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
  _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
  _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
  _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
  _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
  _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
  _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
  _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
  _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
  _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
  _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
  _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
  _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
  _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
  _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
  _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
  _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
  _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
  _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
  _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
  _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
  _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
  _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
  _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
  _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
  _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
  _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
  _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
  _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
  _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
  _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
  _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
  _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
  _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
  _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
  _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
  _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
  _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
  _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
  _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
  _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
  _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
  _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
  _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
  _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
  _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
  _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
  _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
  _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
  _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
  _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
  _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
  _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
  _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
  _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
  _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
  _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
  _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
  _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
  _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
  _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
  _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
  _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
  _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
  _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
  _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
  _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
  _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
  _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
  _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
  _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
  _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
  _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
  _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
  _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
  _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
  _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
  _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
  _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
  _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;
# 4716 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rolv_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rolv_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rolv_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rorv_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rorv_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rorv_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rolv_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rolv_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W,
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rolv_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prolvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rorv_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rorv_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W,
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rorv_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_prorvq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        (__mmask8) __U);
}
# 5164 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu32_sd (__m128d __A, unsigned __B)
{
  return (__m128d) __builtin_ia32_cvtusi2sd32 ((__v2df) __A, __B);
}
# 5273 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovdb512_mask ((__v16si) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovsdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb512_mask ((__v16si) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi32_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovusdb512mem_mask ((__v16qi *) __P, (__v16si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi32_epi8 (__m128i __O, __mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi32_epi8 (__mmask16 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb512_mask ((__v16si) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
        (__v16hi)
        _mm256_undefined_si256 (),
        (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_storeu_epi16 (void * __P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovdw512mem_mask ((__v16hi *) __P, (__v16si) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
        (__v16hi) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovdw512_mask ((__v16si) __A,
        (__v16hi)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
         (__v16hi)
         _mm256_undefined_si256 (),
         (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi32_storeu_epi16 (void *__P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovsdw512mem_mask ((__v16hi*) __P, (__v16si) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
         (__v16hi) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsdw512_mask ((__v16si) __A,
         (__v16hi)
         _mm256_setzero_si256 (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi32_epi16 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
          (__v16hi)
          _mm256_undefined_si256 (),
          (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi32_storeu_epi16 (void *__P, __mmask16 __M, __m512i __A)
{
  __builtin_ia32_pmovusdw512mem_mask ((__v16hi*) __P, (__v16si) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi32_epi16 (__m256i __O, __mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
          (__v16hi) __O,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi32_epi16 (__mmask16 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusdw512_mask ((__v16si) __A,
          (__v16hi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
        (__v8si)
        _mm256_undefined_si256 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_storeu_epi32 (void* __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqd512mem_mask ((__v8si *) __P, (__v8di) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
        (__v8si) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovqd512_mask ((__v8di) __A,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
         (__v8si)
         _mm256_undefined_si256 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_storeu_epi32 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqd512mem_mask ((__v8si *) __P, (__v8di) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
         (__v8si) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovsqd512_mask ((__v8di) __A,
         (__v8si)
         _mm256_setzero_si256 (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi64_epi32 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
          (__v8si)
          _mm256_undefined_si256 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_storeu_epi32 (void* __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqd512mem_mask ((__v8si*) __P, (__v8di) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_epi32 (__m256i __O, __mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
          (__v8si) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi64_epi32 (__mmask8 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovusqd512_mask ((__v8di) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
        (__v8hi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_storeu_epi16 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqw512mem_mask ((__v8hi *) __P, (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
        (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqw512_mask ((__v8di) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
         (__v8hi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqw512mem_mask ((__v8hi *) __P, (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
         (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw512_mask ((__v8di) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi64_epi16 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
          (__v8hi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_storeu_epi16 (void *__P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqw512mem_mask ((__v8hi*) __P, (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
          (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi64_epi16 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw512_mask ((__v8di) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovqb512mem_mask ((unsigned long long *) __P,
        (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovqb512_mask ((__v8di) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovsqb512mem_mask ((unsigned long long *) __P, (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb512_mask ((__v8di) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi64_epi8 (__m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m512i __A)
{
  __builtin_ia32_pmovusqb512mem_mask ((unsigned long long *) __P, (__v8di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi64_epi8 (__mmask8 __M, __m512i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb512_mask ((__v8di) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_pd (__m256i __A)
{
  return (__m512d) __builtin_ia32_cvtdq2pd512_mask ((__v8si) __A,
          (__v8df)
          _mm512_undefined_pd (),
          (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_pd (__m512d __W, __mmask8 __U, __m256i __A)
{
  return (__m512d) __builtin_ia32_cvtdq2pd512_mask ((__v8si) __A,
          (__v8df) __W,
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_pd (__mmask8 __U, __m256i __A)
{
  return (__m512d) __builtin_ia32_cvtdq2pd512_mask ((__v8si) __A,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu32_pd (__m256i __A)
{
  return (__m512d) __builtin_ia32_cvtudq2pd512_mask ((__v8si) __A,
           (__v8df)
           _mm512_undefined_pd (),
           (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu32_pd (__m512d __W, __mmask8 __U, __m256i __A)
{
  return (__m512d) __builtin_ia32_cvtudq2pd512_mask ((__v8si) __A,
           (__v8df) __W,
           (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu32_pd (__mmask8 __U, __m256i __A)
{
  return (__m512d) __builtin_ia32_cvtudq2pd512_mask ((__v8si) __A,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) __U);
}
# 6288 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_pd (void const *__P)
{
  return *(__m512d_u *)__P;
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_pd (__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadupd512_mask ((const double *) __P,
         (__v8df) __W,
         (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_pd (__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadupd512_mask ((const double *) __P,
         (__v8df)
         _mm512_setzero_pd (),
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_pd (void *__P, __m512d __A)
{
  *(__m512d_u *)__P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_pd (void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeupd512_mask ((double *) __P, (__v8df) __A,
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_ps (void const *__P)
{
  return *(__m512_u *)__P;
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_ps (__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadups512_mask ((const float *) __P,
        (__v16sf) __W,
        (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_ps (__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadups512_mask ((const float *) __P,
        (__v16sf)
        _mm512_setzero_ps (),
        (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_ps (void *__P, __m512 __A)
{
  *(__m512_u *)__P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_ps (void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeups512_mask ((float *) __P, (__v16sf) __A,
       (__mmask16) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_ss (__m128 __W, __mmask8 __U, const float *__P)
{
  return (__m128) __builtin_ia32_loadss_mask (__P, (__v4sf) __W, __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_ss (__mmask8 __U, const float *__P)
{
  return (__m128) __builtin_ia32_loadss_mask (__P, (__v4sf) _mm_setzero_ps (),
           __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_sd (__m128d __W, __mmask8 __U, const double *__P)
{
  return (__m128d) __builtin_ia32_loadsd_mask (__P, (__v2df) __W, __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_sd (__mmask8 __U, const double *__P)
{
  return (__m128d) __builtin_ia32_loadsd_mask (__P, (__v2df) _mm_setzero_pd (),
            __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_move_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movess_mask ((__v4sf) __A, (__v4sf) __B,
           (__v4sf) __W, __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_move_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movess_mask ((__v4sf) __A, (__v4sf) __B,
           (__v4sf) _mm_setzero_ps (), __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_move_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movesd_mask ((__v2df) __A, (__v2df) __B,
            (__v2df) __W, __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_move_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movesd_mask ((__v2df) __A, (__v2df) __B,
            (__v2df) _mm_setzero_pd (),
            __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_ss (float *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storess_mask (__P, (__v4sf) __A, (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_sd (double *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storesd_mask (__P, (__v2df) __A, (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_epi64 (void const *__P)
{
  return *(__m512i_u *) __P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_epi64 (__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqudi512_mask ((const long long *) __P,
           (__v8di) __W,
           (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqudi512_mask ((const long long *) __P,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_epi64 (void *__P, __m512i __A)
{
  *(__m512i_u *) __P = (__m512i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_epi64 (void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_storedqudi512_mask ((long long *) __P, (__v8di) __A,
         (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_si512 (void const *__P)
{
  return *(__m512i_u *)__P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_epi32 (void const *__P)
{
  return *(__m512i_u *) __P;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_epi32 (__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const int *) __P,
           (__v16si) __W,
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_epi32 (__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const int *) __P,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_si512 (void *__P, __m512i __A)
{
  *(__m512i_u *)__P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_epi32 (void *__P, __m512i __A)
{
  *(__m512i_u *) __P = (__m512i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_epi32 (void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_storedqusi512_mask ((int *) __P, (__v16si) __A,
         (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutevar_pd (__m512d __A, __m512i __C)
{
  return (__m512d) __builtin_ia32_vpermilvarpd512_mask ((__v8df) __A,
       (__v8di) __C,
       (__v8df)
       _mm512_undefined_pd (),
       (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutevar_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512i __C)
{
  return (__m512d) __builtin_ia32_vpermilvarpd512_mask ((__v8df) __A,
       (__v8di) __C,
       (__v8df) __W,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutevar_pd (__mmask8 __U, __m512d __A, __m512i __C)
{
  return (__m512d) __builtin_ia32_vpermilvarpd512_mask ((__v8df) __A,
       (__v8di) __C,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutevar_ps (__m512 __A, __m512i __C)
{
  return (__m512) __builtin_ia32_vpermilvarps512_mask ((__v16sf) __A,
             (__v16si) __C,
             (__v16sf)
             _mm512_undefined_ps (),
             (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutevar_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512i __C)
{
  return (__m512) __builtin_ia32_vpermilvarps512_mask ((__v16sf) __A,
             (__v16si) __C,
             (__v16sf) __W,
             (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutevar_ps (__mmask16 __U, __m512 __A, __m512i __C)
{
  return (__m512) __builtin_ia32_vpermilvarps512_mask ((__v16sf) __A,
             (__v16si) __C,
             (__v16sf)
             _mm512_setzero_ps (),
             (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_epi64 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_mask ((__v8di) __I
                       ,
             (__v8di) __A,
             (__v8di) __B,
             (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_epi64 (__m512i __A, __mmask8 __U, __m512i __I,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_mask ((__v8di) __I
                       ,
             (__v8di) __A,
             (__v8di) __B,
             (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_epi64 (__m512i __A, __m512i __I,
     __mmask8 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varq512_mask ((__v8di) __A,
             (__v8di) __I
                       ,
             (__v8di) __B,
             (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_epi64 (__mmask8 __U, __m512i __A,
     __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_maskz ((__v8di) __I
                 ,
       (__v8di) __A,
       (__v8di) __B,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_epi32 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_mask ((__v16si) __I
                       ,
             (__v16si) __A,
             (__v16si) __B,
             (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_epi32 (__m512i __A, __mmask16 __U,
    __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_mask ((__v16si) __I
                       ,
             (__v16si) __A,
             (__v16si) __B,
             (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_epi32 (__m512i __A, __m512i __I,
     __mmask16 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2vard512_mask ((__v16si) __A,
             (__v16si) __I
                       ,
             (__v16si) __B,
             (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_epi32 (__mmask16 __U, __m512i __A,
     __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_maskz ((__v16si) __I
                 ,
       (__v16si) __A,
       (__v16si) __B,
       (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_pd (__m512d __A, __m512i __I, __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_mask ((__v8di) __I
                 ,
       (__v8df) __A,
       (__v8df) __B,
       (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_pd (__m512d __A, __mmask8 __U, __m512i __I,
        __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_mask ((__v8di) __I
                 ,
       (__v8df) __A,
       (__v8df) __B,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_pd (__m512d __A, __m512i __I, __mmask8 __U,
         __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermi2varpd512_mask ((__v8df) __A,
       (__v8di) __I
                 ,
       (__v8df) __B,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_pd (__mmask8 __U, __m512d __A, __m512i __I,
         __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_maskz ((__v8di) __I
                  ,
        (__v8df) __A,
        (__v8df) __B,
        (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_ps (__m512 __A, __m512i __I, __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_mask ((__v16si) __I
                       ,
             (__v16sf) __A,
             (__v16sf) __B,
             (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_ps (__m512 __A, __mmask16 __U, __m512i __I, __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_mask ((__v16si) __I
                       ,
             (__v16sf) __A,
             (__v16sf) __B,
             (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_ps (__m512 __A, __m512i __I, __mmask16 __U,
         __m512 __B)
{
  return (__m512) __builtin_ia32_vpermi2varps512_mask ((__v16sf) __A,
             (__v16si) __I
                       ,
             (__v16sf) __B,
             (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_ps (__mmask16 __U, __m512 __A, __m512i __I,
         __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_maskz ((__v16si) __I
                 ,
       (__v16sf) __A,
       (__v16sf) __B,
       (__mmask16) __U);
}
# 6979 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_epi64 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
           (__v8di) __X,
           (__v8di)
           _mm512_setzero_si512 (),
           __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_epi64 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
           (__v8di) __X,
           (__v8di)
           _mm512_undefined_epi32 (),
           (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_epi64 (__m512i __W, __mmask8 __M, __m512i __X,
          __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvardi512_mask ((__v8di) __Y,
           (__v8di) __X,
           (__v8di) __W,
           __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_epi32 (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
           (__v16si) __X,
           (__v16si)
           _mm512_setzero_si512 (),
           __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_epi32 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
           (__v16si) __X,
           (__v16si)
           _mm512_undefined_epi32 (),
           (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_epi32 (__m512i __W, __mmask16 __M, __m512i __X,
          __m512i __Y)
{
  return (__m512i) __builtin_ia32_permvarsi512_mask ((__v16si) __Y,
           (__v16si) __X,
           (__v16si) __W,
           __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_pd (__m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
           (__v8di) __X,
           (__v8df)
           _mm512_undefined_pd (),
           (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_pd (__m512d __W, __mmask8 __U, __m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
           (__v8di) __X,
           (__v8df) __W,
           (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_pd (__mmask8 __U, __m512i __X, __m512d __Y)
{
  return (__m512d) __builtin_ia32_permvardf512_mask ((__v8df) __Y,
           (__v8di) __X,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_ps (__m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
          (__v16si) __X,
          (__v16sf)
          _mm512_undefined_ps (),
          (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_ps (__m512 __W, __mmask16 __U, __m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
          (__v16si) __X,
          (__v16sf) __W,
          (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_ps (__mmask16 __U, __m512i __X, __m512 __Y)
{
  return (__m512) __builtin_ia32_permvarsf512_mask ((__v16sf) __Y,
          (__v16si) __X,
          (__v16sf)
          _mm512_setzero_ps (),
          (__mmask16) __U);
}
# 7414 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movehdup_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_movshdup512_mask ((__v16sf) __A,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_movehdup_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movshdup512_mask ((__v16sf) __A,
         (__v16sf) __W,
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_movehdup_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movshdup512_mask ((__v16sf) __A,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_moveldup_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_movsldup512_mask ((__v16sf) __A,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_moveldup_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movsldup512_mask ((__v16sf) __A,
         (__v16sf) __W,
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_moveldup_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_movsldup512_mask ((__v16sf) __A,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_or_si512 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A | (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_or_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A | (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_or_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pord512_mask ((__v16si) __A,
      (__v16si) __B,
      (__v16si) __W,
      (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_or_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pord512_mask ((__v16si) __A,
      (__v16si) __B,
      (__v16si)
      _mm512_setzero_si512 (),
      (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_or_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A | (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_or_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_porq512_mask ((__v8di) __A,
      (__v8di) __B,
      (__v8di) __W,
      (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_or_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_porq512_mask ((__v8di) __A,
      (__v8di) __B,
      (__v8di)
      _mm512_setzero_si512 (),
      (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_xor_si512 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A ^ (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_xor_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A ^ (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_xor_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pxord512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_xor_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pxord512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_xor_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A ^ (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_xor_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pxorq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_xor_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pxorq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}
# 7779 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_and_si512 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A & (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_and_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16su) __A & (__v16su) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_and_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_and_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandd512_mask ((__v16si) __A,
       (__v16si) __B,
       (__v16si)
       _mm512_setzero_si512 (),
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_and_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A & (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_and_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di) __W, __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_and_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandq512_mask ((__v8di) __A,
       (__v8di) __B,
       (__v8di)
       _mm512_setzero_pd (),
       __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_andnot_si512 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_andnot_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_andnot_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_andnot_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_andnot_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_andnot_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W, __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_andnot_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_pd (),
        __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_test_epi32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestmd512 ((__v16si) __A,
      (__v16si) __B,
      (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_test_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestmd512 ((__v16si) __A,
      (__v16si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_test_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq512 ((__v8di) __A,
            (__v8di) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_test_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq512 ((__v8di) __A, (__v8di) __B, __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_testn_epi32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmd512 ((__v16si) __A,
       (__v16si) __B,
       (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_testn_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmd512 ((__v16si) __A,
       (__v16si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_testn_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq512 ((__v8di) __A,
      (__v8di) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_testn_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq512 ((__v8di) __A,
      (__v8di) __B, __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_ps (__m512 __A)
{
  return (__m512) _mm512_and_epi32 ((__m512i) __A,
        _mm512_set1_epi32 (0x7fffffff));
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) _mm512_mask_and_epi32 ((__m512i) __W, __U, (__m512i) __A,
      _mm512_set1_epi32 (0x7fffffff));
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_pd (__m512d __A)
{
  return (__m512d) _mm512_and_epi64 ((__m512i) __A,
         _mm512_set1_epi64 (0x7fffffffffffffffLL));
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d)
  _mm512_mask_and_epi64 ((__m512i) __W, __U, (__m512i) __A,
    _mm512_set1_epi64 (0x7fffffffffffffffLL));
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhdq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si)
           _mm512_undefined_epi32 (),
           (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_epi32 (__m512i __W, __mmask16 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhdq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si) __W,
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhdq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di)
            _mm512_undefined_epi32 (),
            (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di) __W,
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckldq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si)
           _mm512_undefined_epi32 (),
           (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_epi32 (__m512i __W, __mmask16 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckldq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si) __W,
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckldq512_mask ((__v16si) __A,
           (__v16si) __B,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di)
            _mm512_undefined_epi32 (),
            (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di) __W,
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklqdq512_mask ((__v8di) __A,
            (__v8di) __B,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U);
}
# 8397 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movedup_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_movddup512_mask ((__v8df) __A,
         (__v8df)
         _mm512_undefined_pd (),
         (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_movedup_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_movddup512_mask ((__v8df) __A,
         (__v8df) __W,
         (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_movedup_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_movddup512_mask ((__v8df) __A,
         (__v8df)
         _mm512_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpcklpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_undefined_pd (),
          (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpcklpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __W,
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpcklpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpckhpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_undefined_pd (),
          (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpckhpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __W,
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_unpckhpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpckhps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpckhps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __W,
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpckhps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U);
}
# 8826 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_stream_si512 (__m512i * __P, __m512i __A)
{
  __builtin_ia32_movntdq512 ((__v8di *) __P, (__v8di) __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_stream_ps (float *__P, __m512 __A)
{
  __builtin_ia32_movntps512 (__P, (__v16sf) __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_stream_pd (double *__P, __m512d __A)
{
  __builtin_ia32_movntpd512 (__P, (__v8df) __A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_stream_load_si512 (void *__P)
{
  return __builtin_ia32_movntdqa512 ((__v8di *)__P);
}


typedef enum
{
  _MM_MANT_NORM_1_2,
  _MM_MANT_NORM_p5_2,
  _MM_MANT_NORM_p5_1,
  _MM_MANT_NORM_p75_1p5
} _MM_MANTISSA_NORM_ENUM;

typedef enum
{
  _MM_MANT_SIGN_src,
  _MM_MANT_SIGN_zero,
  _MM_MANT_SIGN_nan
} _MM_MANTISSA_SIGN_ENUM;
# 9498 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_floor_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
        (0x01 | 0x00),
        (__v16sf) __A, -1,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_floor_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
         (0x01 | 0x00),
         (__v8df) __A, -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_ceil_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
        (0x02 | 0x00),
        (__v16sf) __A, -1,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_ceil_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
         (0x02 | 0x00),
         (__v8df) __A, -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_floor_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
        (0x01 | 0x00),
        (__v16sf) __W, __U,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_floor_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
         (0x01 | 0x00),
         (__v8df) __W, __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_ceil_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
        (0x02 | 0x00),
        (__v16sf) __W, __U,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_ceil_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
         (0x02 | 0x00),
         (__v8df) __W, __U,
         0x04);
}
# 9677 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epi32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqd512_mask ((__v16si) __A,
           (__v16si) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqd512_mask ((__v16si) __A,
           (__v16si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq512_mask ((__v8di) __A,
          (__v8di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq512_mask ((__v8di) __A,
          (__v8di) __B,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epi32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtd512_mask ((__v16si) __A,
           (__v16si) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epi32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtd512_mask ((__v16si) __A,
           (__v16si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epi64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq512_mask ((__v8di) __A,
          (__v8di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq512_mask ((__v8di) __A,
          (__v8di) __B,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epi32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 5,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epi32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 5,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epu32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 5,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epu32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 5,
          (__mmask16) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epi64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 5,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epi64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 5,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epu64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 5,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epu64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 5,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epi32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 2,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epi32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 2,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epu32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 2,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epu32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 2,
          (__mmask16) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epi64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 2,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epi64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 2,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epu64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 2,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epu64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 2,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epi32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 1,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epi32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 1,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epu32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 1,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epu32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 1,
          (__mmask16) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epi64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 1,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epi64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 1,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epu64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 1,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epu64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 1,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epi32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 4,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epi32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_cmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 4,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epu32_mask (__mmask16 __M, __m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 4,
          (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epu32_mask (__m512i __X, __m512i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __X,
          (__v16si) __Y, 4,
          (__mmask16) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epi64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 4,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epi64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 4,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epu64_mask (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 4,
          (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epu64_mask (__m512i __X, __m512i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __X,
          (__v8di) __Y, 4,
          (__mmask8) -1);
}
# 10825 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_compressdf512_mask ((__v8df) __A,
            (__v8df) __W,
            (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_compressdf512_mask ((__v8df) __A,
            (__v8df)
            _mm512_setzero_pd (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_compressstoredf512_mask ((__v8df *) __P, (__v8df) __A,
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_compresssf512_mask ((__v16sf) __A,
           (__v16sf) __W,
           (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_compresssf512_mask ((__v16sf) __A,
           (__v16sf)
           _mm512_setzero_ps (),
           (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_ps (void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_compressstoresf512_mask ((__v16sf *) __P, (__v16sf) __A,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compressdi512_mask ((__v8di) __A,
            (__v8di) __W,
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compressdi512_mask ((__v8di) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_compressstoredi512_mask ((__v8di *) __P, (__v8di) __A,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compresssi512_mask ((__v16si) __A,
            (__v16si) __W,
            (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_compresssi512_mask ((__v16si) __A,
            (__v16si)
            _mm512_setzero_si512 (),
            (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_epi32 (void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_compressstoresi512_mask ((__v16si *) __P, (__v16si) __A,
       (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_expanddf512_mask ((__v8df) __A,
          (__v8df) __W,
          (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_expanddf512_maskz ((__v8df) __A,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_pd (__m512d __W, __mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_expandloaddf512_mask ((const __v8df *) __P,
       (__v8df) __W,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_pd (__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_expandloaddf512_maskz ((const __v8df *) __P,
        (__v8df)
        _mm512_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_expandsf512_mask ((__v16sf) __A,
         (__v16sf) __W,
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_expandsf512_maskz ((__v16sf) __A,
          (__v16sf)
          _mm512_setzero_ps (),
          (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_ps (__m512 __W, __mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_expandloadsf512_mask ((const __v16sf *) __P,
             (__v16sf) __W,
             (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_ps (__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_expandloadsf512_maskz ((const __v16sf *) __P,
       (__v16sf)
       _mm512_setzero_ps (),
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expanddi512_mask ((__v8di) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expanddi512_maskz ((__v8di) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_epi64 (__m512i __W, __mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloaddi512_mask ((const __v8di *) __P,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m512i)
  __builtin_ia32_expandloaddi512_maskz ((const __v8di *) __P,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expandsi512_mask ((__v16si) __A,
          (__v16si) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_expandsi512_maskz ((__v16si) __A,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_epi32 (__m512i __W, __mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloadsi512_mask ((const __v16si *) __P,
       (__v16si) __W,
       (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_epi32 (__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_expandloadsi512_maskz ((const __v16si *) __P,
        (__v16si)
        _mm512_setzero_si512
        (), (__mmask16) __U);
}
# 11094 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortest_mask16_u8 (__mmask16 __A, __mmask16 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_kortestchi (__A, __B);
  return (unsigned char) __builtin_ia32_kortestzhi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestz_mask16_u8 (__mmask16 __A, __mmask16 __B)
{
  return (unsigned char) __builtin_ia32_kortestzhi ((__mmask16) __A,
          (__mmask16) __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestc_mask16_u8 (__mmask16 __A, __mmask16 __B)
{
  return (unsigned char) __builtin_ia32_kortestchi ((__mmask16) __A,
          (__mmask16) __B);
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtmask16_u32 (__mmask16 __A)
{
  return (unsigned int) __builtin_ia32_kmovw ((__mmask16 ) __A);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtu32_mask16 (unsigned int __A)
{
  return (__mmask16) __builtin_ia32_kmovw ((__mmask16 ) __A);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_load_mask16 (__mmask16 *__A)
{
  return (__mmask16) __builtin_ia32_kmovw (*(__mmask16 *) __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_store_mask16 (__mmask16 *__A, __mmask16 __B)
{
  *(__mmask16 *) __A = __builtin_ia32_kmovw (__B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kand (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kandhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kandn (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kandnhi ((__mmask16) __A,
          (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_korhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kortestz (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kortestzhi ((__mmask16) __A,
      (__mmask16) __B);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kortestc (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kortestchi ((__mmask16) __A,
      (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kxnor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kxnorhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kxor (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kxorhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_knot (__mmask16 __A)
{
  return (__mmask16) __builtin_ia32_knothi ((__mmask16) __A);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kunpackb (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kunpckhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kunpackb_mask16 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask16) __builtin_ia32_kunpckhi ((__mmask16) __A, (__mmask16) __B);
}
# 11289 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epi64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epi64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epi64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epi64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epu64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epu64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epu64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epu64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_undefined_epi32 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epu64 (__m512i __W, __mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epu64 (__mmask8 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epu32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epu32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epu32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epu32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_undefined_epi32 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epu32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si)
        _mm512_setzero_si512 (),
        __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epu32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
        (__v16si) __B,
        (__v16si) __W, __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpcklps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpcklps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __W,
         (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_unpcklps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U);
}
# 11737 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_blend_pd (__mmask8 __U, __m512d __A, __m512d __W)
{
  return (__m512d) __builtin_ia32_blendmpd_512_mask ((__v8df) __A,
           (__v8df) __W,
           (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_blend_ps (__mmask16 __U, __m512 __A, __m512 __W)
{
  return (__m512) __builtin_ia32_blendmps_512_mask ((__v16sf) __A,
          (__v16sf) __W,
          (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_blend_epi64 (__mmask8 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmq_512_mask ((__v8di) __A,
          (__v8di) __W,
          (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_blend_epi32 (__mmask16 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmd_512_mask ((__v16si) __A,
          (__v16si) __W,
          (__mmask16) __U);
}
# 11879 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask ((__v2df) __W,
        (__v2df) __A,
        (__v2df) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
       (__v4sf) __A,
       (__v4sf) __B,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_sd (__m128d __W, __m128d __A, __m128d __B, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask3 ((__v2df) __W,
         (__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_ss (__m128 __W, __m128 __A, __m128 __B, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask3 ((__v4sf) __W,
        (__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_sd (__mmask8 __U, __m128d __W, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_maskz ((__v2df) __W,
         (__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_ss (__mmask8 __U, __m128 __W, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __W,
        (__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask ((__v2df) __W,
        (__v2df) __A,
        -(__v2df) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
       (__v4sf) __A,
       -(__v4sf) __B,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_sd (__m128d __W, __m128d __A, __m128d __B, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubsd3_mask3 ((__v2df) __W,
         (__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_ss (__m128 __W, __m128 __A, __m128 __B, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubss3_mask3 ((__v4sf) __W,
        (__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_sd (__mmask8 __U, __m128d __W, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_maskz ((__v2df) __W,
         (__v2df) __A,
         -(__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_ss (__mmask8 __U, __m128 __W, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __W,
        (__v4sf) __A,
        -(__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask ((__v2df) __W,
        -(__v2df) __A,
        (__v2df) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
       -(__v4sf) __A,
       (__v4sf) __B,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_sd (__m128d __W, __m128d __A, __m128d __B, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask3 ((__v2df) __W,
         -(__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_ss (__m128 __W, __m128 __A, __m128 __B, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask3 ((__v4sf) __W,
        -(__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_sd (__mmask8 __U, __m128d __W, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_maskz ((__v2df) __W,
         -(__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_ss (__mmask8 __U, __m128 __W, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __W,
        -(__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_mask ((__v2df) __W,
        -(__v2df) __A,
        -(__v2df) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_mask ((__v4sf) __W,
       -(__v4sf) __A,
       -(__v4sf) __B,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_sd (__m128d __W, __m128d __A, __m128d __B, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubsd3_mask3 ((__v2df) __W,
         -(__v2df) __A,
         (__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_ss (__m128 __W, __m128 __A, __m128 __B, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubss3_mask3 ((__v4sf) __W,
        -(__v4sf) __A,
        (__v4sf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_sd (__mmask8 __U, __m128d __W, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_vfmaddsd3_maskz ((__v2df) __W,
         -(__v2df) __A,
         -(__v2df) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_ss (__mmask8 __U, __m128 __W, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_vfmaddss3_maskz ((__v4sf) __W,
        -(__v4sf) __A,
        -(__v4sf) __B,
        (__mmask8) __U,
        0x04);
}
# 12502 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sqrt_pd (__m512d __A)
{
  return (__m512d) __builtin_ia32_sqrtpd512_mask ((__v8df) __A,
        (__v8df)
        _mm512_undefined_pd (),
        (__mmask8) -1,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sqrt_pd (__m512d __W, __mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_sqrtpd512_mask ((__v8df) __A,
        (__v8df) __W,
        (__mmask8) __U,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sqrt_pd (__mmask8 __U, __m512d __A)
{
  return (__m512d) __builtin_ia32_sqrtpd512_mask ((__v8df) __A,
        (__v8df)
        _mm512_setzero_pd (),
        (__mmask8) __U,
        0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sqrt_ps (__m512 __A)
{
  return (__m512) __builtin_ia32_sqrtps512_mask ((__v16sf) __A,
       (__v16sf)
       _mm512_undefined_ps (),
       (__mmask16) -1,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sqrt_ps (__m512 __W, __mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_sqrtps512_mask ((__v16sf) __A,
       (__v16sf) __W,
       (__mmask16) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sqrt_ps (__mmask16 __U, __m512 __A)
{
  return (__m512) __builtin_ia32_sqrtps512_mask ((__v16sf) __A,
       (__v16sf)
       _mm512_setzero_ps (),
       (__mmask16) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_pd (__m512d __A, __m512d __B)
{
  return (__m512d) ((__v8df)__A + (__v8df)__B);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_addpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_addpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_ps (__m512 __A, __m512 __B)
{
  return (__m512) ((__v16sf)__A + (__v16sf)__B);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_addps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_addps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_addsd_mask_round ((__v2df) __A,
      (__v2df) __B,
      (__v2df) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_addsd_mask_round ((__v2df) __A,
      (__v2df) __B,
      (__v2df)
      _mm_setzero_pd (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_pd (__m512d __A, __m512d __B)
{
  return (__m512d) ((__v8df)__A - (__v8df)__B);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_subpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_subpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_ps (__m512 __A, __m512 __B)
{
  return (__m512) ((__v16sf)__A - (__v16sf)__B);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_subps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_subps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_subsd_mask_round ((__v2df) __A,
      (__v2df) __B,
      (__v2df) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_subsd_mask_round ((__v2df) __A,
      (__v2df) __B,
      (__v2df)
      _mm_setzero_pd (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mul_pd (__m512d __A, __m512d __B)
{
  return (__m512d) ((__v8df)__A * (__v8df)__B);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mul_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_mulpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mul_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_mulpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mul_ps (__m512 __A, __m512 __B)
{
  return (__m512) ((__v16sf)__A * (__v16sf)__B);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mul_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_mulps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mul_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_mulps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_sd (__m128d __W, __mmask8 __U, __m128d __A,
     __m128d __B)
{
  return (__m128d) __builtin_ia32_mulsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_mulsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_ss (__m128 __W, __mmask8 __U, __m128 __A,
     __m128 __B)
{
  return (__m128) __builtin_ia32_mulss_mask_round ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf) __W,
       (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss_mask_round ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_div_pd (__m512d __M, __m512d __V)
{
  return (__m512d) ((__v8df)__M / (__v8df)__V);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_div_pd (__m512d __W, __mmask8 __U, __m512d __M, __m512d __V)
{
  return (__m512d) __builtin_ia32_divpd512_mask ((__v8df) __M,
       (__v8df) __V,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_div_pd (__mmask8 __U, __m512d __M, __m512d __V)
{
  return (__m512d) __builtin_ia32_divpd512_mask ((__v8df) __M,
       (__v8df) __V,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_div_ps (__m512 __A, __m512 __B)
{
  return (__m512) ((__v16sf)__A / (__v16sf)__B);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_div_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_divps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_div_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_divps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_sd (__m128d __W, __mmask8 __U, __m128d __A,
     __m128d __B)
{
  return (__m128d) __builtin_ia32_divsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U,
        0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_divsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_ss (__m128 __W, __mmask8 __U, __m128 __A,
     __m128 __B)
{
  return (__m128) __builtin_ia32_divss_mask_round ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf) __W,
       (__mmask8) __U,
        0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss_mask_round ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U,
        0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_undefined_pd (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_undefined_ps (),
      (__mmask16) -1,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_maxsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_maxsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_undefined_pd (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_undefined_ps (),
      (__mmask16) -1,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U,
      0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U,
      0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_sd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_minsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U,
       0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_sd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_minsd_mask_round ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U,
       0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_ss (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U,
      0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_ss (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss_mask_round ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U,
      0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_scalef_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_undefined_pd (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_scalef_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_scalef_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_scalefpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_scalef_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_scalef_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __W,
         (__mmask16) __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_scalef_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_scalefps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U,
         0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_scalefsd_mask_round ((__v2df) __A,
          (__v2df) __B,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_scalefss_mask_round ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) -1,
         0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmadd_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __C,
          (__mmask8) -1,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmadd_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __C,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmadd_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask3 ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmadd_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmadd_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __C,
         (__mmask16) -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmadd_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __C,
         (__mmask16) __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmadd_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask3 ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmadd_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmsub_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __C,
          (__mmask8) -1,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsub_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_mask ((__v8df) __A,
          (__v8df) __B,
          (__v8df) __C,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsub_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_mask3 ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsub_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_maskz ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmsub_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmsubps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __C,
         (__mmask16) -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsub_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmsubps512_mask ((__v16sf) __A,
         (__v16sf) __B,
         (__v16sf) __C,
         (__mmask16) __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsub_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubps512_mask3 ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsub_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmsubps512_maskz ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmaddsub_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __C,
             (__mmask8) -1,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmaddsub_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __C,
             (__mmask8) __U,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmaddsub_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask3 ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __C,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmaddsub_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __C,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmaddsub_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __C,
            (__mmask16) -1,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmaddsub_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __C,
            (__mmask16) __U,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmaddsub_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask3 ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf) __C,
             (__mmask16) __U,
             0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmaddsub_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf) __C,
             (__mmask16) __U,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmsubadd_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
             (__v8df) __B,
             -(__v8df) __C,
             (__mmask8) -1,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsubadd_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
             (__v8df) __B,
             -(__v8df) __C,
             (__mmask8) __U,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsubadd_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubaddpd512_mask3 ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __C,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsubadd_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
       (__v8df) __B,
       -(__v8df) __C,
       (__mmask8) __U,
       0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmsubadd_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            -(__v16sf) __C,
            (__mmask16) -1,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsubadd_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            -(__v16sf) __C,
            (__mmask16) __U,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsubadd_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubaddps512_mask3 ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf) __C,
             (__mmask16) __U,
             0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsubadd_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
             (__v16sf) __B,
             -(__v16sf) __C,
             (__mmask16) __U,
             0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmadd_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_mask ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) -1,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmadd_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_mask ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmadd_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_mask3 ((__v8df) __A,
            (__v8df) __B,
            (__v8df) __C,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmadd_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_maskz ((__v8df) __A,
            (__v8df) __B,
            (__v8df) __C,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmadd_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmaddps512_mask ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) -1,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmadd_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmaddps512_mask ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmadd_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfnmaddps512_mask3 ((__v16sf) __A,
           (__v16sf) __B,
           (__v16sf) __C,
           (__mmask16) __U,
           0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmadd_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmaddps512_maskz ((__v16sf) __A,
           (__v16sf) __B,
           (__v16sf) __C,
           (__mmask16) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmsub_pd (__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) -1,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmsub_pd (__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask ((__v8df) __A,
           (__v8df) __B,
           (__v8df) __C,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmsub_pd (__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask3 ((__v8df) __A,
            (__v8df) __B,
            (__v8df) __C,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmsub_pd (__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_maskz ((__v8df) __A,
            (__v8df) __B,
            (__v8df) __C,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmsub_ps (__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) -1,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmsub_ps (__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask ((__v16sf) __A,
          (__v16sf) __B,
          (__v16sf) __C,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmsub_ps (__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask3 ((__v16sf) __A,
           (__v16sf) __B,
           (__v16sf) __C,
           (__mmask16) __U,
           0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmsub_ps (__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmsubps512_maskz ((__v16sf) __A,
           (__v16sf) __B,
           (__v16sf) __C,
           (__mmask16) __U,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttpd_epi32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2dq512_mask ((__v8df) __A,
           (__v8si)
           _mm256_undefined_si256 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttpd_epi32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2dq512_mask ((__v8df) __A,
           (__v8si) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttpd_epi32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2dq512_mask ((__v8df) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttpd_epu32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
            (__v8si)
            _mm256_undefined_si256 (),
            (__mmask8) -1,
            0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttpd_epu32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
            (__v8si) __W,
            (__mmask8) __U,
            0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttpd_epu32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2udq512_mask ((__v8df) __A,
            (__v8si)
            _mm256_setzero_si256 (),
            (__mmask8) __U,
            0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_epi32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
          (__v8si)
          _mm256_undefined_si256 (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_epi32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
          (__v8si) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_epi32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2dq512_mask ((__v8df) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_epu32 (__m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
           (__v8si)
           _mm256_undefined_si256 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_epu32 (__m256i __W, __mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
           (__v8si) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_epu32 (__mmask8 __U, __m512d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2udq512_mask ((__v8df) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttps_epi32 (__m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2dq512_mask ((__v16sf) __A,
           (__v16si)
           _mm512_undefined_epi32 (),
           (__mmask16) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttps_epi32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2dq512_mask ((__v16sf) __A,
           (__v16si) __W,
           (__mmask16) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttps_epi32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2dq512_mask ((__v16sf) __A,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttps_epu32 (__m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
            (__v16si)
            _mm512_undefined_epi32 (),
            (__mmask16) -1,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttps_epu32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
            (__v16si) __W,
            (__mmask16) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttps_epu32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
            (__v16si)
            _mm512_setzero_si512 (),
            (__mmask16) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtps_epi32 (__m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
          (__v16si)
          _mm512_undefined_epi32 (),
          (__mmask16) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtps_epi32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
          (__v16si) __W,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtps_epi32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2dq512_mask ((__v16sf) __A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtps_epu32 (__m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A,
           (__v16si)
           _mm512_undefined_epi32 (),
           (__mmask16) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtps_epu32 (__m512i __W, __mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A,
           (__v16si) __W,
           (__mmask16) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtps_epu32 (__mmask16 __U, __m512 __A)
{
  return (__m512i) __builtin_ia32_cvtps2udq512_mask ((__v16sf) __A,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) __U,
           0x04);
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsd_f64 (__m512d __A)
{
  return __A[0];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtss_f32 (__m512 __A)
{
  return __A[0];
}


extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu64_ss (__m128 __A, unsigned long long __B)
{
  return (__m128) __builtin_ia32_cvtusi2ss64 ((__v4sf) __A, __B,
           0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu64_sd (__m128d __A, unsigned long long __B)
{
  return (__m128d) __builtin_ia32_cvtusi2sd64 ((__v2df) __A, __B,
            0x04);
}


extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu32_ss (__m128 __A, unsigned __B)
{
  return (__m128) __builtin_ia32_cvtusi2ss32 ((__v4sf) __A, __B,
           0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_ps (__m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
         (__v16sf)
         _mm512_undefined_ps (),
         (__mmask16) -1,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_ps (__m512 __W, __mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
         (__v16sf) __W,
         (__mmask16) __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_ps (__mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtdq2ps512_mask ((__v16si) __A,
         (__v16sf)
         _mm512_setzero_ps (),
         (__mmask16) __U,
         0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu32_ps (__m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
          (__v16sf)
          _mm512_undefined_ps (),
          (__mmask16) -1,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu32_ps (__m512 __W, __mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
          (__v16sf) __W,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu32_ps (__mmask16 __U, __m512i __A)
{
  return (__m512) __builtin_ia32_cvtudq2ps512_mask ((__v16si) __A,
          (__v16sf)
          _mm512_setzero_ps (),
          (__mmask16) __U,
          0x04);
}
# 14418 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_u64 (__m128 __A)
{
  return (unsigned long long) __builtin_ia32_vcvtss2usi64 ((__v4sf)
          __A,
          0x04);
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_u64 (__m128 __A)
{
  return (unsigned long long) __builtin_ia32_vcvttss2usi64 ((__v4sf)
           __A,
           0x04);
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_i64 (__m128 __A)
{
  return (long long) __builtin_ia32_vcvttss2si64 ((__v4sf) __A,
        0x04);
}


extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsi512_si32 (__m512i __A)
{
  __v16si __B = (__v16si) __A;
  return __B[0];
}

extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_u32 (__m128 __A)
{
  return (unsigned) __builtin_ia32_vcvtss2usi32 ((__v4sf) __A,
       0x04);
}

extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_u32 (__m128 __A)
{
  return (unsigned) __builtin_ia32_vcvttss2usi32 ((__v4sf) __A,
        0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_i32 (__m128 __A)
{
  return (int) __builtin_ia32_vcvttss2si32 ((__v4sf) __A,
         0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_i32 (__m128d __A)
{
  return (int) __builtin_ia32_cvtsd2si ((__v2df) __A);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_i32 (__m128 __A)
{
  return (int) __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti32_sd (__m128d __A, int __B)
{
  return (__m128d) __builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}


extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_u64 (__m128d __A)
{
  return (unsigned long long) __builtin_ia32_vcvtsd2usi64 ((__v2df)
          __A,
          0x04);
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_u64 (__m128d __A)
{
  return (unsigned long long) __builtin_ia32_vcvttsd2usi64 ((__v2df)
           __A,
           0x04);
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_i64 (__m128d __A)
{
  return (long long) __builtin_ia32_vcvttsd2si64 ((__v2df) __A,
        0x04);
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_i64 (__m128d __A)
{
  return (long long) __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_i64 (__m128 __A)
{
  return (long long) __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti64_sd (__m128d __A, long long __B)
{
  return (__m128d) __builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti64_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}


extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_u32 (__m128d __A)
{
  return (unsigned) __builtin_ia32_vcvtsd2usi32 ((__v2df) __A,
       0x04);
}

extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_u32 (__m128d __A)
{
  return (unsigned) __builtin_ia32_vcvttsd2usi32 ((__v2df) __A,
        0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_i32 (__m128d __A)
{
  return (int) __builtin_ia32_vcvttsd2si32 ((__v2df) __A,
         0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtps_pd (__m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
          (__v8df)
          _mm512_undefined_pd (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtps_pd (__m512d __W, __mmask8 __U, __m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
          (__v8df) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtps_pd (__mmask8 __U, __m256 __A)
{
  return (__m512d) __builtin_ia32_cvtps2pd512_mask ((__v8sf) __A,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_ps (__m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
          (__v16sf)
          _mm512_undefined_ps (),
          (__mmask16) -1,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_ps (__m512 __W, __mmask16 __U, __m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
          (__v16sf) __W,
          (__mmask16) __U,
          0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_ps (__mmask16 __U, __m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
          (__v16sf)
          _mm512_setzero_ps (),
          (__mmask16) __U,
          0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_ps (__m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
         (__v8sf)
         _mm256_undefined_ps (),
         (__mmask8) -1,
         0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_ps (__m256 __W, __mmask8 __U, __m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
         (__v8sf) __W,
         (__mmask8) __U,
         0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_ps (__mmask8 __U, __m512d __A)
{
  return (__m256) __builtin_ia32_cvtpd2ps512_mask ((__v8df) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U,
         0x04);
}
# 15442 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x00,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x00,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x01,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x01,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x02,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x02,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpunord_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x03,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpunord_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x03,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x04,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x04,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpnlt_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x05,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpnlt_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x05,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpnle_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x06,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpnle_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x06,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpord_pd_mask (__m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x07,
        (__mmask8) -1,
        0x04);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpord_pd_mask (__mmask8 __U, __m512d __X, __m512d __Y)
{
  return (__mmask8) __builtin_ia32_cmppd512_mask ((__v8df) __X,
        (__v8df) __Y, 0x07,
        (__mmask8) __U,
        0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x00,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x00,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x01,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x01,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x02,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x02,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpunord_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x03,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpunord_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x03,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x04,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x04,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpnlt_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x05,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpnlt_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x05,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpnle_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x06,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpnle_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x06,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpord_ps_mask (__m512 __X, __m512 __Y)
{
  return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x07,
         (__mmask16) -1,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpord_ps_mask (__mmask16 __U, __m512 __X, __m512 __Y)
{
   return (__mmask16) __builtin_ia32_cmpps512_mask ((__v16sf) __X,
         (__v16sf) __Y, 0x07,
         (__mmask16) __U,
         0x04);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kmov (__mmask16 __A)
{
  return __builtin_ia32_kmovw (__A);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd_ps (__m512d __A)
{
  return (__m512) (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd_si512 (__m512d __A)
{
  return (__m512i) (__A);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps_pd (__m512 __A)
{
  return (__m512d) (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps_si512 (__m512 __A)
{
  return (__m512i) (__A);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi512_ps (__m512i __A)
{
  return (__m512) (__A);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi512_pd (__m512i __A)
{
  return (__m512d) (__A);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd512_pd128 (__m512d __A)
{
  return (__m128d)((__m128) __builtin_ia32_extractf32x4_mask ((__v16sf)(__m512) ((__m512)__A), (int) (0), (__v4sf)(__m128)_mm_undefined_ps(), (__mmask8)-1));
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps512_ps128 (__m512 __A)
{
  return ((__m128) __builtin_ia32_extractf32x4_mask ((__v16sf)(__m512) (__A), (int) (0), (__v4sf)(__m128)_mm_undefined_ps(), (__mmask8)-1));
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi512_si128 (__m512i __A)
{
  return (__m128i)((__m128i) __builtin_ia32_extracti32x4_mask ((__v16si)(__m512i) ((__m512i)__A), (int) (0), (__v4si)(__m128i)_mm_undefined_si128 (), (__mmask8)-1));
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd512_pd256 (__m512d __A)
{
  return ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1));
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps512_ps256 (__m512 __A)
{
  return (__m256)((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d)__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1));
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi512_si256 (__m512i __A)
{
  return (__m256i)((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d)__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1));
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd128_pd512 (__m128d __A)
{
  return (__m512d) __builtin_ia32_pd512_pd((__m128d)__A);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps128_ps512 (__m128 __A)
{
  return (__m512) __builtin_ia32_ps512_ps((__m128)__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi128_si512 (__m128i __A)
{
  return (__m512i) __builtin_ia32_si512_si((__v4si)__A);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd256_pd512 (__m256d __A)
{
  return __builtin_ia32_pd512_256pd (__A);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps256_ps512 (__m256 __A)
{
  return __builtin_ia32_ps512_256ps (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi256_si512 (__m256i __A)
{
  return (__m512i)__builtin_ia32_si512_256si ((__v8si)__A);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextpd128_pd512 (__m128d __A)
{
  return (__m512d) ((__m512) __builtin_ia32_insertf32x4_mask ((__v16sf)(__m512) (_mm512_setzero_ps ()), (__v4sf)(__m128) ((__m128) __A), (int) (0), (__v16sf)(__m512) (_mm512_setzero_ps ()), (__mmask16)(-1)));
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextps128_ps512 (__m128 __A)
{
  return ((__m512) __builtin_ia32_insertf32x4_mask ((__v16sf)(__m512) (_mm512_setzero_ps ()), (__v4sf)(__m128) (__A), (int) (0), (__v16sf)(__m512) (_mm512_setzero_ps ()), (__mmask16)(-1)));
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextsi128_si512 (__m128i __A)
{
  return ((__m512i) __builtin_ia32_inserti32x4_mask ((__v16si)(__m512i) (_mm512_setzero_si512 ()), (__v4si)(__m128i) (__A), (int) (0), (__v16si)(__m512i) (_mm512_setzero_si512 ()), (__mmask16)(-1)));
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextpd256_pd512 (__m256d __A)
{
  return ((__m512d) __builtin_ia32_insertf64x4_mask ((__v8df)(__m512d) (_mm512_setzero_pd ()), (__v4df)(__m256d) (__A), (int) (0), (__v8df)(__m512d)_mm512_undefined_pd(), (__mmask8)-1));
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextps256_ps512 (__m256 __A)
{
  return (__m512) ((__m512d) __builtin_ia32_insertf64x4_mask ((__v8df)(__m512d) (_mm512_setzero_pd ()), (__v4df)(__m256d) ((__m256d) __A), (int) (0), (__v8df)(__m512d)_mm512_undefined_pd(), (__mmask8)-1));
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextsi256_si512 (__m256i __A)
{
  return ((__m512i) __builtin_ia32_inserti64x4_mask ((__v8di)(__m512i) (_mm512_setzero_si512 ()), (__v4di)(__m256i) (__A), (int) (0), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1));
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epu32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __A,
           (__v16si) __B, 0,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epu32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __A,
           (__v16si) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epu64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __A,
          (__v8di) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epu64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __A,
          (__v8di) __B, 0,
          (__mmask8) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epu32_mask (__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __A,
           (__v16si) __B, 6,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epu32_mask (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ucmpd512_mask ((__v16si) __A,
           (__v16si) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epu64_mask (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __A,
          (__v8di) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epu64_mask (__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq512_mask ((__v8di) __A,
          (__v8di) __B, 6,
          (__mmask8) -1);
}
# 16017 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_add_epi32 (__m512i __A)
{
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 + __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 + __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 + __T7; return __T8[0] + __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_mul_epi32 (__m512i __A)
{
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 * __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 * __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 * __T7; return __T8[0] * __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_and_epi32 (__m512i __A)
{
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 & __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 & __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 & __T7; return __T8[0] & __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_or_epi32 (__m512i __A)
{
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 | __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 | __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 | __T7; return __T8[0] | __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_add_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi32 (__U, __A);
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 + __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 + __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 + __T7; return __T8[0] + __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_mul_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi32 (_mm512_set1_epi32 (1), __U, __A);
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 * __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 * __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 * __T7; return __T8[0] * __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_and_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi32 (_mm512_set1_epi32 (~0), __U, __A);
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 & __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 & __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 & __T7; return __T8[0] & __T8[1];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_or_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi32 (__U, __A);
  __v8si __T1 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v8si __T2 = (__v8si) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 | __T2); __v4si __T4 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v4si __T5 = (__v4si) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v4si __T6 = __T4 | __T5; __v4si __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __v4si __T8 = __T6 | __T7; return __T8[0] | __T8[1];
}
# 16093 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_epi32 (__m512i __A)
{
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_min_epi32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_min_epi32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_min_epi32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_min_epi32 (__T8, __T9); return __T10[0];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_epi32 (__m512i __A)
{
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_max_epi32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_max_epi32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_max_epi32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_max_epi32 (__T8, __T9); return __T10[0];
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_epu32 (__m512i __A)
{
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_min_epu32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_min_epu32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_min_epu32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_min_epu32 (__T8, __T9); return __T10[0];
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_epu32 (__m512i __A)
{
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_max_epu32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_max_epu32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_max_epu32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_max_epu32 (__T8, __T9); return __T10[0];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi32 (_mm512_set1_epi32 (0x7fffffff), __U, __A);
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_min_epi32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_min_epi32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_min_epi32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_min_epi32 (__T8, __T9); return __T10[0];
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_epi32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi32 (_mm512_set1_epi32 (-0x7fffffff - 1), __U, __A);
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_max_epi32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_max_epi32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_max_epi32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_max_epi32 (__T8, __T9); return __T10[0];
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_epu32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi32 (_mm512_set1_epi32 (~0), __U, __A);
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_min_epu32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_min_epu32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_min_epu32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_min_epu32 (__T8, __T9); return __T10[0];
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_epu32 (__mmask16 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi32 (__U, __A);
  __m256i __T1 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T2 = (__m256i) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = _mm256_max_epu32 (__T1, __T2); __m128i __T4 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __m128i __T5 = (__m128i) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __m128i __T6 = _mm_max_epu32 (__T4, __T5); __m128i __T7 = (__m128i) __builtin_shuffle ((__v4si) __T6, (__v4si) { 2, 3, 0, 1 }); __m128i __T8 = _mm_max_epu32 (__T6, __T7); __m128i __T9 = (__m128i) __builtin_shuffle ((__v4si) __T8, (__v4si) { 1, 0, 1, 0 }); __v4si __T10 = (__v4si) _mm_max_epu32 (__T8, __T9); return __T10[0];
}
# 16165 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_add_ps (__m512 __A)
{
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = __T1 + __T2; __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = __T4 + __T5; __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = __T6 + __T7; return __T8[0] + __T8[1];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_mul_ps (__m512 __A)
{
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = __T1 * __T2; __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = __T4 * __T5; __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = __T6 * __T7; return __T8[0] * __T8[1];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_add_ps (__mmask16 __U, __m512 __A)
{
  __A = _mm512_maskz_mov_ps (__U, __A);
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = __T1 + __T2; __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = __T4 + __T5; __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = __T6 + __T7; return __T8[0] + __T8[1];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_mul_ps (__mmask16 __U, __m512 __A)
{
  __A = _mm512_mask_mov_ps (_mm512_set1_ps (1.0f), __U, __A);
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = __T1 * __T2; __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = __T4 * __T5; __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = __T6 * __T7; return __T8[0] * __T8[1];
}
# 16209 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_ps (__m512 __A)
{
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = _mm256_min_ps (__T1, __T2); __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = _mm_min_ps (__T4, __T5); __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = _mm_min_ps (__T6, __T7); __m128 __T9 = __builtin_shuffle (__T8, (__v4si) { 1, 0, 1, 0 }); __m128 __T10 = _mm_min_ps (__T8, __T9); return __T10[0];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_ps (__m512 __A)
{
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = _mm256_max_ps (__T1, __T2); __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = _mm_max_ps (__T4, __T5); __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = _mm_max_ps (__T6, __T7); __m128 __T9 = __builtin_shuffle (__T8, (__v4si) { 1, 0, 1, 0 }); __m128 __T10 = _mm_max_ps (__T8, __T9); return __T10[0];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_ps (__mmask16 __U, __m512 __A)
{
  __A = _mm512_mask_mov_ps (_mm512_set1_ps (__builtin_inff ()), __U, __A);
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = _mm256_min_ps (__T1, __T2); __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = _mm_min_ps (__T4, __T5); __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = _mm_min_ps (__T6, __T7); __m128 __T9 = __builtin_shuffle (__T8, (__v4si) { 1, 0, 1, 0 }); __m128 __T10 = _mm_min_ps (__T8, __T9); return __T10[0];
}

extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_ps (__mmask16 __U, __m512 __A)
{
  __A = _mm512_mask_mov_ps (_mm512_set1_ps (-__builtin_inff ()), __U, __A);
  __m256 __T1 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T2 = (__m256) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256 __T3 = _mm256_max_ps (__T1, __T2); __m128 __T4 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(1))); __m128 __T5 = ((__m128) __builtin_ia32_vextractf128_ps256 ((__v8sf)(__m256)(__T3), (int)(0))); __m128 __T6 = _mm_max_ps (__T4, __T5); __m128 __T7 = __builtin_shuffle (__T6, (__v4si) { 2, 3, 0, 1 }); __m128 __T8 = _mm_max_ps (__T6, __T7); __m128 __T9 = __builtin_shuffle (__T8, (__v4si) { 1, 0, 1, 0 }); __m128 __T10 = _mm_max_ps (__T8, __T9); return __T10[0];
}
# 16249 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_add_epi64 (__m512i __A)
{
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 + __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 + __T5; return __T6[0] + __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_mul_epi64 (__m512i __A)
{
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 * __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 * __T5; return __T6[0] * __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_and_epi64 (__m512i __A)
{
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 & __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 & __T5; return __T6[0] & __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_or_epi64 (__m512i __A)
{
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 | __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 | __T5; return __T6[0] | __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_add_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi64 (__U, __A);
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 + __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 + __T5; return __T6[0] + __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_mul_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi64 (_mm512_set1_epi64 (1LL), __U, __A);
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 * __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 * __T5; return __T6[0] * __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_and_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi64 (_mm512_set1_epi64 (~0LL), __U, __A);
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 & __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 & __T5; return __T6[0] & __T6[1];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_or_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi64 (__U, __A);
  __v4di __T1 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (1), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __v4di __T2 = (__v4di) ((__m256i) __builtin_ia32_extracti64x4_mask ((__v8di)(__m512i) (__A), (int) (0), (__v4di)(__m256i)_mm256_undefined_si256 (), (__mmask8)-1)); __m256i __T3 = (__m256i) (__T1 | __T2); __v2di __T4 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(1))); __v2di __T5 = (__v2di) ((__m128i) __builtin_ia32_extract128i256 ((__v4di)(__m256i)(__T3), (int)(0))); __v2di __T6 = __T4 | __T5; return __T6[0] | __T6[1];
}
# 16323 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_epi64 (__m512i __A)
{
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_min_epi64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_min_epi64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_min_epi64 (__T4, __T5); return __T6[0];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_epi64 (__m512i __A)
{
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_max_epi64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_max_epi64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_max_epi64 (__T4, __T5); return __T6[0];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi64 (_mm512_set1_epi64 (0x7fffffffffffffffLL),
          __U, __A);
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_min_epi64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_min_epi64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_min_epi64 (__T4, __T5); return __T6[0];
}

extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_epi64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi64 (_mm512_set1_epi64 (-0x7fffffffffffffffLL - 1),
          __U, __A);
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_max_epi64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_max_epi64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_max_epi64 (__T4, __T5); return __T6[0];
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_epu64 (__m512i __A)
{
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_min_epu64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_min_epu64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_min_epu64 (__T4, __T5); return __T6[0];
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_epu64 (__m512i __A)
{
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_max_epu64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_max_epu64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_max_epu64 (__T4, __T5); return __T6[0];
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_epu64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_mask_mov_epi64 (_mm512_set1_epi64 (~0LL), __U, __A);
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_min_epu64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_min_epu64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_min_epu64 (__T4, __T5); return __T6[0];
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_epu64 (__mmask8 __U, __m512i __A)
{
  __A = _mm512_maskz_mov_epi64 (__U, __A);
  __m512i __T1 = ((__m512i) __builtin_ia32_shuf_i64x2_mask ((__v8di)(__m512i)(__A), (__v8di)(__m512i)(__A), (int)(0x4e), (__v8di)(__m512i)_mm512_undefined_epi32 (), (__mmask8)-1)); __m512i __T2 = _mm512_max_epu64 (__A, __T1); __m512i __T3 = (__m512i) __builtin_shuffle ((__v8di) __T2, (__v8di) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m512i __T4 = _mm512_max_epu64 (__T2, __T3); __m512i __T5 = (__m512i) __builtin_shuffle ((__v8di) __T4, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 }); __v8di __T6 = (__v8di) _mm512_max_epu64 (__T4, __T5); return __T6[0];
}
# 16395 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_add_pd (__m512d __A)
{
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = __T1 + __T2; __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = __T4 + __T5; return __T6[0] + __T6[1];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_mul_pd (__m512d __A)
{
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = __T1 * __T2; __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = __T4 * __T5; return __T6[0] * __T6[1];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_add_pd (__mmask8 __U, __m512d __A)
{
  __A = _mm512_maskz_mov_pd (__U, __A);
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = __T1 + __T2; __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = __T4 + __T5; return __T6[0] + __T6[1];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_mul_pd (__mmask8 __U, __m512d __A)
{
  __A = _mm512_mask_mov_pd (_mm512_set1_pd (1.0), __U, __A);
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = __T1 * __T2; __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = __T4 * __T5; return __T6[0] * __T6[1];
}
# 16437 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fintrin.h" 3 4
extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_pd (__m512d __A)
{
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = _mm256_min_pd (__T1, __T2); __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = _mm_min_pd (__T4, __T5); __m128d __T7 = (__m128d) __builtin_shuffle (__T6, (__v2di) { 1, 0 }); __m128d __T8 = _mm_min_pd (__T6, __T7); return __T8[0];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_pd (__m512d __A)
{
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = _mm256_max_pd (__T1, __T2); __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = _mm_max_pd (__T4, __T5); __m128d __T7 = (__m128d) __builtin_shuffle (__T6, (__v2di) { 1, 0 }); __m128d __T8 = _mm_max_pd (__T6, __T7); return __T8[0];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_min_pd (__mmask8 __U, __m512d __A)
{
  __A = _mm512_mask_mov_pd (_mm512_set1_pd (__builtin_inf ()), __U, __A);
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = _mm256_min_pd (__T1, __T2); __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = _mm_min_pd (__T4, __T5); __m128d __T7 = (__m128d) __builtin_shuffle (__T6, (__v2di) { 1, 0 }); __m128d __T8 = _mm_min_pd (__T6, __T7); return __T8[0];
}

extern __inline double
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_reduce_max_pd (__mmask8 __U, __m512d __A)
{
  __A = _mm512_mask_mov_pd (_mm512_set1_pd (-__builtin_inf ()), __U, __A);
  __m256d __T1 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T2 = (__m256d) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) (__A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256d __T3 = _mm256_max_pd (__T1, __T2); __m128d __T4 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(1))); __m128d __T5 = ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)(__T3), (int)(0))); __m128d __T6 = _mm_max_pd (__T4, __T5); __m128d __T7 = (__m128d) __builtin_shuffle (__T6, (__v2di) { 1, 0 }); __m128d __T8 = _mm_max_pd (__T6, __T7); return __T8[0];
}





#pragma GCC pop_options
# 50 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512erintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512erintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512er")




typedef double __v8df __attribute__ ((__vector_size__ (64)));
typedef float __v16sf __attribute__ ((__vector_size__ (64)));



typedef float __m512 __attribute__ ((__vector_size__ (64), __may_alias__));
typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;
# 539 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512erintrin.h" 3 4
#pragma GCC pop_options
# 52 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512pfintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512pfintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512pf")




typedef long long __v8di __attribute__ ((__vector_size__ (64)));
typedef int __v16si __attribute__ ((__vector_size__ (64)));



typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;
# 266 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512pfintrin.h" 3 4
#pragma GCC pop_options
# 54 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512cdintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512cdintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512cd")




typedef long long __v8di __attribute__ ((__vector_size__ (64)));
typedef int __v16si __attribute__ ((__vector_size__ (64)));



typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_conflict_epi32 (__m512i __A)
{
  return (__m512i)
  __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
            (__v16si) _mm512_setzero_si512 (),
            (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_conflict_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_conflict_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i)
  __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
            (__v16si) _mm512_setzero_si512 (),
            (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_conflict_epi64 (__m512i __A)
{
  return (__m512i)
  __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
            (__v8di) _mm512_setzero_si512 (),
            (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_conflict_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
        (__v8di) __W,
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_conflict_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i)
  __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
            (__v8di) _mm512_setzero_si512 (),
            (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_lzcnt_epi64 (__m512i __A)
{
  return (__m512i)
  __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
        (__v8di) _mm512_setzero_si512 (),
        (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_lzcnt_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
           (__v8di) __W,
           (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_lzcnt_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i)
  __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
        (__v8di) _mm512_setzero_si512 (),
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_lzcnt_epi32 (__m512i __A)
{
  return (__m512i)
  __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
        (__v16si) _mm512_setzero_si512 (),
        (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_lzcnt_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
           (__v16si) __W,
           (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_lzcnt_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i)
  __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
        (__v16si) _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m512i) __builtin_ia32_broadcastmb512 (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m512i) __builtin_ia32_broadcastmw512 (__A);
}



#pragma GCC pop_options
# 56 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vl")




typedef unsigned int __mmask32;
typedef int __v4si_u __attribute__ ((__vector_size__ (16),
         __may_alias__, __aligned__ (1)));
typedef int __v8si_u __attribute__ ((__vector_size__ (32),
         __may_alias__, __aligned__ (1)));
typedef long long __v2di_u __attribute__ ((__vector_size__ (16),
        __may_alias__, __aligned__ (1)));
typedef long long __v4di_u __attribute__ ((__vector_size__ (32),
        __may_alias__, __aligned__ (1)));

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_movapd256_mask ((__v4df) __A,
        (__v4df) __W,
        (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_movapd256_mask ((__v4df) __A,
        (__v4df)
        _mm256_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_movapd128_mask ((__v2df) __A,
        (__v2df) __W,
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_movapd128_mask ((__v2df) __A,
        (__v2df)
        _mm_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_load_pd (__m256d __W, __mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadapd256_mask ((__v4df *) __P,
         (__v4df) __W,
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_load_pd (__mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadapd256_mask ((__v4df *) __P,
         (__v4df)
         _mm256_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_pd (__m128d __W, __mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadapd128_mask ((__v2df *) __P,
         (__v2df) __W,
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_pd (__mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadapd128_mask ((__v2df *) __P,
         (__v2df)
         _mm_setzero_pd (),
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_store_pd (void *__P, __mmask8 __U, __m256d __A)
{
  __builtin_ia32_storeapd256_mask ((__v4df *) __P,
       (__v4df) __A,
       (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_pd (void *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storeapd128_mask ((__v2df *) __P,
       (__v2df) __A,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movaps256_mask ((__v8sf) __A,
       (__v8sf) __W,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movaps256_mask ((__v8sf) __A,
       (__v8sf)
       _mm256_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movaps128_mask ((__v4sf) __A,
       (__v4sf) __W,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movaps128_mask ((__v4sf) __A,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_load_ps (__m256 __W, __mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadaps256_mask ((__v8sf *) __P,
        (__v8sf) __W,
        (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_load_ps (__mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadaps256_mask ((__v8sf *) __P,
        (__v8sf)
        _mm256_setzero_ps (),
        (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_ps (__m128 __W, __mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadaps128_mask ((__v4sf *) __P,
        (__v4sf) __W,
        (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_ps (__mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadaps128_mask ((__v4sf *) __P,
        (__v4sf)
        _mm_setzero_ps (),
        (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_store_ps (void *__P, __mmask8 __U, __m256 __A)
{
  __builtin_ia32_storeaps256_mask ((__v8sf *) __P,
       (__v8sf) __A,
       (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_ps (void *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storeaps128_mask ((__v4sf *) __P,
       (__v4sf) __A,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdqa64_256_mask ((__v4di) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdqa64_256_mask ((__v4di) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdqa64_128_mask ((__v2di) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdqa64_128_mask ((__v2di) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_epi64 (void const *__P)
{
  return (__m256i) (*(__v4di *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_load_epi64 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa64load256_mask ((__v4di *) __P,
       (__v4di) __W,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa64load256_mask ((__v4di *) __P,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_epi64 (void const *__P)
{
  return (__m128i) (*(__v2di *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_epi64 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa64load128_mask ((__v2di *) __P,
       (__v2di) __W,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_epi64 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa64load128_mask ((__v2di *) __P,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8)
       __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_store_epi64 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_movdqa64store256_mask ((__v4di *) __P,
     (__v4di) __A,
     (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_epi64 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_movdqa64store128_mask ((__v2di *) __P,
     (__v2di) __A,
     (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdqa32_256_mask ((__v8si) __A,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdqa32_256_mask ((__v8si) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdqa32_128_mask ((__v4si) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdqa32_128_mask ((__v4si) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_epi32 (void const *__P)
{
  return (__m256i) (*(__v8si *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_load_epi32 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa32load256_mask ((__v8si *) __P,
       (__v8si) __W,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_load_epi32 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_movdqa32load256_mask ((__v8si *) __P,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_epi32 (void const *__P)
{
  return (__m128i) (*(__v4si *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_epi32 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa32load128_mask ((__v4si *) __P,
       (__v4si) __W,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_epi32 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_movdqa32load128_mask ((__v4si *) __P,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8)
       __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_epi32 (void *__P, __m256i __A)
{
  *(__v8si *) __P = (__v8si) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_store_epi32 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_movdqa32store256_mask ((__v8si *) __P,
     (__v8si) __A,
     (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_epi32 (void *__P, __m128i __A)
{
  *(__v4si *) __P = (__v4si) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_epi32 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_movdqa32store128_mask ((__v4si *) __P,
     (__v4si) __A,
     (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_addpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_addpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_addpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_addpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_addps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_addps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_subpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_subpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_subpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_subpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_subps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_subps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_epi64 (void *__P, __m256i __A)
{
  *(__m256i *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_epi64 (void *__P, __m128i __A)
{
  *(__m128i *) __P = __A;
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_pd (__m256d __W, __mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadupd256_mask ((const double *) __P,
         (__v4df) __W,
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_pd (__mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_loadupd256_mask ((const double *) __P,
         (__v4df)
         _mm256_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_pd (__m128d __W, __mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadupd128_mask ((const double *) __P,
         (__v2df) __W,
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_pd (__mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_loadupd128_mask ((const double *) __P,
         (__v2df)
         _mm_setzero_pd (),
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_pd (void *__P, __mmask8 __U, __m256d __A)
{
  __builtin_ia32_storeupd256_mask ((double *) __P,
       (__v4df) __A,
       (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_pd (void *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_storeupd128_mask ((double *) __P,
       (__v2df) __A,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_ps (__m256 __W, __mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadups256_mask ((const float *) __P,
        (__v8sf) __W,
        (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_ps (__mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_loadups256_mask ((const float *) __P,
        (__v8sf)
        _mm256_setzero_ps (),
        (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_ps (__m128 __W, __mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadups128_mask ((const float *) __P,
        (__v4sf) __W,
        (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_ps (__mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_loadups128_mask ((const float *) __P,
        (__v4sf)
        _mm_setzero_ps (),
        (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_ps (void *__P, __mmask8 __U, __m256 __A)
{
  __builtin_ia32_storeups256_mask ((float *) __P,
       (__v8sf) __A,
       (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_ps (void *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_storeups128_mask ((float *) __P,
       (__v4sf) __A,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_epi64 (void const *__P)
{
  return (__m256i) (*(__v4di_u *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_epi64 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqudi256_mask ((const long long *) __P,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqudi256_mask ((const long long *) __P,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_epi64 (void const *__P)
{
  return (__m128i) (*(__v2di_u *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_epi64 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqudi128_mask ((const long long *) __P,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqudi128_mask ((const long long *) __P,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_epi64 (void *__P, __m256i __A)
{
  *(__m256i_u *) __P = (__m256i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_epi64 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_storedqudi256_mask ((long long *) __P,
         (__v4di) __A,
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_epi64 (void *__P, __m128i __A)
{
  *(__m128i_u *) __P = (__m128i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_epi64 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedqudi128_mask ((long long *) __P,
         (__v2di) __A,
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_epi32 (void const *__P)
{
  return (__m256i) (*(__v8si_u *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_epi32 (__m256i __W, __mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqusi256_mask ((const int *) __P,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddqusi256_mask ((const int *) __P,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_epi32 (void const *__P)
{
  return (__m128i) (*(__v4si_u *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_epi32 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqusi128_mask ((const int *) __P,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddqusi128_mask ((const int *) __P,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_epi32 (void *__P, __m256i __A)
{
  *(__m256i_u *) __P = (__m256i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_epi32 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_storedqusi256_mask ((int *) __P,
         (__v8si) __A,
         (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_epi32 (void *__P, __m128i __A)
{
  *(__m128i_u *) __P = (__m128i_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_epi32 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedqusi128_mask ((int *) __P,
         (__v4si) __A,
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_abs_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsd256_mask ((__v8si) __A,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_abs_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsd256_mask ((__v8si) __A,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_abs_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsd128_mask ((__v4si) __A,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_abs_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsd128_mask ((__v4si) __A,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_abs_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_abs_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_abs_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_abs_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_abs_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_epu32 (__m256d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_epu32 (__mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epu32 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_epu32 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttps_epi32 (__m256i __W, __mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttps_epi32 (__mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttps_epi32 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttps_epi32 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttps_epu32 (__m256 __A)
{
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
            (__v8si)
            _mm256_setzero_si256 (),
            (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttps_epu32 (__m256i __W, __mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
            (__v8si) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttps_epu32 (__mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
            (__v8si)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epu32 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttps_epu32 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
            (__v4si) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttps_epu32 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttpd_epi32 (__mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttpd_epi32 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttpd_epu32 (__m256d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
            (__v4si) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttpd_epu32 (__mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epu32 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
            (__v4si) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttpd_epu32 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_epi32 (__mmask8 __U, __m256d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_epi32 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_pd (__m256d __W, __mmask8 __U, __m128i __A)
{
  return (__m256d) __builtin_ia32_cvtdq2pd256_mask ((__v4si) __A,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A)
{
  return (__m256d) __builtin_ia32_cvtdq2pd256_mask ((__v4si) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_pd (__m128d __W, __mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtdq2pd128_mask ((__v4si) __A,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtdq2pd128_mask ((__v4si) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu32_pd (__m128i __A)
{
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu32_pd (__m256d __W, __mmask8 __U, __m128i __A)
{
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
           (__v4df) __W,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A)
{
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu32_pd (__m128i __A)
{
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu32_pd (__m128d __W, __mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_ps (__m256 __W, __mmask8 __U, __m256i __A)
{
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_ps (__mmask8 __U, __m256i __A)
{
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu32_ps (__m256i __A)
{
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu32_ps (__m256 __W, __mmask8 __U, __m256i __A)
{
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
          (__v8sf) __W,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu32_ps (__mmask8 __U, __m256i __A)
{
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu32_ps (__m128i __A)
{
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu32_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu32_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtps_pd (__m256d __W, __mmask8 __U, __m128 __A)
{
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtps_pd (__mmask8 __U, __m128 __A)
{
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtps_pd (__m128d __W, __mmask8 __U, __m128 __A)
{
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtps_pd (__mmask8 __U, __m128 __A)
{
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovdb128mem_mask ((unsigned int *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdb128_mask ((__v4si) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
        (__v16qi) __O, __M);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovdb256mem_mask ((unsigned long long *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdb256_mask ((__v8si) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsdb128mem_mask ((unsigned int *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb128_mask ((__v4si) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsdb256mem_mask ((unsigned long long *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdb256_mask ((__v8si) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi32_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusdb128mem_mask ((unsigned int *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi32_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi32_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb128_mask ((__v4si) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi32_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi32_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusdb256mem_mask ((unsigned long long *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi32_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi32_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdb256_mask ((__v8si) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovdw128mem_mask ((unsigned long long *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
        (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovdw128_mask ((__v4si) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
        (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovdw256_mask ((__v8si) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsdw128mem_mask ((unsigned long long *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
         (__v8hi)__O,
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw128_mask ((__v4si) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
         (__v8hi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
         (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsdw256_mask ((__v8si) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi32_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
          (__v8hi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi32_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusdw128mem_mask ((unsigned long long *) __P, (__v4si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi32_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
          (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi32_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw128_mask ((__v4si) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi32_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
          (__v8hi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi32_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusdw256mem_mask ((__v8hi *) __P, (__v8si) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi32_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
          (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi32_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusdw256_mask ((__v8si) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqb128mem_mask ((unsigned short *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqb128_mask ((__v2di) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
        (__v16qi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqb256mem_mask ((unsigned int *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqb256_mask ((__v4di) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqb128mem_mask ((unsigned short *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb128_mask ((__v2di) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqb256mem_mask ((unsigned int *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqb256_mask ((__v4di) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi64_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqb128mem_mask ((unsigned short *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi64_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb128_mask ((__v2di) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi64_epi8 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
          (__v16qi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_storeu_epi8 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusqb256mem_mask ((unsigned int *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_epi8 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi64_epi8 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqb256_mask ((__v4di) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
        (__v8hi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqw128mem_mask ((unsigned int *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
        (__v8hi)__O,
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqw128_mask ((__v2di) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
        (__v8hi)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqw256mem_mask ((unsigned long long *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
        (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqw256_mask ((__v4di) __A,
        (__v8hi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
         (__v8hi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqw128mem_mask ((unsigned int *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
         (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw128_mask ((__v2di) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
         (__v8hi)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqw256mem_mask ((unsigned long long *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
         (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqw256_mask ((__v4di) __A,
         (__v8hi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi64_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
          (__v8hi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_storeu_epi16 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqw128mem_mask ((unsigned int *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
          (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi64_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw128_mask ((__v2di) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi64_epi16 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
          (__v8hi)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_storeu_epi16 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusqw256mem_mask ((unsigned long long *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_epi16 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
          (__v8hi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi64_epi16 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqw256_mask ((__v4di) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
        (__v4si)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovqd128mem_mask ((unsigned long long *) __P,
        (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
        (__v4si) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovqd128_mask ((__v2di) __A,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
        (__v4si)
        _mm_undefined_si128 (),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
        (__v4si) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovqd256_mask ((__v4di) __A,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
         (__v4si)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovsqd128mem_mask ((unsigned long long *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
         (__v4si) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd128_mask ((__v2di) __A,
         (__v4si)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
         (__v4si)
         _mm_undefined_si128 (),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovsqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
         (__v4si)__O,
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovsqd256_mask ((__v4di) __A,
         (__v4si)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi64_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
          (__v4si)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_storeu_epi32 (void * __P, __mmask8 __M, __m128i __A)
{
  __builtin_ia32_pmovusqd128mem_mask ((unsigned long long *) __P, (__v2di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi64_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
          (__v4si) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi64_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd128_mask ((__v2di) __A,
          (__v4si)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi64_epi32 (__m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
          (__v4si)
          _mm_undefined_si128 (),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_storeu_epi32 (void * __P, __mmask8 __M, __m256i __A)
{
  __builtin_ia32_pmovusqd256mem_mask ((__v4si *) __P, (__v4di) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi64_epi32 (__m128i __O, __mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
          (__v4si) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi64_epi32 (__mmask8 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovusqd256_mask ((__v4di) __A,
          (__v4si)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastss_ps (__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastss256_mask ((__v4sf) __A,
            (__v8sf) __O,
            __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastss_ps (__mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastss256_mask ((__v4sf) __A,
            (__v8sf)
            _mm256_setzero_ps (),
            __M);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcastss_ps (__m128 __O, __mmask8 __M, __m128 __A)
{
  return (__m128) __builtin_ia32_broadcastss128_mask ((__v4sf) __A,
            (__v4sf) __O,
            __M);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcastss_ps (__mmask8 __M, __m128 __A)
{
  return (__m128) __builtin_ia32_broadcastss128_mask ((__v4sf) __A,
            (__v4sf)
            _mm_setzero_ps (),
            __M);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastsd_pd (__m256d __O, __mmask8 __M, __m128d __A)
{
  return (__m256d) __builtin_ia32_broadcastsd256_mask ((__v2df) __A,
             (__v4df) __O,
             __M);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastsd_pd (__mmask8 __M, __m128d __A)
{
  return (__m256d) __builtin_ia32_broadcastsd256_mask ((__v2df) __A,
             (__v4df)
             _mm256_setzero_pd (),
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastd_epi32 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastd256_mask ((__v4si) __A,
             (__v8si) __O,
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastd_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastd256_mask ((__v4si) __A,
             (__v8si)
             _mm256_setzero_si256 (),
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_set1_epi32 (__m256i __O, __mmask8 __M, int __A)
{
  return (__m256i) __builtin_ia32_pbroadcastd256_gpr_mask (__A, (__v8si) __O,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_set1_epi32 (__mmask8 __M, int __A)
{
  return (__m256i) __builtin_ia32_pbroadcastd256_gpr_mask (__A,
          (__v8si)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcastd_epi32 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastd128_mask ((__v4si) __A,
             (__v4si) __O,
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcastd_epi32 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastd128_mask ((__v4si) __A,
             (__v4si)
             _mm_setzero_si128 (),
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_set1_epi32 (__m128i __O, __mmask8 __M, int __A)
{
  return (__m128i) __builtin_ia32_pbroadcastd128_gpr_mask (__A, (__v4si) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_set1_epi32 (__mmask8 __M, int __A)
{
  return (__m128i)
  __builtin_ia32_pbroadcastd128_gpr_mask (__A,
       (__v4si) _mm_setzero_si128 (),
       __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastq_epi64 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_mask ((__v2di) __A,
             (__v4di) __O,
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_mask ((__v2di) __A,
             (__v4di)
             _mm256_setzero_si256 (),
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_set1_epi64 (__m256i __O, __mmask8 __M, long long __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_gpr_mask (__A, (__v4di) __O,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_set1_epi64 (__mmask8 __M, long long __A)
{
  return (__m256i) __builtin_ia32_pbroadcastq256_gpr_mask (__A,
          (__v4di)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcastq_epi64 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastq128_mask ((__v2di) __A,
             (__v2di) __O,
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcastq_epi64 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastq128_mask ((__v2di) __A,
             (__v2di)
             _mm_setzero_si128 (),
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_set1_epi64 (__m128i __O, __mmask8 __M, long long __A)
{
  return (__m128i) __builtin_ia32_pbroadcastq128_gpr_mask (__A, (__v2di) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_set1_epi64 (__mmask8 __M, long long __A)
{
  return (__m128i)
  __builtin_ia32_pbroadcastq128_gpr_mask (__A,
       (__v2di) _mm_setzero_si128 (),
       __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_f32x4 (__m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x4_256_mask ((__v4sf) __A,
                (__v8sf)_mm256_undefined_pd (),
         (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_f32x4 (__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x4_256_mask ((__v4sf) __A,
         (__v8sf) __O,
         __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_f32x4 (__mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x4_256_mask ((__v4sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_i32x4 (__m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x4_256_mask ((__v4si)
          __A,
                 (__v8si)_mm256_undefined_si256 (),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_i32x4 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x4_256_mask ((__v4si)
          __A,
          (__v8si)
          __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_i32x4 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x4_256_mask ((__v4si)
          __A,
          (__v8si)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi8_epi32 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbd256_mask ((__v16qi) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi8_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbd256_mask ((__v16qi) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi8_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbd128_mask ((__v16qi) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi8_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbd128_mask ((__v16qi) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi8_epi64 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbq256_mask ((__v16qi) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbq256_mask ((__v16qi) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi8_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbq128_mask ((__v16qi) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbq128_mask ((__v16qi) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi16_epi32 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxwd256_mask ((__v8hi) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi16_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxwd256_mask ((__v8hi) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi16_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxwd128_mask ((__v8hi) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi16_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxwd128_mask ((__v8hi) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi16_epi64 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxwq256_mask ((__v8hi) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxwq256_mask ((__v8hi) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi16_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxwq128_mask ((__v8hi) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxwq128_mask ((__v8hi) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_epi64 (__m256i __W, __mmask8 __U, __m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxdq256_mask ((__v4si) __X,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_epi64 (__mmask8 __U, __m128i __X)
{
  return (__m256i) __builtin_ia32_pmovsxdq256_mask ((__v4si) __X,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_epi64 (__m128i __W, __mmask8 __U, __m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxdq128_mask ((__v4si) __X,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_epi64 (__mmask8 __U, __m128i __X)
{
  return (__m128i) __builtin_ia32_pmovsxdq128_mask ((__v4si) __X,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu8_epi32 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbd256_mask ((__v16qi) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu8_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbd256_mask ((__v16qi) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu8_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbd128_mask ((__v16qi) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu8_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbd128_mask ((__v16qi) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu8_epi64 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbq256_mask ((__v16qi) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbq256_mask ((__v16qi) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu8_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbq128_mask ((__v16qi) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu8_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbq128_mask ((__v16qi) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu16_epi32 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxwd256_mask ((__v8hi) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu16_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxwd256_mask ((__v8hi) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu16_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxwd128_mask ((__v8hi) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu16_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxwd128_mask ((__v8hi) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu16_epi64 (__m256i __W, __mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxwq256_mask ((__v8hi) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxwq256_mask ((__v8hi) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu16_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxwq128_mask ((__v8hi) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu16_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxwq128_mask ((__v8hi) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu32_epi64 (__m256i __W, __mmask8 __U, __m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxdq256_mask ((__v4si) __X,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu32_epi64 (__mmask8 __U, __m128i __X)
{
  return (__m256i) __builtin_ia32_pmovzxdq256_mask ((__v4si) __X,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu32_epi64 (__m128i __W, __mmask8 __U, __m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxdq128_mask ((__v4si) __X,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu32_epi64 (__mmask8 __U, __m128i __X)
{
  return (__m128i) __builtin_ia32_pmovzxdq128_mask ((__v4si) __X,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rcp14_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rcp14_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
           (__v4df) __W,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rcp14_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rcp14pd256_mask ((__v4df) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp14_pd (__m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp14_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp14_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rcp14pd128_mask ((__v2df) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rcp14_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rcp14_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
          (__v8sf) __W,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rcp14_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rcp14ps256_mask ((__v8sf) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp14_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp14_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp14_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rcp14ps128_mask ((__v4sf) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rsqrt14_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rsqrt14_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
           (__v4df) __W,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rsqrt14_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_rsqrt14pd256_mask ((__v4df) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt14_pd (__m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt14_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt14_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_rsqrt14pd128_mask ((__v2df) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rsqrt14_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rsqrt14_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
          (__v8sf) __W,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rsqrt14_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_rsqrt14ps256_mask ((__v8sf) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt14_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt14_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt14_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_rsqrt14ps128_mask ((__v4sf) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sqrt_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_sqrtpd256_mask ((__v4df) __A,
        (__v4df) __W,
        (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sqrt_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_sqrtpd256_mask ((__v4df) __A,
        (__v4df)
        _mm256_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sqrt_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_sqrtpd128_mask ((__v2df) __A,
        (__v2df) __W,
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sqrt_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_sqrtpd128_mask ((__v2df) __A,
        (__v2df)
        _mm_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sqrt_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_sqrtps256_mask ((__v8sf) __A,
       (__v8sf) __W,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sqrt_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_sqrtps256_mask ((__v8sf) __A,
       (__v8sf)
       _mm256_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sqrt_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps128_mask ((__v4sf) __A,
       (__v4sf) __W,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sqrt_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps128_mask ((__v4sf) __A,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_paddd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_paddq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_psubd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_psubq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_paddd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_paddq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psubd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psubq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_getexp_ps (__m256 __A)
{
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_getexp_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_getexp_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_getexp_pd (__m256d __A)
{
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_getexp_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_getexp_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_getexp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_getexp_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_getexp_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_getexp_pd (__m128d __A)
{
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_getexp_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_getexp_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srl_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psrld256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srl_epi32 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psrld256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srl_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psrld128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srl_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrld128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srl_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psrlq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srl_epi64 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psrlq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srl_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srl_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_and_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pandd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_and_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandd256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_scalef_pd (__m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_scalef_pd (__m256d __W, __mmask8 __U, __m256d __A,
         __m256d __B)
{
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_scalef_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_scalef_ps (__m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_scalef_ps (__m256 __W, __mmask8 __U, __m256 __A,
         __m256 __B)
{
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_scalef_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_pd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_scalef_pd (__m128d __W, __mmask8 __U, __m128d __A,
      __m128d __B)
{
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_scalef_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_scalef_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_scalef_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmadd_pd (__m256d __A, __mmask8 __U, __m256d __B,
        __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df) __C,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmadd_pd (__m256d __A, __m256d __B, __m256d __C,
         __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask3 ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmadd_pd (__mmask8 __U, __m256d __A, __m256d __B,
         __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_pd (__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df) __C,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_pd (__m128d __A, __m128d __B, __m128d __C,
      __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask3 ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_pd (__mmask8 __U, __m128d __A, __m128d __B,
      __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmadd_ps (__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf) __C,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmadd_ps (__m256 __A, __m256 __B, __m256 __C,
         __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask3 ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmadd_ps (__mmask8 __U, __m256 __A, __m256 __B,
         __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf) __C,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_ps (__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask3 ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_ps (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsub_pd (__m256d __A, __mmask8 __U, __m256d __B,
        __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmsubpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df) __C,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsub_pd (__m256d __A, __m256d __B, __m256d __C,
         __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubpd256_mask3 ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsub_pd (__mmask8 __U, __m256d __A, __m256d __B,
         __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmsubpd256_maskz ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_pd (__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmsubpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df) __C,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_pd (__m128d __A, __m128d __B, __m128d __C,
      __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubpd128_mask3 ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_pd (__mmask8 __U, __m128d __A, __m128d __B,
      __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmsubpd128_maskz ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsub_ps (__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmsubps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf) __C,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsub_ps (__m256 __A, __m256 __B, __m256 __C,
         __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubps256_mask3 ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsub_ps (__mmask8 __U, __m256 __A, __m256 __B,
         __m256 __C)
{
  return (__m256) __builtin_ia32_vfmsubps256_maskz ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmsubps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf) __C,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_ps (__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubps128_mask3 ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_ps (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmsubps128_maskz ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmaddsub_pd (__m256d __A, __mmask8 __U, __m256d __B,
    __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __C,
             (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmaddsub_pd (__m256d __A, __m256d __B, __m256d __C,
     __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask3 ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __C,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmaddsub_pd (__mmask8 __U, __m256d __A, __m256d __B,
     __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __C,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmaddsub_pd (__m128d __A, __mmask8 __U, __m128d __B,
        __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df) __C,
             (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmaddsub_pd (__m128d __A, __m128d __B, __m128d __C,
         __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask3 ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __C,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmaddsub_pd (__mmask8 __U, __m128d __A, __m128d __B,
         __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __C,
       (__mmask8)
       __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmaddsub_ps (__m256 __A, __mmask8 __U, __m256 __B,
    __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __C,
            (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmaddsub_ps (__m256 __A, __m256 __B, __m256 __C,
     __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask3 ((__v8sf) __A,
             (__v8sf) __B,
             (__v8sf) __C,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmaddsub_ps (__mmask8 __U, __m256 __A, __m256 __B,
     __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
             (__v8sf) __B,
             (__v8sf) __C,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmaddsub_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __C,
            (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmaddsub_ps (__m128 __A, __m128 __B, __m128 __C,
         __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask3 ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf) __C,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmaddsub_ps (__mmask8 __U, __m128 __A, __m128 __B,
         __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf) __C,
             (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsubadd_pd (__m256d __A, __mmask8 __U, __m256d __B,
    __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
             (__v4df) __B,
             -(__v4df) __C,
             (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsubadd_pd (__m256d __A, __m256d __B, __m256d __C,
     __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubaddpd256_mask3 ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __C,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsubadd_pd (__mmask8 __U, __m256d __A, __m256d __B,
     __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
       (__v4df) __B,
       -(__v4df) __C,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsubadd_pd (__m128d __A, __mmask8 __U, __m128d __B,
        __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
             (__v2df) __B,
             -(__v2df) __C,
             (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsubadd_pd (__m128d __A, __m128d __B, __m128d __C,
         __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubaddpd128_mask3 ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __C,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsubadd_pd (__mmask8 __U, __m128d __A, __m128d __B,
         __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
       (__v2df) __B,
       -(__v2df) __C,
       (__mmask8)
       __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsubadd_ps (__m256 __A, __mmask8 __U, __m256 __B,
    __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            -(__v8sf) __C,
            (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsubadd_ps (__m256 __A, __m256 __B, __m256 __C,
     __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubaddps256_mask3 ((__v8sf) __A,
             (__v8sf) __B,
             (__v8sf) __C,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsubadd_ps (__mmask8 __U, __m256 __A, __m256 __B,
     __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
             (__v8sf) __B,
             -(__v8sf) __C,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsubadd_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            -(__v4sf) __C,
            (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsubadd_ps (__m128 __A, __m128 __B, __m128 __C,
         __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubaddps128_mask3 ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf) __C,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsubadd_ps (__mmask8 __U, __m128 __A, __m128 __B,
         __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
             (__v4sf) __B,
             -(__v4sf) __C,
             (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmadd_pd (__m256d __A, __mmask8 __U, __m256d __B,
         __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmaddpd256_mask ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmadd_pd (__m256d __A, __m256d __B, __m256d __C,
   __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfnmaddpd256_mask3 ((__v4df) __A,
            (__v4df) __B,
            (__v4df) __C,
            (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmadd_pd (__mmask8 __U, __m256d __A, __m256d __B,
   __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmaddpd256_maskz ((__v4df) __A,
            (__v4df) __B,
            (__v4df) __C,
            (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_pd (__m128d __A, __mmask8 __U, __m128d __B,
      __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmaddpd128_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_pd (__m128d __A, __m128d __B, __m128d __C,
       __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfnmaddpd128_mask3 ((__v2df) __A,
            (__v2df) __B,
            (__v2df) __C,
            (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_pd (__mmask8 __U, __m128d __A, __m128d __B,
       __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmaddpd128_maskz ((__v2df) __A,
            (__v2df) __B,
            (__v2df) __C,
            (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmadd_ps (__m256 __A, __mmask8 __U, __m256 __B,
         __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmaddps256_mask ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmadd_ps (__m256 __A, __m256 __B, __m256 __C,
   __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfnmaddps256_mask3 ((__v8sf) __A,
           (__v8sf) __B,
           (__v8sf) __C,
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmadd_ps (__mmask8 __U, __m256 __A, __m256 __B,
   __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmaddps256_maskz ((__v8sf) __A,
           (__v8sf) __B,
           (__v8sf) __C,
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmaddps128_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_ps (__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfnmaddps128_mask3 ((__v4sf) __A,
           (__v4sf) __B,
           (__v4sf) __C,
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_ps (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmaddps128_maskz ((__v4sf) __A,
           (__v4sf) __B,
           (__v4sf) __C,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmsub_pd (__m256d __A, __mmask8 __U, __m256d __B,
         __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask ((__v4df) __A,
           (__v4df) __B,
           (__v4df) __C,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmsub_pd (__m256d __A, __m256d __B, __m256d __C,
   __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask3 ((__v4df) __A,
            (__v4df) __B,
            (__v4df) __C,
            (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmsub_pd (__mmask8 __U, __m256d __A, __m256d __B,
   __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_maskz ((__v4df) __A,
            (__v4df) __B,
            (__v4df) __C,
            (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_pd (__m128d __A, __mmask8 __U, __m128d __B,
      __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __C,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_pd (__m128d __A, __m128d __B, __m128d __C,
       __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask3 ((__v2df) __A,
            (__v2df) __B,
            (__v2df) __C,
            (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_pd (__mmask8 __U, __m128d __A, __m128d __B,
       __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_maskz ((__v2df) __A,
            (__v2df) __B,
            (__v2df) __C,
            (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmsub_ps (__m256 __A, __mmask8 __U, __m256 __B,
         __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask ((__v8sf) __A,
          (__v8sf) __B,
          (__v8sf) __C,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmsub_ps (__m256 __A, __m256 __B, __m256 __C,
   __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask3 ((__v8sf) __A,
           (__v8sf) __B,
           (__v8sf) __C,
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmsub_ps (__mmask8 __U, __m256 __A, __m256 __B,
   __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmsubps256_maskz ((__v8sf) __A,
           (__v8sf) __B,
           (__v8sf) __C,
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_ps (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __C,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_ps (__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask3 ((__v4sf) __A,
           (__v4sf) __B,
           (__v4sf) __C,
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_ps (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmsubps128_maskz ((__v4sf) __A,
           (__v4sf) __B,
           (__v4sf) __C,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_and_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pandd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_and_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandd128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_andnot_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
     __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_andnot_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_andnot_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_andnot_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_or_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pord256_mask ((__v8si) __A,
      (__v8si) __B,
      (__v8si) __W,
      (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_or_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pord256_mask ((__v8si) __A,
      (__v8si) __B,
      (__v8si)
      _mm256_setzero_si256 (),
      (__mmask8) __U);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_or_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8su)__A | (__v8su)__B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_or_epi32 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pord128_mask ((__v4si) __A,
      (__v4si) __B,
      (__v4si) __W,
      (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_or_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pord128_mask ((__v4si) __A,
      (__v4si) __B,
      (__v4si)
      _mm_setzero_si128 (),
      (__mmask8) __U);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A | (__v4su)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_xor_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pxord256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_xor_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pxord256_mask ((__v8si) __A,
       (__v8si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_xor_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v8su)__A ^ (__v8su)__B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_xor_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pxord128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_xor_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pxord128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A ^ (__v4su)__B);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m128d __A)
{
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_ps (__mmask8 __U, __m128d __A)
{
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m256d __A)
{
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_ps (__mmask8 __U, __m256d __A)
{
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtps_epi32 (__m256i __W, __mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtps_epi32 (__mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtps_epi32 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtps_epi32 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtps_epu32 (__m256 __A)
{
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtps_epu32 (__m256i __W, __mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtps_epu32 (__mmask8 __U, __m256 __A)
{
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epu32 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtps_epu32 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtps_epu32 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_movedup_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_movddup256_mask ((__v4df) __A,
         (__v4df) __W,
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_movedup_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_movddup256_mask ((__v4df) __A,
         (__v4df)
         _mm256_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_movedup_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_movddup128_mask ((__v2df) __A,
         (__v2df) __W,
         (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_movedup_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_movddup128_mask ((__v2df) __A,
         (__v2df)
         _mm_setzero_pd (),
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_movehdup_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movshdup256_mask ((__v8sf) __A,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_movehdup_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movshdup256_mask ((__v8sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_movehdup_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movshdup128_mask ((__v4sf) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_movehdup_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movshdup128_mask ((__v4sf) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_moveldup_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movsldup256_mask ((__v8sf) __A,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_moveldup_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_movsldup256_mask ((__v8sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_moveldup_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movsldup128_mask ((__v4sf) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_moveldup_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_movsldup128_mask ((__v4sf) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhdq128_mask ((__v4si) __A,
           (__v4si) __B,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhdq128_mask ((__v4si) __A,
           (__v4si) __B,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhdq256_mask ((__v8si) __A,
           (__v8si) __B,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhdq256_mask ((__v8si) __A,
           (__v8si) __B,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhqdq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhqdq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhqdq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhqdq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckldq128_mask ((__v4si) __A,
           (__v4si) __B,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckldq128_mask ((__v4si) __A,
           (__v4si) __B,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckldq256_mask ((__v8si) __A,
           (__v8si) __B,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckldq256_mask ((__v8si) __A,
           (__v8si) __B,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklqdq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklqdq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklqdq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklqdq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epu32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __A,
         (__v4si) __B, 0,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqd128_mask ((__v4si) __A,
          (__v4si) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epu32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __A,
         (__v4si) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqd128_mask ((__v4si) __A,
          (__v4si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epu32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __A,
         (__v8si) __B, 0,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqd256_mask ((__v8si) __A,
          (__v8si) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epu32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __A,
         (__v8si) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqd256_mask ((__v8si) __A,
          (__v8si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epu64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __A,
         (__v2di) __B, 0,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq128_mask ((__v2di) __A,
          (__v2di) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epu64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __A,
         (__v2di) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq128_mask ((__v2di) __A,
          (__v2di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epu64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __A,
         (__v4di) __B, 0,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq256_mask ((__v4di) __A,
          (__v4di) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epu64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __A,
         (__v4di) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqq256_mask ((__v4di) __A,
          (__v4di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epu32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __A,
         (__v4si) __B, 6,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtd128_mask ((__v4si) __A,
          (__v4si) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epu32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __A,
         (__v4si) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtd128_mask ((__v4si) __A,
          (__v4si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epu32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __A,
         (__v8si) __B, 6,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtd256_mask ((__v8si) __A,
          (__v8si) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epu32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __A,
         (__v8si) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtd256_mask ((__v8si) __A,
          (__v8si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epu64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __A,
         (__v2di) __B, 6,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq128_mask ((__v2di) __A,
          (__v2di) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epu64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __A,
         (__v2di) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq128_mask ((__v2di) __A,
          (__v2di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epu64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __A,
         (__v4di) __B, 6,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq256_mask ((__v4di) __A,
          (__v4di) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epu64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __A,
         (__v4di) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtq256_mask ((__v4di) __A,
          (__v4di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_test_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd128 ((__v4si) __A,
            (__v4si) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_test_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd128 ((__v4si) __A,
            (__v4si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_test_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd256 ((__v8si) __A,
            (__v8si) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_test_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmd256 ((__v8si) __A,
            (__v8si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_test_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq128 ((__v2di) __A,
            (__v2di) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_test_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq128 ((__v2di) __A,
            (__v2di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_test_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq256 ((__v4di) __A,
            (__v4di) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_test_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq256 ((__v4di) __A,
            (__v4di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_testn_epi32_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd128 ((__v4si) __A,
      (__v4si) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_testn_epi32_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd128 ((__v4si) __A,
      (__v4si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testn_epi32_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd256 ((__v8si) __A,
      (__v8si) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_testn_epi32_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmd256 ((__v8si) __A,
      (__v8si) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_testn_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq128 ((__v2di) __A,
      (__v2di) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_testn_epi64_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq128 ((__v2di) __A,
      (__v2di) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testn_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq256 ((__v4di) __A,
      (__v4di) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_testn_epi64_mask (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmq256 ((__v4di) __A,
      (__v4di) __B, __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
            (__v4df) __W,
            (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
            (__v4df)
            _mm256_setzero_pd (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m256d __A)
{
  __builtin_ia32_compressstoredf256_mask ((__v4df *) __P,
       (__v4df) __A,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
            (__v2df) __W,
            (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
            (__v2df)
            _mm_setzero_pd (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m128d __A)
{
  __builtin_ia32_compressstoredf128_mask ((__v2df *) __P,
       (__v2df) __A,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
           (__v8sf) __W,
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
           (__v8sf)
           _mm256_setzero_ps (),
           (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m256 __A)
{
  __builtin_ia32_compressstoresf256_mask ((__v8sf *) __P,
       (__v8sf) __A,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
           (__v4sf) __W,
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
           (__v4sf)
           _mm_setzero_ps (),
           (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m128 __A)
{
  __builtin_ia32_compressstoresf128_mask ((__v4sf *) __P,
       (__v4sf) __A,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
            (__v4di) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_compressstoredi256_mask ((__v4di *) __P,
       (__v4di) __A,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
            (__v2di) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_compressstoredi128_mask ((__v2di *) __P,
       (__v2di) __A,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
            (__v8si) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
            (__v8si)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m256i __A)
{
  __builtin_ia32_compressstoresi256_mask ((__v8si *) __P,
       (__v8si) __A,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
            (__v4si) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_compressstoresi128_mask ((__v4si *) __P,
       (__v4si) __A,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_pd (__m256d __W, __mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_expanddf256_mask ((__v4df) __A,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_pd (__mmask8 __U, __m256d __A)
{
  return (__m256d) __builtin_ia32_expanddf256_maskz ((__v4df) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_pd (__m256d __W, __mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_expandloaddf256_mask ((__v4df *) __P,
       (__v4df) __W,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_pd (__mmask8 __U, void const *__P)
{
  return (__m256d) __builtin_ia32_expandloaddf256_maskz ((__v4df *) __P,
        (__v4df)
        _mm256_setzero_pd (),
        (__mmask8)
        __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_pd (__m128d __W, __mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_expanddf128_mask ((__v2df) __A,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_pd (__mmask8 __U, __m128d __A)
{
  return (__m128d) __builtin_ia32_expanddf128_maskz ((__v2df) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_pd (__m128d __W, __mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_expandloaddf128_mask ((__v2df *) __P,
       (__v2df) __W,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_pd (__mmask8 __U, void const *__P)
{
  return (__m128d) __builtin_ia32_expandloaddf128_maskz ((__v2df *) __P,
        (__v2df)
        _mm_setzero_pd (),
        (__mmask8)
        __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_ps (__m256 __W, __mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_expandsf256_mask ((__v8sf) __A,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_ps (__mmask8 __U, __m256 __A)
{
  return (__m256) __builtin_ia32_expandsf256_maskz ((__v8sf) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_ps (__m256 __W, __mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_expandloadsf256_mask ((__v8sf *) __P,
             (__v8sf) __W,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_ps (__mmask8 __U, void const *__P)
{
  return (__m256) __builtin_ia32_expandloadsf256_maskz ((__v8sf *) __P,
       (__v8sf)
       _mm256_setzero_ps (),
       (__mmask8)
       __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_ps (__m128 __W, __mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_expandsf128_mask ((__v4sf) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_ps (__mmask8 __U, __m128 __A)
{
  return (__m128) __builtin_ia32_expandsf128_maskz ((__v4sf) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_ps (__m128 __W, __mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_expandloadsf128_mask ((__v4sf *) __P,
             (__v4sf) __W,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_ps (__mmask8 __U, void const *__P)
{
  return (__m128) __builtin_ia32_expandloadsf128_maskz ((__v4sf *) __P,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_expanddi256_mask ((__v4di) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_expanddi256_maskz ((__v4di) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_epi64 (__m256i __W, __mmask8 __U,
          void const *__P)
{
  return (__m256i) __builtin_ia32_expandloaddi256_mask ((__v4di *) __P,
       (__v4di) __W,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_expandloaddi256_maskz ((__v4di *) __P,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_expanddi128_mask ((__v2di) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_expanddi128_maskz ((__v2di) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_epi64 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_expandloaddi128_mask ((__v2di *) __P,
       (__v2di) __W,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_expandloaddi128_maskz ((__v2di *) __P,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8)
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_expandsi256_mask ((__v8si) __A,
          (__v8si) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_expandsi256_maskz ((__v8si) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_epi32 (__m256i __W, __mmask8 __U,
          void const *__P)
{
  return (__m256i) __builtin_ia32_expandloadsi256_mask ((__v8si *) __P,
       (__v8si) __W,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_expandloadsi256_maskz ((__v8si *) __P,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_expandsi128_mask ((__v4si) __A,
          (__v4si) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_expandsi128_maskz ((__v4si) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_epi32 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_expandloadsi128_mask ((__v4si *) __P,
       (__v4si) __W,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_expandloadsi128_maskz ((__v4si *) __P,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8)
        __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_pd (__m256d __A, __m256i __I, __m256d __B)
{
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                 ,
       (__v4df) __A,
       (__v4df) __B,
       (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_pd (__m256d __A, __mmask8 __U, __m256i __I,
        __m256d __B)
{
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                 ,
       (__v4df) __A,
       (__v4df) __B,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_pd (__m256d __A, __m256i __I, __mmask8 __U,
         __m256d __B)
{
  return (__m256d) __builtin_ia32_vpermi2varpd256_mask ((__v4df) __A,
       (__v4di) __I
                 ,
       (__v4df) __B,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_pd (__mmask8 __U, __m256d __A, __m256i __I,
         __m256d __B)
{
  return (__m256d) __builtin_ia32_vpermt2varpd256_maskz ((__v4di) __I
                  ,
        (__v4df) __A,
        (__v4df) __B,
        (__mmask8)
        __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_ps (__m256 __A, __m256i __I, __m256 __B)
{
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                       ,
             (__v8sf) __A,
             (__v8sf) __B,
             (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_ps (__m256 __A, __mmask8 __U, __m256i __I,
        __m256 __B)
{
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                       ,
             (__v8sf) __A,
             (__v8sf) __B,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_ps (__m256 __A, __m256i __I, __mmask8 __U,
         __m256 __B)
{
  return (__m256) __builtin_ia32_vpermi2varps256_mask ((__v8sf) __A,
             (__v8si) __I
                       ,
             (__v8sf) __B,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_ps (__mmask8 __U, __m256 __A, __m256i __I,
         __m256 __B)
{
  return (__m256) __builtin_ia32_vpermt2varps256_maskz ((__v8si) __I
                 ,
       (__v8sf) __A,
       (__v8sf) __B,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_epi64 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                       ,
             (__v2di) __A,
             (__v2di) __B,
             (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_epi64 (__m128i __A, __mmask8 __U, __m128i __I,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                       ,
             (__v2di) __A,
             (__v2di) __B,
             (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_epi64 (__m128i __A, __m128i __I, __mmask8 __U,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varq128_mask ((__v2di) __A,
             (__v2di) __I
                       ,
             (__v2di) __B,
             (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_epi64 (__mmask8 __U, __m128i __A, __m128i __I,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varq128_maskz ((__v2di) __I
                 ,
       (__v2di) __A,
       (__v2di) __B,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_epi32 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                       ,
             (__v4si) __A,
             (__v4si) __B,
             (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_epi32 (__m128i __A, __mmask8 __U, __m128i __I,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                       ,
             (__v4si) __A,
             (__v4si) __B,
             (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_epi32 (__m128i __A, __m128i __I, __mmask8 __U,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2vard128_mask ((__v4si) __A,
             (__v4si) __I
                       ,
             (__v4si) __B,
             (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_epi32 (__mmask8 __U, __m128i __A, __m128i __I,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2vard128_maskz ((__v4si) __I
                 ,
       (__v4si) __A,
       (__v4si) __B,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_epi64 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                       ,
             (__v4di) __A,
             (__v4di) __B,
             (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_epi64 (__m256i __A, __mmask8 __U, __m256i __I,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                       ,
             (__v4di) __A,
             (__v4di) __B,
             (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_epi64 (__m256i __A, __m256i __I,
     __mmask8 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varq256_mask ((__v4di) __A,
             (__v4di) __I
                       ,
             (__v4di) __B,
             (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_epi64 (__mmask8 __U, __m256i __A,
     __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varq256_maskz ((__v4di) __I
                 ,
       (__v4di) __A,
       (__v4di) __B,
       (__mmask8)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_epi32 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                       ,
             (__v8si) __A,
             (__v8si) __B,
             (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_epi32 (__m256i __A, __mmask8 __U, __m256i __I,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                       ,
             (__v8si) __A,
             (__v8si) __B,
             (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_epi32 (__m256i __A, __m256i __I,
     __mmask8 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2vard256_mask ((__v8si) __A,
             (__v8si) __I
                       ,
             (__v8si) __B,
             (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_epi32 (__mmask8 __U, __m256i __A,
     __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2vard256_maskz ((__v8si) __I
                 ,
       (__v8si) __A,
       (__v8si) __B,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_pd (__m128d __A, __m128i __I, __m128d __B)
{
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                 ,
       (__v2df) __A,
       (__v2df) __B,
       (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_pd (__m128d __A, __mmask8 __U, __m128i __I,
     __m128d __B)
{
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                 ,
       (__v2df) __A,
       (__v2df) __B,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_pd (__m128d __A, __m128i __I, __mmask8 __U,
      __m128d __B)
{
  return (__m128d) __builtin_ia32_vpermi2varpd128_mask ((__v2df) __A,
       (__v2di) __I
                 ,
       (__v2df) __B,
       (__mmask8)
       __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_pd (__mmask8 __U, __m128d __A, __m128i __I,
      __m128d __B)
{
  return (__m128d) __builtin_ia32_vpermt2varpd128_maskz ((__v2di) __I
                  ,
        (__v2df) __A,
        (__v2df) __B,
        (__mmask8)
        __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_ps (__m128 __A, __m128i __I, __m128 __B)
{
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                       ,
             (__v4sf) __A,
             (__v4sf) __B,
             (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_ps (__m128 __A, __mmask8 __U, __m128i __I,
     __m128 __B)
{
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                       ,
             (__v4sf) __A,
             (__v4sf) __B,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_ps (__m128 __A, __m128i __I, __mmask8 __U,
      __m128 __B)
{
  return (__m128) __builtin_ia32_vpermi2varps128_mask ((__v4sf) __A,
             (__v4si) __I
                       ,
             (__v4sf) __B,
             (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_ps (__mmask8 __U, __m128 __A, __m128i __I,
      __m128 __B)
{
  return (__m128) __builtin_ia32_vpermt2varps128_maskz ((__v4si) __I
                 ,
       (__v4sf) __A,
       (__v4sf) __B,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srav_epi64 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psravq128_mask ((__v2di) __X,
        (__v2di) __Y,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srav_epi64 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psravq128_mask ((__v2di) __X,
        (__v2di) __Y,
        (__v2di) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srav_epi64 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psravq128_mask ((__v2di) __X,
        (__v2di) __Y,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sllv_epi32 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sllv_epi32 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sllv_epi32 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sllv_epi32 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sllv_epi64 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv4di_mask ((__v4di) __X,
       (__v4di) __Y,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sllv_epi64 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psllv4di_mask ((__v4di) __X,
       (__v4di) __Y,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sllv_epi64 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv2di_mask ((__v2di) __X,
       (__v2di) __Y,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sllv_epi64 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psllv2di_mask ((__v2di) __X,
       (__v2di) __Y,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srav_epi32 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrav8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srav_epi32 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrav8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srav_epi32 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrav4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srav_epi32 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrav4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srlv_epi32 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srlv_epi32 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv8si_mask ((__v8si) __X,
       (__v8si) __Y,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srlv_epi32 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srlv_epi32 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv4si_mask ((__v4si) __X,
       (__v4si) __Y,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srlv_epi64 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv4di_mask ((__v4di) __X,
       (__v4di) __Y,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srlv_epi64 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psrlv4di_mask ((__v4di) __X,
       (__v4di) __Y,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srlv_epi64 (__m128i __W, __mmask8 __U, __m128i __X,
       __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv2di_mask ((__v2di) __X,
       (__v2di) __Y,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srlv_epi64 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_psrlv2di_mask ((__v2di) __X,
       (__v2di) __Y,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rolv_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rolv_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rolv_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rolv_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rolv_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rolv_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rorv_epi32 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rorv_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rorv_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rorv_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rorv_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rorv_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rolv_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rolv_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rolv_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prolvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rolv_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rolv_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rolv_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prolvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rorv_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rorv_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rorv_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_prorvq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rorv_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rorv_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rorv_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_prorvq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srav_epi64 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psravq256_mask ((__v4di) __X,
        (__v4di) __Y,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srav_epi64 (__m256i __W, __mmask8 __U, __m256i __X,
   __m256i __Y)
{
  return (__m256i) __builtin_ia32_psravq256_mask ((__v4di) __X,
        (__v4di) __Y,
        (__v4di) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srav_epi64 (__mmask8 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_psravq256_mask ((__v4di) __X,
        (__v4di) __Y,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_and_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pandq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di) __W, __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_and_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di)
       _mm256_setzero_pd (),
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_and_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pandq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W, __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_and_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_pd (),
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_andnot_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
     __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W, __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_andnot_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_pd (),
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_andnot_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W, __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_andnot_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_pd (),
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_or_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_porq256_mask ((__v4di) __A,
      (__v4di) __B,
      (__v4di) __W,
      (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_or_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_porq256_mask ((__v4di) __A,
      (__v4di) __B,
      (__v4di)
      _mm256_setzero_si256 (),
      (__mmask8) __U);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_or_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A | (__v4du)__B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_or_epi64 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_porq128_mask ((__v2di) __A,
      (__v2di) __B,
      (__v2di) __W,
      (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_or_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_porq128_mask ((__v2di) __A,
      (__v2di) __B,
      (__v2di)
      _mm_setzero_si128 (),
      (__mmask8) __U);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A | (__v2du)__B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_xor_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pxorq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_xor_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pxorq256_mask ((__v4di) __A,
       (__v4di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_xor_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du)__A ^ (__v4du)__B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_xor_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pxorq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_xor_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pxorq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A ^ (__v2du)__B);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_maxpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_maxpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_maxps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_maxps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_divpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_divpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_minpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_div_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_divpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_minpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_minps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_div_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_divpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_div_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_divps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_minps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_div_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_divps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps_mask ((__v4sf) __A,
          (__v4sf) __B,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_minpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_minpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_maxpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_maxpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_mulpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_mulpd_mask ((__v2df) __A,
           (__v2df) __B,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mul_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_mulps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mul_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_mulps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mul_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_mulpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mul_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_mulpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epi64 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epi64 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epu64 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_epu64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_epu64 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epu64 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epi32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epi32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsd256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epu32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxud256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epu32 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxud256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epu32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminud256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epu32 (__m256i __W, __mmask8 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminud256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epi64 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epi64 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epu64 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epu64 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsd128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epu32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxud128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epu32 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxud128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epu32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminud128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epu32 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminud128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W, __M);
}


#pragma GCC push_options
#pragma GCC target("avx512vl,avx512cd")



extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_broadcastmb128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastmb_epi64 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_broadcastmb256 (__A);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m128i) __builtin_ia32_broadcastmw128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcastmw_epi32 (__mmask16 __A)
{
  return (__m256i) __builtin_ia32_broadcastmw256 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_lzcnt_epi32 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_lzcnt_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
           (__v8si) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_lzcnt_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntd_256_mask ((__v8si) __A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_lzcnt_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_lzcnt_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_lzcnt_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vplzcntq_256_mask ((__v4di) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_conflict_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_conflict_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
        (__v4di) __W,
        (__mmask8)
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_conflict_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictdi_256_mask ((__v4di) __A,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8)
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_conflict_epi32 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_conflict_epi32 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
        (__v8si) __W,
        (__mmask8)
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_conflict_epi32 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpconflictsi_256_mask ((__v8si) __A,
        (__v8si)
        _mm256_setzero_si256 (),
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_lzcnt_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_lzcnt_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
           (__v4si) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_lzcnt_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntd_128_mask ((__v4si) __A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_lzcnt_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_lzcnt_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_lzcnt_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vplzcntq_128_mask ((__v2di) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_conflict_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_conflict_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
        (__v2di) __W,
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_conflict_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictdi_128_mask ((__v2di) __A,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_conflict_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_conflict_epi32 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
        (__v4si) __W,
        (__mmask8)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_conflict_epi32 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpconflictsi_128_mask ((__v4si) __A,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask8)
        __U);
}


#pragma GCC pop_options


extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_pd (__m256d __W, __mmask8 __U, __m256d __A,
    __m256d __B)
{
  return (__m256d) __builtin_ia32_unpcklpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_unpcklpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_pd (__m128d __W, __mmask8 __U, __m128d __A,
        __m128d __B)
{
  return (__m128d) __builtin_ia32_unpcklpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_unpcklpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_ps (__m256 __W, __mmask8 __U, __m256 __A,
    __m256 __B)
{
  return (__m256) __builtin_ia32_unpcklps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_pd (__m256d __W, __mmask8 __U, __m256d __A,
    __m256d __B)
{
  return (__m256d) __builtin_ia32_unpckhpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_unpckhpd256_mask ((__v4df) __A,
          (__v4df) __B,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_pd (__m128d __W, __mmask8 __U, __m128d __A,
        __m128d __B)
{
  return (__m128d) __builtin_ia32_unpckhpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_unpckhpd128_mask ((__v2df) __A,
          (__v2df) __B,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_ps (__m256 __W, __mmask8 __U, __m256 __A,
    __m256 __B)
{
  return (__m256) __builtin_ia32_unpckhps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf) __W,
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_unpckhps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_vcvtph2ps_mask ((__v8hi) __A,
       (__v4sf) __W,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_vcvtph2ps_mask ((__v8hi) __A,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_unpcklps256_mask ((__v8sf) __A,
         (__v8sf) __B,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_ps (__m256 __W, __mmask8 __U, __m128i __A)
{
  return (__m256) __builtin_ia32_vcvtph2ps256_mask ((__v8hi) __A,
          (__v8sf) __W,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_ps (__mmask8 __U, __m128i __A)
{
  return (__m256) __builtin_ia32_vcvtph2ps256_mask ((__v8hi) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps128_mask ((__v4sf) __A,
         (__v4sf) __B,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sra_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psrad256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sra_epi32 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psrad256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sra_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psrad128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sra_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrad128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sra_epi64 (__m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psraq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sra_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psraq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sra_epi64 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psraq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psraq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sra_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psraq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sra_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psraq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sll_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pslld128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sll_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pslld128_mask ((__v4si) __A,
       (__v4si) __B,
       (__v4si)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sll_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psllq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sll_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psllq128_mask ((__v2di) __A,
       (__v2di) __B,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sll_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_pslld256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sll_epi32 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_pslld256_mask ((__v8si) __A,
       (__v4si) __B,
       (__v8si)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sll_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psllq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sll_epi64 (__mmask8 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psllq256_mask ((__v4di) __A,
       (__v2di) __B,
       (__v4di)
       _mm256_setzero_si256 (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_ps (__m256 __W, __mmask8 __U, __m256i __X,
       __m256 __Y)
{
  return (__m256) __builtin_ia32_permvarsf256_mask ((__v8sf) __Y,
          (__v8si) __X,
          (__v8sf) __W,
          (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_ps (__mmask8 __U, __m256i __X, __m256 __Y)
{
  return (__m256) __builtin_ia32_permvarsf256_mask ((__v8sf) __Y,
          (__v8si) __X,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_pd (__m256i __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
           (__v4di) __X,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_pd (__m256d __W, __mmask8 __U, __m256i __X,
       __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
           (__v4di) __X,
           (__v4df) __W,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_pd (__mmask8 __U, __m256i __X, __m256d __Y)
{
  return (__m256d) __builtin_ia32_permvardf256_mask ((__v4df) __Y,
           (__v4di) __X,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutevar_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256i __C)
{
  return (__m256d) __builtin_ia32_vpermilvarpd256_mask ((__v4df) __A,
       (__v4di) __C,
       (__v4df) __W,
       (__mmask8)
       __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutevar_pd (__mmask8 __U, __m256d __A, __m256i __C)
{
  return (__m256d) __builtin_ia32_vpermilvarpd256_mask ((__v4df) __A,
       (__v4di) __C,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8)
       __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutevar_ps (__m256 __W, __mmask8 __U, __m256 __A,
      __m256i __C)
{
  return (__m256) __builtin_ia32_vpermilvarps256_mask ((__v8sf) __A,
             (__v8si) __C,
             (__v8sf) __W,
             (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutevar_ps (__mmask8 __U, __m256 __A, __m256i __C)
{
  return (__m256) __builtin_ia32_vpermilvarps256_mask ((__v8sf) __A,
             (__v8si) __C,
             (__v8sf)
             _mm256_setzero_ps (),
             (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutevar_pd (__m128d __W, __mmask8 __U, __m128d __A,
   __m128i __C)
{
  return (__m128d) __builtin_ia32_vpermilvarpd_mask ((__v2df) __A,
           (__v2di) __C,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutevar_pd (__mmask8 __U, __m128d __A, __m128i __C)
{
  return (__m128d) __builtin_ia32_vpermilvarpd_mask ((__v2df) __A,
           (__v2di) __C,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutevar_ps (__m128 __W, __mmask8 __U, __m128 __A,
   __m128i __C)
{
  return (__m128) __builtin_ia32_vpermilvarps_mask ((__v4sf) __A,
          (__v4si) __C,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutevar_ps (__mmask8 __U, __m128 __A, __m128i __C)
{
  return (__m128) __builtin_ia32_vpermilvarps_mask ((__v4sf) __A,
          (__v4si) __C,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mullo_epi32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulld256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_epi64 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
           (__v4di) __X,
           (__v4di)
           _mm256_setzero_si256 (),
           __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mullo_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulld256_mask ((__v8si) __A,
        (__v8si) __B,
        (__v8si) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mullo_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulld128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mullo_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulld128_mask ((__v4si) __A,
        (__v4si) __B,
        (__v4si) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mul_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
         __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuldq256_mask ((__v8si) __X,
        (__v8si) __Y,
        (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mul_epi32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuldq256_mask ((__v8si) __X,
        (__v8si) __Y,
        (__v4di)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_epi32 (__m128i __W, __mmask8 __M, __m128i __X,
      __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuldq128_mask ((__v4si) __X,
        (__v4si) __Y,
        (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_epi32 (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuldq128_mask ((__v4si) __X,
        (__v4si) __Y,
        (__v2di)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_epi64 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
           (__v4di) __X,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_epi64 (__m256i __W, __mmask8 __M, __m256i __X,
          __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
           (__v4di) __X,
           (__v4di) __W,
           __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mul_epu32 (__m256i __W, __mmask8 __M, __m256i __X,
         __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuludq256_mask ((__v8si) __X,
         (__v8si) __Y,
         (__v4di) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_epi32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
           (__v8si) __X,
           (__v8si)
           _mm256_setzero_si256 (),
           __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mul_epu32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuludq256_mask ((__v8si) __X,
         (__v8si) __Y,
         (__v4di)
         _mm256_setzero_si256 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_epu32 (__m128i __W, __mmask8 __M, __m128i __X,
      __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuludq128_mask ((__v4si) __X,
         (__v4si) __Y,
         (__v2di) __W, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_epu32 (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuludq128_mask ((__v4si) __X,
         (__v4si) __Y,
         (__v2di)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_epi32 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
           (__v8si) __X,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
          __m256i __Y)
{
  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
           (__v8si) __X,
           (__v8si) __W,
           __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epu32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 4,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epu32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 4,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epu32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 1,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epu32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 1,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epu32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 5,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epu32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 5,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epu32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 2,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epu32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd256_mask ((__v8si) __X,
        (__v8si) __Y, 2,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epu64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 4,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epu64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 4,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epu64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 1,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epu64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 1,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epu64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 5,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epu64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 5,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epu64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 2,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epu64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq256_mask ((__v4di) __X,
        (__v4di) __Y, 2,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epi32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 4,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epi32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 4,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epi32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 1,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epi32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 1,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epi32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 5,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epi32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 5,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epi32_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 2,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epi32_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd256_mask ((__v8si) __X,
       (__v8si) __Y, 2,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epi64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 4,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epi64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 4,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epi64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 1,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epi64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 1,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epi64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 5,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epi64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 5,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epi64_mask (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 2,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epi64_mask (__m256i __X, __m256i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq256_mask ((__v4di) __X,
       (__v4di) __Y, 2,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epu32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 4,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epu32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 4,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epu32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 1,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epu32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 1,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epu32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 5,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epu32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 5,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epu32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 2,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epu32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpd128_mask ((__v4si) __X,
        (__v4si) __Y, 2,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epu64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 4,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epu64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 4,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epu64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 1,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epu64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 1,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epu64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 5,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epu64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 5,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epu64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 2,
        (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epu64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpq128_mask ((__v2di) __X,
        (__v2di) __Y, 2,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epi32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 4,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epi32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 4,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epi32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 1,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 1,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epi32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 5,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epi32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 5,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epi32_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 2,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epi32_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpd128_mask ((__v4si) __X,
       (__v4si) __Y, 2,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epi64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 4,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epi64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 4,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epi64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 1,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 1,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epi64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 5,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epi64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 5,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epi64_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 2,
       (__mmask8) __M);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epi64_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpq128_mask ((__v2di) __X,
       (__v2di) __Y, 2,
       (__mmask8) -1);
}
# 13893 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlintrin.h" 3 4
#pragma GCC pop_options
# 58 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bwintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bwintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512bw")




typedef short __v32hi __attribute__ ((__vector_size__ (64)));
typedef short __v32hi_u __attribute__ ((__vector_size__ (64),
     __may_alias__, __aligned__ (1)));
typedef char __v64qi __attribute__ ((__vector_size__ (64)));
typedef char __v64qi_u __attribute__ ((__vector_size__ (64),
           __may_alias__, __aligned__ (1)));

typedef unsigned long long __mmask64;

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktest_mask32_u8 (__mmask32 __A, __mmask32 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_ktestcsi (__A, __B);
  return (unsigned char) __builtin_ia32_ktestzsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktest_mask64_u8 (__mmask64 __A, __mmask64 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_ktestcdi (__A, __B);
  return (unsigned char) __builtin_ia32_ktestzdi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestz_mask32_u8 (__mmask32 __A, __mmask32 __B)
{
  return (unsigned char) __builtin_ia32_ktestzsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestz_mask64_u8 (__mmask64 __A, __mmask64 __B)
{
  return (unsigned char) __builtin_ia32_ktestzdi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestc_mask32_u8 (__mmask32 __A, __mmask32 __B)
{
  return (unsigned char) __builtin_ia32_ktestcsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestc_mask64_u8 (__mmask64 __A, __mmask64 __B)
{
  return (unsigned char) __builtin_ia32_ktestcdi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortest_mask32_u8 (__mmask32 __A, __mmask32 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_kortestcsi (__A, __B);
  return (unsigned char) __builtin_ia32_kortestzsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortest_mask64_u8 (__mmask64 __A, __mmask64 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_kortestcdi (__A, __B);
  return (unsigned char) __builtin_ia32_kortestzdi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestz_mask32_u8 (__mmask32 __A, __mmask32 __B)
{
  return (unsigned char) __builtin_ia32_kortestzsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestz_mask64_u8 (__mmask64 __A, __mmask64 __B)
{
  return (unsigned char) __builtin_ia32_kortestzdi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestc_mask32_u8 (__mmask32 __A, __mmask32 __B)
{
  return (unsigned char) __builtin_ia32_kortestcsi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestc_mask64_u8 (__mmask64 __A, __mmask64 __B)
{
  return (unsigned char) __builtin_ia32_kortestcdi (__A, __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kadd_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kaddsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kadd_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kadddi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtmask32_u32 (__mmask32 __A)
{
  return (unsigned int) __builtin_ia32_kmovd ((__mmask32) __A);
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtmask64_u64 (__mmask64 __A)
{
  return (unsigned long long) __builtin_ia32_kmovq ((__mmask64) __A);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtu32_mask32 (unsigned int __A)
{
  return (__mmask32) __builtin_ia32_kmovd ((__mmask32) __A);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtu64_mask64 (unsigned long long __A)
{
  return (__mmask64) __builtin_ia32_kmovq ((__mmask64) __A);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_load_mask32 (__mmask32 *__A)
{
  return (__mmask32) __builtin_ia32_kmovd (*__A);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_load_mask64 (__mmask64 *__A)
{
  return (__mmask64) __builtin_ia32_kmovq (*(__mmask64 *) __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_store_mask32 (__mmask32 *__A, __mmask32 __B)
{
  *(__mmask32 *) __A = __builtin_ia32_kmovd (__B);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_store_mask64 (__mmask64 *__A, __mmask64 __B)
{
  *(__mmask64 *) __A = __builtin_ia32_kmovq (__B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_knot_mask32 (__mmask32 __A)
{
  return (__mmask32) __builtin_ia32_knotsi ((__mmask32) __A);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_knot_mask64 (__mmask64 __A)
{
  return (__mmask64) __builtin_ia32_knotdi ((__mmask64) __A);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kor_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_korsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kor_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kordi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxnor_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kxnorsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxnor_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kxnordi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxor_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kxorsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxor_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kxordi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kand_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kandsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kand_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kanddi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kandn_mask32 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kandnsi ((__mmask32) __A, (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kandn_mask64 (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kandndi ((__mmask64) __A, (__mmask64) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdquhi512_mask ((__v32hi) __A,
          (__v32hi) __W,
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdquhi512_mask ((__v32hi) __A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_epi16 (void const *__P)
{
  return (__m512i) (*(__v32hi_u *) __P);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_epi16 (__m512i __W, __mmask32 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquhi512_mask ((const short *) __P,
           (__v32hi) __W,
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_epi16 (__mmask32 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquhi512_mask ((const short *) __P,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_epi16 (void *__P, __m512i __A)
{
  *(__v32hi_u *) __P = (__v32hi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_epi16 (void *__P, __mmask32 __U, __m512i __A)
{
  __builtin_ia32_storedquhi512_mask ((short *) __P,
         (__v32hi) __A,
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mov_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdquqi512_mask ((__v64qi) __A,
          (__v64qi) __W,
          (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mov_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_movdquqi512_mask ((__v64qi) __A,
          (__v64qi)
          _mm512_setzero_si512 (),
          (__mmask64) __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kunpackw (__mmask32 __A, __mmask32 __B)
{
  return (__mmask32) __builtin_ia32_kunpcksi ((__mmask32) __A,
           (__mmask32) __B);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kunpackw_mask32 (__mmask16 __A, __mmask16 __B)
{
  return (__mmask32) __builtin_ia32_kunpcksi ((__mmask32) __A,
           (__mmask32) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_kunpackd (__mmask64 __A, __mmask64 __B)
{
  return (__mmask64) __builtin_ia32_kunpckdi ((__mmask64) __A,
           (__mmask64) __B);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kunpackd_mask64 (__mmask32 __A, __mmask32 __B)
{
  return (__mmask64) __builtin_ia32_kunpckdi ((__mmask64) __A,
           (__mmask64) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_epi8 (void const *__P)
{
  return (__m512i) (*(__v64qi_u *) __P);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_loadu_epi8 (__m512i __W, __mmask64 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquqi512_mask ((const char *) __P,
           (__v64qi) __W,
           (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_loadu_epi8 (__mmask64 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddquqi512_mask ((const char *) __P,
           (__v64qi)
           _mm512_setzero_si512 (),
           (__mmask64) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_epi8 (void *__P, __m512i __A)
{
  *(__v64qi_u *) __P = (__v64qi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_storeu_epi8 (void *__P, __mmask64 __U, __m512i __A)
{
  __builtin_ia32_storedquqi512_mask ((char *) __P,
         (__v64qi) __A,
         (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sad_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psadbw512 ((__v64qi) __A,
          (__v64qi) __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi16_epi8 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
        (__v32qi) _mm256_undefined_si256(),
        (__mmask32) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovwb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
        (__v32qi) __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi16_epi8 (__mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
        (__v32qi)
        _mm256_setzero_si256 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsepi16_epi8 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
         (__v32qi)_mm256_undefined_si256(),
         (__mmask32) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovswb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtsepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
         (__v32qi)__O,
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtsepi16_epi8 (__mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
         (__v32qi)
         _mm256_setzero_si256 (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtusepi16_epi8 (__m512i __A)
{
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
          (__v32qi)_mm256_undefined_si256(),
          (__mmask32) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
          (__v32qi) __O,
          __M);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask32 __M, __m512i __A)
{
  __builtin_ia32_pmovuswb512mem_mask ((__v32qi *) __P, (__v32hi) __A, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtusepi16_epi8 (__mmask32 __M, __m512i __A)
{
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
          (__v32qi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastb_epi8 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_mask ((__v16qi) __A,
             (__v64qi)_mm512_undefined_epi32(),
             (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastb_epi8 (__m512i __O, __mmask64 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_mask ((__v16qi) __A,
             (__v64qi) __O,
             __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastb_epi8 (__mmask64 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_mask ((__v16qi) __A,
             (__v64qi)
             _mm512_setzero_si512 (),
             __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_set1_epi8 (__m512i __O, __mmask64 __M, char __A)
{
  return (__m512i) __builtin_ia32_pbroadcastb512_gpr_mask (__A,
          (__v64qi) __O,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_set1_epi8 (__mmask64 __M, char __A)
{
  return (__m512i)
  __builtin_ia32_pbroadcastb512_gpr_mask (__A,
       (__v64qi)
       _mm512_setzero_si512 (),
       __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcastw_epi16 (__m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_mask ((__v8hi) __A,
             (__v32hi)_mm512_undefined_epi32(),
             (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcastw_epi16 (__m512i __O, __mmask32 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_mask ((__v8hi) __A,
             (__v32hi) __O,
             __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcastw_epi16 (__mmask32 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_mask ((__v8hi) __A,
             (__v32hi)
             _mm512_setzero_si512 (),
             __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_set1_epi16 (__m512i __O, __mmask32 __M, short __A)
{
  return (__m512i) __builtin_ia32_pbroadcastw512_gpr_mask (__A,
          (__v32hi) __O,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_set1_epi16 (__mmask32 __M, short __A)
{
  return (__m512i)
  __builtin_ia32_pbroadcastw512_gpr_mask (__A,
       (__v32hi)
       _mm512_setzero_si512 (),
       __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mulhrs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mulhrs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
     __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v32hi) __W,
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mulhrs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mulhi_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mulhi_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mulhi_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mulhi_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mulhi_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi) __W,
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mulhi_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mullo_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v32hu) __A * (__v32hu) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mullo_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_pmullw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mullo_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmullw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi8_epi16 (__m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbw512_mask ((__v32qi) __A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi8_epi16 (__m512i __W, __mmask32 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbw512_mask ((__v32qi) __A,
          (__v32hi) __W,
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi8_epi16 (__mmask32 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovsxbw512_mask ((__v32qi) __A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu8_epi16 (__m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbw512_mask ((__v32qi) __A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu8_epi16 (__m512i __W, __mmask32 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbw512_mask ((__v32qi) __A,
          (__v32hi) __W,
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu8_epi16 (__mmask32 __U, __m256i __A)
{
  return (__m512i) __builtin_ia32_pmovzxbw512_mask ((__v32qi) __A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
           (__v32hi) __A,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_epi16 (__mmask32 __M, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
           (__v32hi) __A,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
           (__v32hi) __A,
           (__v32hi) __W,
           (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_epi16 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I
                 ,
       (__v32hi) __A,
       (__v32hi) __B,
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_epi16 (__m512i __A, __mmask32 __U,
    __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I
                 ,
       (__v32hi) __A,
       (__v32hi) __B,
       (__mmask32)
       __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_epi16 (__m512i __A, __m512i __I,
     __mmask32 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varhi512_mask ((__v32hi) __A,
       (__v32hi) __I
                 ,
       (__v32hi) __B,
       (__mmask32)
       __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_epi16 (__mmask32 __U, __m512i __A,
     __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_maskz ((__v32hi) __I
                  ,
        (__v32hi) __A,
        (__v32hi) __B,
        (__mmask32)
        __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_avg_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_avg_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi) __W,
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_avg_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v64qu) __A + (__v64qu) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_paddb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi) __W,
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v64qu) __A - (__v64qu) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_psubb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi) __W,
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_avg_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_avg_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_avg_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_subs_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_subs_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_subs_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_subs_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi)
         _mm512_setzero_si512 (),
         (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_subs_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi) __W,
         (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_subs_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi)
         _mm512_setzero_si512 (),
         (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_adds_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_adds_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_adds_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_adds_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi)
         _mm512_setzero_si512 (),
         (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_adds_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi) __W,
         (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_adds_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
         (__v64qi) __B,
         (__v64qi)
         _mm512_setzero_si512 (),
         (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v32hu) __A - (__v32hu) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_psubw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_subs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_subs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_subs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_subs_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_subs_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi) __W,
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_subs_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v32hu) __A + (__v32hu) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_paddw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddw512_mask ((__v32hi) __A,
       (__v32hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_adds_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_adds_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_adds_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_adds_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_adds_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi) __W,
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_adds_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srl_epi16 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srl_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srl_epi16 (__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psrlw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_packs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi)
          _mm512_setzero_si512 (),
          (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sll_epi16 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psllw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sll_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m128i __B)
{
  return (__m512i) __builtin_ia32_psllw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sll_epi16 (__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psllw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maddubs_epi16 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
           (__v64qi) __Y,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_maddubs_epi16 (__m512i __W, __mmask32 __U, __m512i __X,
      __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
           (__v64qi) __Y,
           (__v32hi) __W,
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_maddubs_epi16 (__mmask32 __U, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
           (__v64qi) __Y,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_madd_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v16si)
         _mm512_setzero_si512 (),
         (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_madd_epi16 (__m512i __W, __mmask16 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v16si) __W,
         (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_madd_epi16 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
         (__v32hi) __B,
         (__v16si)
         _mm512_setzero_si512 (),
         (__mmask16) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi)
           _mm512_setzero_si512 (),
           (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi) __W,
           (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi)
           _mm512_setzero_si512 (),
           (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpackhi_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpackhi_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi) __W,
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpackhi_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi)
           _mm512_setzero_si512 (),
           (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi) __W,
           (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__v64qi)
           _mm512_setzero_si512 (),
           (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_unpacklo_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_unpacklo_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi) __W,
           (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_unpacklo_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epu8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __A,
          (__v64qi) __B, 0,
          (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_pcmpeqb512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epu8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __A,
          (__v64qi) __B, 0,
          __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_pcmpeqb512_mask ((__v64qi) __A,
           (__v64qi) __B,
           __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epu16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __A,
          (__v32hi) __B, 0,
          (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpeq_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_pcmpeqw512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epu16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __A,
          (__v32hi) __B, 0,
          __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpeq_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_pcmpeqw512_mask ((__v32hi) __A,
           (__v32hi) __B,
           __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epu8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __A,
          (__v64qi) __B, 6,
          (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_pcmpgtb512_mask ((__v64qi) __A,
           (__v64qi) __B,
           (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epu8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __A,
          (__v64qi) __B, 6,
          __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_pcmpgtb512_mask ((__v64qi) __A,
           (__v64qi) __B,
           __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epu16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __A,
          (__v32hi) __B, 6,
          (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpgt_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_pcmpgtw512_mask ((__v32hi) __A,
           (__v32hi) __B,
           (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epu16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __A,
          (__v32hi) __B, 6,
          __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpgt_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_pcmpgtw512_mask ((__v32hi) __A,
           (__v32hi) __B,
           __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movepi8_mask (__m512i __A)
{
  return (__mmask64) __builtin_ia32_cvtb2mask512 ((__v64qi) __A);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movepi16_mask (__m512i __A)
{
  return (__mmask32) __builtin_ia32_cvtw2mask512 ((__v32hi) __A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movm_epi8 (__mmask64 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2b512 (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movm_epi16 (__mmask32 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2w512 (__A);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_test_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestmb512 ((__v64qi) __A,
      (__v64qi) __B,
      (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_test_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestmb512 ((__v64qi) __A,
      (__v64qi) __B, __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_test_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestmw512 ((__v32hi) __A,
      (__v32hi) __B,
      (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_test_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestmw512 ((__v32hi) __A,
      (__v32hi) __B, __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_testn_epi8_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestnmb512 ((__v64qi) __A,
       (__v64qi) __B,
       (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_testn_epi8_mask (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_ptestnmb512 ((__v64qi) __A,
       (__v64qi) __B, __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_testn_epi16_mask (__m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmw512 ((__v32hi) __A,
       (__v32hi) __B,
       (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_testn_epi16_mask (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmw512 ((__v32hi) __A,
       (__v32hi) __B, __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shuffle_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shuffle_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
     __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shuffle_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi)
        _mm512_setzero_si512 (),
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
        (__v64qi) __B,
        (__v64qi) __W,
        (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
         __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sra_epi16 (__m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psraw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sra_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
         __m128i __B)
{
  return (__m512i) __builtin_ia32_psraw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sra_epi16 (__mmask32 __U, __m512i __A, __m128i __B)
{
  return (__m512i) __builtin_ia32_psraw512_mask ((__v32hi) __A,
       (__v8hi) __B,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srav_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psrav32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srav_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_psrav32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srav_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psrav32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_srlv_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psrlv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_srlv_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_psrlv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_srlv_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psrlv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sllv_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psllv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sllv_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
   __m512i __B)
{
  return (__m512i) __builtin_ia32_psllv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi) __W,
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sllv_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psllv32hi_mask ((__v32hi) __A,
        (__v32hi) __B,
        (__v32hi)
        _mm512_setzero_si512 (),
        (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_packs_epi16 (__m512i __W, __mmask64 __M, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi) __W,
          (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_packs_epi16 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_packus_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi)
          _mm512_setzero_si512 (),
          (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_packus_epi16 (__m512i __W, __mmask64 __M, __m512i __A,
     __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi) __W,
          (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_packus_epi16 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
          (__v32hi) __B,
          (__v64qi)
          _mm512_setzero_si512 (),
          (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_epi8 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
       (__v64qi) __W,
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_abs_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
       (__v64qi)
       _mm512_setzero_si512 (),
       (__mmask64) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_epi16 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_abs_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_abs_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
       (__v32hi)
       _mm512_setzero_si512 (),
       (__mmask32) __U);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epu8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 4,
         (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epu8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 1,
         (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epu8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 5,
         (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epu8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 2,
         (__mmask64) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epu16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 4,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epu16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 1,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epu16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 5,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epu16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 2,
         (__mmask32) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epi8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 4,
        (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epi8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 1,
        (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epi8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 5,
        (__mmask64) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epi8_mask (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 2,
        (__mmask64) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpneq_epi16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 4,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmplt_epi16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 1,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmpge_epi16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 5,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cmple_epi16_mask (__mmask32 __M, __m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 2,
        (__mmask32) __M);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epu8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 4,
         (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epu8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 1,
         (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epu8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 5,
         (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epu8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_ucmpb512_mask ((__v64qi) __X,
         (__v64qi) __Y, 2,
         (__mmask64) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epu16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 4,
         (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epu16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 1,
         (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epu16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 5,
         (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epu16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpw512_mask ((__v32hi) __X,
         (__v32hi) __Y, 2,
         (__mmask32) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epi8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 4,
        (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epi8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 1,
        (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epi8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 5,
        (__mmask64) -1);
}

extern __inline __mmask64
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epi8_mask (__m512i __X, __m512i __Y)
{
  return (__mmask64) __builtin_ia32_cmpb512_mask ((__v64qi) __X,
        (__v64qi) __Y, 2,
        (__mmask64) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpneq_epi16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 4,
        (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmplt_epi16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 1,
        (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmpge_epi16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 5,
        (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cmple_epi16_mask (__m512i __X, __m512i __Y)
{
  return (__mmask32) __builtin_ia32_cmpw512_mask ((__v32hi) __X,
        (__v32hi) __Y, 2,
        (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_packs_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_packs_epi32 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_packs_epi32 (__m512i __W, __mmask32 __M, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi) __W,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_packus_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_packus_epi32 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_packus_epi32 (__m512i __W, __mmask32 __M, __m512i __A,
     __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
          (__v16si) __B,
          (__v32hi) __W,
          __M);
}
# 3330 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bwintrin.h" 3 4
#pragma GCC pop_options
# 60 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512dqintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512dqintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512dq")



extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktest_mask8_u8 (__mmask8 __A, __mmask8 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_ktestcqi (__A, __B);
  return (unsigned char) __builtin_ia32_ktestzqi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestz_mask8_u8 (__mmask8 __A, __mmask8 __B)
{
  return (unsigned char) __builtin_ia32_ktestzqi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestc_mask8_u8 (__mmask8 __A, __mmask8 __B)
{
  return (unsigned char) __builtin_ia32_ktestcqi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktest_mask16_u8 (__mmask16 __A, __mmask16 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_ktestchi (__A, __B);
  return (unsigned char) __builtin_ia32_ktestzhi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestz_mask16_u8 (__mmask16 __A, __mmask16 __B)
{
  return (unsigned char) __builtin_ia32_ktestzhi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_ktestc_mask16_u8 (__mmask16 __A, __mmask16 __B)
{
  return (unsigned char) __builtin_ia32_ktestchi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortest_mask8_u8 (__mmask8 __A, __mmask8 __B, unsigned char *__CF)
{
  *__CF = (unsigned char) __builtin_ia32_kortestcqi (__A, __B);
  return (unsigned char) __builtin_ia32_kortestzqi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestz_mask8_u8 (__mmask8 __A, __mmask8 __B)
{
  return (unsigned char) __builtin_ia32_kortestzqi (__A, __B);
}

extern __inline unsigned char
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kortestc_mask8_u8 (__mmask8 __A, __mmask8 __B)
{
  return (unsigned char) __builtin_ia32_kortestcqi (__A, __B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kadd_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_kaddqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kadd_mask16 (__mmask16 __A, __mmask16 __B)
{
  return (__mmask16) __builtin_ia32_kaddhi ((__mmask16) __A, (__mmask16) __B);
}

extern __inline unsigned int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtmask8_u32 (__mmask8 __A)
{
  return (unsigned int) __builtin_ia32_kmovb ((__mmask8 ) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_cvtu32_mask8 (unsigned int __A)
{
  return (__mmask8) __builtin_ia32_kmovb ((__mmask8) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_load_mask8 (__mmask8 *__A)
{
  return (__mmask8) __builtin_ia32_kmovb (*(__mmask8 *) __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_store_mask8 (__mmask8 *__A, __mmask8 __B)
{
  *(__mmask8 *) __A = __builtin_ia32_kmovb (__B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_knot_mask8 (__mmask8 __A)
{
  return (__mmask8) __builtin_ia32_knotqi ((__mmask8) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kor_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_korqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxnor_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_kxnorqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kxor_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_kxorqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kand_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_kandqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_kandn_mask8 (__mmask8 __A, __mmask8 __B)
{
  return (__mmask8) __builtin_ia32_kandnqi ((__mmask8) __A, (__mmask8) __B);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_f64x2 (__m128d __A)
{
  return (__m512d)
  __builtin_ia32_broadcastf64x2_512_mask ((__v2df) __A,
       _mm512_undefined_pd (),
       (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_f64x2 (__m512d __O, __mmask8 __M, __m128d __A)
{
  return (__m512d) __builtin_ia32_broadcastf64x2_512_mask ((__v2df)
          __A,
          (__v8df)
          __O, __M);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_f64x2 (__mmask8 __M, __m128d __A)
{
  return (__m512d) __builtin_ia32_broadcastf64x2_512_mask ((__v2df)
          __A,
          (__v8df)
          _mm512_setzero_ps (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_i64x2 (__m128i __A)
{
  return (__m512i)
  __builtin_ia32_broadcasti64x2_512_mask ((__v2di) __A,
       _mm512_undefined_epi32 (),
       (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_i64x2 (__m512i __O, __mmask8 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti64x2_512_mask ((__v2di)
          __A,
          (__v8di)
          __O, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_i64x2 (__mmask8 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti64x2_512_mask ((__v2di)
          __A,
          (__v8di)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_f32x2 (__m128 __A)
{
  return (__m512)
  __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
       (__v16sf)_mm512_undefined_ps (),
       (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_f32x2 (__m512 __O, __mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
         (__v16sf)
         __O, __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_f32x2 (__mmask16 __M, __m128 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x2_512_mask ((__v4sf) __A,
         (__v16sf)
         _mm512_setzero_ps (),
         __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_i32x2 (__m128i __A)
{
  return (__m512i)
  __builtin_ia32_broadcasti32x2_512_mask ((__v4si) __A,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_i32x2 (__m512i __O, __mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x2_512_mask ((__v4si)
          __A,
          (__v16si)
          __O, __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_i32x2 (__mmask16 __M, __m128i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x2_512_mask ((__v4si)
          __A,
          (__v16si)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_f32x8 (__m256 __A)
{
  return (__m512)
  __builtin_ia32_broadcastf32x8_512_mask ((__v8sf) __A,
       _mm512_undefined_ps (),
       (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_f32x8 (__m512 __O, __mmask16 __M, __m256 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x8_512_mask ((__v8sf) __A,
         (__v16sf)__O,
         __M);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_f32x8 (__mmask16 __M, __m256 __A)
{
  return (__m512) __builtin_ia32_broadcastf32x8_512_mask ((__v8sf) __A,
         (__v16sf)
         _mm512_setzero_ps (),
         __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_broadcast_i32x8 (__m256i __A)
{
  return (__m512i)
  __builtin_ia32_broadcasti32x8_512_mask ((__v8si) __A,
       (__v16si)
       _mm512_undefined_epi32 (),
       (__mmask16) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_broadcast_i32x8 (__m512i __O, __mmask16 __M, __m256i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x8_512_mask ((__v8si)
          __A,
          (__v16si)__O,
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_broadcast_i32x8 (__mmask16 __M, __m256i __A)
{
  return (__m512i) __builtin_ia32_broadcasti32x8_512_mask ((__v8si)
          __A,
          (__v16si)
          _mm512_setzero_si512 (),
          __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mullo_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8du) __A * (__v8du) __B);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mullo_epi64 (__m512i __W, __mmask8 __U, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_pmullq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di) __W,
        (__mmask8) __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mullo_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmullq512_mask ((__v8di) __A,
        (__v8di) __B,
        (__v8di)
        _mm512_setzero_si512 (),
        (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_xor_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_xorpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_xor_pd (__m512d __W, __mmask8 __U, __m512d __A,
      __m512d __B)
{
  return (__m512d) __builtin_ia32_xorpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_xor_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_xorpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_xor_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_xorps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_xor_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_xorps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_xor_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_xorps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_or_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_orpd512_mask ((__v8df) __A,
      (__v8df) __B,
      (__v8df)
      _mm512_setzero_pd (),
      (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_or_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_orpd512_mask ((__v8df) __A,
      (__v8df) __B,
      (__v8df) __W,
      (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_or_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_orpd512_mask ((__v8df) __A,
      (__v8df) __B,
      (__v8df)
      _mm512_setzero_pd (),
      (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_or_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_orps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_or_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_orps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_or_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_orps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_and_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_andpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_and_pd (__m512d __W, __mmask8 __U, __m512d __A,
      __m512d __B)
{
  return (__m512d) __builtin_ia32_andpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df) __W,
       (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_and_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_andpd512_mask ((__v8df) __A,
       (__v8df) __B,
       (__v8df)
       _mm512_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_and_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_andps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_and_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_andps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf) __W,
      (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_and_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_andps512_mask ((__v16sf) __A,
      (__v16sf) __B,
      (__v16sf)
      _mm512_setzero_ps (),
      (__mmask16) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_andnot_pd (__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
        (__v8df) __B,
        (__v8df)
        _mm512_setzero_pd (),
        (__mmask8) -1);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_andnot_pd (__m512d __W, __mmask8 __U, __m512d __A,
         __m512d __B)
{
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
        (__v8df) __B,
        (__v8df) __W,
        (__mmask8) __U);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_andnot_pd (__mmask8 __U, __m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
        (__v8df) __B,
        (__v8df)
        _mm512_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_andnot_ps (__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
       (__v16sf) __B,
       (__v16sf)
       _mm512_setzero_ps (),
       (__mmask16) -1);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_andnot_ps (__m512 __W, __mmask16 __U, __m512 __A,
         __m512 __B)
{
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
       (__v16sf) __B,
       (__v16sf) __W,
       (__mmask16) __U);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_andnot_ps (__mmask16 __U, __m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
       (__v16sf) __B,
       (__v16sf)
       _mm512_setzero_ps (),
       (__mmask16) __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movepi32_mask (__m512i __A)
{
  return (__mmask16) __builtin_ia32_cvtd2mask512 ((__v16si) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movepi64_mask (__m512i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask512 ((__v8di) __A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movm_epi32 (__mmask16 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2d512 (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_movm_epi64 (__mmask8 __A)
{
  return (__m512i) __builtin_ia32_cvtmask2q512 (__A);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttpd_epi64 (__m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
           (__v8di) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttpd_epi64 (__mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttpd_epu64 (__m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) -1,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
            (__v8di) __W,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttpd_epu64 (__mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttps_epi64 (__m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttps_epi64 (__m512i __W, __mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
           (__v8di) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttps_epi64 (__mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttps_epu64 (__m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) -1,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttps_epu64 (__m512i __W, __mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
            (__v8di) __W,
            (__mmask8) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttps_epu64 (__mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
            (__v8di)
            _mm512_setzero_si512 (),
            (__mmask8) __U,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_epi64 (__m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
          (__v8di) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_epi64 (__mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_epu64 (__m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
           (__v8di) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_epu64 (__mmask8 __U, __m512d __A)
{
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtps_epi64 (__m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtps_epi64 (__m512i __W, __mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
          (__v8di) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtps_epi64 (__mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
          (__v8di)
          _mm512_setzero_si512 (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtps_epu64 (__m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtps_epu64 (__m512i __W, __mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
           (__v8di) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtps_epu64 (__mmask8 __U, __m256 __A)
{
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
           (__v8di)
           _mm512_setzero_si512 (),
           (__mmask8) __U,
           0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_ps (__m512i __A)
{
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) -1,
         0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_ps (__m256 __W, __mmask8 __U, __m512i __A)
{
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
         (__v8sf) __W,
         (__mmask8) __U,
         0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_ps (__mmask8 __U, __m512i __A)
{
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         (__mmask8) __U,
         0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu64_ps (__m512i __A)
{
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu64_ps (__m256 __W, __mmask8 __U, __m512i __A)
{
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
          (__v8sf) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu64_ps (__mmask8 __U, __m512i __A)
{
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
          (__v8sf)
          _mm256_setzero_ps (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_pd (__m512i __A)
{
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_pd (__m512d __W, __mmask8 __U, __m512i __A)
{
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
          (__v8df) __W,
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_pd (__mmask8 __U, __m512i __A)
{
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
          (__v8df)
          _mm512_setzero_pd (),
          (__mmask8) __U,
          0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu64_pd (__m512i __A)
{
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu64_pd (__m512d __W, __mmask8 __U, __m512i __A)
{
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
           (__v8df) __W,
           (__mmask8) __U,
           0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu64_pd (__mmask8 __U, __m512i __A)
{
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
           (__v8df)
           _mm512_setzero_pd (),
           (__mmask8) __U,
           0x04);
}
# 2888 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512dqintrin.h" 3 4
#pragma GCC pop_options
# 62 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlbwintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlbwintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vl,avx512bw")




typedef short __v16hi_u __attribute__ ((__vector_size__ (32),
     __may_alias__, __aligned__ (1)));
typedef short __v8hi_u __attribute__ ((__vector_size__ (16),
           __may_alias__, __aligned__ (1)));
typedef char __v32qi_u __attribute__ ((__vector_size__ (32),
           __may_alias__, __aligned__ (1)));
typedef char __v16qi_u __attribute__ ((__vector_size__ (16),
           __may_alias__, __aligned__ (1)));

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdquqi256_mask ((__v32qi) __A,
          (__v32qi) __W,
          (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdquqi256_mask ((__v32qi) __A,
          (__v32qi)
          _mm256_setzero_si256 (),
          (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdquqi128_mask ((__v16qi) __A,
          (__v16qi) __W,
          (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_epi8 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdquqi128_mask ((__v16qi) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_epi8 (void *__P, __m256i __A)
{
  *(__v32qi_u *) __P = (__v32qi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_epi8 (void *__P, __mmask32 __U, __m256i __A)
{
  __builtin_ia32_storedquqi256_mask ((char *) __P,
         (__v32qi) __A,
         (__mmask32) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_epi8 (void *__P, __m128i __A)
{
  *(__v16qi_u *) __P = (__v16qi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_epi8 (void *__P, __mmask16 __U, __m128i __A)
{
  __builtin_ia32_storedquqi128_mask ((char *) __P,
         (__v16qi) __A,
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_epi16 (void const *__P)
{
  return (__m256i) (*(__v16hi_u *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_epi16 (__m256i __W, __mmask16 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquhi256_mask ((const short *) __P,
           (__v16hi) __W,
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_epi16 (__mmask16 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquhi256_mask ((const short *) __P,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_epi16 (void const *__P)
{
  return (__m128i) (*(__v8hi_u *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_epi16 (__m128i __W, __mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquhi128_mask ((const short *) __P,
           (__v8hi) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_epi16 (__mmask8 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquhi128_mask ((const short *) __P,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}


extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mov_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdquhi256_mask ((__v16hi) __A,
          (__v16hi) __W,
          (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mov_epi16 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_movdquhi256_mask ((__v16hi) __A,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mov_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdquhi128_mask ((__v8hi) __A,
          (__v8hi) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mov_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_movdquhi128_mask ((__v8hi) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_epi8 (void const *__P)
{
  return (__m256i) (*(__v32qi_u *) __P);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_loadu_epi8 (__m256i __W, __mmask32 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquqi256_mask ((const char *) __P,
           (__v32qi) __W,
           (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_loadu_epi8 (__mmask32 __U, void const *__P)
{
  return (__m256i) __builtin_ia32_loaddquqi256_mask ((const char *) __P,
           (__v32qi)
           _mm256_setzero_si256 (),
           (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_epi8 (void const *__P)
{
  return (__m128i) (*(__v16qi_u *) __P);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_loadu_epi8 (__m128i __W, __mmask16 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquqi128_mask ((const char *) __P,
           (__v16qi) __W,
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_loadu_epi8 (__mmask16 __U, void const *__P)
{
  return (__m128i) __builtin_ia32_loaddquqi128_mask ((const char *) __P,
           (__v16qi)
           _mm_setzero_si128 (),
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi16_epi8 (__m256i __A)
{

  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
        (__v16qi)_mm_undefined_si128(),
        (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi16_storeu_epi8 (void * __P, __mmask16 __M,__m256i __A)
{
  __builtin_ia32_pmovwb256mem_mask ((__v16qi *) __P , (__v16hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi16_epi8 (__mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsepi16_epi8 (__m128i __A)
{

  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
         (__v16qi)_mm_undefined_si128(),
         (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask8 __M,__m128i __A)
{
  __builtin_ia32_pmovswb128mem_mask ((unsigned long long *) __P , (__v8hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsepi16_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsepi16_epi8 (__m256i __A)
{

  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
         (__v16qi)_mm_undefined_si128(),
         (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi16_storeu_epi8 (void * __P, __mmask16 __M,__m256i __A)
{
  __builtin_ia32_pmovswb256mem_mask ((__v16qi *) __P , (__v16hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtsepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
         (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtsepi16_epi8 (__mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
         (__v16qi)
         _mm_setzero_si128 (),
         __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtusepi16_epi8 (__m128i __A)
{

  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
          (__v16qi)_mm_undefined_si128(),
          (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask8 __M,__m128i __A)
{
  __builtin_ia32_pmovuswb128mem_mask ((unsigned long long *) __P , (__v8hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtusepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtusepi16_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtusepi16_epi8 (__m256i __A)
{

  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
          (__v16qi)_mm_undefined_si128(),
          (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi16_storeu_epi8 (void * __P, __mmask16 __M,__m256i __A)
{
  __builtin_ia32_pmovuswb256mem_mask ((__v16qi *) __P , (__v16hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtusepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtusepi16_epi8 (__mmask16 __M, __m256i __A)
{
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastb_epi8 (__m256i __O, __mmask32 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_mask ((__v16qi) __A,
             (__v32qi) __O,
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastb_epi8 (__mmask32 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_mask ((__v16qi) __A,
             (__v32qi)
             _mm256_setzero_si256 (),
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_set1_epi8 (__m256i __O, __mmask32 __M, char __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_gpr_mask (__A,
          (__v32qi) __O,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_set1_epi8 (__mmask32 __M, char __A)
{
  return (__m256i) __builtin_ia32_pbroadcastb256_gpr_mask (__A,
          (__v32qi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcastb_epi8 (__m128i __O, __mmask16 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_mask ((__v16qi) __A,
             (__v16qi) __O,
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcastb_epi8 (__mmask16 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_mask ((__v16qi) __A,
             (__v16qi)
             _mm_setzero_si128 (),
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_set1_epi8 (__m128i __O, __mmask16 __M, char __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_gpr_mask (__A,
          (__v16qi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_set1_epi8 (__mmask16 __M, char __A)
{
  return (__m128i) __builtin_ia32_pbroadcastb128_gpr_mask (__A,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcastw_epi16 (__m256i __O, __mmask16 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_mask ((__v8hi) __A,
             (__v16hi) __O,
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcastw_epi16 (__mmask16 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_mask ((__v8hi) __A,
             (__v16hi)
             _mm256_setzero_si256 (),
             __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_set1_epi16 (__m256i __O, __mmask16 __M, short __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_gpr_mask (__A,
          (__v16hi) __O,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_set1_epi16 (__mmask16 __M, short __A)
{
  return (__m256i) __builtin_ia32_pbroadcastw256_gpr_mask (__A,
          (__v16hi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcastw_epi16 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_mask ((__v8hi) __A,
             (__v8hi) __O,
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcastw_epi16 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_mask ((__v8hi) __A,
             (__v8hi)
             _mm_setzero_si128 (),
             __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_set1_epi16 (__m128i __O, __mmask8 __M, short __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_gpr_mask (__A,
          (__v8hi) __O,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_set1_epi16 (__mmask8 __M, short __A)
{
  return (__m128i) __builtin_ia32_pbroadcastw128_gpr_mask (__A,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
           (__v16hi) __A,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_epi16 (__mmask16 __M, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
           (__v16hi) __A,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
           (__v16hi) __A,
           (__v16hi) __W,
           (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutexvar_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
           (__v8hi) __A,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutexvar_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
           (__v8hi) __A,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutexvar_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
           (__v8hi) __A,
           (__v8hi) __W,
           (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_epi16 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I
                 ,
       (__v16hi) __A,
       (__v16hi) __B,
       (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_epi16 (__m256i __A, __mmask16 __U,
    __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I
                 ,
       (__v16hi) __A,
       (__v16hi) __B,
       (__mmask16)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_epi16 (__m256i __A, __m256i __I,
     __mmask16 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varhi256_mask ((__v16hi) __A,
       (__v16hi) __I
                 ,
       (__v16hi) __B,
       (__mmask16)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_epi16 (__mmask16 __U, __m256i __A,
     __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_maskz ((__v16hi) __I
                  ,
        (__v16hi) __A,
        (__v16hi) __B,
        (__mmask16)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_epi16 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I
                 ,
       (__v8hi) __A,
       (__v8hi) __B,
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_epi16 (__m128i __A, __mmask8 __U, __m128i __I,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I
                 ,
       (__v8hi) __A,
       (__v8hi) __B,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_epi16 (__m128i __A, __m128i __I, __mmask8 __U,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varhi128_mask ((__v8hi) __A,
       (__v8hi) __I
                 ,
       (__v8hi) __B,
       (__mmask8)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_epi16 (__mmask8 __U, __m128i __A, __m128i __I,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_maskz ((__v8hi) __I
                  ,
        (__v8hi) __A,
        (__v8hi) __B,
        (__mmask8)
        __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_maddubs_epi16 (__m256i __W, __mmask16 __U, __m256i __X,
      __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmaddubsw256_mask ((__v32qi) __X,
           (__v32qi) __Y,
           (__v16hi) __W,
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_maddubs_epi16 (__mmask16 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmaddubsw256_mask ((__v32qi) __X,
           (__v32qi) __Y,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_maddubs_epi16 (__m128i __W, __mmask8 __U, __m128i __X,
   __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaddubsw128_mask ((__v16qi) __X,
           (__v16qi) __Y,
           (__v8hi) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_maddubs_epi16 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmaddubsw128_mask ((__v16qi) __X,
           (__v16qi) __Y,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_madd_epi16 (__m256i __W, __mmask8 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaddwd256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v8si) __W,
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_madd_epi16 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaddwd256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v8si)
         _mm256_setzero_si256 (),
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_madd_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaddwd128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v4si) __W,
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_madd_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaddwd128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v4si)
         _mm_setzero_si128 (),
         (__mmask8) __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi8_mask (__m128i __A)
{
  return (__mmask16) __builtin_ia32_cvtb2mask128 ((__v16qi) __A);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movepi8_mask (__m256i __A)
{
  return (__mmask32) __builtin_ia32_cvtb2mask256 ((__v32qi) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi16_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtw2mask128 ((__v8hi) __A);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movepi16_mask (__m256i __A)
{
  return (__mmask16) __builtin_ia32_cvtw2mask256 ((__v16hi) __A);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movm_epi8 (__mmask16 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2b128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movm_epi8 (__mmask32 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2b256 (__A);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movm_epi16 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2w128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movm_epi16 (__mmask16 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2w256 (__A);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_test_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestmb128 ((__v16qi) __A,
      (__v16qi) __B,
      (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_test_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestmb128 ((__v16qi) __A,
      (__v16qi) __B, __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_test_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestmb256 ((__v32qi) __A,
      (__v32qi) __B,
      (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_test_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestmb256 ((__v32qi) __A,
      (__v32qi) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_test_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmw128 ((__v8hi) __A,
            (__v8hi) __B,
            (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_test_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestmw128 ((__v8hi) __A,
            (__v8hi) __B, __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_test_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestmw256 ((__v16hi) __A,
      (__v16hi) __B,
      (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_test_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestmw256 ((__v16hi) __A,
      (__v16hi) __B, __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epu16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epu16 (__m256i __W, __mmask16 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epu16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epu16 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epi16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxub256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epu8 (__m256i __W, __mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxub256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epu8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxub128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epu8 (__m128i __W, __mmask16 __M, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxub128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epi8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminub256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epu8 (__m256i __W, __mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pminub256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epu8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminub128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epu8 (__m128i __W, __mmask16 __M, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_pminub128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_epi8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epi16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_epu16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_epu16 (__m256i __W, __mmask16 __M, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_epu16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_epu16 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __M);
}
# 2090 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vlbwintrin.h" 3 4
extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epi8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 4,
        (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epi8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 1,
        (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epi8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 5,
        (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epi8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 2,
        (__mmask32) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epi16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 4,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epi16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 1,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epi16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 5,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epi16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 2,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epu8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 4,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epu8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 1,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epu8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 5,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epu8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 2,
         (__mmask16) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epu16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 4,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epu16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 1,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epu16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 5,
        (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epu16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 2,
        (__mmask8) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epi8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 4,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 1,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epi8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 5,
        (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epi8_mask (__m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 2,
        (__mmask16) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_epi16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 4,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 1,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_epi16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 5,
       (__mmask8) -1);
}

extern __inline __mmask8
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_epi16_mask (__m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 2,
       (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mulhrs_epi16 (__m256i __W, __mmask16 __U, __m256i __X,
     __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmulhrsw256_mask ((__v16hi) __X,
          (__v16hi) __Y,
          (__v16hi) __W,
          (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mulhrs_epi16 (__mmask16 __U, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmulhrsw256_mask ((__v16hi) __X,
          (__v16hi) __Y,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mulhi_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulhuw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi) __W,
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mulhi_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulhuw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi)
         _mm256_setzero_si256 (),
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mulhi_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulhw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mulhi_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulhw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mulhi_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulhw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mulhi_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulhw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mulhi_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulhuw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi) __W,
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mulhi_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulhuw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi)
         _mm_setzero_si128 (),
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mulhrs_epi16 (__m128i __W, __mmask8 __U, __m128i __X,
         __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmulhrsw128_mask ((__v8hi) __X,
          (__v8hi) __Y,
          (__v8hi) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mulhrs_epi16 (__mmask8 __U, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmulhrsw128_mask ((__v8hi) __X,
          (__v8hi) __Y,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mullo_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_pmullw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mullo_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmullw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mullo_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmullw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mullo_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmullw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi8_epi16 (__m256i __W, __mmask16 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbw256_mask ((__v16qi) __A,
          (__v16hi) __W,
          (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi8_epi16 (__mmask16 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovsxbw256_mask ((__v16qi) __A,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi8_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbw128_mask ((__v16qi) __A,
          (__v8hi) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi8_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovsxbw128_mask ((__v16qi) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu8_epi16 (__m256i __W, __mmask16 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbw256_mask ((__v16qi) __A,
          (__v16hi) __W,
          (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu8_epi16 (__mmask16 __U, __m128i __A)
{
  return (__m256i) __builtin_ia32_pmovzxbw256_mask ((__v16qi) __A,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu8_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbw128_mask ((__v16qi) __A,
          (__v8hi) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu8_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovzxbw128_mask ((__v16qi) __A,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_avg_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi) __W,
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_avg_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi)
       _mm256_setzero_si256 (),
       (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_avg_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi) __W,
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_avg_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi)
       _mm_setzero_si128 (),
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_avg_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_avg_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_avg_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_avg_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_paddb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi) __W,
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi)
       _mm256_setzero_si256 (),
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_paddw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_adds_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_adds_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_adds_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_adds_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_adds_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusb256_mask ((__v32qi) __A,
         (__v32qi) __B,
         (__v32qi) __W,
         (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_adds_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusb256_mask ((__v32qi) __A,
         (__v32qi) __B,
         (__v32qi)
         _mm256_setzero_si256 (),
         (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_adds_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi) __W,
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_adds_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi)
         _mm256_setzero_si256 (),
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_psubb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi) __W,
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__v32qi)
       _mm256_setzero_si256 (),
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_psubw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubw256_mask ((__v16hi) __A,
       (__v16hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_subs_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_subs_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_subs_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_subs_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsw256_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_subs_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusb256_mask ((__v32qi) __A,
         (__v32qi) __B,
         (__v32qi) __W,
         (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_subs_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusb256_mask ((__v32qi) __A,
         (__v32qi) __B,
         (__v32qi)
         _mm256_setzero_si256 (),
         (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_subs_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi) __W,
         (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_subs_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusw256_mask ((__v16hi) __A,
         (__v16hi) __B,
         (__v16hi)
         _mm256_setzero_si256 (),
         (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_paddb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi) __W,
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi)
       _mm_setzero_si128 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_paddw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhbw256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__v32qi) __W,
           (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhbw256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__v32qi)
           _mm256_setzero_si256 (),
           (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
   __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhbw128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__v16qi) __W,
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhbw128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__v16qi)
           _mm_setzero_si128 (),
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpackhi_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhwd256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__v16hi) __W,
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpackhi_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpckhwd256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpackhi_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhwd128_mask ((__v8hi) __A,
           (__v8hi) __B,
           (__v8hi) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpackhi_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpckhwd128_mask ((__v8hi) __A,
           (__v8hi) __B,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklbw256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__v32qi) __W,
           (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklbw256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__v32qi)
           _mm256_setzero_si256 (),
           (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
   __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklbw128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__v16qi) __W,
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklbw128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__v16qi)
           _mm_setzero_si128 (),
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_unpacklo_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklwd256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__v16hi) __W,
           (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_unpacklo_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_punpcklwd256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_unpacklo_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
    __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklwd128_mask ((__v8hi) __A,
           (__v8hi) __B,
           (__v8hi) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_unpacklo_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_punpcklwd128_mask ((__v8hi) __A,
           (__v8hi) __B,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqb128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epu8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __A,
          (__v16qi) __B, 0,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epu8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __A,
          (__v16qi) __B, 0,
          __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqb128_mask ((__v16qi) __A,
           (__v16qi) __B,
           __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epu8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __A,
          (__v32qi) __B, 0,
          (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_pcmpeqb256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epu8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __A,
          (__v32qi) __B, 0,
          __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_pcmpeqb256_mask ((__v32qi) __A,
           (__v32qi) __B,
           __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epu16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __A,
         (__v8hi) __B, 0,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqw128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epu16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __A,
         (__v8hi) __B, 0, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpeq_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpeqw128_mask ((__v8hi) __A,
          (__v8hi) __B, __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epu16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __A,
          (__v16hi) __B, 0,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpeq_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqw256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epu16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __A,
          (__v16hi) __B, 0,
          __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpeq_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_pcmpeqw256_mask ((__v16hi) __A,
           (__v16hi) __B,
           __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epu8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __A,
          (__v16qi) __B, 6,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtb128_mask ((__v16qi) __A,
           (__v16qi) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epu8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __A,
          (__v16qi) __B, 6,
          __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtb128_mask ((__v16qi) __A,
           (__v16qi) __B,
           __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epu8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __A,
          (__v32qi) __B, 6,
          (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_pcmpgtb256_mask ((__v32qi) __A,
           (__v32qi) __B,
           (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epu8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __A,
          (__v32qi) __B, 6,
          __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_pcmpgtb256_mask ((__v32qi) __A,
           (__v32qi) __B,
           __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epu16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __A,
         (__v8hi) __B, 6,
         (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtw128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epu16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __A,
         (__v8hi) __B, 6, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpgt_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_pcmpgtw128_mask ((__v8hi) __A,
          (__v8hi) __B, __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epu16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __A,
          (__v16hi) __B, 6,
          (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpgt_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtw256_mask ((__v16hi) __A,
           (__v16hi) __B,
           (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epu16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __A,
          (__v16hi) __B, 6,
          __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpgt_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_pcmpgtw256_mask ((__v16hi) __A,
           (__v16hi) __B,
           __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_testn_epi8_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmb128 ((__v16qi) __A,
       (__v16qi) __B,
       (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_testn_epi8_mask (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmb128 ((__v16qi) __A,
       (__v16qi) __B, __U);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testn_epi8_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmb256 ((__v32qi) __A,
       (__v32qi) __B,
       (__mmask32) -1);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_testn_epi8_mask (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_ptestnmb256 ((__v32qi) __A,
       (__v32qi) __B, __U);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_testn_epi16_mask (__m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmw128 ((__v8hi) __A,
      (__v8hi) __B,
      (__mmask8) -1);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_testn_epi16_mask (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__mmask8) __builtin_ia32_ptestnmw128 ((__v8hi) __A,
      (__v8hi) __B, __U);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_testn_epi16_mask (__m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmw256 ((__v16hi) __A,
       (__v16hi) __B,
       (__mmask16) -1);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_testn_epi16_mask (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__mmask16) __builtin_ia32_ptestnmw256 ((__v16hi) __A,
       (__v16hi) __B, __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shuffle_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
     __m256i __B)
{
  return (__m256i) __builtin_ia32_pshufb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi) __W,
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shuffle_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pshufb256_mask ((__v32qi) __A,
        (__v32qi) __B,
        (__v32qi)
        _mm256_setzero_si256 (),
        (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shuffle_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_pshufb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shuffle_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pshufb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_packs_epi16 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packsswb256_mask ((__v16hi) __A,
          (__v16hi) __B,
          (__v32qi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_packs_epi16 (__m256i __W, __mmask32 __M, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_packsswb256_mask ((__v16hi) __A,
          (__v16hi) __B,
          (__v32qi) __W,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_packs_epi16 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packsswb128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_packs_epi16 (__m128i __W, __mmask16 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_packsswb128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__v16qi) __W,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_packus_epi16 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packuswb256_mask ((__v16hi) __A,
          (__v16hi) __B,
          (__v32qi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_packus_epi16 (__m256i __W, __mmask32 __M, __m256i __A,
     __m256i __B)
{
  return (__m256i) __builtin_ia32_packuswb256_mask ((__v16hi) __A,
          (__v16hi) __B,
          (__v32qi) __W,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_packus_epi16 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packuswb128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__v16qi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_packus_epi16 (__m128i __W, __mmask16 __M, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_packuswb128_mask ((__v8hi) __A,
          (__v8hi) __B,
          (__v16qi) __W,
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_abs_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsb256_mask ((__v32qi) __A,
       (__v32qi) __W,
       (__mmask32) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_abs_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsb256_mask ((__v32qi) __A,
       (__v32qi)
       _mm256_setzero_si256 (),
       (__mmask32) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_abs_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsb128_mask ((__v16qi) __A,
       (__v16qi) __W,
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_abs_epi8 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsb128_mask ((__v16qi) __A,
       (__v16qi)
       _mm_setzero_si128 (),
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_abs_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsw256_mask ((__v16hi) __A,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_abs_epi16 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsw256_mask ((__v16hi) __A,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_abs_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsw128_mask ((__v8hi) __A,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_abs_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsw128_mask ((__v8hi) __A,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epu8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 4,
         (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epu8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 1,
         (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epu8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 5,
         (__mmask32) -1);
}

extern __inline __mmask32
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epu8_mask (__m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 2,
         (__mmask32) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpneq_epu16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 4,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmplt_epu16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 1,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmpge_epu16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 5,
         (__mmask16) -1);
}

extern __inline __mmask16
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cmple_epu16_mask (__m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 2,
         (__mmask16) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_epi16 (void *__P, __m256i __A)
{
  *(__v16hi_u *) __P = (__v16hi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_storeu_epi16 (void *__P, __mmask16 __U, __m256i __A)
{
  __builtin_ia32_storedquhi256_mask ((short *) __P,
         (__v16hi) __A,
         (__mmask16) __U);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_epi16 (void *__P, __m128i __A)
{
  *(__v8hi_u *) __P = (__v8hi_u) __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_storeu_epi16 (void *__P, __mmask8 __U, __m128i __A)
{
  __builtin_ia32_storedquhi128_mask ((short *) __P,
         (__v8hi) __A,
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_adds_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_subs_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_subs_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_subs_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_subs_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_subs_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusb128_mask ((__v16qi) __A,
         (__v16qi) __B,
         (__v16qi) __W,
         (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_subs_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusb128_mask ((__v16qi) __A,
         (__v16qi) __B,
         (__v16qi)
         _mm_setzero_si128 (),
         (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_subs_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi) __W,
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_subs_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi)
         _mm_setzero_si128 (),
         (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srl_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psrlw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srl_epi16 (__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psrlw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srl_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srl_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sra_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psraw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sra_epi16 (__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psraw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sra_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psraw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sra_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psraw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_adds_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsw128_mask ((__v8hi) __A,
        (__v8hi) __B,
        (__v8hi)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_adds_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusb128_mask ((__v16qi) __A,
         (__v16qi) __B,
         (__v16qi) __W,
         (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_adds_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusb128_mask ((__v16qi) __A,
         (__v16qi) __B,
         (__v16qi)
         _mm_setzero_si128 (),
         (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_adds_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi) __W,
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_adds_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusw128_mask ((__v8hi) __A,
         (__v8hi) __B,
         (__v8hi)
         _mm_setzero_si128 (),
         (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
     __m128i __B)
{
  return (__m128i) __builtin_ia32_psubb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi) __W,
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__v16qi)
       _mm_setzero_si128 (),
       (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psubw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_adds_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi) __W,
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_adds_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsb128_mask ((__v16qi) __A,
        (__v16qi) __B,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi16_epi8 (__m128i __A)
{

  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
        (__v16qi)_mm_undefined_si128(),
        (__mmask8) -1);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi16_storeu_epi8 (void * __P, __mmask8 __M,__m128i __A)
{
  __builtin_ia32_pmovwb128mem_mask ((unsigned long long *) __P , (__v8hi) __A, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
        (__v16qi) __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi16_epi8 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srav_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psrav16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srav_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_psrav16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srav_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psrav16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srav_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrav8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srav_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_psrav8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srav_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrav8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_srlv_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psrlv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_srlv_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_psrlv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_srlv_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psrlv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_srlv_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_srlv_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_srlv_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psrlv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sllv_epi16 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psllv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sllv_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
   __m256i __B)
{
  return (__m256i) __builtin_ia32_psllv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sllv_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psllv16hi_mask ((__v16hi) __A,
        (__v16hi) __B,
        (__v16hi)
        _mm256_setzero_si256 (),
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sllv_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psllv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sllv_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_psllv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sllv_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psllv8hi_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sll_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
      __m128i __B)
{
  return (__m128i) __builtin_ia32_psllw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sll_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psllw128_mask ((__v8hi) __A,
       (__v8hi) __B,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sll_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
         __m128i __B)
{
  return (__m256i) __builtin_ia32_psllw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sll_epi16 (__mmask16 __U, __m256i __A, __m128i __B)
{
  return (__m256i) __builtin_ia32_psllw256_mask ((__v16hi) __A,
       (__v8hi) __B,
       (__v16hi)
       _mm256_setzero_si256 (),
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_packus_epi32 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packusdw256_mask ((__v8si) __A,
          (__v8si) __B,
          (__v16hi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_packus_epi32 (__m256i __W, __mmask16 __M, __m256i __A,
     __m256i __B)
{
  return (__m256i) __builtin_ia32_packusdw256_mask ((__v8si) __A,
          (__v8si) __B,
          (__v16hi) __W,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_packus_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packusdw128_mask ((__v4si) __A,
          (__v4si) __B,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_packus_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_packusdw128_mask ((__v4si) __A,
          (__v4si) __B,
          (__v8hi) __W, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_packs_epi32 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packssdw256_mask ((__v8si) __A,
          (__v8si) __B,
          (__v16hi)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_packs_epi32 (__m256i __W, __mmask16 __M, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_packssdw256_mask ((__v8si) __A,
          (__v8si) __B,
          (__v16hi) __W,
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_packs_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packssdw128_mask ((__v4si) __A,
          (__v4si) __B,
          (__v8hi)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_packs_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_packssdw128_mask ((__v4si) __A,
          (__v4si) __B,
          (__v8hi) __W, __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epu8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 4,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epu8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 1,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epu8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 5,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epu8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpb128_mask ((__v16qi) __X,
         (__v16qi) __Y, 2,
         (__mmask16) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epu16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 4,
        (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epu16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 1,
        (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epu16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 5,
        (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epu16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_ucmpw128_mask ((__v8hi) __X,
        (__v8hi) __Y, 2,
        (__mmask8) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epi8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 4,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epi8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 1,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epi8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 5,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epi8_mask (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__mmask16) __builtin_ia32_cmpb128_mask ((__v16qi) __X,
        (__v16qi) __Y, 2,
        (__mmask16) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpneq_epi16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 4,
       (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmplt_epi16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 1,
       (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmpge_epi16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 5,
       (__mmask8) __M);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cmple_epi16_mask (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__mmask8) __builtin_ia32_cmpw128_mask ((__v8hi) __X,
       (__v8hi) __Y, 2,
       (__mmask8) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epu8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 4,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epu8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 1,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epu8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 5,
         (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epu8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_ucmpb256_mask ((__v32qi) __X,
         (__v32qi) __Y, 2,
         (__mmask32) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epu16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 4,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epu16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 1,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epu16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 5,
         (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epu16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_ucmpw256_mask ((__v16hi) __X,
         (__v16hi) __Y, 2,
         (__mmask16) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epi8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 4,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epi8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 1,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epi8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 5,
        (__mmask32) __M);
}

extern __inline __mmask32
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epi8_mask (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__mmask32) __builtin_ia32_cmpb256_mask ((__v32qi) __X,
        (__v32qi) __Y, 2,
        (__mmask32) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpneq_epi16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 4,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmplt_epi16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 1,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmpge_epi16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 5,
        (__mmask16) __M);
}

extern __inline __mmask16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cmple_epi16_mask (__mmask16 __M, __m256i __X, __m256i __Y)
{
  return (__mmask16) __builtin_ia32_cmpw256_mask ((__v16hi) __X,
        (__v16hi) __Y, 2,
        (__mmask16) __M);
}



#pragma GCC pop_options
# 64 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vldqintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vldqintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vl,avx512dq")



extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttpd_epi64 (__m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttpd_epi64 (__mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi64 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttpd_epi64 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttpd_epu64 (__m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
            (__v4di) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttpd_epu64 (__mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epu64 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
            (__v2di) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttpd_epu64 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_epi64 (__m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_epi64 (__mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi64 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_epi64 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_epu64 (__m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_epu64 (__mmask8 __U, __m256d __A)
{
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epu64 (__m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_epu64 (__mmask8 __U, __m128d __A)
{
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttps_epi64 (__m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttps_epi64 (__m256i __W, __mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi64 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttps_epi64 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttps_epu64 (__m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttps_epu64 (__m256i __W, __mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
            (__v4di) __W,
            (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epu64 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttps_epu64 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
            (__v2di) __W,
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_f64x2 (__m128d __A)
{
  return (__m256d) __builtin_ia32_broadcastf64x2_256_mask ((__v2df)
          __A,
                 (__v4df)_mm256_undefined_pd(),
          (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_f64x2 (__m256d __O, __mmask8 __M, __m128d __A)
{
  return (__m256d) __builtin_ia32_broadcastf64x2_256_mask ((__v2df)
          __A,
          (__v4df)
          __O, __M);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_f64x2 (__mmask8 __M, __m128d __A)
{
  return (__m256d) __builtin_ia32_broadcastf64x2_256_mask ((__v2df)
          __A,
          (__v4df)
          _mm256_setzero_ps (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_i64x2 (__m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti64x2_256_mask ((__v2di)
          __A,
                 (__v4di)_mm256_undefined_si256(),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_i64x2 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti64x2_256_mask ((__v2di)
          __A,
          (__v4di)
          __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_i64x2 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti64x2_256_mask ((__v2di)
          __A,
          (__v4di)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_f32x2 (__m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
                (__v8sf)_mm256_undefined_ps(),
         (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_f32x2 (__m256 __O, __mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
         (__v8sf) __O,
         __M);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_f32x2 (__mmask8 __M, __m128 __A)
{
  return (__m256) __builtin_ia32_broadcastf32x2_256_mask ((__v4sf) __A,
         (__v8sf)
         _mm256_setzero_ps (),
         __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_broadcast_i32x2 (__m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si)
          __A,
                (__v8si)_mm256_undefined_si256(),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_broadcast_i32x2 (__m256i __O, __mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si)
          __A,
          (__v8si)
          __O, __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_broadcast_i32x2 (__mmask8 __M, __m128i __A)
{
  return (__m256i) __builtin_ia32_broadcasti32x2_256_mask ((__v4si)
          __A,
          (__v8si)
          _mm256_setzero_si256 (),
          __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_broadcast_i32x2 (__m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si)
          __A,
                (__v4si)_mm_undefined_si128(),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_broadcast_i32x2 (__m128i __O, __mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si)
          __A,
          (__v4si)
          __O, __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_broadcast_i32x2 (__mmask8 __M, __m128i __A)
{
  return (__m128i) __builtin_ia32_broadcasti32x2_128_mask ((__v4si)
          __A,
          (__v4si)
          _mm_setzero_si128 (),
          __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mullo_epi64 (__m256i __A, __m256i __B)
{
  return (__m256i) ((__v4du) __A * (__v4du) __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mullo_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_pmullq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di) __W,
        (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mullo_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmullq256_mask ((__v4di) __A,
        (__v4di) __B,
        (__v4di)
        _mm256_setzero_si256 (),
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du) __A * (__v2du) __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mullo_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmullq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di) __W,
        (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mullo_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmullq128_mask ((__v2di) __A,
        (__v2di) __B,
        (__v2di)
        _mm_setzero_si128 (),
        (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_andnot_pd (__m256d __W, __mmask8 __U, __m256d __A,
         __m256d __B)
{
  return (__m256d) __builtin_ia32_andnpd256_mask ((__v4df) __A,
        (__v4df) __B,
        (__v4df) __W,
        (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_andnot_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_andnpd256_mask ((__v4df) __A,
        (__v4df) __B,
        (__v4df)
        _mm256_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_andnot_pd (__m128d __W, __mmask8 __U, __m128d __A,
      __m128d __B)
{
  return (__m128d) __builtin_ia32_andnpd128_mask ((__v2df) __A,
        (__v2df) __B,
        (__v2df) __W,
        (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_andnot_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_andnpd128_mask ((__v2df) __A,
        (__v2df) __B,
        (__v2df)
        _mm_setzero_pd (),
        (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_andnot_ps (__m256 __W, __mmask8 __U, __m256 __A,
         __m256 __B)
{
  return (__m256) __builtin_ia32_andnps256_mask ((__v8sf) __A,
       (__v8sf) __B,
       (__v8sf) __W,
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_andnot_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_andnps256_mask ((__v8sf) __A,
       (__v8sf) __B,
       (__v8sf)
       _mm256_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_andnot_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_andnps128_mask ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf) __W,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_andnot_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_andnps128_mask ((__v4sf) __A,
       (__v4sf) __B,
       (__v4sf)
       _mm_setzero_ps (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtps_epi64 (__m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtps_epi64 (__m256i __W, __mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
          (__v4di) __W,
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
          (__v4di)
          _mm256_setzero_si256 (),
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi64 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtps_epi64 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
          (__v2di) __W,
          (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
          (__v2di)
          _mm_setzero_si128 (),
          (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtps_epu64 (__m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtps_epu64 (__m256i __W, __mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
           (__v4di) __W,
           (__mmask8) __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A)
{
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
           (__v4di)
           _mm256_setzero_si256 (),
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epu64 (__m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtps_epu64 (__m128i __W, __mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
           (__v2di) __W,
           (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A)
{
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
           (__v2di)
           _mm_setzero_si128 (),
           (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_ps (__m256i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m256i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_ps (__mmask8 __U, __m256i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_ps (__m128i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
         (__v4sf) __W,
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
         (__v4sf)
         _mm_setzero_ps (),
         (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu64_ps (__m256i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m256i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu64_ps (__mmask8 __U, __m256i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu64_ps (__m128i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
          (__v4sf) __W,
          (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu64_ps (__mmask8 __U, __m128i __A)
{
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
          (__v4sf)
          _mm_setzero_ps (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_pd (__m256i __A)
{
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_pd (__m256d __W, __mmask8 __U, __m256i __A)
{
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
          (__v4df) __W,
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_pd (__mmask8 __U, __m256i __A)
{
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
          (__v4df)
          _mm256_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_pd (__m128i __A)
{
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_pd (__m128d __W, __mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
          (__v2df) __W,
          (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_pd (__mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
          (__v2df)
          _mm_setzero_pd (),
          (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu64_pd (__m256i __A)
{
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu64_pd (__m256d __W, __mmask8 __U, __m256i __A)
{
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
           (__v4df) __W,
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu64_pd (__mmask8 __U, __m256i __A)
{
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
           (__v4df)
           _mm256_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_and_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_andpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_and_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_andpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_and_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_andpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_and_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_andpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_and_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_andps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_and_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_andps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_and_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_andps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_and_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_andps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu64_pd (__m128i __A)
{
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu64_pd (__m128d __W, __mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
           (__v2df) __W,
           (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu64_pd (__mmask8 __U, __m128i __A)
{
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
           (__v2df)
           _mm_setzero_pd (),
           (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_xor_pd (__m256d __W, __mmask8 __U, __m256d __A,
      __m256d __B)
{
  return (__m256d) __builtin_ia32_xorpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df) __W,
       (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_xor_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_xorpd256_mask ((__v4df) __A,
       (__v4df) __B,
       (__v4df)
       _mm256_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_xor_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_xorpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df) __W,
       (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_xor_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_xorpd128_mask ((__v2df) __A,
       (__v2df) __B,
       (__v2df)
       _mm_setzero_pd (),
       (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_xor_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_xorps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf) __W,
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_xor_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_xorps256_mask ((__v8sf) __A,
      (__v8sf) __B,
      (__v8sf)
      _mm256_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_xor_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_xorps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf) __W,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_xor_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_xorps128_mask ((__v4sf) __A,
      (__v4sf) __B,
      (__v4sf)
      _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_or_pd (__m256d __W, __mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_orpd256_mask ((__v4df) __A,
      (__v4df) __B,
      (__v4df) __W,
      (__mmask8) __U);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_or_pd (__mmask8 __U, __m256d __A, __m256d __B)
{
  return (__m256d) __builtin_ia32_orpd256_mask ((__v4df) __A,
      (__v4df) __B,
      (__v4df)
      _mm256_setzero_pd (),
      (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_or_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_orpd128_mask ((__v2df) __A,
      (__v2df) __B,
      (__v2df) __W,
      (__mmask8) __U);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_or_pd (__mmask8 __U, __m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_orpd128_mask ((__v2df) __A,
      (__v2df) __B,
      (__v2df)
      _mm_setzero_pd (),
      (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_or_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_orps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_or_ps (__mmask8 __U, __m256 __A, __m256 __B)
{
  return (__m256) __builtin_ia32_orps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_or_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_orps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __W,
            (__mmask8) __U);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_or_ps (__mmask8 __U, __m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_orps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movm_epi32 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2d128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movm_epi32 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2d256 (__A);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movm_epi64 (__mmask8 __A)
{
  return (__m128i) __builtin_ia32_cvtmask2q128 (__A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movm_epi64 (__mmask8 __A)
{
  return (__m256i) __builtin_ia32_cvtmask2q256 (__A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi32_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtd2mask128 ((__v4si) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movepi32_mask (__m256i __A)
{
  return (__mmask8) __builtin_ia32_cvtd2mask256 ((__v8si) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_mask (__m128i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask128 ((__v2di) __A);
}

extern __inline __mmask8
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_movepi64_mask (__m256i __A)
{
  return (__mmask8) __builtin_ia32_cvtq2mask256 ((__v4di) __A);
}
# 2013 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vldqintrin.h" 3 4
#pragma GCC pop_options
# 66 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512ifmaintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512ifmaintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512ifma")



extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_madd52lo_epu64 (__m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_mask ((__v8di) __X,
             (__v8di) __Y,
             (__v8di) __Z,
             (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_madd52hi_epu64 (__m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_mask ((__v8di) __X,
             (__v8di) __Y,
             (__v8di) __Z,
             (__mmask8) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_madd52lo_epu64 (__m512i __W, __mmask8 __M, __m512i __X,
       __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_mask ((__v8di) __W,
             (__v8di) __X,
             (__v8di) __Y,
             (__mmask8) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_madd52hi_epu64 (__m512i __W, __mmask8 __M, __m512i __X,
       __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_mask ((__v8di) __W,
             (__v8di) __X,
             (__v8di) __Y,
             (__mmask8) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_madd52lo_epu64 (__mmask8 __M, __m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52luq512_maskz ((__v8di) __X,
       (__v8di) __Y,
       (__v8di) __Z,
       (__mmask8) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_madd52hi_epu64 (__mmask8 __M, __m512i __X, __m512i __Y, __m512i __Z)
{
  return (__m512i) __builtin_ia32_vpmadd52huq512_maskz ((__v8di) __X,
       (__v8di) __Y,
       (__v8di) __Z,
       (__mmask8) __M);
}



#pragma GCC pop_options
# 68 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512ifmavlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512ifmavlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512ifma,avx512vl")



extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd52lo_epu64 (__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_mask ((__v2di) __X,
             (__v2di) __Y,
             (__v2di) __Z,
             (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd52hi_epu64 (__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_mask ((__v2di) __X,
             (__v2di) __Y,
             (__v2di) __Z,
             (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_madd52lo_epu64 (__m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_mask ((__v4di) __X,
             (__v4di) __Y,
             (__v4di) __Z,
             (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_madd52hi_epu64 (__m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_mask ((__v4di) __X,
             (__v4di) __Y,
             (__v4di) __Z,
             (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_madd52lo_epu64 (__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_mask ((__v2di) __W,
             (__v2di) __X,
             (__v2di) __Y,
             (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_madd52hi_epu64 (__m128i __W, __mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_mask ((__v2di) __W,
             (__v2di) __X,
             (__v2di) __Y,
             (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_madd52lo_epu64 (__m256i __W, __mmask8 __M, __m256i __X,
       __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_mask ((__v4di) __W,
             (__v4di) __X,
             (__v4di) __Y,
             (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_madd52hi_epu64 (__m256i __W, __mmask8 __M, __m256i __X,
       __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_mask ((__v4di) __W,
             (__v4di) __X,
             (__v4di) __Y,
             (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_madd52lo_epu64 (__mmask8 __M, __m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52luq128_maskz ((__v2di) __X,
       (__v2di) __Y,
       (__v2di) __Z,
       (__mmask8) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_madd52hi_epu64 (__mmask8 __M, __m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i) __builtin_ia32_vpmadd52huq128_maskz ((__v2di) __X,
       (__v2di) __Y,
       (__v2di) __Z,
       (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_madd52lo_epu64 (__mmask8 __M, __m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52luq256_maskz ((__v4di) __X,
       (__v4di) __Y,
       (__v4di) __Z,
       (__mmask8) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_madd52hi_epu64 (__mmask8 __M, __m256i __X, __m256i __Y, __m256i __Z)
{
  return (__m256i) __builtin_ia32_vpmadd52huq256_maskz ((__v4di) __X,
       (__v4di) __Y,
       (__v4di) __Z,
       (__mmask8) __M);
}



#pragma GCC pop_options
# 70 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmiintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmiintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vbmi")



extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_multishift_epi64_epi8 (__m512i __W, __mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
         (__v64qi) __Y,
         (__v64qi) __W,
         (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_multishift_epi64_epi8 (__mmask64 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
         (__v64qi) __Y,
         (__v64qi)
         _mm512_setzero_si512 (),
         (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_multishift_epi64_epi8 (__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_vpmultishiftqb512_mask ((__v64qi) __X,
         (__v64qi) __Y,
         (__v64qi)
         _mm512_undefined_epi32 (),
         (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
           (__v64qi) __A,
           (__v64qi)
           _mm512_undefined_epi32 (),
           (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutexvar_epi8 (__mmask64 __M, __m512i __A,
    __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
           (__v64qi) __A,
           (__v64qi)
           _mm512_setzero_si512(),
           (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutexvar_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_permvarqi512_mask ((__v64qi) __B,
           (__v64qi) __A,
           (__v64qi) __W,
           (__mmask64) __M);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_epi8 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_mask ((__v64qi) __I
                 ,
       (__v64qi) __A,
       (__v64qi) __B,
       (__mmask64) -1);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_permutex2var_epi8 (__m512i __A, __mmask64 __U,
    __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_mask ((__v64qi) __I
                 ,
       (__v64qi) __A,
       (__v64qi) __B,
       (__mmask64)
       __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask2_permutex2var_epi8 (__m512i __A, __m512i __I,
     __mmask64 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varqi512_mask ((__v64qi) __A,
       (__v64qi) __I
                 ,
       (__v64qi) __B,
       (__mmask64)
       __U);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_permutex2var_epi8 (__mmask64 __U, __m512i __A,
     __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varqi512_maskz ((__v64qi) __I
                  ,
        (__v64qi) __A,
        (__v64qi) __B,
        (__mmask64)
        __U);
}



#pragma GCC pop_options
# 72 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmivlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmivlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vbmi,avx512vl")



extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_multishift_epi64_epi8 (__m256i __W, __mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
         (__v32qi) __Y,
         (__v32qi) __W,
         (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_multishift_epi64_epi8 (__mmask32 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
         (__v32qi) __Y,
         (__v32qi)
         _mm256_setzero_si256 (),
         (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_multishift_epi64_epi8 (__m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_vpmultishiftqb256_mask ((__v32qi) __X,
         (__v32qi) __Y,
         (__v32qi)
         _mm256_undefined_si256 (),
         (__mmask32) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_multishift_epi64_epi8 (__m128i __W, __mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
         (__v16qi) __Y,
         (__v16qi) __W,
         (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_multishift_epi64_epi8 (__mmask16 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
         (__v16qi) __Y,
         (__v16qi)
         _mm_setzero_si128 (),
         (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_multishift_epi64_epi8 (__m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_vpmultishiftqb128_mask ((__v16qi) __X,
         (__v16qi) __Y,
         (__v16qi)
         _mm_undefined_si128 (),
         (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
           (__v32qi) __A,
           (__v32qi)
           _mm256_undefined_si256 (),
           (__mmask32) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutexvar_epi8 (__mmask32 __M, __m256i __A,
    __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
           (__v32qi) __A,
           (__v32qi)
           _mm256_setzero_si256 (),
           (__mmask32) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutexvar_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_permvarqi256_mask ((__v32qi) __B,
           (__v32qi) __A,
           (__v32qi) __W,
           (__mmask32) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutexvar_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
           (__v16qi) __A,
           (__v16qi)
           _mm_undefined_si128 (),
           (__mmask16) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutexvar_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
           (__v16qi) __A,
           (__v16qi)
           _mm_setzero_si128 (),
           (__mmask16) __M);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutexvar_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_permvarqi128_mask ((__v16qi) __B,
           (__v16qi) __A,
           (__v16qi) __W,
           (__mmask16) __M);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_epi8 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_mask ((__v32qi) __I
                 ,
       (__v32qi) __A,
       (__v32qi) __B,
       (__mmask32) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_permutex2var_epi8 (__m256i __A, __mmask32 __U,
    __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_mask ((__v32qi) __I
                 ,
       (__v32qi) __A,
       (__v32qi) __B,
       (__mmask32)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask2_permutex2var_epi8 (__m256i __A, __m256i __I,
     __mmask32 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varqi256_mask ((__v32qi) __A,
       (__v32qi) __I
                 ,
       (__v32qi) __B,
       (__mmask32)
       __U);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_permutex2var_epi8 (__mmask32 __U, __m256i __A,
     __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varqi256_maskz ((__v32qi) __I
                  ,
        (__v32qi) __A,
        (__v32qi) __B,
        (__mmask32)
        __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_epi8 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_mask ((__v16qi) __I
                 ,
       (__v16qi) __A,
       (__v16qi) __B,
       (__mmask16) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_permutex2var_epi8 (__m128i __A, __mmask16 __U, __m128i __I,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_mask ((__v16qi) __I
                 ,
       (__v16qi) __A,
       (__v16qi) __B,
       (__mmask16)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask2_permutex2var_epi8 (__m128i __A, __m128i __I, __mmask16 __U,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varqi128_mask ((__v16qi) __A,
       (__v16qi) __I
                 ,
       (__v16qi) __B,
       (__mmask16)
       __U);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_permutex2var_epi8 (__mmask16 __U, __m128i __A, __m128i __I,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varqi128_maskz ((__v16qi) __I
                  ,
        (__v16qi) __A,
        (__v16qi) __B,
        (__mmask16)
        __U);
}



#pragma GCC pop_options
# 74 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx5124fmapsintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx5124fmapsintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx5124fmaps")



extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_4fmadd_ps (__m512 __A, __m512 __B, __m512 __C,
    __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fmaddps ((__v16sf) __B,
        (__v16sf) __C,
        (__v16sf) __D,
        (__v16sf) __E,
        (__v16sf) __A,
        (const __v4sf *) __F);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_4fmadd_ps (__m512 __A, __mmask16 __U, __m512 __B,
         __m512 __C, __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fmaddps_mask ((__v16sf) __B,
      (__v16sf) __C,
      (__v16sf) __D,
      (__v16sf) __E,
      (__v16sf) __A,
      (const __v4sf *) __F,
      (__v16sf) __A,
      (__mmask16) __U);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_4fmadd_ps (__mmask16 __U,
   __m512 __A, __m512 __B, __m512 __C,
   __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fmaddps_mask ((__v16sf) __B,
      (__v16sf) __C,
      (__v16sf) __D,
      (__v16sf) __E,
      (__v16sf) __A,
      (const __v4sf *) __F,
      (__v16sf) _mm512_setzero_ps (),
      (__mmask16) __U);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_4fmadd_ss (__m128 __A, __m128 __B, __m128 __C,
        __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fmaddss ((__v4sf) __B,
        (__v4sf) __C,
        (__v4sf) __D,
        (__v4sf) __E,
        (__v4sf) __A,
        (const __v4sf *) __F);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_4fmadd_ss (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C,
      __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fmaddss_mask ((__v4sf) __B,
      (__v4sf) __C,
      (__v4sf) __D,
      (__v4sf) __E,
      (__v4sf) __A,
      (const __v4sf *) __F,
      (__v4sf) __A,
      (__mmask8) __U);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_4fmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C,
       __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fmaddss_mask ((__v4sf) __B,
      (__v4sf) __C,
      (__v4sf) __D,
      (__v4sf) __E,
      (__v4sf) __A,
      (const __v4sf *) __F,
      (__v4sf) _mm_setzero_ps (),
      (__mmask8) __U);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_4fnmadd_ps (__m512 __A, __m512 __B, __m512 __C,
     __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fnmaddps ((__v16sf) __B,
         (__v16sf) __C,
         (__v16sf) __D,
         (__v16sf) __E,
         (__v16sf) __A,
         (const __v4sf *) __F);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_4fnmadd_ps (__m512 __A, __mmask16 __U, __m512 __B,
   __m512 __C, __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fnmaddps_mask ((__v16sf) __B,
       (__v16sf) __C,
       (__v16sf) __D,
       (__v16sf) __E,
       (__v16sf) __A,
       (const __v4sf *) __F,
       (__v16sf) __A,
       (__mmask16) __U);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_4fnmadd_ps (__mmask16 __U,
    __m512 __A, __m512 __B, __m512 __C,
    __m512 __D, __m512 __E, __m128 *__F)
{
  return (__m512) __builtin_ia32_4fnmaddps_mask ((__v16sf) __B,
       (__v16sf) __C,
       (__v16sf) __D,
       (__v16sf) __E,
       (__v16sf) __A,
       (const __v4sf *) __F,
       (__v16sf) _mm512_setzero_ps (),
       (__mmask16) __U);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_4fnmadd_ss (__m128 __A, __m128 __B, __m128 __C,
  __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fnmaddss ((__v4sf) __B,
         (__v4sf) __C,
         (__v4sf) __D,
         (__v4sf) __E,
         (__v4sf) __A,
         (const __v4sf *) __F);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_4fnmadd_ss (__m128 __A, __mmask8 __U, __m128 __B, __m128 __C,
       __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fnmaddss_mask ((__v4sf) __B,
       (__v4sf) __C,
       (__v4sf) __D,
       (__v4sf) __E,
       (__v4sf) __A,
       (const __v4sf *) __F,
       (__v4sf) __A,
       (__mmask8) __U);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_4fnmadd_ss (__mmask8 __U, __m128 __A, __m128 __B, __m128 __C,
        __m128 __D, __m128 __E, __m128 *__F)
{
  return (__m128) __builtin_ia32_4fnmaddss_mask ((__v4sf) __B,
       (__v4sf) __C,
       (__v4sf) __D,
       (__v4sf) __E,
       (__v4sf) __A,
       (const __v4sf *) __F,
       (__v4sf) _mm_setzero_ps (),
       (__mmask8) __U);
}



#pragma GCC pop_options
# 76 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx5124vnniwintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx5124vnniwintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx5124vnniw")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_4dpwssd_epi32 (__m512i __A, __m512i __B, __m512i __C,
        __m512i __D, __m512i __E, __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssd ((__v16si) __B,
          (__v16si) __C,
          (__v16si) __D,
          (__v16si) __E,
          (__v16si) __A,
          (const __v4si *) __F);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_4dpwssd_epi32 (__m512i __A, __mmask16 __U, __m512i __B,
      __m512i __C, __m512i __D, __m512i __E,
      __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssd_mask ((__v16si) __B,
        (__v16si) __C,
        (__v16si) __D,
        (__v16si) __E,
        (__v16si) __A,
        (const __v4si *) __F,
        (__v16si) __A,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_4dpwssd_epi32 (__mmask16 __U, __m512i __A, __m512i __B,
       __m512i __C, __m512i __D, __m512i __E,
       __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssd_mask ((__v16si) __B,
        (__v16si) __C,
        (__v16si) __D,
        (__v16si) __E,
        (__v16si) __A,
        (const __v4si *) __F,
        (__v16si) _mm512_setzero_ps (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_4dpwssds_epi32 (__m512i __A, __m512i __B, __m512i __C,
         __m512i __D, __m512i __E, __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssds ((__v16si) __B,
           (__v16si) __C,
           (__v16si) __D,
           (__v16si) __E,
           (__v16si) __A,
           (const __v4si *) __F);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_4dpwssds_epi32 (__m512i __A, __mmask16 __U, __m512i __B,
       __m512i __C, __m512i __D, __m512i __E,
       __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssds_mask ((__v16si) __B,
         (__v16si) __C,
         (__v16si) __D,
         (__v16si) __E,
         (__v16si) __A,
         (const __v4si *) __F,
         (__v16si) __A,
         (__mmask16) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_4dpwssds_epi32 (__mmask16 __U, __m512i __A, __m512i __B,
        __m512i __C, __m512i __D, __m512i __E,
        __m128i *__F)
{
  return (__m512i) __builtin_ia32_vp4dpwssds_mask ((__v16si) __B,
         (__v16si) __C,
         (__v16si) __D,
         (__v16si) __E,
         (__v16si) __A,
         (const __v4si *) __F,
         (__v16si) _mm512_setzero_ps (),
         (__mmask16) __U);
}



#pragma GCC pop_options
# 78 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vpopcntdqintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vpopcntdqintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vpopcntdq")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_popcnt_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountd_v16si ((__v16si) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_popcnt_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountd_v16si_mask ((__v16si) __A,
        (__v16si) __W,
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_popcnt_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountd_v16si_mask ((__v16si) __A,
        (__v16si)
        _mm512_setzero_si512 (),
        (__mmask16) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_popcnt_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountq_v8di ((__v8di) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_popcnt_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountq_v8di_mask ((__v8di) __A,
       (__v8di) __W,
       (__mmask8) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_popcnt_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountq_v8di_mask ((__v8di) __A,
       (__v8di)
       _mm512_setzero_si512 (),
       (__mmask8) __U);
}



#pragma GCC pop_options
# 80 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vbmi2")
# 218 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2intrin.h" 3 4
extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shrdv_epi16 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshrdv_v32hi ((__v32hi)__A, (__v32hi) __B,
        (__v32hi) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shrdv_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshrdv_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shrdv_epi32 (__m512i __A, __mmask16 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shrdv_epi32 (__mmask16 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shrdv_epi64 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshrdv_v8di ((__v8di)__A, (__v8di) __B,
        (__v8di) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shrdv_epi64 (__m512i __A, __mmask8 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v8di_mask ((__v8di)__A, (__v8di) __C,
      (__v8di) __D, (__mmask8)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shrdv_epi64 (__mmask8 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v8di_maskz ((__v8di)__B, (__v8di) __C,
       (__v8di) __D, (__mmask8)__A);
}
extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shldv_epi16 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshldv_v32hi ((__v32hi)__A, (__v32hi) __B,
        (__v32hi) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shldv_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshldv_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shldv_epi32 (__m512i __A, __mmask16 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shldv_epi32 (__mmask16 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_shldv_epi64 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpshldv_v8di ((__v8di)__A, (__v8di) __B,
        (__v8di) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shldv_epi64 (__m512i __A, __mmask8 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v8di_mask ((__v8di)__A, (__v8di) __C,
      (__v8di) __D, (__mmask8)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shldv_epi64 (__mmask8 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v8di_maskz ((__v8di)__B, (__v8di) __C,
      (__v8di) __D, (__mmask8)__A);
}




#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("avx512vbmi2,avx512bw")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_epi8 (__m512i __A, __mmask64 __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_compressqi512_mask ((__v64qi)__C,
      (__v64qi)__A, (__mmask64)__B);
}


extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_epi8 (__mmask64 __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_compressqi512_mask ((__v64qi)__B,
   (__v64qi)_mm512_setzero_si512 (), (__mmask64)__A);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_epi8 (void * __A, __mmask64 __B, __m512i __C)
{
  __builtin_ia32_compressstoreuqi512_mask ((__v64qi *) __A, (__v64qi) __C,
       (__mmask64) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compress_epi16 (__m512i __A, __mmask32 __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_compresshi512_mask ((__v32hi)__C,
      (__v32hi)__A, (__mmask32)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_compress_epi16 (__mmask32 __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_compresshi512_mask ((__v32hi)__B,
   (__v32hi)_mm512_setzero_si512 (), (__mmask32)__A);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_compressstoreu_epi16 (void * __A, __mmask32 __B, __m512i __C)
{
  __builtin_ia32_compressstoreuhi512_mask ((__v32hi *) __A, (__v32hi) __C,
       (__mmask32) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_epi8 (__m512i __A, __mmask64 __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_expandqi512_mask ((__v64qi) __C,
          (__v64qi) __A,
          (__mmask64) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_epi8 (__mmask64 __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_expandqi512_maskz ((__v64qi) __B,
   (__v64qi) _mm512_setzero_si512 (), (__mmask64) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_epi8 (__m512i __A, __mmask64 __B, const void * __C)
{
  return (__m512i) __builtin_ia32_expandloadqi512_mask ((const __v64qi *) __C,
     (__v64qi) __A, (__mmask64) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_epi8 (__mmask64 __A, const void * __B)
{
  return (__m512i) __builtin_ia32_expandloadqi512_maskz ((const __v64qi *) __B,
   (__v64qi) _mm512_setzero_si512 (), (__mmask64) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expand_epi16 (__m512i __A, __mmask32 __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_expandhi512_mask ((__v32hi) __C,
          (__v32hi) __A,
          (__mmask32) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expand_epi16 (__mmask32 __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_expandhi512_maskz ((__v32hi) __B,
   (__v32hi) _mm512_setzero_si512 (), (__mmask32) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_expandloadu_epi16 (__m512i __A, __mmask32 __B, const void * __C)
{
  return (__m512i) __builtin_ia32_expandloadhi512_mask ((const __v32hi *) __C,
     (__v32hi) __A, (__mmask32) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_expandloadu_epi16 (__mmask32 __A, const void * __B)
{
  return (__m512i) __builtin_ia32_expandloadhi512_maskz ((const __v32hi *) __B,
   (__v32hi) _mm512_setzero_si512 (), (__mmask32) __A);
}
# 519 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2intrin.h" 3 4
extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shrdv_epi16 (__m512i __A, __mmask32 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v32hi_mask ((__v32hi)__A,
    (__v32hi) __C, (__v32hi) __D, (__mmask32)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shrdv_epi16 (__mmask32 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshrdv_v32hi_maskz ((__v32hi)__B,
    (__v32hi) __C, (__v32hi) __D, (__mmask32)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_shldv_epi16 (__m512i __A, __mmask32 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v32hi_mask ((__v32hi)__A,
    (__v32hi) __C, (__v32hi) __D, (__mmask32)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_shldv_epi16 (__mmask32 __A, __m512i __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpshldv_v32hi_maskz ((__v32hi)__B,
    (__v32hi) __C, (__v32hi) __D, (__mmask32)__A);
}




#pragma GCC pop_options
# 82 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2vlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2vlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vbmi2,avx512vl")



extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_epi8 (__m128i __A, __mmask16 __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_compressqi128_mask ((__v16qi)__C,
      (__v16qi)__A, (__mmask16)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_epi8 (__mmask16 __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_compressqi128_mask ((__v16qi) __B,
   (__v16qi) _mm_setzero_si128 (), (__mmask16) __A);
}


extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_epi16 (void * __A, __mmask16 __B, __m256i __C)
{
  __builtin_ia32_compressstoreuhi256_mask ((__v16hi *) __A, (__v16hi) __C,
       (__mmask16) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compress_epi16 (__m128i __A, __mmask8 __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_compresshi128_mask ((__v8hi)__C, (__v8hi)__A,
        (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_compress_epi16 (__mmask8 __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_compresshi128_mask ((__v8hi) __B,
    (__v8hi) _mm_setzero_si128 (), (__mmask8) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_epi16 (__m256i __A, __mmask16 __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_compresshi256_mask ((__v16hi)__C,
      (__v16hi)__A, (__mmask16)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_epi16 (__mmask16 __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_compresshi256_mask ((__v16hi) __B,
   (__v16hi) _mm256_setzero_si256 (), (__mmask16) __A);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_epi8 (void * __A, __mmask16 __B, __m128i __C)
{
  __builtin_ia32_compressstoreuqi128_mask ((__v16qi *) __A, (__v16qi) __C,
       (__mmask16) __B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_compressstoreu_epi16 (void * __A, __mmask8 __B, __m128i __C)
{
  __builtin_ia32_compressstoreuhi128_mask ((__v8hi *) __A, (__v8hi) __C,
       (__mmask8) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_epi8 (__m128i __A, __mmask16 __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_expandqi128_mask ((__v16qi) __C,
          (__v16qi) __A,
          (__mmask16) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_epi8 (__mmask16 __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_expandqi128_maskz ((__v16qi) __B,
   (__v16qi) _mm_setzero_si128 (), (__mmask16) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_epi8 (__m128i __A, __mmask16 __B, const void * __C)
{
  return (__m128i) __builtin_ia32_expandloadqi128_mask ((const __v16qi *) __C,
     (__v16qi) __A, (__mmask16) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_epi8 (__mmask16 __A, const void * __B)
{
  return (__m128i) __builtin_ia32_expandloadqi128_maskz ((const __v16qi *) __B,
   (__v16qi) _mm_setzero_si128 (), (__mmask16) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expand_epi16 (__m128i __A, __mmask8 __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_expandhi128_mask ((__v8hi) __C,
          (__v8hi) __A,
          (__mmask8) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expand_epi16 (__mmask8 __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_expandhi128_maskz ((__v8hi) __B,
    (__v8hi) _mm_setzero_si128 (), (__mmask8) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_expandloadu_epi16 (__m128i __A, __mmask8 __B, const void * __C)
{
  return (__m128i) __builtin_ia32_expandloadhi128_mask ((const __v8hi *) __C,
      (__v8hi) __A, (__mmask8) __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_expandloadu_epi16 (__mmask8 __A, const void * __B)
{
  return (__m128i) __builtin_ia32_expandloadhi128_maskz ((const __v8hi *) __B,
    (__v8hi) _mm_setzero_si128 (), (__mmask8) __A);
}
extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_epi16 (__m256i __A, __mmask16 __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_expandhi256_mask ((__v16hi) __C,
          (__v16hi) __A,
          (__mmask16) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_epi16 (__mmask16 __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_expandhi256_maskz ((__v16hi) __B,
   (__v16hi) _mm256_setzero_si256 (), (__mmask16) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_epi16 (__m256i __A, __mmask16 __B, const void * __C)
{
  return (__m256i) __builtin_ia32_expandloadhi256_mask ((const __v16hi *) __C,
     (__v16hi) __A, (__mmask16) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_epi16 (__mmask16 __A, const void * __B)
{
  return (__m256i) __builtin_ia32_expandloadhi256_maskz ((const __v16hi *) __B,
   (__v16hi) _mm256_setzero_si256 (), (__mmask16) __A);
}
# 672 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vbmi2vlintrin.h" 3 4
extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shrdv_epi16 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshrdv_v16hi ((__v16hi)__A, (__v16hi) __B,
        (__v16hi) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shrdv_epi16 (__m256i __A, __mmask16 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v16hi_mask ((__v16hi)__A,
    (__v16hi) __C, (__v16hi) __D, (__mmask16)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shrdv_epi16 (__mmask16 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v16hi_maskz ((__v16hi)__B,
    (__v16hi) __C, (__v16hi) __D, (__mmask16)__A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shrdv_epi32 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshrdv_v8si ((__v8si)__A, (__v8si) __B,
        (__v8si) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shrdv_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v8si_mask ((__v8si)__A, (__v8si) __C,
      (__v8si) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shrdv_epi32 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v8si_maskz ((__v8si)__B, (__v8si) __C,
       (__v8si) __D, (__mmask8)__A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shrdv_epi64 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshrdv_v4di ((__v4di)__A, (__v4di) __B,
        (__v4di) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shrdv_epi64 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v4di_mask ((__v4di)__A, (__v4di) __C,
      (__v4di) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shrdv_epi64 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshrdv_v4di_maskz ((__v4di)__B, (__v4di) __C,
       (__v4di) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shrdv_epi16 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshrdv_v8hi ((__v8hi)__A, (__v8hi) __B,
        (__v8hi) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shrdv_epi16 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v8hi_mask ((__v8hi)__A, (__v8hi) __C,
      (__v8hi) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shrdv_epi16 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v8hi_maskz ((__v8hi)__B, (__v8hi) __C,
       (__v8hi) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shrdv_epi32 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshrdv_v4si ((__v4si)__A, (__v4si) __B,
        (__v4si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shrdv_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v4si_mask ((__v4si)__A, (__v4si) __C,
      (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shrdv_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v4si_maskz ((__v4si)__B, (__v4si) __C,
       (__v4si) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shrdv_epi64 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshrdv_v2di ((__v2di)__A, (__v2di) __B,
        (__v2di) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shrdv_epi64 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v2di_mask ((__v2di)__A, (__v2di) __C,
      (__v2di) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shrdv_epi64 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshrdv_v2di_maskz ((__v2di)__B, (__v2di) __C,
       (__v2di) __D, (__mmask8)__A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shldv_epi16 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshldv_v16hi ((__v16hi)__A, (__v16hi) __B,
        (__v16hi) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shldv_epi16 (__m256i __A, __mmask16 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v16hi_mask ((__v16hi)__A,
    (__v16hi) __C, (__v16hi) __D, (__mmask16)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shldv_epi16 (__mmask16 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v16hi_maskz ((__v16hi)__B,
    (__v16hi) __C, (__v16hi) __D, (__mmask16)__A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shldv_epi32 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshldv_v8si ((__v8si)__A, (__v8si) __B,
        (__v8si) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shldv_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v8si_mask ((__v8si)__A, (__v8si) __C,
      (__v8si) __D, (__mmask8)__B) ;
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shldv_epi32 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v8si_maskz ((__v8si)__B, (__v8si) __C,
      (__v8si) __D, (__mmask8)__A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_shldv_epi64 (__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vpshldv_v4di ((__v4di)__A, (__v4di) __B,
        (__v4di) __C);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_shldv_epi64 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v4di_mask ((__v4di)__A, (__v4di) __C,
      (__v4di) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_shldv_epi64 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpshldv_v4di_maskz ((__v4di)__B, (__v4di) __C,
       (__v4di) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shldv_epi16 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshldv_v8hi ((__v8hi)__A, (__v8hi) __B,
        (__v8hi) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shldv_epi16 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v8hi_mask ((__v8hi)__A, (__v8hi) __C,
      (__v8hi) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shldv_epi16 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v8hi_maskz ((__v8hi)__B, (__v8hi) __C,
       (__v8hi) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shldv_epi32 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshldv_v4si ((__v4si)__A, (__v4si) __B,
        (__v4si) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shldv_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v4si_mask ((__v4si)__A, (__v4si) __C,
      (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shldv_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v4si_maskz ((__v4si)__B, (__v4si) __C,
       (__v4si) __D, (__mmask8)__A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shldv_epi64 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vpshldv_v2di ((__v2di)__A, (__v2di) __B,
        (__v2di) __C);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_shldv_epi64 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v2di_mask ((__v2di)__A, (__v2di) __C,
      (__v2di) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_shldv_epi64 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpshldv_v2di_maskz ((__v2di)__B, (__v2di) __C,
      (__v2di) __D, (__mmask8)__A);
}






#pragma GCC pop_options




#pragma GCC push_options
#pragma GCC target("avx512vbmi2,avx512vl,avx512bw")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compress_epi8 (__m256i __A, __mmask32 __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_compressqi256_mask ((__v32qi)__C,
      (__v32qi)__A, (__mmask32)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_compress_epi8 (__mmask32 __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_compressqi256_mask ((__v32qi) __B,
   (__v32qi) _mm256_setzero_si256 (), (__mmask32) __A);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_compressstoreu_epi8 (void * __A, __mmask32 __B, __m256i __C)
{
  __builtin_ia32_compressstoreuqi256_mask ((__v32qi *) __A, (__v32qi) __C,
       (__mmask32) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expand_epi8 (__m256i __A, __mmask32 __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_expandqi256_mask ((__v32qi) __C,
          (__v32qi) __A,
          (__mmask32) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expand_epi8 (__mmask32 __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_expandqi256_maskz ((__v32qi) __B,
   (__v32qi) _mm256_setzero_si256 (), (__mmask32) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_expandloadu_epi8 (__m256i __A, __mmask32 __B, const void * __C)
{
  return (__m256i) __builtin_ia32_expandloadqi256_mask ((const __v32qi *) __C,
     (__v32qi) __A, (__mmask32) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_expandloadu_epi8 (__mmask32 __A, const void * __B)
{
  return (__m256i) __builtin_ia32_expandloadqi256_maskz ((const __v32qi *) __B,
   (__v32qi) _mm256_setzero_si256 (), (__mmask32) __A);
}



#pragma GCC pop_options
# 84 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vnniintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vnniintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vnni")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_dpbusd_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpdpbusd_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_dpbusd_epi32 (__m512i __A, __mmask16 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpbusd_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_dpbusd_epi32 (__mmask16 __A, __m512i __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpbusd_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_dpbusds_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpdpbusds_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_dpbusds_epi32 (__m512i __A, __mmask16 __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpbusds_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_dpbusds_epi32 (__mmask16 __A, __m512i __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpbusds_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_dpwssd_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpdpwssd_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_dpwssd_epi32 (__m512i __A, __mmask16 __B, __m512i __C, __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpwssd_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_dpwssd_epi32 (__mmask16 __A, __m512i __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpwssd_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_dpwssds_epi32 (__m512i __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vpdpwssds_v16si ((__v16si)__A, (__v16si) __B,
        (__v16si) __C);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_dpwssds_epi32 (__m512i __A, __mmask16 __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpwssds_v16si_mask ((__v16si)__A,
    (__v16si) __C, (__v16si) __D, (__mmask16)__B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_dpwssds_epi32 (__mmask16 __A, __m512i __B, __m512i __C,
       __m512i __D)
{
  return (__m512i)__builtin_ia32_vpdpwssds_v16si_maskz ((__v16si)__B,
    (__v16si) __C, (__v16si) __D, (__mmask16)__A);
}



#pragma GCC pop_options
# 86 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vnnivlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vnnivlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vnni,avx512vl")
# 42 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vnnivlintrin.h" 3 4
extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_dpbusd_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpbusd_v8si_mask ((__v8si)__A, (__v8si) __C,
      (__v8si) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_dpbusd_epi32 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpbusd_v8si_maskz ((__v8si)__B,
    (__v8si) __C, (__v8si) __D, (__mmask8)__A);
}






extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_dpbusd_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpbusd_v4si_mask ((__v4si)__A, (__v4si) __C,
      (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_dpbusd_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpbusd_v4si_maskz ((__v4si)__B,
    (__v4si) __C, (__v4si) __D, (__mmask8)__A);
}






extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_dpbusds_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpbusds_v8si_mask ((__v8si)__A,
    (__v8si) __C, (__v8si) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_dpbusds_epi32 (__mmask8 __A, __m256i __B, __m256i __C,
        __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpbusds_v8si_maskz ((__v8si)__B,
    (__v8si) __C, (__v8si) __D, (__mmask8)__A);
}






extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_dpbusds_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpbusds_v4si_mask ((__v4si)__A,
    (__v4si) __C, (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_dpbusds_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpbusds_v4si_maskz ((__v4si)__B,
    (__v4si) __C, (__v4si) __D, (__mmask8)__A);
}






extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_dpwssd_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpwssd_v8si_mask ((__v8si)__A, (__v8si) __C,
      (__v8si) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_dpwssd_epi32 (__mmask8 __A, __m256i __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpwssd_v8si_maskz ((__v8si)__B,
    (__v8si) __C, (__v8si) __D, (__mmask8)__A);
}






extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_dpwssd_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpwssd_v4si_mask ((__v4si)__A, (__v4si) __C,
      (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_dpwssd_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpwssd_v4si_maskz ((__v4si)__B,
    (__v4si) __C, (__v4si) __D, (__mmask8)__A);
}






extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_dpwssds_epi32 (__m256i __A, __mmask8 __B, __m256i __C, __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpwssds_v8si_mask ((__v8si)__A,
    (__v8si) __C, (__v8si) __D, (__mmask8)__B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_dpwssds_epi32 (__mmask8 __A, __m256i __B, __m256i __C,
       __m256i __D)
{
  return (__m256i)__builtin_ia32_vpdpwssds_v8si_maskz ((__v8si)__B,
    (__v8si) __C, (__v8si) __D, (__mmask8)__A);
}






extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_dpwssds_epi32 (__m128i __A, __mmask8 __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpwssds_v4si_mask ((__v4si)__A,
    (__v4si) __C, (__v4si) __D, (__mmask8)__B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_dpwssds_epi32 (__mmask8 __A, __m128i __B, __m128i __C, __m128i __D)
{
  return (__m128i)__builtin_ia32_vpdpwssds_v4si_maskz ((__v4si)__B,
    (__v4si) __C, (__v4si) __D, (__mmask8)__A);
}


#pragma GCC pop_options
# 88 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vpopcntdqvlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vpopcntdqvlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vpopcntdq,avx512vl")



extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_epi32 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountd_v4si ((__v4si) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_popcnt_epi32 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountd_v4si_mask ((__v4si) __A,
        (__v4si) __W,
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_popcnt_epi32 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountd_v4si_mask ((__v4si) __A,
        (__v4si)
        _mm_setzero_si128 (),
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_popcnt_epi32 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountd_v8si ((__v8si) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_popcnt_epi32 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountd_v8si_mask ((__v8si) __A,
        (__v8si) __W,
        (__mmask16) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_popcnt_epi32 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountd_v8si_mask ((__v8si) __A,
      (__v8si)
      _mm256_setzero_si256 (),
      (__mmask16) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_epi64 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountq_v2di ((__v2di) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_popcnt_epi64 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountq_v2di_mask ((__v2di) __A,
       (__v2di) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_popcnt_epi64 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountq_v2di_mask ((__v2di) __A,
       (__v2di)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_popcnt_epi64 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountq_v4di ((__v4di) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_popcnt_epi64 (__m256i __W, __mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountq_v4di_mask ((__v4di) __A,
       (__v4di) __W,
       (__mmask8) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_popcnt_epi64 (__mmask8 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountq_v4di_mask ((__v4di) __A,
      (__v4di)
      _mm256_setzero_si256 (),
      (__mmask8) __U);
}



#pragma GCC pop_options
# 90 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bitalgintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bitalgintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512bitalg")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_popcnt_epi8 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountb_v64qi ((__v64qi) __A);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_popcnt_epi16 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountw_v32hi ((__v32hi) __A);
}



#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("avx512bitalg,avx512bw")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_popcnt_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountb_v64qi_mask ((__v64qi) __A,
        (__v64qi) __W,
        (__mmask64) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_popcnt_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountb_v64qi_mask ((__v64qi) __A,
      (__v64qi)
      _mm512_setzero_si512 (),
      (__mmask64) __U);
}
extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_popcnt_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountw_v32hi_mask ((__v32hi) __A,
       (__v32hi) __W,
       (__mmask32) __U);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_popcnt_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpopcountw_v32hi_mask ((__v32hi) __A,
      (__v32hi)
      _mm512_setzero_si512 (),
      (__mmask32) __U);
}

extern __inline __mmask64
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_bitshuffle_epi64_mask (__m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_vpshufbitqmb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__mmask64) -1);
}

extern __inline __mmask64
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_bitshuffle_epi64_mask (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__mmask64) __builtin_ia32_vpshufbitqmb512_mask ((__v64qi) __A,
       (__v64qi) __B,
       (__mmask64) __M);
}



#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("avx512bitalg,avx512vl,avx512bw")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_popcnt_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountb_v32qi_mask ((__v32qi) __A,
        (__v32qi) __W,
        (__mmask32) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_popcnt_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountb_v32qi_mask ((__v32qi) __A,
      (__v32qi)
       _mm256_setzero_si256 (),
      (__mmask32) __U);
}

extern __inline __mmask32
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_bitshuffle_epi64_mask (__m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_vpshufbitqmb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__mmask32) -1);
}

extern __inline __mmask32
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_bitshuffle_epi64_mask (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__mmask32) __builtin_ia32_vpshufbitqmb256_mask ((__v32qi) __A,
       (__v32qi) __B,
       (__mmask32) __M);
}



#pragma GCC pop_options




#pragma GCC push_options
#pragma GCC target("avx512bitalg,avx512vl")



extern __inline __mmask16
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_bitshuffle_epi64_mask (__m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_vpshufbitqmb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__mmask16) -1);
}

extern __inline __mmask16
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_bitshuffle_epi64_mask (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__mmask16) __builtin_ia32_vpshufbitqmb128_mask ((__v16qi) __A,
       (__v16qi) __B,
       (__mmask16) __M);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_popcnt_epi8 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountb_v32qi ((__v32qi) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_popcnt_epi16 (__m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountw_v16hi ((__v16hi) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_epi8 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountb_v16qi ((__v16qi) __A);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_popcnt_epi16 (__m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountw_v8hi ((__v8hi) __A);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_popcnt_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountw_v16hi_mask ((__v16hi) __A,
       (__v16hi) __W,
       (__mmask16) __U);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_popcnt_epi16 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_vpopcountw_v16hi_mask ((__v16hi) __A,
      (__v16hi)
      _mm256_setzero_si256 (),
      (__mmask16) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_popcnt_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountb_v16qi_mask ((__v16qi) __A,
        (__v16qi) __W,
        (__mmask16) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_popcnt_epi8 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountb_v16qi_mask ((__v16qi) __A,
        (__v16qi)
        _mm_setzero_si128 (),
        (__mmask16) __U);
}
extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_popcnt_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountw_v8hi_mask ((__v8hi) __A,
       (__v8hi) __W,
       (__mmask8) __U);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_popcnt_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_vpopcountw_v8hi_mask ((__v8hi) __A,
       (__v8hi)
       _mm_setzero_si128 (),
       (__mmask8) __U);
}


#pragma GCC pop_options
# 92 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vp2intersectintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vp2intersectintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vp2intersect")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_2intersect_epi32 (__m512i __A, __m512i __B, __mmask16 *__U,
    __mmask16 *__M)
{
  __builtin_ia32_2intersectd512 (__U, __M, (__v16si) __A, (__v16si) __B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_2intersect_epi64 (__m512i __A, __m512i __B, __mmask8 *__U,
    __mmask8 *__M)
{
  __builtin_ia32_2intersectq512 (__U, __M, (__v8di) __A, (__v8di) __B);
}



#pragma GCC pop_options
# 94 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vp2intersectvlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512vp2intersectvlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512vp2intersect,avx512vl")



extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_2intersect_epi32 (__m128i __A, __m128i __B, __mmask8 *__U, __mmask8 *__M)
{
  __builtin_ia32_2intersectd128 (__U, __M, (__v4si) __A, (__v4si) __B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_2intersect_epi32 (__m256i __A, __m256i __B, __mmask8 *__U,
    __mmask8 *__M)
{
  __builtin_ia32_2intersectd256 (__U, __M, (__v8si) __A, (__v8si) __B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_2intersect_epi64 (__m128i __A, __m128i __B, __mmask8 *__U, __mmask8 *__M)
{
  __builtin_ia32_2intersectq128 (__U, __M, (__v2di) __A, (__v2di) __B);
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_2intersect_epi64 (__m256i __A, __m256i __B, __mmask8 *__U,
    __mmask8 *__M)
{
  __builtin_ia32_2intersectq256 (__U, __M, (__v4di) __A, (__v4di) __B);
}



#pragma GCC pop_options
# 96 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512fp16")




typedef _Float16 __v8hf __attribute__ ((__vector_size__ (16)));
typedef _Float16 __v16hf __attribute__ ((__vector_size__ (32)));
typedef _Float16 __v32hf __attribute__ ((__vector_size__ (64)));



typedef _Float16 __m128h __attribute__ ((__vector_size__ (16), __may_alias__));
typedef _Float16 __m256h __attribute__ ((__vector_size__ (32), __may_alias__));
typedef _Float16 __m512h __attribute__ ((__vector_size__ (64), __may_alias__));


typedef _Float16 __m128h_u __attribute__ ((__vector_size__ (16),
        __may_alias__, __aligned__ (1)));
typedef _Float16 __m256h_u __attribute__ ((__vector_size__ (32),
        __may_alias__, __aligned__ (1)));
typedef _Float16 __m512h_u __attribute__ ((__vector_size__ (64),
        __may_alias__, __aligned__ (1)));

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ph (_Float16 __A7, _Float16 __A6, _Float16 __A5,
     _Float16 __A4, _Float16 __A3, _Float16 __A2,
     _Float16 __A1, _Float16 __A0)
{
  return __extension__ (__m128h)(__v8hf){ __A0, __A1, __A2, __A3,
       __A4, __A5, __A6, __A7 };
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set_ph (_Float16 __A15, _Float16 __A14, _Float16 __A13,
        _Float16 __A12, _Float16 __A11, _Float16 __A10,
        _Float16 __A9, _Float16 __A8, _Float16 __A7,
        _Float16 __A6, _Float16 __A5, _Float16 __A4,
        _Float16 __A3, _Float16 __A2, _Float16 __A1,
        _Float16 __A0)
{
  return __extension__ (__m256h)(__v16hf){ __A0, __A1, __A2, __A3,
        __A4, __A5, __A6, __A7,
        __A8, __A9, __A10, __A11,
        __A12, __A13, __A14, __A15 };
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set_ph (_Float16 __A31, _Float16 __A30, _Float16 __A29,
        _Float16 __A28, _Float16 __A27, _Float16 __A26,
        _Float16 __A25, _Float16 __A24, _Float16 __A23,
        _Float16 __A22, _Float16 __A21, _Float16 __A20,
        _Float16 __A19, _Float16 __A18, _Float16 __A17,
        _Float16 __A16, _Float16 __A15, _Float16 __A14,
        _Float16 __A13, _Float16 __A12, _Float16 __A11,
        _Float16 __A10, _Float16 __A9, _Float16 __A8,
        _Float16 __A7, _Float16 __A6, _Float16 __A5,
        _Float16 __A4, _Float16 __A3, _Float16 __A2,
        _Float16 __A1, _Float16 __A0)
{
  return __extension__ (__m512h)(__v32hf){ __A0, __A1, __A2, __A3,
        __A4, __A5, __A6, __A7,
        __A8, __A9, __A10, __A11,
        __A12, __A13, __A14, __A15,
        __A16, __A17, __A18, __A19,
        __A20, __A21, __A22, __A23,
        __A24, __A25, __A26, __A27,
        __A28, __A29, __A30, __A31 };
}




extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ph (_Float16 __A0, _Float16 __A1, _Float16 __A2,
      _Float16 __A3, _Float16 __A4, _Float16 __A5,
      _Float16 __A6, _Float16 __A7)
{
  return _mm_set_ph (__A7, __A6, __A5, __A4, __A3, __A2, __A1, __A0);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setr_ph (_Float16 __A0, _Float16 __A1, _Float16 __A2,
  _Float16 __A3, _Float16 __A4, _Float16 __A5,
  _Float16 __A6, _Float16 __A7, _Float16 __A8,
  _Float16 __A9, _Float16 __A10, _Float16 __A11,
  _Float16 __A12, _Float16 __A13, _Float16 __A14,
  _Float16 __A15)
{
  return _mm256_set_ph (__A15, __A14, __A13, __A12, __A11, __A10, __A9,
   __A8, __A7, __A6, __A5, __A4, __A3, __A2, __A1,
   __A0);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setr_ph (_Float16 __A0, _Float16 __A1, _Float16 __A2,
  _Float16 __A3, _Float16 __A4, _Float16 __A5,
  _Float16 __A6, _Float16 __A7, _Float16 __A8,
  _Float16 __A9, _Float16 __A10, _Float16 __A11,
  _Float16 __A12, _Float16 __A13, _Float16 __A14,
  _Float16 __A15, _Float16 __A16, _Float16 __A17,
  _Float16 __A18, _Float16 __A19, _Float16 __A20,
  _Float16 __A21, _Float16 __A22, _Float16 __A23,
  _Float16 __A24, _Float16 __A25, _Float16 __A26,
  _Float16 __A27, _Float16 __A28, _Float16 __A29,
  _Float16 __A30, _Float16 __A31)

{
  return _mm512_set_ph (__A31, __A30, __A29, __A28, __A27, __A26, __A25,
   __A24, __A23, __A22, __A21, __A20, __A19, __A18,
   __A17, __A16, __A15, __A14, __A13, __A12, __A11,
   __A10, __A9, __A8, __A7, __A6, __A5, __A4, __A3,
   __A2, __A1, __A0);
}



extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ph (_Float16 __A)
{
  return _mm_set_ph (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_ph (_Float16 __A)
{
  return _mm256_set_ph (__A, __A, __A, __A, __A, __A, __A, __A,
   __A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_ph (_Float16 __A)
{
  return _mm512_set_ph (__A, __A, __A, __A, __A, __A, __A, __A,
   __A, __A, __A, __A, __A, __A, __A, __A,
   __A, __A, __A, __A, __A, __A, __A, __A,
   __A, __A, __A, __A, __A, __A, __A, __A);
}



extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ph (void)
{
  return _mm_set1_ph (0.0f);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_setzero_ph (void)
{
  return _mm256_set1_ph (0.0f);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_setzero_ph (void)
{
  return _mm512_set1_ph (0.0f);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_ph (void)
{
  __m128h __Y = __Y;
  return __Y;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_undefined_ph (void)
{
  __m256h __Y = __Y;
  return __Y;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_undefined_ph (void)
{
  __m512h __Y = __Y;
  return __Y;
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_h (__m128h __A)
{
  return __A[0];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtsh_h (__m256h __A)
{
  return __A[0];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtsh_h (__m512h __A)
{
  return __A[0];
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph_ps (__m512h __a)
{
  return (__m512) __a;
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph_pd (__m512h __a)
{
  return (__m512d) __a;
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph_si512 (__m512h __a)
{
  return (__m512i) __a;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph512_ph128 (__m512h __A)
{
  union
  {
    __m128h __a[4];
    __m512h __v;
  } __u = { .__v = __A };
  return __u.__a[0];
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph512_ph256 (__m512h __A)
{
  union
  {
    __m256h __a[2];
    __m512h __v;
  } __u = { .__v = __A };
  return __u.__a[0];
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph128_ph512 (__m128h __A)
{
  union
  {
    __m128h __a[4];
    __m512h __v;
  } __u;
  __u.__a[0] = __A;
  return __u.__v;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castph256_ph512 (__m256h __A)
{
  union
  {
    __m256h __a[2];
    __m512h __v;
  } __u;
  __u.__a[0] = __A;
  return __u.__v;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextph128_ph512 (__m128h __A)
{
  return (__m512h) ((__m512) __builtin_ia32_insertf32x4_mask ((__v16sf)(__m512) (_mm512_setzero_ps ()), (__v4sf)(__m128) ((__m128) __A), (int) (0), (__v16sf)(__m512) (_mm512_setzero_ps ()), (__mmask16)(-1)))
                           ;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_zextph256_ph512 (__m256h __A)
{
  return (__m512h) ((__m512d) __builtin_ia32_insertf64x4_mask ((__v8df)(__m512d) (_mm512_setzero_pd ()), (__v4df)(__m256d) ((__m256d) __A), (int) (0), (__v8df)(__m512d)_mm512_undefined_pd(), (__mmask8)-1))
                            ;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castps_ph (__m512 __a)
{
  return (__m512h) __a;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castpd_ph (__m512d __a)
{
  return (__m512h) __a;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_castsi512_ph (__m512i __a)
{
  return (__m512h) __a;
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sh (_Float16 __F)
{
  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, __F);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sh (void const *__P)
{
  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
       *(_Float16 const *) __P);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_load_ph (void const *__P)
{
  return *(const __m512h *) __P;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_load_ph (void const *__P)
{
  return *(const __m256h *) __P;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ph (void const *__P)
{
  return *(const __m128h *) __P;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_loadu_ph (void const *__P)
{
  return *(const __m512h_u *) __P;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_loadu_ph (void const *__P)
{
  return *(const __m256h_u *) __P;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ph (void const *__P)
{
  return *(const __m128h_u *) __P;
}


extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sh (void *__P, __m128h __A)
{
  *(_Float16 *) __P = ((__v8hf)__A)[0];
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_store_ph (void *__P, __m512h __A)
{
   *(__m512h *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_store_ph (void *__P, __m256h __A)
{
   *(__m256h *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ph (void *__P, __m128h __A)
{
   *(__m128h *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_storeu_ph (void *__P, __m512h __A)
{
   *(__m512h_u *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_storeu_ph (void *__P, __m256h __A)
{
   *(__m256h_u *) __P = __A;
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ph (void *__P, __m128h __A)
{
   *(__m128h_u *) __P = __A;
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_abs_ph (__m512h __A)
{
  return (__m512h) _mm512_and_epi32 ( _mm512_set1_epi32 (0x7FFF7FFF),
          (__m512i) __A);
}


extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_add_ph (__m512h __A, __m512h __B)
{
  return (__m512h) ((__v32hf) __A + (__v32hf) __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_add_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_addph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_add_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_addph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sub_ph (__m512h __A, __m512h __B)
{
  return (__m512h) ((__v32hf) __A - (__v32hf) __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sub_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_subph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sub_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_subph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mul_ph (__m512h __A, __m512h __B)
{
  return (__m512h) ((__v32hf) __A * (__v32hf) __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_mul_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_mulph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_mul_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_mulph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_div_ph (__m512h __A, __m512h __B)
{
  return (__m512h) ((__v32hf) __A / (__v32hf) __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_div_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_divph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_div_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_divph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}
# 724 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_conj_pch (__m512h __A)
{
  return (__m512h) _mm512_xor_epi32 ((__m512i) __A, _mm512_set1_epi32 (1<<31));
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_conj_pch (__m512h __W, __mmask16 __U, __m512h __A)
{
  return (__m512h)
    __builtin_ia32_movaps512_mask ((__v16sf) _mm512_conj_pch (__A),
       (__v16sf) __W,
       (__mmask16) __U);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_conj_pch (__mmask16 __U, __m512h __A)
{
  return (__m512h)
    __builtin_ia32_movaps512_mask ((__v16sf) _mm512_conj_pch (__A),
       (__v16sf) _mm512_setzero_ps (),
       (__mmask16) __U);
}


extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sh (__m128h __A, __m128h __B)
{
  __A[0] += __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_addsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_addsh_mask (__B, __C, _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sh (__m128h __A, __m128h __B)
{
  __A[0] -= __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_subsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_subsh_mask (__B, __C, _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sh (__m128h __A, __m128h __B)
{
  __A[0] *= __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_mulsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_mulsh_mask (__B, __C, _mm_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sh (__m128h __A, __m128h __B)
{
  __A[0] /= __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_divsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_divsh_mask (__B, __C, _mm_setzero_ph (),
        __A);
}
# 1006 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_max_ph (__m512h __A, __m512h __B)
{
  return __builtin_ia32_maxph512_mask (__A, __B,
           _mm512_setzero_ph (),
           (__mmask32) -1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_max_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_maxph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_max_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_maxph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_min_ph (__m512h __A, __m512h __B)
{
  return __builtin_ia32_minph512_mask (__A, __B,
           _mm512_setzero_ph (),
           (__mmask32) -1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_min_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_minph512_mask (__C, __D, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_min_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_minph512_mask (__B, __C,
           _mm512_setzero_ph (), __A);
}
# 1138 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sh (__m128h __A, __m128h __B)
{
  __A[0] = __A[0] > __B[0] ? __A[0] : __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_maxsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_maxsh_mask (__B, __C, _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sh (__m128h __A, __m128h __B)
{
  __A[0] = __A[0] < __B[0] ? __A[0] : __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_minsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_minsh_mask (__B, __C, _mm_setzero_ph (),
        __A);
}
# 1383 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x10,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x01,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x02,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x0e,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x0d,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x14,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x00,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x11,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x12,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x1e,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x1d,
       (__mmask8) -1,
       0x04);
}

extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_cmpsh_mask_round (__A, __B, 0x04,
       (__mmask8) -1,
       0x04);
}
# 1519 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_sqrt_ph (__m512h __A)
{
  return __builtin_ia32_sqrtph512_mask_round (__A,
           _mm512_setzero_ph(),
           (__mmask32) -1,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_sqrt_ph (__m512h __A, __mmask32 __B, __m512h __C)
{
  return __builtin_ia32_sqrtph512_mask_round (__C, __A, __B,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_sqrt_ph (__mmask32 __A, __m512h __B)
{
  return __builtin_ia32_sqrtph512_mask_round (__B,
           _mm512_setzero_ph (),
           __A,
           0x04);
}
# 1591 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rsqrt_ph (__m512h __A)
{
  return __builtin_ia32_rsqrtph512_mask (__A, _mm512_setzero_ph (),
      (__mmask32) -1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rsqrt_ph (__m512h __A, __mmask32 __B, __m512h __C)
{
  return __builtin_ia32_rsqrtph512_mask (__C, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rsqrt_ph (__mmask32 __A, __m512h __B)
{
  return __builtin_ia32_rsqrtph512_mask (__B, _mm512_setzero_ph (),
      __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_rsqrtsh_mask (__B, __A, _mm_setzero_ph (),
          (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_rsqrtsh_mask (__D, __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_rsqrtsh_mask (__C, __B, _mm_setzero_ph (),
          __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_sqrtsh_mask_round (__B, __A,
        _mm_setzero_ph (),
        (__mmask8) -1,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sqrt_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_sqrtsh_mask_round (__D, __C, __A, __B,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sqrt_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_sqrtsh_mask_round (__C, __B,
        _mm_setzero_ph (),
        __A, 0x04);
}
# 1712 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_rcp_ph (__m512h __A)
{
  return __builtin_ia32_rcpph512_mask (__A, _mm512_setzero_ph (),
           (__mmask32) -1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_rcp_ph (__m512h __A, __mmask32 __B, __m512h __C)
{
  return __builtin_ia32_rcpph512_mask (__C, __A, __B);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_rcp_ph (__mmask32 __A, __m512h __B)
{
  return __builtin_ia32_rcpph512_mask (__B, _mm512_setzero_ph (),
           __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_rcpsh_mask (__B, __A, _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp_sh (__m128h __A, __mmask32 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_rcpsh_mask (__D, __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp_sh (__mmask32 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_rcpsh_mask (__C, __B, _mm_setzero_ph (),
        __A);
}


extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_scalef_ph (__m512h __A, __m512h __B)
{
  return __builtin_ia32_scalefph512_mask_round (__A, __B,
      _mm512_setzero_ph (),
      (__mmask32) -1,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_scalef_ph (__m512h __A, __mmask32 __B, __m512h __C, __m512h __D)
{
  return __builtin_ia32_scalefph512_mask_round (__C, __D, __A, __B,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_scalef_ph (__mmask32 __A, __m512h __B, __m512h __C)
{
  return __builtin_ia32_scalefph512_mask_round (__B, __C,
      _mm512_setzero_ph (),
      __A,
      0x04);
}
# 1834 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_sh (__m128h __A, __m128h __B)
{
  return __builtin_ia32_scalefsh_mask_round (__A, __B,
          _mm_setzero_ph (),
          (__mmask8) -1,
          0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_scalef_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_scalefsh_mask_round (__C, __D, __A, __B,
          0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_scalef_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_scalefsh_mask_round (__B, __C,
          _mm_setzero_ph (),
          __A,
          0x04);
}
# 2323 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_getexp_sh (__m128h __A, __m128h __B)
{
  return (__m128h)
    __builtin_ia32_getexpsh_mask_round ((__v8hf) __A, (__v8hf) __B,
     (__v8hf) _mm_setzero_ph (),
     (__mmask8) -1,
     0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_getexp_sh (__m128h __W, __mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h)
    __builtin_ia32_getexpsh_mask_round ((__v8hf) __A, (__v8hf) __B,
     (__v8hf) __W, (__mmask8) __U,
     0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_getexp_sh (__mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h)
    __builtin_ia32_getexpsh_mask_round ((__v8hf) __A, (__v8hf) __B,
     (__v8hf) _mm_setzero_ph (),
     (__mmask8) __U,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_getexp_ph (__m512h __A)
{
  return (__m512h)
    __builtin_ia32_getexpph512_mask ((__v32hf) __A,
         (__v32hf) _mm512_setzero_ph (),
         (__mmask32) -1, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_getexp_ph (__m512h __W, __mmask32 __U, __m512h __A)
{
  return (__m512h)
    __builtin_ia32_getexpph512_mask ((__v32hf) __A, (__v32hf) __W,
         (__mmask32) __U, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_getexp_ph (__mmask32 __U, __m512h __A)
{
  return (__m512h)
    __builtin_ia32_getexpph512_mask ((__v32hf) __A,
         (__v32hf) _mm512_setzero_ph (),
         (__mmask32) __U, 0x04);
}
# 2737 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi16_si128 (short __A)
{
  return _mm_set_epi16 (0, 0, 0, 0, 0, 0, 0, __A);
}

extern __inline short
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si16 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, 0);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_load_sh (__m128h __A, __mmask8 __B, _Float16 const* __C)
{
  return __builtin_ia32_loadsh_mask (__C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_load_sh (__mmask8 __A, _Float16 const* __B)
{
  return __builtin_ia32_loadsh_mask (__B, _mm_setzero_ph (), __A);
}

extern __inline void
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_store_sh (_Float16 const* __A, __mmask8 __B, __m128h __C)
{
  __builtin_ia32_storesh_mask (__A, __C, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sh (__m128h __A, __m128h __B)
{
  __A[0] = __B[0];
  return __A;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_move_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_vmovsh_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_move_sh (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_vmovsh_mask (__B, __C, _mm_setzero_ph (), __A);
}


extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epi32 (__m256h __A)
{
  return (__m512i)
    __builtin_ia32_vcvtph2dq512_mask_round (__A,
         (__v16si)
         _mm512_setzero_si512 (),
         (__mmask16) -1,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epi32 (__m512i __A, __mmask16 __B, __m256h __C)
{
  return (__m512i)
    __builtin_ia32_vcvtph2dq512_mask_round (__C,
         (__v16si) __A,
         __B,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epi32 (__mmask16 __A, __m256h __B)
{
  return (__m512i)
    __builtin_ia32_vcvtph2dq512_mask_round (__B,
         (__v16si)
         _mm512_setzero_si512 (),
         __A,
         0x04);
}
# 2891 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epu32 (__m256h __A)
{
  return (__m512i)
    __builtin_ia32_vcvtph2udq512_mask_round (__A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epu32 (__m512i __A, __mmask16 __B, __m256h __C)
{
  return (__m512i)
    __builtin_ia32_vcvtph2udq512_mask_round (__C,
          (__v16si) __A,
          __B,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epu32 (__mmask16 __A, __m256h __B)
{
  return (__m512i)
    __builtin_ia32_vcvtph2udq512_mask_round (__B,
          (__v16si)
          _mm512_setzero_si512 (),
          __A,
          0x04);
}
# 2986 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epi32 (__m256h __A)
{
  return (__m512i)
    __builtin_ia32_vcvttph2dq512_mask_round (__A,
          (__v16si)
          _mm512_setzero_si512 (),
          (__mmask16) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epi32 (__m512i __A, __mmask16 __B, __m256h __C)
{
  return (__m512i)
    __builtin_ia32_vcvttph2dq512_mask_round (__C,
          (__v16si) __A,
          __B,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epi32 (__mmask16 __A, __m256h __B)
{
  return (__m512i)
    __builtin_ia32_vcvttph2dq512_mask_round (__B,
          (__v16si)
          _mm512_setzero_si512 (),
          __A,
          0x04);
}
# 3084 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epu32 (__m256h __A)
{
  return (__m512i)
    __builtin_ia32_vcvttph2udq512_mask_round (__A,
           (__v16si)
           _mm512_setzero_si512 (),
           (__mmask16) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epu32 (__m512i __A, __mmask16 __B, __m256h __C)
{
  return (__m512i)
    __builtin_ia32_vcvttph2udq512_mask_round (__C,
           (__v16si) __A,
           __B,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epu32 (__mmask16 __A, __m256h __B)
{
  return (__m512i)
    __builtin_ia32_vcvttph2udq512_mask_round (__B,
           (__v16si)
           _mm512_setzero_si512 (),
           __A,
           0x04);
}
# 3183 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi32_ph (__m512i __A)
{
  return __builtin_ia32_vcvtdq2ph512_mask_round ((__v16si) __A,
       _mm256_setzero_ph (),
       (__mmask16) -1,
       0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi32_ph (__m256h __A, __mmask16 __B, __m512i __C)
{
  return __builtin_ia32_vcvtdq2ph512_mask_round ((__v16si) __C,
       __A,
       __B,
       0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi32_ph (__mmask16 __A, __m512i __B)
{
  return __builtin_ia32_vcvtdq2ph512_mask_round ((__v16si) __B,
       _mm256_setzero_ph (),
       __A,
       0x04);
}
# 3266 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu32_ph (__m512i __A)
{
  return __builtin_ia32_vcvtudq2ph512_mask_round ((__v16si) __A,
        _mm256_setzero_ph (),
        (__mmask16) -1,
        0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu32_ph (__m256h __A, __mmask16 __B, __m512i __C)
{
  return __builtin_ia32_vcvtudq2ph512_mask_round ((__v16si) __C,
        __A,
        __B,
        0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu32_ph (__mmask16 __A, __m512i __B)
{
  return __builtin_ia32_vcvtudq2ph512_mask_round ((__v16si) __B,
        _mm256_setzero_ph (),
        __A,
        0x04);
}
# 3349 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epi64 (__m128h __A)
{
  return __builtin_ia32_vcvtph2qq512_mask_round (__A,
       _mm512_setzero_si512 (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epi64 (__m512i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2qq512_mask_round (__C, __A, __B,
       0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2qq512_mask_round (__B,
       _mm512_setzero_si512 (),
       __A,
       0x04);
}
# 3424 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvtph2uqq512_mask_round (__A,
        _mm512_setzero_si512 (),
        (__mmask8) -1,
        0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epu64 (__m512i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2uqq512_mask_round (__C, __A, __B,
        0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2uqq512_mask_round (__B,
        _mm512_setzero_si512 (),
        __A,
        0x04);
}
# 3500 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epi64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2qq512_mask_round (__A,
        _mm512_setzero_si512 (),
        (__mmask8) -1,
        0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epi64 (__m512i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2qq512_mask_round (__C, __A, __B,
        0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2qq512_mask_round (__B,
        _mm512_setzero_si512 (),
        __A,
        0x04);
}
# 3575 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2uqq512_mask_round (__A,
         _mm512_setzero_si512 (),
         (__mmask8) -1,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epu64 (__m512i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2uqq512_mask_round (__C, __A, __B,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2uqq512_mask_round (__B,
         _mm512_setzero_si512 (),
         __A,
         0x04);
}
# 3650 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi64_ph (__m512i __A)
{
  return __builtin_ia32_vcvtqq2ph512_mask_round ((__v8di) __A,
       _mm_setzero_ph (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi64_ph (__m128h __A, __mmask8 __B, __m512i __C)
{
  return __builtin_ia32_vcvtqq2ph512_mask_round ((__v8di) __C,
       __A,
       __B,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi64_ph (__mmask8 __A, __m512i __B)
{
  return __builtin_ia32_vcvtqq2ph512_mask_round ((__v8di) __B,
       _mm_setzero_ph (),
       __A,
       0x04);
}
# 3730 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepu64_ph (__m512i __A)
{
  return __builtin_ia32_vcvtuqq2ph512_mask_round ((__v8di) __A,
        _mm_setzero_ph (),
        (__mmask8) -1,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu64_ph (__m128h __A, __mmask8 __B, __m512i __C)
{
  return __builtin_ia32_vcvtuqq2ph512_mask_round ((__v8di) __C,
        __A,
        __B,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu64_ph (__mmask8 __A, __m512i __B)
{
  return __builtin_ia32_vcvtuqq2ph512_mask_round ((__v8di) __B,
        _mm_setzero_ph (),
        __A,
        0x04);
}
# 3810 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epi16 (__m512h __A)
{
  return (__m512i)
    __builtin_ia32_vcvtph2w512_mask_round (__A,
           (__v32hi)
           _mm512_setzero_si512 (),
           (__mmask32) -1,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epi16 (__m512i __A, __mmask32 __B, __m512h __C)
{
  return (__m512i)
    __builtin_ia32_vcvtph2w512_mask_round (__C,
           (__v32hi) __A,
           __B,
           0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epi16 (__mmask32 __A, __m512h __B)
{
  return (__m512i)
    __builtin_ia32_vcvtph2w512_mask_round (__B,
           (__v32hi)
           _mm512_setzero_si512 (),
           __A,
           0x04);
}
# 3905 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_epu16 (__m512h __A)
{
  return (__m512i)
    __builtin_ia32_vcvtph2uw512_mask_round (__A,
            (__v32hi)
            _mm512_setzero_si512 (),
            (__mmask32) -1,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_epu16 (__m512i __A, __mmask32 __B, __m512h __C)
{
  return (__m512i)
    __builtin_ia32_vcvtph2uw512_mask_round (__C, (__v32hi) __A, __B,
            0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_epu16 (__mmask32 __A, __m512h __B)
{
  return (__m512i)
    __builtin_ia32_vcvtph2uw512_mask_round (__B,
            (__v32hi)
            _mm512_setzero_si512 (),
            __A,
            0x04);
}
# 3994 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epi16 (__m512h __A)
{
  return (__m512i)
    __builtin_ia32_vcvttph2w512_mask_round (__A,
         (__v32hi)
         _mm512_setzero_si512 (),
         (__mmask32) -1,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epi16 (__m512i __A, __mmask32 __B, __m512h __C)
{
  return (__m512i)
    __builtin_ia32_vcvttph2w512_mask_round (__C,
         (__v32hi) __A,
         __B,
         0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epi16 (__mmask32 __A, __m512h __B)
{
  return (__m512i)
    __builtin_ia32_vcvttph2w512_mask_round (__B,
         (__v32hi)
         _mm512_setzero_si512 (),
         __A,
         0x04);
}
# 4093 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvttph_epu16 (__m512h __A)
{
  return (__m512i)
    __builtin_ia32_vcvttph2uw512_mask_round (__A,
          (__v32hi)
          _mm512_setzero_si512 (),
          (__mmask32) -1,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvttph_epu16 (__m512i __A, __mmask32 __B, __m512h __C)
{
  return (__m512i)
    __builtin_ia32_vcvttph2uw512_mask_round (__C,
          (__v32hi) __A,
          __B,
          0x04);
}

extern __inline __m512i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvttph_epu16 (__mmask32 __A, __m512h __B)
{
  return (__m512i)
    __builtin_ia32_vcvttph2uw512_mask_round (__B,
          (__v32hi)
          _mm512_setzero_si512 (),
          __A,
          0x04);
}
# 4192 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtepi16_ph (__m512i __A)
{
  return __builtin_ia32_vcvtw2ph512_mask_round ((__v32hi) __A,
      _mm512_setzero_ph (),
      (__mmask32) -1,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepi16_ph (__m512h __A, __mmask32 __B, __m512i __C)
{
  return __builtin_ia32_vcvtw2ph512_mask_round ((__v32hi) __C,
      __A,
      __B,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepi16_ph (__mmask32 __A, __m512i __B)
{
  return __builtin_ia32_vcvtw2ph512_mask_round ((__v32hi) __B,
      _mm512_setzero_ph (),
      __A,
      0x04);
}
# 4275 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
  extern __inline __m512h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
  _mm512_cvtepu16_ph (__m512i __A)
  {
    return __builtin_ia32_vcvtuw2ph512_mask_round ((__v32hi) __A,
         _mm512_setzero_ph (),
         (__mmask32) -1,
         0x04);
  }

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtepu16_ph (__m512h __A, __mmask32 __B, __m512i __C)
{
  return __builtin_ia32_vcvtuw2ph512_mask_round ((__v32hi) __C,
       __A,
       __B,
       0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtepu16_ph (__mmask32 __A, __m512i __B)
{
  return __builtin_ia32_vcvtuw2ph512_mask_round ((__v32hi) __B,
       _mm512_setzero_ph (),
       __A,
       0x04);
}
# 4358 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_i32 (__m128h __A)
{
  return (int) __builtin_ia32_vcvtsh2si32_round (__A, 0x04);
}

extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_u32 (__m128h __A)
{
  return (int) __builtin_ia32_vcvtsh2usi32_round (__A,
        0x04);
}
# 4397 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_i64 (__m128h __A)
{
  return (long long)
    __builtin_ia32_vcvtsh2si64_round (__A, 0x04);
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_u64 (__m128h __A)
{
  return (long long)
    __builtin_ia32_vcvtsh2usi64_round (__A, 0x04);
}
# 4438 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline int
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsh_i32 (__m128h __A)
{
  return (int)
    __builtin_ia32_vcvttsh2si32_round (__A, 0x04);
}

extern __inline unsigned
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsh_u32 (__m128h __A)
{
  return (int)
    __builtin_ia32_vcvttsh2usi32_round (__A, 0x04);
}
# 4478 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsh_i64 (__m128h __A)
{
  return (long long)
    __builtin_ia32_vcvttsh2si64_round (__A, 0x04);
}

extern __inline unsigned long long
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsh_u64 (__m128h __A)
{
  return (long long)
    __builtin_ia32_vcvttsh2usi64_round (__A, 0x04);
}
# 4519 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti32_sh (__m128h __A, int __B)
{
  return __builtin_ia32_vcvtsi2sh32_round (__A, __B, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu32_sh (__m128h __A, unsigned int __B)
{
  return __builtin_ia32_vcvtusi2sh32_round (__A, __B, 0x04);
}
# 4557 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvti64_sh (__m128h __A, long long __B)
{
  return __builtin_ia32_vcvtsi2sh64_round (__A, __B, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtu64_sh (__m128h __A, unsigned long long __B)
{
  return __builtin_ia32_vcvtusi2sh64_round (__A, __B, 0x04);
}
# 4596 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtph_pd (__m128h __A)
{
  return __builtin_ia32_vcvtph2pd512_mask_round (__A,
       _mm512_setzero_pd (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtph_pd (__m512d __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2pd512_mask_round (__C, __A, __B,
       0x04);
}

extern __inline __m512d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtph_pd (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2pd512_mask_round (__B,
       _mm512_setzero_pd (),
       __A,
       0x04);
}
# 4671 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtxph_ps (__m256h __A)
{
  return __builtin_ia32_vcvtph2psx512_mask_round (__A,
        _mm512_setzero_ps (),
        (__mmask16) -1,
        0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtxph_ps (__m512 __A, __mmask16 __B, __m256h __C)
{
  return __builtin_ia32_vcvtph2psx512_mask_round (__C, __A, __B,
        0x04);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtxph_ps (__mmask16 __A, __m256h __B)
{
  return __builtin_ia32_vcvtph2psx512_mask_round (__B,
        _mm512_setzero_ps (),
        __A,
        0x04);
}
# 4745 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtxps_ph (__m512 __A)
{
  return __builtin_ia32_vcvtps2phx512_mask_round ((__v16sf) __A,
        _mm256_setzero_ph (),
        (__mmask16) -1,
        0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtxps_ph (__m256h __A, __mmask16 __B, __m512 __C)
{
  return __builtin_ia32_vcvtps2phx512_mask_round ((__v16sf) __C,
        __A, __B,
        0x04);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtxps_ph (__mmask16 __A, __m512 __B)
{
  return __builtin_ia32_vcvtps2phx512_mask_round ((__v16sf) __B,
        _mm256_setzero_ph (),
        __A,
        0x04);
}
# 4819 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpd_ph (__m512d __A)
{
  return __builtin_ia32_vcvtpd2ph512_mask_round ((__v8df) __A,
       _mm_setzero_ph (),
       (__mmask8) -1,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpd_ph (__m128h __A, __mmask8 __B, __m512d __C)
{
  return __builtin_ia32_vcvtpd2ph512_mask_round ((__v8df) __C,
       __A, __B,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpd_ph (__mmask8 __A, __m512d __B)
{
  return __builtin_ia32_vcvtpd2ph512_mask_round ((__v8df) __B,
       _mm_setzero_ph (),
       __A,
       0x04);
}
# 4894 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_ss (__m128 __A, __m128h __B)
{
  return __builtin_ia32_vcvtsh2ss_mask_round (__B, __A,
           _mm_setzero_ps (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsh_ss (__m128 __A, __mmask8 __B, __m128 __C,
    __m128h __D)
{
  return __builtin_ia32_vcvtsh2ss_mask_round (__D, __C, __A, __B,
           0x04);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsh_ss (__mmask8 __A, __m128 __B,
     __m128h __C)
{
  return __builtin_ia32_vcvtsh2ss_mask_round (__C, __B,
           _mm_setzero_ps (),
           __A, 0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsh_sd (__m128d __A, __m128h __B)
{
  return __builtin_ia32_vcvtsh2sd_mask_round (__B, __A,
           _mm_setzero_pd (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsh_sd (__m128d __A, __mmask8 __B, __m128d __C,
    __m128h __D)
{
  return __builtin_ia32_vcvtsh2sd_mask_round (__D, __C, __A, __B,
           0x04);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsh_sd (__mmask8 __A, __m128d __B, __m128h __C)
{
  return __builtin_ia32_vcvtsh2sd_mask_round (__C, __B,
           _mm_setzero_pd (),
           __A, 0x04);
}
# 5035 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sh (__m128h __A, __m128 __B)
{
  return __builtin_ia32_vcvtss2sh_mask_round (__B, __A,
           _mm_setzero_ph (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtss_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128 __D)
{
  return __builtin_ia32_vcvtss2sh_mask_round (__D, __C, __A, __B,
           0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtss_sh (__mmask8 __A, __m128h __B, __m128 __C)
{
  return __builtin_ia32_vcvtss2sh_mask_round (__C, __B,
           _mm_setzero_ph (),
           __A, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_sh (__m128h __A, __m128d __B)
{
  return __builtin_ia32_vcvtsd2sh_mask_round (__B, __A,
           _mm_setzero_ph (),
           (__mmask8) -1,
           0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtsd_sh (__m128h __A, __mmask8 __B, __m128h __C, __m128d __D)
{
  return __builtin_ia32_vcvtsd2sh_mask_round (__D, __C, __A, __B,
           0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtsd_sh (__mmask8 __A, __m128h __B, __m128d __C)
{
  return __builtin_ia32_vcvtsd2sh_mask_round (__C, __B,
           _mm_setzero_ph (),
           __A, 0x04);
}
# 5174 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmaddsub_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddsubph512_mask ((__v32hf) __A,
     (__v32hf) __B,
     (__v32hf) __C,
     (__mmask32) -1,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmaddsub_ph (__m512h __A, __mmask32 __U, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddsubph512_mask ((__v32hf) __A,
     (__v32hf) __B,
     (__v32hf) __C,
     (__mmask32) __U,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmaddsub_ph (__m512h __A, __m512h __B, __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfmaddsubph512_mask3 ((__v32hf) __A,
      (__v32hf) __B,
      (__v32hf) __C,
      (__mmask32) __U,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmaddsub_ph (__mmask32 __U, __m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddsubph512_maskz ((__v32hf) __A,
      (__v32hf) __B,
      (__v32hf) __C,
      (__mmask32) __U,
      0x04);
}
# 5286 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
  _mm512_fmsubadd_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubaddph512_mask ((__v32hf) __A,
     (__v32hf) __B,
     (__v32hf) __C,
     (__mmask32) -1,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsubadd_ph (__m512h __A, __mmask32 __U,
    __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubaddph512_mask ((__v32hf) __A,
     (__v32hf) __B,
     (__v32hf) __C,
     (__mmask32) __U,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsubadd_ph (__m512h __A, __m512h __B,
     __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfmsubaddph512_mask3 ((__v32hf) __A,
      (__v32hf) __B,
      (__v32hf) __C,
      (__mmask32) __U,
      0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsubadd_ph (__mmask32 __U, __m512h __A,
     __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubaddph512_maskz ((__v32hf) __A,
      (__v32hf) __B,
      (__v32hf) __C,
      (__mmask32) __U,
      0x04);
}
# 5402 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
  _mm512_fmadd_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddph512_mask ((__v32hf) __A,
         (__v32hf) __B,
         (__v32hf) __C,
         (__mmask32) -1,
         0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmadd_ph (__m512h __A, __mmask32 __U, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddph512_mask ((__v32hf) __A,
         (__v32hf) __B,
         (__v32hf) __C,
         (__mmask32) __U,
         0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmadd_ph (__m512h __A, __m512h __B, __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfmaddph512_mask3 ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmadd_ph (__mmask32 __U, __m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddph512_maskz ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}
# 5510 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmadd_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmaddph512_mask ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) -1,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmadd_ph (__m512h __A, __mmask32 __U, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmaddph512_mask ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmadd_ph (__m512h __A, __m512h __B, __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfnmaddph512_mask3 ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           (__mmask32) __U,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmadd_ph (__mmask32 __U, __m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmaddph512_maskz ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           (__mmask32) __U,
           0x04);
}
# 5618 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmsub_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubph512_mask ((__v32hf) __A,
         (__v32hf) __B,
         (__v32hf) __C,
         (__mmask32) -1,
         0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmsub_ph (__m512h __A, __mmask32 __U, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubph512_mask ((__v32hf) __A,
         (__v32hf) __B,
         (__v32hf) __C,
         (__mmask32) __U,
         0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmsub_ph (__m512h __A, __m512h __B, __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfmsubph512_mask3 ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmsub_ph (__mmask32 __U, __m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmsubph512_maskz ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}
# 5726 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fnmsub_ph (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmsubph512_mask ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) -1,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fnmsub_ph (__m512h __A, __mmask32 __U, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmsubph512_mask ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          (__mmask32) __U,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fnmsub_ph (__m512h __A, __m512h __B, __m512h __C, __mmask32 __U)
{
  return (__m512h)
    __builtin_ia32_vfnmsubph512_mask3 ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           (__mmask32) __U,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fnmsub_ph (__mmask32 __U, __m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfnmsubph512_maskz ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           (__mmask32) __U,
           0x04);
}
# 5834 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_sh (__m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        (__v8hf) __A,
        (__v8hf) __B,
        (__mmask8) -1,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_sh (__m128h __W, __mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        (__v8hf) __A,
        (__v8hf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_sh (__m128h __W, __m128h __A, __m128h __B, __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask3 ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_sh (__mmask8 __U, __m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_maskz ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}
# 5937 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_sh (__m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfnmaddsh3_mask ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) -1,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_sh (__m128h __W, __mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfnmaddsh3_mask ((__v8hf) __W,
        (__v8hf) __A,
        (__v8hf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_sh (__m128h __W, __m128h __A, __m128h __B, __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfnmaddsh3_mask3 ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_sh (__mmask8 __U, __m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfnmaddsh3_maskz ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}
# 6040 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_sh (__m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        (__v8hf) __A,
        -(__v8hf) __B,
        (__mmask8) -1,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_sh (__m128h __W, __mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        (__v8hf) __A,
        -(__v8hf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_sh (__m128h __W, __m128h __A, __m128h __B, __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmsubsh3_mask3 ((__v8hf) __W,
         (__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_sh (__mmask8 __U, __m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_maskz ((__v8hf) __W,
         (__v8hf) __A,
         -(__v8hf) __B,
         (__mmask8) __U,
         0x04);
}
# 6143 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
  __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_sh (__m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        -(__v8hf) __A,
        -(__v8hf) __B,
        (__mmask8) -1,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_sh (__m128h __W, __mmask8 __U, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_mask ((__v8hf) __W,
        -(__v8hf) __A,
        -(__v8hf) __B,
        (__mmask8) __U,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_sh (__m128h __W, __m128h __A, __m128h __B, __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmsubsh3_mask3 ((__v8hf) __W,
         -(__v8hf) __A,
         (__v8hf) __B,
         (__mmask8) __U,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_sh (__mmask8 __U, __m128h __W, __m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmaddsh3_maskz ((__v8hf) __W,
         -(__v8hf) __A,
         -(__v8hf) __B,
         (__mmask8) __U,
         0x04);
}
# 6246 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fcmadd_pch (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfcmaddcph512_round ((__v32hf) __A,
     (__v32hf) __B,
     (__v32hf) __C,
     0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fcmadd_pch (__m512h __A, __mmask16 __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfcmaddcph512_mask_round ((__v32hf) __A,
          (__v32hf) __C,
          (__v32hf) __D, __B,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fcmadd_pch (__m512h __A, __m512h __B, __m512h __C, __mmask16 __D)
{
  return (__m512h)
    __builtin_ia32_vfcmaddcph512_mask3_round ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           __D, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fcmadd_pch (__mmask16 __A, __m512h __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfcmaddcph512_maskz_round ((__v32hf) __B,
           (__v32hf) __C,
           (__v32hf) __D,
           __A, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmadd_pch (__m512h __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmaddcph512_round ((__v32hf) __A,
           (__v32hf) __B,
           (__v32hf) __C,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmadd_pch (__m512h __A, __mmask16 __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfmaddcph512_mask_round ((__v32hf) __A,
         (__v32hf) __C,
         (__v32hf) __D, __B,
         0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask3_fmadd_pch (__m512h __A, __m512h __B, __m512h __C, __mmask16 __D)
{
  return (__m512h)
    __builtin_ia32_vfmaddcph512_mask3_round ((__v32hf) __A,
          (__v32hf) __B,
          (__v32hf) __C,
          __D, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmadd_pch (__mmask16 __A, __m512h __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfmaddcph512_maskz_round ((__v32hf) __B,
          (__v32hf) __C,
          (__v32hf) __D,
          __A, 0x04);
}
# 6470 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fcmul_pch (__m512h __A, __m512h __B)
{
  return (__m512h)
    __builtin_ia32_vfcmulcph512_round ((__v32hf) __A,
           (__v32hf) __B,
           0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fcmul_pch (__m512h __A, __mmask16 __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfcmulcph512_mask_round ((__v32hf) __C,
         (__v32hf) __D,
         (__v32hf) __A,
         __B, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fcmul_pch (__mmask16 __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfcmulcph512_mask_round ((__v32hf) __B,
         (__v32hf) __C,
         _mm512_setzero_ph (),
         __A, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_fmul_pch (__m512h __A, __m512h __B)
{
  return (__m512h)
    __builtin_ia32_vfmulcph512_round ((__v32hf) __A,
          (__v32hf) __B,
          0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_fmul_pch (__m512h __A, __mmask16 __B, __m512h __C, __m512h __D)
{
  return (__m512h)
    __builtin_ia32_vfmulcph512_mask_round ((__v32hf) __C,
        (__v32hf) __D,
        (__v32hf) __A,
        __B, 0x04);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_fmul_pch (__mmask16 __A, __m512h __B, __m512h __C)
{
  return (__m512h)
    __builtin_ia32_vfmulcph512_mask_round ((__v32hf) __B,
        (__v32hf) __C,
        _mm512_setzero_ph (),
        __A, 0x04);
}
# 6630 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fcmadd_sch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfcmaddcsh_mask_round ((__v8hf) __A,
       (__v8hf) __C,
       (__v8hf) __D, __B,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fcmadd_sch (__m128h __A, __m128h __B, __m128h __C, __mmask8 __D)
{
  return (__m128h)
    __builtin_ia32_vfcmaddcsh_mask3_round ((__v8hf) __A,
        (__v8hf) __B,
        (__v8hf) __C, __D,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fcmadd_sch (__mmask8 __A, __m128h __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfcmaddcsh_maskz_round ((__v8hf) __B,
        (__v8hf) __C,
        (__v8hf) __D,
        __A, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fcmadd_sch (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h)
    __builtin_ia32_vfcmaddcsh_round ((__v8hf) __A,
         (__v8hf) __B,
         (__v8hf) __C,
         0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_sch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfmaddcsh_mask_round ((__v8hf) __A,
      (__v8hf) __C,
      (__v8hf) __D, __B,
      0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_sch (__m128h __A, __m128h __B, __m128h __C, __mmask8 __D)
{
  return (__m128h)
    __builtin_ia32_vfmaddcsh_mask3_round ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C, __D,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_sch (__mmask8 __A, __m128h __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfmaddcsh_maskz_round ((__v8hf) __B,
       (__v8hf) __C,
       (__v8hf) __D,
       __A, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_sch (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h)
    __builtin_ia32_vfmaddcsh_round ((__v8hf) __A,
        (__v8hf) __B,
        (__v8hf) __C,
        0x04);
}
# 6857 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fcmul_sch (__m128h __A, __m128h __B)
{
  return (__m128h)
    __builtin_ia32_vfcmulcsh_round ((__v8hf) __A,
        (__v8hf) __B,
        0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fcmul_sch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfcmulcsh_mask_round ((__v8hf) __C,
      (__v8hf) __D,
      (__v8hf) __A,
      __B, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fcmul_sch (__mmask8 __A, __m128h __B, __m128h __C)
{
  return (__m128h)
    __builtin_ia32_vfcmulcsh_mask_round ((__v8hf) __B,
      (__v8hf) __C,
      _mm_setzero_ph (),
      __A, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmul_sch (__m128h __A, __m128h __B)
{
  return (__m128h)
    __builtin_ia32_vfmulcsh_round ((__v8hf) __A,
       (__v8hf) __B,
       0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmul_sch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfmulcsh_mask_round ((__v8hf) __C,
     (__v8hf) __D,
     (__v8hf) __A,
     __B, 0x04);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmul_sch (__mmask8 __A, __m128h __B, __m128h __C)
{
  return (__m128h)
    __builtin_ia32_vfmulcsh_mask_round ((__v8hf) __B,
     (__v8hf) __C,
     _mm_setzero_ph (),
     __A, 0x04);
}
# 7039 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_add_ph (__m512h __A)
{
   __m256h __T1 = (__m256h) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256h __T2 = (__m256h) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256h __T3 = (__T1 + __T2); __m128h __T4 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __T3), (int)(0))); __m128h __T5 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __T3), (int)(1))); __m128h __T6 = (__T4 + __T5); __m128h __T7 = (__m128h) __builtin_shuffle ((__m128h)__T6, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T8 = (__T6 + __T7); __m128h __T9 = (__m128h) __builtin_shuffle ((__m128h)__T8, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T10 = __T8 + __T9; return __T10[0] + __T10[1];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_mul_ph (__m512h __A)
{
   __m256h __T1 = (__m256h) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (0), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256h __T2 = (__m256h) ((__m256d) __builtin_ia32_extractf64x4_mask ((__v8df)(__m512d) ((__m512d) __A), (int) (1), (__v4df)(__m256d)_mm256_undefined_pd(), (__mmask8)-1)); __m256h __T3 = (__T1 * __T2); __m128h __T4 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __T3), (int)(0))); __m128h __T5 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __T3), (int)(1))); __m128h __T6 = (__T4 * __T5); __m128h __T7 = (__m128h) __builtin_shuffle ((__m128h)__T6, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T8 = (__T6 * __T7); __m128h __T9 = (__m128h) __builtin_shuffle ((__m128h)__T8, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T10 = __T8 * __T9; return __T10[0] * __T10[1];
}
# 7105 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_min_ph (__m512h __A)
{
  __m512h __T1 = (__m512h) __builtin_shuffle ((__m512d) __A, (__v8di) { 4, 5, 6, 7, 0, 0, 0, 0 }); __m512h __T2 = _mm512_min_ph (__A, __T1); __m512h __T3 = (__m512h) __builtin_shuffle ((__m512d) __T2, (__v8di) { 2, 3, 0, 0, 0, 0, 0, 0 }); __m512h __T4 = _mm512_min_ph (__T2, __T3); __m512h __T5 = (__m512h) __builtin_shuffle ((__m512d) __T4, (__v8di) { 1, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T6 = _mm512_min_ph (__T4, __T5); __m512h __T7 = (__m512h) __builtin_shuffle ((__m512) __T6, (__v16si) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T8 = _mm512_min_ph (__T6, __T7); __m512h __T9 = (__m512h) __builtin_shuffle (__T8, (__v32hi) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T10 = _mm512_min_ph (__T8, __T9); return __T10[0];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_reduce_max_ph (__m512h __A)
{
  __m512h __T1 = (__m512h) __builtin_shuffle ((__m512d) __A, (__v8di) { 4, 5, 6, 7, 0, 0, 0, 0 }); __m512h __T2 = _mm512_max_ph (__A, __T1); __m512h __T3 = (__m512h) __builtin_shuffle ((__m512d) __T2, (__v8di) { 2, 3, 0, 0, 0, 0, 0, 0 }); __m512h __T4 = _mm512_max_ph (__T2, __T3); __m512h __T5 = (__m512h) __builtin_shuffle ((__m512d) __T4, (__v8di) { 1, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T6 = _mm512_max_ph (__T4, __T5); __m512h __T7 = (__m512h) __builtin_shuffle ((__m512) __T6, (__v16si) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T8 = _mm512_max_ph (__T6, __T7); __m512h __T9 = (__m512h) __builtin_shuffle (__T8, (__v32hi) { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }); __m512h __T10 = _mm512_max_ph (__T8, __T9); return __T10[0];
}



extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_blend_ph (__mmask32 __U, __m512h __A, __m512h __W)
{
  return (__m512h) __builtin_ia32_movdquhi512_mask ((__v32hi) __W,
          (__v32hi) __A,
          (__mmask32) __U);

}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutex2var_ph (__m512h __A, __m512i __I, __m512h __B)
{
  return (__m512h) __builtin_ia32_vpermi2varhi512_mask ((__v32hi) __A,
             (__v32hi) __I,
             (__v32hi) __B,
             (__mmask32)-1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_permutexvar_ph (__m512i __A, __m512h __B)
{
  return (__m512h) __builtin_ia32_permvarhi512_mask ((__v32hi) __B,
           (__v32hi) __A,
           (__v32hi)
           (_mm512_setzero_ph ()),
           (__mmask32)-1);
}

extern __inline __m512h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_set1_pch (_Float16 _Complex __A)
{
  union
  {
    _Float16 _Complex __a;
    float __b;
  } __u = { .__a = __A};

  return (__m512h) _mm512_set1_ps (__u.__b);
}
# 7206 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16intrin.h" 3 4
#pragma GCC pop_options
# 99 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512fp16,avx512vl")



extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castph_ps (__m128h __a)
{
  return (__m128) __a;
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castph_ps (__m256h __a)
{
  return (__m256) __a;
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castph_pd (__m128h __a)
{
  return (__m128d) __a;
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castph_pd (__m256h __a)
{
  return (__m256d) __a;
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castph_si128 (__m128h __a)
{
  return (__m128i) __a;
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castph_si256 (__m256h __a)
{
  return (__m256i) __a;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_ph (__m128 __a)
{
  return (__m128h) __a;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castps_ph (__m256 __a)
{
  return (__m256h) __a;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ph (__m128d __a)
{
  return (__m128h) __a;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castpd_ph (__m256d __a)
{
  return (__m256h) __a;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ph (__m128i __a)
{
  return (__m128h) __a;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castsi256_ph (__m256i __a)
{
  return (__m256h) __a;
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castph256_ph128 (__m256h __A)
{
  union
  {
    __m128h __a[2];
    __m256h __v;
  } __u = { .__v = __A };
  return __u.__a[0];
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_castph128_ph256 (__m128h __A)
{
  union
  {
    __m128h __a[2];
    __m256h __v;
  } __u;
  __u.__a[0] = __A;
  return __u.__v;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_zextph128_ph256 (__m128h __A)
{
  return (__m256h) ((__m256) __builtin_ia32_vinsertf128_ps256 ((__v8sf)(__m256)(_mm256_setzero_ps ()), (__v4sf)(__m128)((__m128) __A), (int)(0)))
                      ;
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_conj_pch (__m256h __A)
{
  return (__m256h) _mm256_xor_epi32 ((__m256i) __A, _mm256_set1_epi32 (1<<31));
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_conj_pch (__m256h __W, __mmask8 __U, __m256h __A)
{
  return (__m256h) __builtin_ia32_movaps256_mask ((__v8sf)
         _mm256_conj_pch (__A),
        (__v8sf) __W,
        (__mmask8) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_conj_pch (__mmask8 __U, __m256h __A)
{
  return (__m256h) __builtin_ia32_movaps256_mask ((__v8sf)
         _mm256_conj_pch (__A),
        (__v8sf)
         _mm256_setzero_ps (),
        (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_conj_pch (__m128h __A)
{
  return (__m128h) _mm_xor_epi32 ((__m128i) __A, _mm_set1_epi32 (1<<31));
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_conj_pch (__m128h __W, __mmask8 __U, __m128h __A)
{
  return (__m128h) __builtin_ia32_movaps128_mask ((__v4sf) _mm_conj_pch (__A),
        (__v4sf) __W,
        (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_conj_pch (__mmask8 __U, __m128h __A)
{
  return (__m128h) __builtin_ia32_movaps128_mask ((__v4sf) _mm_conj_pch (__A),
        (__v4sf) _mm_setzero_ps (),
        (__mmask8) __U);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ph (__m128h __A, __m128h __B)
{
  return (__m128h) ((__v8hf) __A + (__v8hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_add_ph (__m256h __A, __m256h __B)
{
  return (__m256h) ((__v16hf) __A + (__v16hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_add_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_addph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_add_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_addph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_add_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_addph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_add_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_addph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ph (__m128h __A, __m128h __B)
{
  return (__m128h) ((__v8hf) __A - (__v8hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sub_ph (__m256h __A, __m256h __B)
{
  return (__m256h) ((__v16hf) __A - (__v16hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sub_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_subph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sub_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_subph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sub_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_subph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sub_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_subph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ph (__m128h __A, __m128h __B)
{
  return (__m128h) ((__v8hf) __A * (__v8hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mul_ph (__m256h __A, __m256h __B)
{
  return (__m256h) ((__v16hf) __A * (__v16hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_mul_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_mulph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_mul_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_mulph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_mul_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_mulph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_mul_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_mulph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ph (__m128h __A, __m128h __B)
{
  return (__m128h) ((__v8hf) __A / (__v8hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_div_ph (__m256h __A, __m256h __B)
{
  return (__m256h) ((__v16hf) __A / (__v16hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_div_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_divph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_div_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_divph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_div_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_divph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_div_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_divph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ph (__m128h __A, __m128h __B)
{
  return __builtin_ia32_maxph128_mask (__A, __B,
           _mm_setzero_ph (),
           (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_max_ph (__m256h __A, __m256h __B)
{
  return __builtin_ia32_maxph256_mask (__A, __B,
           _mm256_setzero_ph (),
           (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_max_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_maxph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_max_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_maxph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_max_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_maxph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_max_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_maxph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ph (__m128h __A, __m128h __B)
{
  return __builtin_ia32_minph128_mask (__A, __B,
           _mm_setzero_ph (),
           (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_min_ph (__m256h __A, __m256h __B)
{
  return __builtin_ia32_minph256_mask (__A, __B,
           _mm256_setzero_ph (),
           (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_min_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_minph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_min_ph (__m256h __A, __mmask16 __B, __m256h __C, __m256h __D)
{
  return __builtin_ia32_minph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_min_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_minph128_mask (__B, __C, _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_min_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_minph256_mask (__B, __C,
           _mm256_setzero_ph (), __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_abs_ph (__m128h __A)
{
  return (__m128h) _mm_and_si128 ( _mm_set1_epi32 (0x7FFF7FFF),
       (__m128i) __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_abs_ph (__m256h __A)
{
  return (__m256h) _mm256_and_si256 ( _mm256_set1_epi32 (0x7FFF7FFF),
          (__m256i) __A);
}
# 548 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ph (__m128h __A)
{
  return __builtin_ia32_sqrtph128_mask (__A, _mm_setzero_ph (),
     (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_sqrt_ph (__m256h __A)
{
  return __builtin_ia32_sqrtph256_mask (__A, _mm256_setzero_ph (),
     (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_sqrt_ph (__m128h __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_sqrtph128_mask (__C, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_sqrt_ph (__m256h __A, __mmask16 __B, __m256h __C)
{
  return __builtin_ia32_sqrtph256_mask (__C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_sqrt_ph (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_sqrtph128_mask (__B, _mm_setzero_ph (),
     __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_sqrt_ph (__mmask16 __A, __m256h __B)
{
  return __builtin_ia32_sqrtph256_mask (__B, _mm256_setzero_ph (),
     __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ph (__m128h __A)
{
  return __builtin_ia32_rsqrtph128_mask (__A, _mm_setzero_ph (),
      (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rsqrt_ph (__m256h __A)
{
  return __builtin_ia32_rsqrtph256_mask (__A, _mm256_setzero_ph (),
      (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rsqrt_ph (__m128h __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_rsqrtph128_mask (__C, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rsqrt_ph (__m256h __A, __mmask16 __B, __m256h __C)
{
  return __builtin_ia32_rsqrtph256_mask (__C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rsqrt_ph (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_rsqrtph128_mask (__B, _mm_setzero_ph (), __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rsqrt_ph (__mmask16 __A, __m256h __B)
{
  return __builtin_ia32_rsqrtph256_mask (__B, _mm256_setzero_ph (),
      __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ph (__m128h __A)
{
  return __builtin_ia32_rcpph128_mask (__A, _mm_setzero_ph (),
           (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_rcp_ph (__m256h __A)
{
  return __builtin_ia32_rcpph256_mask (__A, _mm256_setzero_ph (),
           (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_rcp_ph (__m128h __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_rcpph128_mask (__C, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_rcp_ph (__m256h __A, __mmask16 __B, __m256h __C)
{
  return __builtin_ia32_rcpph256_mask (__C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_rcp_ph (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_rcpph128_mask (__B, _mm_setzero_ph (), __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_rcp_ph (__mmask16 __A, __m256h __B)
{
  return __builtin_ia32_rcpph256_mask (__B, _mm256_setzero_ph (),
           __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_scalef_ph (__m128h __A, __m128h __B)
{
  return __builtin_ia32_scalefph128_mask (__A, __B,
       _mm_setzero_ph (),
       (__mmask8) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_scalef_ph (__m256h __A, __m256h __B)
{
  return __builtin_ia32_scalefph256_mask (__A, __B,
       _mm256_setzero_ph (),
       (__mmask16) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_scalef_ph (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return __builtin_ia32_scalefph128_mask (__C, __D, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_scalef_ph (__m256h __A, __mmask16 __B, __m256h __C,
         __m256h __D)
{
  return __builtin_ia32_scalefph256_mask (__C, __D, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_scalef_ph (__mmask8 __A, __m128h __B, __m128h __C)
{
  return __builtin_ia32_scalefph128_mask (__B, __C,
       _mm_setzero_ph (), __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_scalef_ph (__mmask16 __A, __m256h __B, __m256h __C)
{
  return __builtin_ia32_scalefph256_mask (__B, __C,
       _mm256_setzero_ph (),
       __A);
}
# 945 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_getexp_ph (__m256h __A)
{
  return (__m256h) __builtin_ia32_getexpph256_mask ((__v16hf) __A,
          (__v16hf)
          _mm256_setzero_ph (),
          (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_getexp_ph (__m256h __W, __mmask16 __U, __m256h __A)
{
  return (__m256h) __builtin_ia32_getexpph256_mask ((__v16hf) __A,
          (__v16hf) __W,
          (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_getexp_ph (__mmask16 __U, __m256h __A)
{
  return (__m256h) __builtin_ia32_getexpph256_mask ((__v16hf) __A,
          (__v16hf)
          _mm256_setzero_ph (),
          (__mmask16) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_getexp_ph (__m128h __A)
{
  return (__m128h) __builtin_ia32_getexpph128_mask ((__v8hf) __A,
          (__v8hf)
          _mm_setzero_ph (),
          (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_getexp_ph (__m128h __W, __mmask8 __U, __m128h __A)
{
  return (__m128h) __builtin_ia32_getexpph128_mask ((__v8hf) __A,
          (__v8hf) __W,
          (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_getexp_ph (__mmask8 __U, __m128h __A)
{
  return (__m128h) __builtin_ia32_getexpph128_mask ((__v8hf) __A,
          (__v8hf)
          _mm_setzero_ph (),
          (__mmask8) __U);
}
# 1120 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epi32 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvtph2dq128_mask (__A,
          (__v4si)
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epi32 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvtph2dq128_mask (__C, ( __v4si) __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epi32 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvtph2dq128_mask (__B,
          (__v4si) _mm_setzero_si128 (),
          __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epi32 (__m128h __A)
{
  return (__m256i)
    __builtin_ia32_vcvtph2dq256_mask (__A,
          (__v8si)
          _mm256_setzero_si256 (),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epi32 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return (__m256i)
    __builtin_ia32_vcvtph2dq256_mask (__C, ( __v8si) __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epi32 (__mmask8 __A, __m128h __B)
{
  return (__m256i)
    __builtin_ia32_vcvtph2dq256_mask (__B,
          (__v8si)
          _mm256_setzero_si256 (),
          __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epu32 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvtph2udq128_mask (__A,
           (__v4si)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epu32 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvtph2udq128_mask (__C, ( __v4si) __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epu32 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvtph2udq128_mask (__B,
           (__v4si)
           _mm_setzero_si128 (),
           __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epu32 (__m128h __A)
{
  return (__m256i)
    __builtin_ia32_vcvtph2udq256_mask (__A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epu32 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return (__m256i)
    __builtin_ia32_vcvtph2udq256_mask (__C, ( __v8si) __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epu32 (__mmask8 __A, __m128h __B)
{
  return (__m256i)
    __builtin_ia32_vcvtph2udq256_mask (__B,
           (__v8si) _mm256_setzero_si256 (),
           __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epi32 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvttph2dq128_mask (__A,
           (__v4si) _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epi32 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)__builtin_ia32_vcvttph2dq128_mask (__C,
           ( __v4si) __A,
           __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epi32 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvttph2dq128_mask (__B,
           (__v4si) _mm_setzero_si128 (),
           __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epi32 (__m128h __A)
{
  return (__m256i)
    __builtin_ia32_vcvttph2dq256_mask (__A,
           (__v8si)
           _mm256_setzero_si256 (),
           (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epi32 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return (__m256i)
    __builtin_ia32_vcvttph2dq256_mask (__C,
           ( __v8si) __A,
           __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epi32 (__mmask8 __A, __m128h __B)
{
  return (__m256i)
    __builtin_ia32_vcvttph2dq256_mask (__B,
           (__v8si)
           _mm256_setzero_si256 (),
           __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epu32 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvttph2udq128_mask (__A,
     (__v4si)
     _mm_setzero_si128 (),
     (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epu32 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvttph2udq128_mask (__C,
     ( __v4si) __A,
     __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epu32 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvttph2udq128_mask (__B,
     (__v4si)
     _mm_setzero_si128 (),
     __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epu32 (__m128h __A)
{
  return (__m256i)
    __builtin_ia32_vcvttph2udq256_mask (__A,
     (__v8si)
     _mm256_setzero_si256 (), (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epu32 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return (__m256i)
    __builtin_ia32_vcvttph2udq256_mask (__C,
     ( __v8si) __A,
     __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epu32 (__mmask8 __A, __m128h __B)
{
  return (__m256i)
    __builtin_ia32_vcvttph2udq256_mask (__B,
     (__v8si)
     _mm256_setzero_si256 (),
     __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ph (__m128i __A)
{
  return __builtin_ia32_vcvtdq2ph128_mask ((__v4si) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi32_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtdq2ph128_mask ((__v4si) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi32_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtdq2ph128_mask ((__v4si) __B,
        _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi32_ph (__m256i __A)
{
  return __builtin_ia32_vcvtdq2ph256_mask ((__v8si) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi32_ph (__m128h __A, __mmask8 __B, __m256i __C)
{
  return __builtin_ia32_vcvtdq2ph256_mask ((__v8si) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi32_ph (__mmask8 __A, __m256i __B)
{
  return __builtin_ia32_vcvtdq2ph256_mask ((__v8si) __B,
        _mm_setzero_ph (),
        __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu32_ph (__m128i __A)
{
  return __builtin_ia32_vcvtudq2ph128_mask ((__v4si) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu32_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtudq2ph128_mask ((__v4si) __C,
         __A,
         __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu32_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtudq2ph128_mask ((__v4si) __B,
         _mm_setzero_ph (),
         __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu32_ph (__m256i __A)
{
  return __builtin_ia32_vcvtudq2ph256_mask ((__v8si) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu32_ph (__m128h __A, __mmask8 __B, __m256i __C)
{
  return __builtin_ia32_vcvtudq2ph256_mask ((__v8si) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu32_ph (__mmask8 __A, __m256i __B)
{
  return __builtin_ia32_vcvtudq2ph256_mask ((__v8si) __B,
         _mm_setzero_ph (),
         __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epi64 (__m128h __A)
{
  return
    __builtin_ia32_vcvtph2qq128_mask (__A,
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epi64 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2qq128_mask (__C, __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2qq128_mask (__B,
        _mm_setzero_si128 (),
        __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epi64 (__m128h __A)
{
  return __builtin_ia32_vcvtph2qq256_mask (__A,
        _mm256_setzero_si256 (),
        (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epi64 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2qq256_mask (__C, __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2qq256_mask (__B,
        _mm256_setzero_si256 (),
        __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvtph2uqq128_mask (__A,
         _mm_setzero_si128 (),
         (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epu64 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2uqq128_mask (__C, __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2uqq128_mask (__B,
         _mm_setzero_si128 (),
         __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvtph2uqq256_mask (__A,
         _mm256_setzero_si256 (),
         (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epu64 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2uqq256_mask (__C, __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2uqq256_mask (__B,
         _mm256_setzero_si256 (),
         __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epi64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2qq128_mask (__A,
         _mm_setzero_si128 (),
         (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epi64 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2qq128_mask (__C,
         __A,
         __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2qq128_mask (__B,
         _mm_setzero_si128 (),
         __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epi64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2qq256_mask (__A,
         _mm256_setzero_si256 (),
         (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epi64 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2qq256_mask (__C,
         __A,
         __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epi64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2qq256_mask (__B,
         _mm256_setzero_si256 (),
         __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2uqq128_mask (__A,
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epu64 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2uqq128_mask (__C,
          __A,
          __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2uqq128_mask (__B,
          _mm_setzero_si128 (),
          __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epu64 (__m128h __A)
{
  return __builtin_ia32_vcvttph2uqq256_mask (__A,
          _mm256_setzero_si256 (),
          (__mmask8) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epu64 (__m256i __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvttph2uqq256_mask (__C,
          __A,
          __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epu64 (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvttph2uqq256_mask (__B,
          _mm256_setzero_si256 (),
          __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi64_ph (__m128i __A)
{
  return __builtin_ia32_vcvtqq2ph128_mask ((__v2di) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi64_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtqq2ph128_mask ((__v2di) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi64_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtqq2ph128_mask ((__v2di) __B,
        _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi64_ph (__m256i __A)
{
  return __builtin_ia32_vcvtqq2ph256_mask ((__v4di) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi64_ph (__m128h __A, __mmask8 __B, __m256i __C)
{
  return __builtin_ia32_vcvtqq2ph256_mask ((__v4di) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi64_ph (__mmask8 __A, __m256i __B)
{
  return __builtin_ia32_vcvtqq2ph256_mask ((__v4di) __B,
        _mm_setzero_ph (),
        __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu64_ph (__m128i __A)
{
  return __builtin_ia32_vcvtuqq2ph128_mask ((__v2di) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu64_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtuqq2ph128_mask ((__v2di) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu64_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtuqq2ph128_mask ((__v2di) __B,
         _mm_setzero_ph (),
         __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu64_ph (__m256i __A)
{
  return __builtin_ia32_vcvtuqq2ph256_mask ((__v4di) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu64_ph (__m128h __A, __mmask8 __B, __m256i __C)
{
  return __builtin_ia32_vcvtuqq2ph256_mask ((__v4di) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu64_ph (__mmask8 __A, __m256i __B)
{
  return __builtin_ia32_vcvtuqq2ph256_mask ((__v4di) __B,
         _mm_setzero_ph (),
         __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epi16 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvtph2w128_mask (__A,
         (__v8hi)
         _mm_setzero_si128 (),
         (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epi16 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvtph2w128_mask (__C, ( __v8hi) __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epi16 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvtph2w128_mask (__B,
         (__v8hi)
         _mm_setzero_si128 (),
         __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epi16 (__m256h __A)
{
  return (__m256i)
    __builtin_ia32_vcvtph2w256_mask (__A,
         (__v16hi)
         _mm256_setzero_si256 (),
         (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epi16 (__m256i __A, __mmask16 __B, __m256h __C)
{
  return (__m256i)
    __builtin_ia32_vcvtph2w256_mask (__C, ( __v16hi) __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epi16 (__mmask16 __A, __m256h __B)
{
  return (__m256i)
    __builtin_ia32_vcvtph2w256_mask (__B,
         (__v16hi)
         _mm256_setzero_si256 (),
         __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_epu16 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvtph2uw128_mask (__A,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_epu16 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvtph2uw128_mask (__C, ( __v8hi) __A, __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_epu16 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvtph2uw128_mask (__B,
          (__v8hi)
          _mm_setzero_si128 (),
          __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_epu16 (__m256h __A)
{
  return (__m256i)
    __builtin_ia32_vcvtph2uw256_mask (__A,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_epu16 (__m256i __A, __mmask16 __B, __m256h __C)
{
  return (__m256i)
    __builtin_ia32_vcvtph2uw256_mask (__C, ( __v16hi) __A, __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_epu16 (__mmask16 __A, __m256h __B)
{
  return (__m256i)
    __builtin_ia32_vcvtph2uw256_mask (__B,
          (__v16hi)
          _mm256_setzero_si256 (),
          __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epi16 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvttph2w128_mask (__A,
          (__v8hi)
          _mm_setzero_si128 (),
          (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epi16 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvttph2w128_mask (__C,
          ( __v8hi) __A,
          __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epi16 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvttph2w128_mask (__B,
          (__v8hi)
          _mm_setzero_si128 (),
          __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epi16 (__m256h __A)
{
  return (__m256i)
    __builtin_ia32_vcvttph2w256_mask (__A,
          (__v16hi)
          _mm256_setzero_si256 (),
          (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epi16 (__m256i __A, __mmask16 __B, __m256h __C)
{
  return (__m256i)
    __builtin_ia32_vcvttph2w256_mask (__C,
          ( __v16hi) __A,
          __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epi16 (__mmask16 __A, __m256h __B)
{
  return (__m256i)
    __builtin_ia32_vcvttph2w256_mask (__B,
          (__v16hi)
          _mm256_setzero_si256 (),
          __A);
}


extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttph_epu16 (__m128h __A)
{
  return (__m128i)
    __builtin_ia32_vcvttph2uw128_mask (__A,
           (__v8hi)
           _mm_setzero_si128 (),
           (__mmask8) -1);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvttph_epu16 (__m128i __A, __mmask8 __B, __m128h __C)
{
  return (__m128i)
    __builtin_ia32_vcvttph2uw128_mask (__C,
           ( __v8hi) __A,
           __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvttph_epu16 (__mmask8 __A, __m128h __B)
{
  return (__m128i)
    __builtin_ia32_vcvttph2uw128_mask (__B,
           (__v8hi)
           _mm_setzero_si128 (),
           __A);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvttph_epu16 (__m256h __A)
{
  return (__m256i)
    __builtin_ia32_vcvttph2uw256_mask (__A,
           (__v16hi)
           _mm256_setzero_si256 (),
           (__mmask16) -1);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvttph_epu16 (__m256i __A, __mmask16 __B, __m256h __C)
{
  return (__m256i)
    __builtin_ia32_vcvttph2uw256_mask (__C,
           ( __v16hi) __A,
           __B);
}

extern __inline __m256i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvttph_epu16 (__mmask16 __A, __m256h __B)
{
  return (__m256i)
    __builtin_ia32_vcvttph2uw256_mask (__B,
           (__v16hi) _mm256_setzero_si256 (),
           __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi16_ph (__m128i __A)
{
  return __builtin_ia32_vcvtw2ph128_mask ((__v8hi) __A,
       _mm_setzero_ph (),
       (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepi16_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtw2ph128_mask ((__v8hi) __C,
       __A,
       __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepi16_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtw2ph128_mask ((__v8hi) __B,
       _mm_setzero_ph (),
       __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepi16_ph (__m256i __A)
{
  return __builtin_ia32_vcvtw2ph256_mask ((__v16hi) __A,
       _mm256_setzero_ph (),
       (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepi16_ph (__m256h __A, __mmask16 __B, __m256i __C)
{
  return __builtin_ia32_vcvtw2ph256_mask ((__v16hi) __C,
       __A,
       __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepi16_ph (__mmask16 __A, __m256i __B)
{
  return __builtin_ia32_vcvtw2ph256_mask ((__v16hi) __B,
       _mm256_setzero_ph (),
       __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepu16_ph (__m128i __A)
{
  return __builtin_ia32_vcvtuw2ph128_mask ((__v8hi) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtepu16_ph (__m128h __A, __mmask8 __B, __m128i __C)
{
  return __builtin_ia32_vcvtuw2ph128_mask ((__v8hi) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtepu16_ph (__mmask8 __A, __m128i __B)
{
  return __builtin_ia32_vcvtuw2ph128_mask ((__v8hi) __B,
        _mm_setzero_ph (),
        __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtepu16_ph (__m256i __A)
{
  return __builtin_ia32_vcvtuw2ph256_mask ((__v16hi) __A,
        _mm256_setzero_ph (),
        (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtepu16_ph (__m256h __A, __mmask16 __B, __m256i __C)
{
  return __builtin_ia32_vcvtuw2ph256_mask ((__v16hi) __C, __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtepu16_ph (__mmask16 __A, __m256i __B)
{
  return __builtin_ia32_vcvtuw2ph256_mask ((__v16hi) __B,
        _mm256_setzero_ph (),
        __A);
}


extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_pd (__m128h __A)
{
  return __builtin_ia32_vcvtph2pd128_mask (__A,
        _mm_setzero_pd (),
        (__mmask8) -1);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtph_pd (__m128d __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2pd128_mask (__C, __A, __B);
}

extern __inline __m128d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtph_pd (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2pd128_mask (__B, _mm_setzero_pd (), __A);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_pd (__m128h __A)
{
  return __builtin_ia32_vcvtph2pd256_mask (__A,
        _mm256_setzero_pd (),
        (__mmask8) -1);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtph_pd (__m256d __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2pd256_mask (__C, __A, __B);
}

extern __inline __m256d
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtph_pd (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2pd256_mask (__B,
        _mm256_setzero_pd (),
        __A);
}


extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtxph_ps (__m128h __A)
{
  return __builtin_ia32_vcvtph2psx128_mask (__A,
        _mm_setzero_ps (),
        (__mmask8) -1);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtxph_ps (__m128 __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2psx128_mask (__C, __A, __B);
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtxph_ps (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2psx128_mask (__B, _mm_setzero_ps (), __A);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtxph_ps (__m128h __A)
{
  return __builtin_ia32_vcvtph2psx256_mask (__A,
         _mm256_setzero_ps (),
         (__mmask8) -1);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtxph_ps (__m256 __A, __mmask8 __B, __m128h __C)
{
  return __builtin_ia32_vcvtph2psx256_mask (__C, __A, __B);
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtxph_ps (__mmask8 __A, __m128h __B)
{
  return __builtin_ia32_vcvtph2psx256_mask (__B,
         _mm256_setzero_ps (),
         __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtxps_ph (__m128 __A)
{
  return __builtin_ia32_vcvtps2phx128_mask ((__v4sf) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtxps_ph (__m128h __A, __mmask8 __B, __m128 __C)
{
  return __builtin_ia32_vcvtps2phx128_mask ((__v4sf) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtxps_ph (__mmask8 __A, __m128 __B)
{
  return __builtin_ia32_vcvtps2phx128_mask ((__v4sf) __B,
         _mm_setzero_ph (),
         __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtxps_ph (__m256 __A)
{
  return __builtin_ia32_vcvtps2phx256_mask ((__v8sf) __A,
         _mm_setzero_ph (),
         (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtxps_ph (__m128h __A, __mmask8 __B, __m256 __C)
{
  return __builtin_ia32_vcvtps2phx256_mask ((__v8sf) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtxps_ph (__mmask8 __A, __m256 __B)
{
  return __builtin_ia32_vcvtps2phx256_mask ((__v8sf) __B,
         _mm_setzero_ph (),
         __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ph (__m128d __A)
{
  return __builtin_ia32_vcvtpd2ph128_mask ((__v2df) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpd_ph (__m128h __A, __mmask8 __B, __m128d __C)
{
  return __builtin_ia32_vcvtpd2ph128_mask ((__v2df) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpd_ph (__mmask8 __A, __m128d __B)
{
  return __builtin_ia32_vcvtpd2ph128_mask ((__v2df) __B,
        _mm_setzero_ph (),
        __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpd_ph (__m256d __A)
{
  return __builtin_ia32_vcvtpd2ph256_mask ((__v4df) __A,
        _mm_setzero_ph (),
        (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpd_ph (__m128h __A, __mmask8 __B, __m256d __C)
{
  return __builtin_ia32_vcvtpd2ph256_mask ((__v4df) __C, __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpd_ph (__mmask8 __A, __m256d __B)
{
  return __builtin_ia32_vcvtpd2ph256_mask ((__v4df) __B,
        _mm_setzero_ph (),
        __A);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmaddsub_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h)__builtin_ia32_vfmaddsubph256_mask ((__v16hf)__A,
            (__v16hf)__B,
            (__v16hf)__C,
            (__mmask16)-1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmaddsub_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddsubph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmaddsub_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfmaddsubph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmaddsub_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddsubph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmaddsub_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h)__builtin_ia32_vfmaddsubph128_mask ((__v8hf)__A,
            (__v8hf)__B,
            (__v8hf)__C,
            (__mmask8)-1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmaddsub_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddsubph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmaddsub_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmaddsubph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmaddsub_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddsubph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsubadd_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsubadd_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsubadd_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfmsubaddph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsubadd_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubaddph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsubadd_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsubadd_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsubadd_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmsubaddph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsubadd_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubaddph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmadd_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmadd_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmadd_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfmaddph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmadd_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmaddph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmadd_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmadd_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmaddph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmadd_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfnmaddph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmadd_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmaddph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmadd_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmaddph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmadd_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfnmaddph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmadd_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmaddph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsub_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmsub_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmsub_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfmsubph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmsub_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmsubph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmsub_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmsub_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfmsubph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmsub_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmsubph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmsub_ph (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmsubph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) -1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fnmsub_ph (__m256h __A, __mmask16 __U, __m256h __B,
    __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmsubph256_mask ((__v16hf) __A,
             (__v16hf) __B,
             (__v16hf) __C,
             (__mmask16) __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fnmsub_ph (__m256h __A, __m256h __B, __m256h __C,
     __mmask16 __U)
{
  return (__m256h) __builtin_ia32_vfnmsubph256_mask3 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fnmsub_ph (__mmask16 __U, __m256h __A, __m256h __B,
     __m256h __C)
{
  return (__m256h) __builtin_ia32_vfnmsubph256_maskz ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C,
       (__mmask16)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_ph (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmsubph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) -1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fnmsub_ph (__m128h __A, __mmask8 __U, __m128h __B,
        __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmsubph128_mask ((__v8hf) __A,
             (__v8hf) __B,
             (__v8hf) __C,
             (__mmask8) __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fnmsub_ph (__m128h __A, __m128h __B, __m128h __C,
         __mmask8 __U)
{
  return (__m128h) __builtin_ia32_vfnmsubph128_mask3 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fnmsub_ph (__mmask8 __U, __m128h __A, __m128h __B,
         __m128h __C)
{
  return (__m128h) __builtin_ia32_vfnmsubph128_maskz ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C,
       (__mmask8)
       __U);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_pch (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmaddcph128 ((__v8hf) __A,
      (__v8hf) __B,
      (__v8hf) __C);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmadd_pch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
    __builtin_ia32_vfmaddcph128_mask ((__v8hf) __A,
          (__v8hf) __C,
          (__v8hf) __D, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fmadd_pch (__m128h __A, __m128h __B, __m128h __C, __mmask8 __D)
{
  return (__m128h)
    __builtin_ia32_vfmaddcph128_mask3 ((__v8hf) __A,
           (__v8hf) __B,
           (__v8hf) __C, __D);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmadd_pch (__mmask8 __A, __m128h __B, __m128h __C, __m128h __D)
{
  return (__m128h) __builtin_ia32_vfmaddcph128_maskz ((__v8hf) __B,
            (__v8hf) __C,
            (__v8hf) __D, __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmadd_pch (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmaddcph256 ((__v16hf) __A,
      (__v16hf) __B,
      (__v16hf) __C);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmadd_pch (__m256h __A, __mmask8 __B, __m256h __C, __m256h __D)
{
  return (__m256h)
     __builtin_ia32_vfmaddcph256_mask ((__v16hf) __A,
           (__v16hf) __C,
           (__v16hf) __D, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fmadd_pch (__m256h __A, __m256h __B, __m256h __C, __mmask8 __D)
{
  return (__m256h)
    __builtin_ia32_vfmaddcph256_mask3 ((__v16hf) __A,
           (__v16hf) __B,
           (__v16hf) __C, __D);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmadd_pch (__mmask8 __A, __m256h __B, __m256h __C, __m256h __D)
{
  return (__m256h)__builtin_ia32_vfmaddcph256_maskz ((__v16hf) __B,
           (__v16hf) __C,
           (__v16hf) __D, __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fcmadd_pch (__m128h __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfcmaddcph128 ((__v8hf) __A,
       (__v8hf) __B,
       (__v8hf) __C);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fcmadd_pch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h)
     __builtin_ia32_vfcmaddcph128_mask ((__v8hf) __A,
     (__v8hf) __C,
     (__v8hf) __D, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask3_fcmadd_pch (__m128h __A, __m128h __B, __m128h __C, __mmask8 __D)
{
  return (__m128h)
    __builtin_ia32_vfcmaddcph128_mask3 ((__v8hf) __A,
     (__v8hf) __B,
     (__v8hf) __C, __D);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fcmadd_pch (__mmask8 __A, __m128h __B, __m128h __C, __m128h __D)
{
  return (__m128h)__builtin_ia32_vfcmaddcph128_maskz ((__v8hf) __B,
            (__v8hf) __C,
            (__v8hf) __D, __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fcmadd_pch (__m256h __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfcmaddcph256 ((__v16hf) __A,
       (__v16hf) __B,
       (__v16hf) __C);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fcmadd_pch (__m256h __A, __mmask8 __B, __m256h __C, __m256h __D)
{
  return (__m256h)
     __builtin_ia32_vfcmaddcph256_mask ((__v16hf) __A,
     (__v16hf) __C,
     (__v16hf) __D, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask3_fcmadd_pch (__m256h __A, __m256h __B, __m256h __C, __mmask8 __D)
{
  return (__m256h)
    __builtin_ia32_vfcmaddcph256_mask3 ((__v16hf) __A,
     (__v16hf) __B,
     (__v16hf) __C, __D);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fcmadd_pch (__mmask8 __A, __m256h __B, __m256h __C, __m256h __D)
{
  return (__m256h) __builtin_ia32_vfcmaddcph256_maskz ((__v16hf) __B,
             (__v16hf) __C,
             (__v16hf) __D, __A);
}


extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmul_pch (__m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfmulcph128 ((__v8hf) __A, (__v8hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fmul_pch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h) __builtin_ia32_vfmulcph128_mask ((__v8hf) __C,
          (__v8hf) __D,
          (__v8hf) __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fmul_pch (__mmask8 __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfmulcph128_mask ((__v8hf) __B,
          (__v8hf) __C,
          _mm_setzero_ph (),
          __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmul_pch (__m256h __A, __m256h __B)
{
  return (__m256h) __builtin_ia32_vfmulcph256 ((__v16hf) __A,
            (__v16hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fmul_pch (__m256h __A, __mmask8 __B, __m256h __C, __m256h __D)
{
  return (__m256h) __builtin_ia32_vfmulcph256_mask ((__v16hf) __C,
          (__v16hf) __D,
          (__v16hf) __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fmul_pch (__mmask8 __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfmulcph256_mask ((__v16hf) __B,
          (__v16hf) __C,
          _mm256_setzero_ph (),
          __A);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_fcmul_pch (__m128h __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_vfcmulcph128 ((__v8hf) __A,
      (__v8hf) __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_fcmul_pch (__m128h __A, __mmask8 __B, __m128h __C, __m128h __D)
{
  return (__m128h) __builtin_ia32_vfcmulcph128_mask ((__v8hf) __C,
           (__v8hf) __D,
           (__v8hf) __A, __B);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_fcmul_pch (__mmask8 __A, __m128h __B, __m128h __C)
{
  return (__m128h) __builtin_ia32_vfcmulcph128_mask ((__v8hf) __B,
           (__v8hf) __C,
           _mm_setzero_ph (),
           __A);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fcmul_pch (__m256h __A, __m256h __B)
{
  return (__m256h) __builtin_ia32_vfcmulcph256 ((__v16hf) __A, (__v16hf) __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_fcmul_pch (__m256h __A, __mmask8 __B, __m256h __C, __m256h __D)
{
  return (__m256h) __builtin_ia32_vfcmulcph256_mask ((__v16hf) __C,
           (__v16hf) __D,
           (__v16hf) __A, __B);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_fcmul_pch (__mmask8 __A, __m256h __B, __m256h __C)
{
  return (__m256h) __builtin_ia32_vfcmulcph256_mask ((__v16hf) __B,
           (__v16hf) __C,
           _mm256_setzero_ph (),
           __A);
}
# 3159 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_reduce_add_ph (__m256h __A)
{
  __m128h __T1 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(0))); __m128h __T2 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(1))); __m128h __T3 = (__T1 + __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T5 = (__T3) + (__T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T7 = __T5 + __T6; return __T7[0] + __T7[1];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_reduce_mul_ph (__m256h __A)
{
  __m128h __T1 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(0))); __m128h __T2 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(1))); __m128h __T3 = (__T1 * __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T5 = (__T3) * (__T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T7 = __T5 * __T6; return __T7[0] * __T7[1];
}
# 3187 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_reduce_min_ph (__m256h __A)
{
  __m128h __T1 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(0))); __m128h __T2 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(1))); __m128h __T3 = _mm_min_ph (__T1, __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T5 = _mm_min_ph (__T3, __T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 4, 5 }); __m128h __T7 = _mm_min_ph (__T5, __T6); __m128h __T8 = (__m128h) __builtin_shuffle (__T7, (__v8hi) { 1, 0 }); __m128h __T9 = _mm_min_ph (__T7, __T8); return __T9[0];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_reduce_max_ph (__m256h __A)
{
  __m128h __T1 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(0))); __m128h __T2 = (__m128h) ((__m128d) __builtin_ia32_vextractf128_pd256 ((__v4df)(__m256d)((__m256d) __A), (int)(1))); __m128h __T3 = _mm_max_ph (__T1, __T2); __m128h __T4 = (__m128h) __builtin_shuffle (__T3, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T5 = _mm_max_ph (__T3, __T4); __m128h __T6 = (__m128h) __builtin_shuffle (__T5, (__v8hi) { 4, 5 }); __m128h __T7 = _mm_max_ph (__T5, __T6); __m128h __T8 = (__m128h) __builtin_shuffle (__T7, (__v8hi) { 1, 0 }); __m128h __T9 = _mm_max_ph (__T7, __T8); return __T9[0];
}
# 3210 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_reduce_add_ph (__m128h __A)
{
  __m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T2 = (__A) + (__T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T4 = __T2 + __T3; return __T4[0] + __T4[1];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_reduce_mul_ph (__m128h __A)
{
  __m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 4, 5, 6, 7, 0, 1, 2, 3 }); __m128h __T2 = (__A) * (__T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 2, 3, 0, 1, 4, 5, 6, 7 }); __m128h __T4 = __T2 * __T3; return __T4[0] * __T4[1];
}
# 3235 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_reduce_min_ph (__m128h __A)
{
  __m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T2 = _mm_min_ph (__A, __T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 4, 5 }); __m128h __T4 = _mm_min_ph (__T2, __T3); __m128h __T5 = (__m128h) __builtin_shuffle (__T4, (__v8hi){ 1, 0 }); __m128h __T6 = _mm_min_ph (__T4, __T5); return __T6[0];
}

extern __inline _Float16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_reduce_max_ph (__m128h __A)
{
  __m128h __T1 = (__m128h) __builtin_shuffle (__A, (__v8hi) { 2, 3, 0, 1, 6, 7, 4, 5 }); __m128h __T2 = _mm_max_ph (__A, __T1); __m128h __T3 = (__m128h) __builtin_shuffle (__T2, (__v8hi){ 4, 5 }); __m128h __T4 = _mm_max_ph (__T2, __T3); __m128h __T5 = (__m128h) __builtin_shuffle (__T4, (__v8hi){ 1, 0 }); __m128h __T6 = _mm_max_ph (__T4, __T5); return __T6[0];
}




extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_blend_ph (__mmask16 __U, __m256h __A, __m256h __W)
{
  return (__m256h) __builtin_ia32_movdquhi256_mask ((__v16hi) __W,
          (__v16hi) __A,
          (__mmask16) __U);

}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutex2var_ph (__m256h __A, __m256i __I, __m256h __B)
{
  return (__m256h) __builtin_ia32_vpermi2varhi256_mask ((__v16hi) __A,
             (__v16hi) __I,
             (__v16hi) __B,
             (__mmask16)-1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_permutexvar_ph (__m256i __A, __m256h __B)
{
  return (__m256h) __builtin_ia32_permvarhi256_mask ((__v16hi) __B,
           (__v16hi) __A,
           (__v16hi)
           (_mm256_setzero_ph ()),
           (__mmask16)-1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_blend_ph (__mmask8 __U, __m128h __A, __m128h __W)
{
  return (__m128h) __builtin_ia32_movdquhi128_mask ((__v8hi) __W,
          (__v8hi) __A,
          (__mmask8) __U);

}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutex2var_ph (__m128h __A, __m128i __I, __m128h __B)
{
  return (__m128h) __builtin_ia32_vpermi2varhi128_mask ((__v8hi) __A,
             (__v8hi) __I,
             (__v8hi) __B,
             (__mmask8)-1);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_permutexvar_ph (__m128i __A, __m128h __B)
{
  return (__m128h) __builtin_ia32_permvarhi128_mask ((__v8hi) __B,
           (__v8hi) __A,
           (__v8hi)
           (_mm_setzero_ph ()),
           (__mmask8)-1);
}

extern __inline __m256h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_set1_pch (_Float16 _Complex __A)
{
  union
  {
    _Float16 _Complex __a;
    float __b;
  } __u = { .__a = __A };

  return (__m256h) _mm256_set1_ps (__u.__b);
}

extern __inline __m128h
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pch (_Float16 _Complex __A)
{
  union
  {
    _Float16 _Complex __a;
    float __b;
  } __u = { .__a = __A };

  return (__m128h) _mm_set1_ps (__u.__b);
}
# 3359 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512fp16vlintrin.h" 3 4
#pragma GCC pop_options
# 101 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/shaintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/shaintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("sha")



extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha1msg1_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_sha1msg1 ((__v4si) __A, (__v4si) __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha1msg2_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_sha1msg2 ((__v4si) __A, (__v4si) __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha1nexte_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_sha1nexte ((__v4si) __A, (__v4si) __B);
}
# 71 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/shaintrin.h" 3 4
extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha256msg1_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_sha256msg1 ((__v4si) __A, (__v4si) __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha256msg2_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_sha256msg2 ((__v4si) __A, (__v4si) __B);
}

extern __inline __m128i
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_sha256rnds2_epu32 (__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_sha256rnds2 ((__v4si) __A, (__v4si) __B,
            (__v4si) __C);
}



#pragma GCC pop_options
# 104 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/fmaintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/fmaintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("fma")



extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd ((__v2df)__A, (__v2df)__B,
                                           (__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmadd_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256 ((__v4df)__A, (__v4df)__B,
                                              (__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps ((__v4sf)__A, (__v4sf)__B,
                                          (__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmadd_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256 ((__v8sf)__A, (__v8sf)__B,
                                             (__v8sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_sd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsd3 ((__v2df)__A, (__v2df)__B,
                                             (__v2df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmadd_ss (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddss3 ((__v4sf)__A, (__v4sf)__B,
                                            (__v4sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubpd ((__v2df)__A, (__v2df)__B,
                                           (__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsub_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubpd256 ((__v4df)__A, (__v4df)__B,
                                              (__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubps ((__v4sf)__A, (__v4sf)__B,
                                          (__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsub_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubps256 ((__v8sf)__A, (__v8sf)__B,
                                             (__v8sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_sd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubsd3 ((__v2df)__A, (__v2df)__B,
                                            (__v2df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsub_ss (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubss3 ((__v4sf)__A, (__v4sf)__B,
                                           (__v4sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddpd ((__v2df)__A, (__v2df)__B,
         (__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmadd_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmaddpd256 ((__v4df)__A, (__v4df)__B,
            (__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddps ((__v4sf)__A, (__v4sf)__B,
        (__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmadd_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmaddps256 ((__v8sf)__A, (__v8sf)__B,
           (__v8sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_sd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddsd3 ((__v2df)__A, (__v2df)__B,
          (__v2df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmadd_ss (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddss3 ((__v4sf)__A, (__v4sf)__B,
         (__v4sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubpd ((__v2df)__A, (__v2df)__B,
         (__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmsub_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmsubpd256 ((__v4df)__A, (__v4df)__B,
            (__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubps ((__v4sf)__A, (__v4sf)__B,
        (__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fnmsub_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmsubps256 ((__v8sf)__A, (__v8sf)__B,
           (__v8sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_sd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubsd3 ((__v2df)__A, (__v2df)__B,
          (__v2df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fnmsub_ss (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubss3 ((__v4sf)__A, (__v4sf)__B,
         (__v4sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmaddsub_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd ((__v2df)__A, (__v2df)__B,
                                              (__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmaddsub_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256 ((__v4df)__A,
                                                 (__v4df)__B,
                                                 (__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmaddsub_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps ((__v4sf)__A, (__v4sf)__B,
                                             (__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmaddsub_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256 ((__v8sf)__A,
                                                (__v8sf)__B,
                                                (__v8sf)__C);
}

extern __inline __m128d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsubadd_pd (__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd ((__v2df)__A, (__v2df)__B,
                                              -(__v2df)__C);
}

extern __inline __m256d
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsubadd_pd (__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256 ((__v4df)__A,
                                                 (__v4df)__B,
                                                 -(__v4df)__C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_fmsubadd_ps (__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps ((__v4sf)__A, (__v4sf)__B,
                                             -(__v4sf)__C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_fmsubadd_ps (__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256 ((__v8sf)__A,
                                                (__v8sf)__B,
                                                -(__v8sf)__C);
}



#pragma GCC pop_options
# 106 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/f16cintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/f16cintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("f16c")



extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_cvtsh_ss (unsigned short __S)
{
  __v8hi __H = __extension__ (__v8hi){ (short) __S, 0, 0, 0, 0, 0, 0, 0 };
  __v4sf __A = __builtin_ia32_vcvtph2ps (__H);
  return __builtin_ia32_vec_ext_v4sf (__A, 0);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtph_ps (__m128i __A)
{
  return (__m128) __builtin_ia32_vcvtph2ps ((__v8hi) __A);
}

extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtph_ps (__m128i __A)
{
  return (__m256) __builtin_ia32_vcvtph2ps256 ((__v8hi) __A);
}
# 95 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/f16cintrin.h" 3 4
#pragma GCC pop_options
# 108 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/rtmintrin.h" 1 3 4
# 110 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("gfni,sse2")



extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_gf2p8mul_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_vgf2p8mulb_v16qi((__v16qi) __A,
         (__v16qi) __B);
}
# 73 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("gfni,avx")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_gf2p8mul_epi8 (__m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_vgf2p8mulb_v32qi ((__v32qi) __A,
          (__v32qi) __B);
}
# 119 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("gfni,avx512vl")



extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_gf2p8mul_epi8 (__m128i __A, __mmask16 __B, __m128i __C, __m128i __D)
{
  return (__m128i) __builtin_ia32_vgf2p8mulb_v16qi_mask ((__v16qi) __C,
        (__v16qi) __D,
        (__v16qi)__A, __B);
}

extern __inline __m128i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_gf2p8mul_epi8 (__mmask16 __A, __m128i __B, __m128i __C)
{
  return (__m128i) __builtin_ia32_vgf2p8mulb_v16qi_mask ((__v16qi) __B,
   (__v16qi) __C, (__v16qi) _mm_setzero_si128 (), __A);
}
# 207 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("gfni,avx512vl,avx512bw")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_gf2p8mul_epi8 (__m256i __A, __mmask32 __B, __m256i __C,
      __m256i __D)
{
  return (__m256i) __builtin_ia32_vgf2p8mulb_v32qi_mask ((__v32qi) __C,
        (__v32qi) __D,
        (__v32qi)__A, __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_gf2p8mul_epi8 (__mmask32 __A, __m256i __B, __m256i __C)
{
  return (__m256i) __builtin_ia32_vgf2p8mulb_v32qi_mask ((__v32qi) __B,
   (__v32qi) __C, (__v32qi) _mm256_setzero_si256 (), __A);
}
# 297 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("gfni,avx512f,avx512bw")



extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_gf2p8mul_epi8 (__m512i __A, __mmask64 __B, __m512i __C,
      __m512i __D)
{
  return (__m512i) __builtin_ia32_vgf2p8mulb_v64qi_mask ((__v64qi) __C,
     (__v64qi) __D, (__v64qi)__A, __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_gf2p8mul_epi8 (__mmask64 __A, __m512i __B, __m512i __C)
{
  return (__m512i) __builtin_ia32_vgf2p8mulb_v64qi_mask ((__v64qi) __B,
   (__v64qi) __C, (__v64qi) _mm512_setzero_si512 (), __A);
}
extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_gf2p8mul_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_vgf2p8mulb_v64qi ((__v64qi) __A,
          (__v64qi) __B);
}
# 411 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/gfniintrin.h" 3 4
#pragma GCC pop_options
# 112 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vaesintrin.h" 1 3 4
# 28 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vaesintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("vaes,avx")



extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_aesdec_epi128 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_vaesdec_v32qi ((__v32qi) __A, (__v32qi) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_aesdeclast_epi128 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_vaesdeclast_v32qi ((__v32qi) __A,
        (__v32qi) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_aesenc_epi128 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_vaesenc_v32qi ((__v32qi) __A, (__v32qi) __B);
}

extern __inline __m256i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_aesenclast_epi128 (__m256i __A, __m256i __B)
{
  return (__m256i)__builtin_ia32_vaesenclast_v32qi ((__v32qi) __A,
        (__v32qi) __B);
}



#pragma GCC pop_options




#pragma GCC push_options
#pragma GCC target("vaes,avx512f")




extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_aesdec_epi128 (__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_vaesdec_v64qi ((__v64qi) __A, (__v64qi) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_aesdeclast_epi128 (__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_vaesdeclast_v64qi ((__v64qi) __A,
          (__v64qi) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_aesenc_epi128 (__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_vaesenc_v64qi ((__v64qi) __A, (__v64qi) __B);
}

extern __inline __m512i
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_aesenclast_epi128 (__m512i __A, __m512i __B)
{
  return (__m512i)__builtin_ia32_vaesenclast_v64qi ((__v64qi) __A,
          (__v64qi) __B);
}



#pragma GCC pop_options
# 114 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vpclmulqdqintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vpclmulqdqintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("vpclmulqdq,avx512f")
# 53 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vpclmulqdqintrin.h" 3 4
#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("vpclmulqdq,avx")
# 78 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/vpclmulqdqintrin.h" 3 4
#pragma GCC pop_options
# 116 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bf16vlintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bf16vlintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512bf16,avx512vl")




typedef short __v16bh __attribute__ ((__vector_size__ (32)));
typedef short __v8bh __attribute__ ((__vector_size__ (16)));



typedef short __m256bh __attribute__ ((__vector_size__ (32), __may_alias__));
typedef short __m128bh __attribute__ ((__vector_size__ (16), __may_alias__));

typedef unsigned short __bfloat16;


extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtne2ps_pbh (__m256 __A, __m256 __B)
{
  return (__m256bh)__builtin_ia32_cvtne2ps2bf16_v16hi(__A, __B);
}

extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtne2ps_pbh (__m256bh __A, __mmask16 __B, __m256 __C, __m256 __D)
{
  return (__m256bh)__builtin_ia32_cvtne2ps2bf16_v16hi_mask(__C, __D, __A, __B);
}

extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtne2ps_pbh (__mmask16 __A, __m256 __B, __m256 __C)
{
  return (__m256bh)__builtin_ia32_cvtne2ps2bf16_v16hi_maskz(__B, __C, __A);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtne2ps_pbh (__m128 __A, __m128 __B)
{
  return (__m128bh)__builtin_ia32_cvtne2ps2bf16_v8hi(__A, __B);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtne2ps_pbh (__m128bh __A, __mmask8 __B, __m128 __C, __m128 __D)
{
  return (__m128bh)__builtin_ia32_cvtne2ps2bf16_v8hi_mask(__C, __D, __A, __B);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtne2ps_pbh (__mmask8 __A, __m128 __B, __m128 __C)
{
  return (__m128bh)__builtin_ia32_cvtne2ps2bf16_v8hi_maskz(__B, __C, __A);
}



extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtneps_pbh (__m256 __A)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v8sf(__A);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtneps_pbh (__m128bh __A, __mmask8 __B, __m256 __C)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v8sf_mask(__C, __A, __B);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtneps_pbh (__mmask8 __A, __m256 __B)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v8sf_maskz(__B, __A);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtneps_pbh (__m128 __A)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v4sf(__A);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtneps_pbh (__m128bh __A, __mmask8 __B, __m128 __C)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v4sf_mask(__C, __A, __B);
}

extern __inline __m128bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtneps_pbh (__mmask8 __A, __m128 __B)
{
  return (__m128bh)__builtin_ia32_cvtneps2bf16_v4sf_maskz(__B, __A);
}



extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_dpbf16_ps (__m256 __A, __m256bh __B, __m256bh __C)
{
  return (__m256)__builtin_ia32_dpbf16ps_v8sf(__A, __B, __C);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_dpbf16_ps (__m256 __A, __mmask8 __B, __m256bh __C, __m256bh __D)
{
  return (__m256)__builtin_ia32_dpbf16ps_v8sf_mask(__A, __C, __D, __B);
}

extern __inline __m256
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_dpbf16_ps (__mmask8 __A, __m256 __B, __m256bh __C, __m256bh __D)
{
  return (__m256)__builtin_ia32_dpbf16ps_v8sf_maskz(__B, __C, __D, __A);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_dpbf16_ps (__m128 __A, __m128bh __B, __m128bh __C)
{
  return (__m128)__builtin_ia32_dpbf16ps_v4sf(__A, __B, __C);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_dpbf16_ps (__m128 __A, __mmask8 __B, __m128bh __C, __m128bh __D)
{
  return (__m128)__builtin_ia32_dpbf16ps_v4sf_mask(__A, __C, __D, __B);
}

extern __inline __m128
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_dpbf16_ps (__mmask8 __A, __m128 __B, __m128bh __C, __m128bh __D)
{
  return (__m128)__builtin_ia32_dpbf16ps_v4sf_maskz(__B, __C, __D, __A);
}

extern __inline __bfloat16
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtness_sbh (float __A)
{
  __v4sf __V = {__A, 0, 0, 0};
  __v8hi __R = __builtin_ia32_cvtneps2bf16_v4sf_mask ((__v4sf)__V,
        (__v8hi)_mm_undefined_si128 (), (__mmask8)-1);
  return __R[0];
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpbh_ps (__m128bh __A)
{
  return (__m128)_mm_castsi128_ps ((__m128i)_mm_slli_epi32 (
  (__m128i)_mm_cvtepi16_epi32 ((__m128i)__A), 16));
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_cvtpbh_ps (__m128bh __A)
{
  return (__m256)_mm256_castsi256_ps ((__m256i)_mm256_slli_epi32 (
  (__m256i)_mm256_cvtepi16_epi32 ((__m128i)__A), 16));
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskz_cvtpbh_ps (__mmask8 __U, __m128bh __A)
{
  return (__m128)_mm_castsi128_ps ((__m128i)_mm_slli_epi32 (
  (__m128i)_mm_maskz_cvtepi16_epi32 (
  (__mmask8)__U, (__m128i)__A), 16));
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_maskz_cvtpbh_ps (__mmask8 __U, __m128bh __A)
{
  return (__m256)_mm256_castsi256_ps ((__m256i)_mm256_slli_epi32 (
  (__m256i)_mm256_maskz_cvtepi16_epi32 (
  (__mmask8)__U, (__m128i)__A), 16));
}

extern __inline __m128
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_mask_cvtpbh_ps (__m128 __S, __mmask8 __U, __m128bh __A)
{
  return (__m128)_mm_castsi128_ps ((__m128i)((__m128i)__builtin_ia32_pslldi128_mask ((__v4si)(__m128i)((__m128i)_mm_cvtepi16_epi32 ( (__m128i)__A)), (int)(16), (__v4si)(__m128i)((__m128i)__S), (__mmask8)((__mmask8)__U)))

                    );
}

extern __inline __m256
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm256_mask_cvtpbh_ps (__m256 __S, __mmask8 __U, __m128bh __A)
{
  return (__m256)_mm256_castsi256_ps ((__m256i)((__m256i)__builtin_ia32_pslldi256_mask ((__v8si)(__m256i)((__m256i)_mm256_cvtepi16_epi32 ( (__m128i)__A)), (int)(16), (__v8si)(__m256i)((__m256i)__S), (__mmask8)((__mmask8)__U)))

                    );
}



#pragma GCC pop_options
# 118 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bf16intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/avx512bf16intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("avx512bf16")




typedef short __v32bh __attribute__ ((__vector_size__ (64)));



typedef short __m512bh __attribute__ ((__vector_size__ (64), __may_alias__));


extern __inline float
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsbh_ss (__bfloat16 __A)
{
  union{ float __a; unsigned int __b;} __tmp;
  __tmp.__b = ((unsigned int)(__A)) << 16;
  return __tmp.__a;
}



extern __inline __m512bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtne2ps_pbh (__m512 __A, __m512 __B)
{
  return (__m512bh)__builtin_ia32_cvtne2ps2bf16_v32hi(__A, __B);
}

extern __inline __m512bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtne2ps_pbh (__m512bh __A, __mmask32 __B, __m512 __C, __m512 __D)
{
  return (__m512bh)__builtin_ia32_cvtne2ps2bf16_v32hi_mask(__C, __D, __A, __B);
}

extern __inline __m512bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtne2ps_pbh (__mmask32 __A, __m512 __B, __m512 __C)
{
  return (__m512bh)__builtin_ia32_cvtne2ps2bf16_v32hi_maskz(__B, __C, __A);
}



extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtneps_pbh (__m512 __A)
{
  return (__m256bh)__builtin_ia32_cvtneps2bf16_v16sf(__A);
}

extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtneps_pbh (__m256bh __A, __mmask16 __B, __m512 __C)
{
  return (__m256bh)__builtin_ia32_cvtneps2bf16_v16sf_mask(__C, __A, __B);
}

extern __inline __m256bh
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtneps_pbh (__mmask16 __A, __m512 __B)
{
  return (__m256bh)__builtin_ia32_cvtneps2bf16_v16sf_maskz(__B, __A);
}



extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_dpbf16_ps (__m512 __A, __m512bh __B, __m512bh __C)
{
  return (__m512)__builtin_ia32_dpbf16ps_v16sf(__A, __B, __C);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_dpbf16_ps (__m512 __A, __mmask16 __B, __m512bh __C, __m512bh __D)
{
  return (__m512)__builtin_ia32_dpbf16ps_v16sf_mask(__A, __C, __D, __B);
}

extern __inline __m512
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_dpbf16_ps (__mmask16 __A, __m512 __B, __m512bh __C, __m512bh __D)
{
  return (__m512)__builtin_ia32_dpbf16ps_v16sf_maskz(__B, __C, __D, __A);
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_cvtpbh_ps (__m256bh __A)
{
  return (__m512)_mm512_castsi512_ps ((__m512i)((__m512i) __builtin_ia32_pslldi512_mask ((__v16si)(__m512i)((__m512i)_mm512_cvtepi16_epi32 ((__m256i)__A)), (int)(16), (__v16si)(__m512i)_mm512_undefined_epi32 (), (__mmask16)-1))
                                                    );
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_maskz_cvtpbh_ps (__mmask16 __U, __m256bh __A)
{
  return (__m512)_mm512_castsi512_ps ((__m512i) ((__m512i) __builtin_ia32_pslldi512_mask ((__v16si)(__m512i)((__m512i)_mm512_maskz_cvtepi16_epi32 ( (__mmask16)__U, (__m256i)__A)), (int)(16), (__v16si)(__m512i)_mm512_undefined_epi32 (), (__mmask16)-1))

                                    );
}

extern __inline __m512
__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
_mm512_mask_cvtpbh_ps (__m512 __S, __mmask16 __U, __m256bh __A)
{
  return (__m512)_mm512_castsi512_ps ((__m512i)(((__m512i) __builtin_ia32_pslldi512_mask ((__v16si)(__m512i)((__m512i)_mm512_cvtepi16_epi32 ((__m256i)__A)), (int)(16), (__v16si)(__m512i)((__m512i)__S), (__mmask16)((__mmask16)__U)))

                                                    ));
}



#pragma GCC pop_options
# 120 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxtileintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxtileintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("amx-tile")




extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tile_loadconfig (const void *__config)
{
  __asm__ volatile ("ldtilecfg\t%X0" :: "m" (*((const void **)__config)));
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tile_storeconfig (void *__config)
{
  __asm__ volatile ("sttilecfg\t%X0" : "=m" (*((void **)__config)));
}

extern __inline void
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
_tile_release (void)
{
  __asm__ volatile ("tilerelease" ::);
}
# 95 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxtileintrin.h" 3 4
#pragma GCC pop_options
# 122 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxint8intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxint8intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("amx-int8")
# 58 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxint8intrin.h" 3 4
#pragma GCC pop_options
# 124 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxbf16intrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxbf16intrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("amx-bf16")
# 49 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/amxbf16intrin.h" 3 4
#pragma GCC pop_options
# 126 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/prfchwintrin.h" 1 3 4
# 31 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/prfchwintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_prefetchw (void *__P)
{
  __builtin_prefetch (__P, 1, 3 );
}
# 128 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/keylockerintrin.h" 1 3 4
# 32 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/keylockerintrin.h" 3 4
#pragma GCC push_options
#pragma GCC target("kl")




extern __inline
void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadiwkey (unsigned int __I, __m128i __A, __m128i __B, __m128i __C)
{
  __builtin_ia32_loadiwkey ((__v2di) __B, (__v2di) __C, (__v2di) __A, __I);
}

extern __inline
unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_encodekey128_u32 (unsigned int __I, __m128i __A, void * __P)
{
  return __builtin_ia32_encodekey128_u32 (__I, (__v2di)__A, __P);
}

extern __inline
unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_encodekey256_u32 (unsigned int __I, __m128i __A, __m128i __B, void * __P)
{
  return __builtin_ia32_encodekey256_u32 (__I, (__v2di)__A, (__v2di)__B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdec128kl_u8 (__m128i * __A, __m128i __B, const void * __P)
{
  return __builtin_ia32_aesdec128kl_u8 ((__v2di *) __A, (__v2di) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdec256kl_u8 (__m128i * __A, __m128i __B, const void * __P)
{
  return __builtin_ia32_aesdec256kl_u8 ((__v2di *) __A, (__v2di) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesenc128kl_u8 (__m128i * __A, __m128i __B, const void * __P)
{
  return __builtin_ia32_aesenc128kl_u8 ((__v2di *) __A, (__v2di) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesenc256kl_u8 (__m128i * __A, __m128i __B, const void * __P)
{
  return __builtin_ia32_aesenc256kl_u8 ((__v2di *) __A, (__v2di) __B, __P);
}



#pragma GCC pop_options



#pragma GCC push_options
#pragma GCC target("widekl")



extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdecwide128kl_u8(__m128i __A[8], const __m128i __B[8], const void * __P)
{
  return __builtin_ia32_aesdecwide128kl_u8 ((__v2di *) __A, (__v2di *) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesdecwide256kl_u8(__m128i __A[8], const __m128i __B[8], const void * __P)
{
  return __builtin_ia32_aesdecwide256kl_u8 ((__v2di *) __A, (__v2di *) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesencwide128kl_u8(__m128i __A[8], const __m128i __B[8], const void * __P)
{
  return __builtin_ia32_aesencwide128kl_u8 ((__v2di *) __A, (__v2di *) __B, __P);
}

extern __inline
unsigned char __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_aesencwide256kl_u8(__m128i __A[8], const __m128i __B[8], const void * __P)
{
  return __builtin_ia32_aesencwide256kl_u8 ((__v2di *) __A, (__v2di *) __B, __P);
}


#pragma GCC pop_options
# 130 "/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1/include/immintrin.h" 2 3 4
# 7 "/home/tabletel/dev/4cc/code/custom/4coder_audio.cpp" 2
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_audio.cpp"

# 15 "/home/tabletel/dev/4cc/code/custom/4coder_audio.cpp"
static u32
AtomicAddU32AndReturnOriginal(u32 volatile *Value, u32 Addend)
{

 u32 Result = __sync_fetch_and_add((long volatile*)Value, (long)Addend);
 return(Result);
}

static void
def_audio_begin_ticket_mutex(Audio_System *Crunky)
{
 u32 Ticket = AtomicAddU32AndReturnOriginal(&Crunky->ticket, 1);
 while(Ticket != Crunky->serving) {_mm_pause();}
}

static void
def_audio_end_ticket_mutex(Audio_System *Crunky)
{
 AtomicAddU32AndReturnOriginal(&Crunky->serving, 1);
}





static Audio_System def_audio_system = {};

static void
def_audio_init(void){
 block_zero((&def_audio_system), sizeof(*(&def_audio_system)));
 system_set_source_mixer(&def_audio_system, def_audio_mix_sources);
 system_set_destination_mixer(def_audio_mix_destination);
}

static void
def_audio_play_clip(Audio_Clip clip, Audio_Control *control){
 clip.control = control;
 Audio_System *Crunky = &def_audio_system;
 def_audio_begin_ticket_mutex(Crunky);
 if (Crunky->pending_clip_count < ((sizeof(Crunky->pending_clips))/(sizeof(*Crunky->pending_clips))))
 {
  Crunky->pending_clips[Crunky->pending_clip_count++] = clip;
 }
 def_audio_end_ticket_mutex(Crunky);
}

static b32
def_audio_is_playing(Audio_Control *control){
 Audio_System *Crunky = &def_audio_system;
 b32 result = (Crunky->generation - control->generation < 2);
 return(result);
}

static void
def_audio_stop(Audio_Control *control){
 Audio_System *Crunky = &def_audio_system;
 def_audio_begin_ticket_mutex(Crunky);

 Audio_Clip *clip = Crunky->playing_clips;
 for(u32 i = 0;
     i < ((sizeof(Crunky->playing_clips))/(sizeof(*Crunky->playing_clips)));
     i += 1, clip += 1){
  if (clip->control == control){
   clip->at_sample_index = clip->sample_count;
   clip->control = 0;
  }
 }
 control->loop = false;

 def_audio_end_ticket_mutex(Crunky);
}

static void
def_audio_mix_sources(void *ctx, f32 *mix_buffer, u32 sample_count){
 Audio_System *Crunky = (Audio_System*)ctx;
 def_audio_begin_ticket_mutex(Crunky);

 {
  Crunky->generation += 1;
  u32 PendIndex = 0;
  Audio_Clip *clip = Crunky->playing_clips;
  for(u32 DestIndex = 0;
      (DestIndex < ((sizeof(Crunky->playing_clips))/(sizeof(*Crunky->playing_clips)))) && (PendIndex < Crunky->pending_clip_count);
      DestIndex += 1, clip += 1)
  {
   if (clip->at_sample_index == clip->sample_count)
   {
    Audio_Control *control = clip->control;
    if (control == 0 || !control->loop){
     *clip = Crunky->pending_clips[PendIndex++];
    }
   }
  }
  Crunky->pending_clip_count = 0;
 }
 def_audio_end_ticket_mutex(Crunky);


 {
  Audio_Clip *clip = Crunky->playing_clips;
  for(u32 SoundIndex = 0;
      SoundIndex < ((sizeof(Crunky->playing_clips))/(sizeof(*Crunky->playing_clips)));
      SoundIndex += 1, clip += 1)
  {

   Audio_Control *control = clip->control;
   if (control != 0 && control->loop && clip->at_sample_index == clip->sample_count){
    clip->at_sample_index = 0;
   }
   u32 base_sample_index = clip->at_sample_index;



   u32 SamplesToMix = ((((clip->sample_count - clip->at_sample_index))<(sample_count))?((clip->sample_count - clip->at_sample_index)):(sample_count));
   clip->at_sample_index += SamplesToMix;




   f32 LeftVol = clip->channel_volume[0];
   f32 RightVol = clip->channel_volume[1];
   if(SamplesToMix && control != 0)
   {
    LeftVol *= control->channel_volume[0];
    RightVol *= control->channel_volume[1];
    control->generation = Crunky->generation;
    control->last_played_sample_index = clip->at_sample_index;
   }


   for(u32 SampleIndex = 0;
       SampleIndex < SamplesToMix;
       ++SampleIndex)
   {
    u32 src_index = 2*(base_sample_index + SampleIndex);
    f32 Left = LeftVol *(f32)clip->samples[src_index + 0];
    f32 Right = RightVol*(f32)clip->samples[src_index + 1];

    u32 dst_index = 2*SampleIndex;
    mix_buffer[dst_index + 0] += Left;
    mix_buffer[dst_index + 1] += Right;
   }
  }
 }
}

static void
def_audio_mix_destination(i16 *dst, f32 *src, u32 sample_count){
 u32 opl = sample_count*2;
 for(u32 i = 0; i < opl; i += 1){
  f32 sample = src[i];
  f32 sat_sample = (((-32768.f)>(sample))?(-32768.f):(((32767.f)<(sample))?(32767.f):(sample)));
  dst[i] = (i16)sat_sample;
 }
}







#pragma pack(push, 1)
struct wave_fmt_data
{
 u16 wFormatTag;
 u16 wChannels;
 u32 dwSamplesPerSec;
 u32 dwAvgBytesPerSec;
 u16 wBlockAlign;
 u16 wBitsPerSample;
};

struct riff_header
{
 u32 ID;
 u32 DataSize;
};
#pragma pack(pop)


static Audio_Clip
audio_clip_from_wav_data(String_Const_u8 data){
 Audio_Clip Result = {};

 if (data.size >= 4 && *(u32 *)data.str == *(u32 *)"RIFF"){


  riff_header *RootHeader = (riff_header *)data.str;

  wave_fmt_data *Format = 0;
  u32 SampleDataSize = 0;
  i16 *Samples = 0;

  u32 At = sizeof(riff_header);
  u32 LastAt = At + ((RootHeader->DataSize + 1) & ~1);
  if ((*(u32 *)(data.str + At) == *(u32 *)"WAVE") &&
      (LastAt <= data.size)){
   At += sizeof(u32);
   while (At < LastAt){
    riff_header *Header = (riff_header *)(data.str + At);
    u32 DataAt = At + sizeof(riff_header);
    u32 EndAt = DataAt + ((Header->DataSize + 1) & ~1);
    if(EndAt <= data.size)
    {
     void *Data = (data.str + DataAt);
     if(Header->ID == *(u32 *)"fmt ")
     {
      Format = (wave_fmt_data *)Data;
     }
     else if(Header->ID == *(u32 *)"data")
     {
      SampleDataSize = Header->DataSize;
      Samples = (i16 *)Data;
     }
    }

    At = EndAt;
   }
  }

  if (Format &&
      Samples &&
      (Format->wFormatTag == 1) &&
      (Format->wChannels == 2) &&
      (Format->wBitsPerSample == 16) &&
      (Format->dwSamplesPerSec == 48000)){
   for (u32 i = 0; i < 2; i += 1){
    Result.channel_volume[i] = 1.f;
   }
   Result.sample_count = SampleDataSize / (Format->wChannels*Format->wBitsPerSample/8);
   Result.samples = (i16 *)Samples;
  }
  else{

  }
 }
 else{

 }

 return(Result);
}

static Audio_Clip
audio_clip_from_wav_FILE(Arena *arena, FILE *file){
 String_Const_u8 data = data_from_file(arena, file);
 Audio_Clip result = audio_clip_from_wav_data(data);
 return(result);
}

static Audio_Clip
audio_clip_from_wav_file_name(Arena *arena, char *file_name){
 Audio_Clip result = {};
 String_Const_u8 data = {};
 FILE *file = fopen(file_name, "rb");
 if (file != 0){
  result = audio_clip_from_wav_FILE(arena, file);
  fclose(file);
 }
 return(result);
}
# 143 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 1 "/home/tabletel/dev/4cc/code/custom/4coder_search_list.cpp" 1
# 15 "/home/tabletel/dev/4cc/code/custom/4coder_search_list.cpp"
static void
def_search_list_add_path(Arena *arena, List_String_Const_u8 *list, String_Const_u8 path){
    String_Const_u8 path_copy = push_string_copy(arena, path);
    string_list_push(arena, list, path_copy);
}

static void
def_search_list_add_system_path(Arena *arena, List_String_Const_u8 *list, System_Path_Code path){
    String_Const_u8 path_string = system_get_path(arena, path);
    string_list_push(arena, list, path_string);
}




static String_Const_u8
def_search_get_full_path(Arena *arena, List_String_Const_u8 *list, String_Const_u8 relative){
    String_Const_u8 result = {};

    Temp_Memory temp = begin_temp(arena);

    u8 slash = '/';

    for (Node_String_Const_u8 *node = list->first;
         node != 0;
         node = node->next){
        String_Const_u8 full_name = {};
        full_name.size = node->string.size + 1 + relative.size;
        full_name.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(full_name.size + 1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_search_list.cpp" ":" "43" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_search_list.cpp" ":" "43" ":") - 1)))));
        block_copy(full_name.str, node->string.str, node->string.size);
        full_name.str[node->string.size] = slash;
        block_copy(full_name.str + node->string.size + 1, relative.str, relative.size);
        full_name.str[full_name.size] = 0;

        File_Attributes attribs = system_quick_file_attributes(arena, full_name);
        if (attribs.last_write_time > 0){
            result = full_name;
            break;
        }

        end_temp(temp);
    }

    return(result);
}

static FILE*
def_search_fopen(Arena *arena, List_String_Const_u8 *list, char *file_name, char *opt){
    Temp_Memory_Block block(arena);
    String_Const_u8 full_path = def_search_get_full_path(arena, list, SCu8(file_name));
    FILE *file = 0;
    if (full_path.size > 0){
        file = fopen((char*)full_path.str, opt);
    }
    return(file);
}
# 144 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp" 1
# 10 "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp"
CUSTOM_COMMAND(double_backspace, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 10, Normal)
CUSTOM_DOC("Example of history group helpers")
{






 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
 History_Group group = history_group_begin(app, buffer);
 backspace_char(app);
 backspace_char(app);
 history_group_end(group);
}



CUSTOM_COMMAND(play_with_a_counter, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 29, Normal)
CUSTOM_DOC("Example of query bar")
{
# 44 "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp"
 i32 counter = 0;

 Query_Bar_Group group(app);
 Query_Bar dumb_bar = {};
 dumb_bar.prompt = SCu8("Goes away at >= 10");
 if (!start_query_bar(app, &dumb_bar, 0)){
  return;
 }

 Query_Bar bar = {};
 bar.prompt = SCu8("Counter = ");
 bar.string = SCu8("");
 if (!start_query_bar(app, &bar, 0)){
  return;
 }

 for (;;){




  Scratch_Block scratch(app);
  bar.string = push_stringf(scratch, "%d", counter);
  if (counter >= 10){
   end_query_bar(app, &dumb_bar, 0);
  }

  User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if (in.abort){
   break;
  }

  if (match_key_code(&in.event, KeyCode_Up)){
   counter += 1;
  }
  else if (match_key_code(&in.event, KeyCode_Down)){
   counter -= 1;
  }
  else{
   leave_current_input_unhandled(app);
  }
 }
}



CUSTOM_COMMAND(display_key_codes, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 90, Normal)
CUSTOM_DOC("Example of input handling loop")
{






 Query_Bar_Group group(app);
 Query_Bar bar = {};
 bar.prompt = SCu8("KeyCode = ");
 if (!start_query_bar(app, &bar, 0)){
  return;
 }

 Key_Code code = 0;
 b32 is_dead_key = false;

 for (;;){
  Scratch_Block scratch(app);
  if (code == 0){
   bar.string = SCu8("...");
  }
  else{
   bar.string = push_stringf(scratch, "KeyCode_%s (%d)%s", key_code_name[code], code,
                             is_dead_key?" dead-key":"");
  }
  User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if (in.abort){
   break;
  }
  if (in.event.kind == InputEventKind_KeyStroke){
   code = in.event.key.code;
   is_dead_key = event_is_dead_key(&in.event);
  }
  else{



   leave_current_input_unhandled(app);
  }
 }
}



CUSTOM_COMMAND(display_text_input, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 137, Normal)
CUSTOM_DOC("Example of to_writable and leave_current_input_unhandled")
{






 Query_Bar_Group group(app);
 Query_Bar bar = {};
 bar.prompt = SCu8("Weird String: ");
 if (!start_query_bar(app, &bar, 0)){
  return;
 }

 u8 buffer[256];
 u64 size = 0;

 for (;;){
  User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if (in.abort){
   break;
  }

  String_Const_u8 in_string = to_writable(&in);
  if (in_string.size > 0){
   size = (((in_string.size)<(sizeof(buffer)))?(in_string.size):(sizeof(buffer)));
   block_copy(buffer, in_string.str, size);
   bar.string = SCu8(buffer, size);
  }
  else if (in.event.kind == InputEventKind_KeyStroke){



   leave_current_input_unhandled(app);
  }
 }
}



CUSTOM_COMMAND(string_repeat, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 179, Normal)
CUSTOM_DOC("Example of query_user_string and query_user_number")
{
 Query_Bar_Group group(app);
 Query_Bar string_bar = {};
 string_bar.prompt = SCu8("String: ");
 u8 string_buffer[((1) << 10)];
 string_bar.string.str = string_buffer;
 string_bar.string_capacity = sizeof(string_buffer);
 Query_Bar number_bar = {};
 number_bar.prompt = SCu8("Repeat Count: ");
 u8 number_buffer[((1) << 10)];
 number_bar.string.str = number_buffer;
 number_bar.string_capacity = sizeof(number_buffer);

 if (query_user_string(app, &string_bar)){
  if (string_bar.string.size > 0){
   if (query_user_number(app, &number_bar)){
    if (number_bar.string.size > 0){
     i32 repeats = (i32)string_to_integer(number_bar.string, 10);
     repeats = (((repeats)<(1000))?(repeats):(1000));
     Scratch_Block scratch(app);
     String_Const_u8 msg = push_stringf(scratch, "%.*s\n", (i32)(string_bar.string).size, (char*)(string_bar.string).str);
     for (i32 i = 0; i < repeats; i += 1){
      print_message(app, msg);
     }
    }
   }
  }
 }
}

static Audio_Control the_music_control = {};

CUSTOM_COMMAND(music_start, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 213, Normal)
CUSTOM_DOC("Starts the music.")
{
 static Audio_Clip the_music_clip = {};
 if (the_music_clip.sample_count == 0){
  Scratch_Block scratch(app);
  FILE *file = def_search_normal_fopen(scratch, "audio_test/chtulthu.wav", "rb");
  if (file != 0){
   the_music_clip = audio_clip_from_wav_FILE(&global_permanent_arena, file);
   fclose(file);
  }
 }

 if (!def_audio_is_playing(&the_music_control)){
  the_music_control.loop = true;
  the_music_control.channel_volume[0] = 1.f;
  the_music_control.channel_volume[1] = 1.f;
  def_audio_play_clip(the_music_clip, &the_music_control);
 }
}

CUSTOM_COMMAND(music_stop, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 234, Normal)
CUSTOM_DOC("Stops the music.")
{
 def_audio_stop(&the_music_control);
}

CUSTOM_COMMAND(hit_sfx, "/home/tabletel/dev/4cc/code/custom/4coder_examples.cpp", 240, Normal)
CUSTOM_DOC("Play the hit sound effect")
{
 static Audio_Clip the_hit_clip = {};
 if (the_hit_clip.sample_count == 0){
  Scratch_Block scratch(app);
  FILE *file = def_search_normal_fopen(scratch, "audio_test/hit.wav", "rb");
  if (file != 0){
   the_hit_clip = audio_clip_from_wav_FILE(&global_permanent_arena, file);
   fclose(file);
  }
 }

 static u32 index = 0;
 static Audio_Control controls[8] = {};

 Audio_Control *control = &controls[index%8];
 if (!def_audio_is_playing(control)){
  control->loop = false;
  control->channel_volume[0] = 1.f;
  control->channel_volume[1] = 1.f;
  def_audio_play_clip(the_hit_clip, control);
  index += 1;
 }
}
# 146 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2

# 1 "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" 1






CUSTOM_COMMAND(default_startup, "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp", 7, Normal)
CUSTOM_DOC("Default command for responding to a startup event")
{
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("default startup"), (u64)(sizeof("default startup") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "10" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "10" ":") - 1)));
    User_Input input = get_current_input(app);
    if (match_core_code(&input, CoreCode_Startup)){
        String_Const_u8_Array file_names = input.event.core.file_names;
        load_themes_default_folder(app);
        default_4coder_initialize(app, file_names);
        default_4coder_side_by_side_panels(app, file_names);
        b32 auto_load = def_get_config_b32(vars_save_string(SCu8((u8*)("automatically_load_project"), (u64)(sizeof("automatically_load_project") - 1))));
        if (auto_load){
            load_project(app);
        }
    }

    {
        def_audio_init();
    }

    {
        def_enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
        clear_all_layouts(app);
    }
}

CUSTOM_COMMAND(default_try_exit, "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp", 33, Normal)
CUSTOM_DOC("Default command for responding to a try-exit event")
{
    User_Input input = get_current_input(app);
    if (match_core_code(&input, CoreCode_TryExit)){
        b32 do_exit = true;
        if (!allow_immediate_close_without_checking_for_changes){
            b32 has_unsaved_changes = false;
            for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
                 buffer != 0;
                 buffer = get_buffer_next(app, buffer, Access_Always)){
                Dirty_State dirty = buffer_get_dirty_state(app, buffer);
                if ((((dirty)&(DirtyState_UnsavedChanges))!=0)){
                    has_unsaved_changes = true;
                    break;
                }
            }
            if (has_unsaved_changes){
                View_ID view = get_active_view(app, Access_Always);
                do_exit = do_4coder_close_user_check(app, view);
            }
        }
        if (do_exit){
            hard_exit(app);
        }
    }
}

static Implicit_Map_Result
default_implicit_map(Application_Links *app, String_ID lang, String_ID mode, Input_Event *event){
    Implicit_Map_Result result = {};

    View_ID view = get_this_ctx_view(app, Access_Always);

    Command_Map_ID map_id = default_get_map_id(app, view);
    Command_Binding binding = map_get_binding_recursive(&framework_mapping, map_id, event);


    result.map = 0;
    result.command = binding.custom;

    return(result);
}

CUSTOM_COMMAND(default_view_input_handler, "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp", 77, Normal)
CUSTOM_DOC("Input consumption loop for default view behavior")
{
    Scratch_Block scratch(app);
    default_input_handler_init(app, scratch);

    View_ID view = get_this_ctx_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);

    for (;;){

        User_Input input = get_next_input(app, EventPropertyGroup_Any, 0);
        if (input.abort){
            break;
        }

        Profile_Scope_Block view_input_profile ((app), SCu8((u8*)("before view input"), (u64)(sizeof("before view input") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "93" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "93" ":") - 1)));


        Event_Property event_properties = get_event_properties(&input.event);
        if (suppressing_mouse && (event_properties & EventPropertyGroup_AnyMouseEvent) != 0){
            continue;
        }


        if (implicit_map_function == 0){
            implicit_map_function = default_implicit_map;
        }
        Implicit_Map_Result map_result = implicit_map_function(app, 0, 0, &input.event);
        if (map_result.command == 0){
            leave_current_input_unhandled(app);
            continue;
        }


        default_pre_command(app, scope);
        ((view_input_profile).close_now());
        map_result.command(app);
        Profile_Scope_Block profile_block_115 ((app), SCu8((u8*)("after view input"), (u64)(sizeof("after view input") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "115" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "115" ":") - 1)));
        default_post_command(app, scope);
    }
}

static void
code_index_update_tick(Application_Links *app){
    Scratch_Block scratch(app);
    for (Buffer_Modified_Node *node = global_buffer_modified_set.first;
         node != 0;
         node = node->next){
        Temp_Memory_Block temp(scratch);
        Buffer_ID buffer_id = node->buffer;

        String_Const_u8 contents = push_whole_buffer(app, scratch, buffer_id);
        Token_Array tokens = get_token_array_from_buffer(app, buffer_id);
        if (tokens.count == 0){
            continue;
        }

        Arena arena = make_arena_system(((16) << 10));
        Code_Index_File *index = ((Code_Index_File*)linalloc_wrap_zero(linalloc_push((&arena), sizeof(Code_Index_File)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "136" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "136" ":") - 1)))));
        index->buffer = buffer_id;

        Generic_Parse_State state = {};
        generic_parse_init(app, &arena, contents, &tokens, &state);



        state.do_cpp_parse = true;
        generic_parse_full_input_breaks(index, &state, max_i32);

        code_index_lock();
        code_index_set_file(buffer_id, arena, index);
        code_index_unlock();
        buffer_clear_layout_cache(app, buffer_id);
    }

    buffer_modified_set_clear();
}

static void
default_tick(Application_Links *app, Frame_Info frame_info){



    code_index_update_tick(app);




    if (tick_all_fade_ranges(app, frame_info.animation_dt)){
        animate_in_n_milliseconds(app, 0);
    }




    {
        b32 enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
        if (enable_virtual_whitespace != def_enable_virtual_whitespace){
            def_enable_virtual_whitespace = enable_virtual_whitespace;
            clear_all_layouts(app);
        }
    }
}

static Rect_f32
default_buffer_region(Application_Links *app, View_ID view_id, Rect_f32 region){
    Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 digit_advance = metrics.decimal_digit_advance;


    region = rect_inner(region, 3.f);


    b64 showing_file_bar = false;
    if (view_get_setting(app, view_id, ViewSetting_ShowFileBar, &showing_file_bar) &&
        showing_file_bar){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        region = pair.max;
    }


    {
        Query_Bar *space[32];
        Query_Bar_Ptr_Array query_bars = {};
        query_bars.ptrs = space;
        if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
            Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, query_bars.count);
            region = pair.max;
        }
    }


    if (show_fps_hud){
        Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
        region = pair.min;
    }


    b32 show_line_number_margins = def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1))));
    if (show_line_number_margins){
        Rect_f32_Pair pair = layout_line_number_margin(app, buffer, region, digit_advance);
        region = pair.max;
    }

    return(region);
}

static void
recursive_nest_highlight(Application_Links *app, Text_Layout_ID layout_id, Range_i64 range,
                         Code_Index_Nest_Ptr_Array *array, i32 counter){
    Code_Index_Nest **ptr = array->ptrs;
    Code_Index_Nest **ptr_end = ptr + array->count;

    for (;ptr < ptr_end; ptr += 1){
        Code_Index_Nest *nest = *ptr;
        if (!nest->is_closed){
            break;
        }
        if (range.first <= nest->close.max){
            break;
        }
    }

    ARGB_Color argb = finalize_color(defcolor_text_cycle, counter);

    for (;ptr < ptr_end; ptr += 1){
        Code_Index_Nest *nest = *ptr;
        if (range.max <= nest->open.min){
            break;
        }

        paint_text_color(app, layout_id, nest->open, argb);
        if (nest->is_closed){
            paint_text_color(app, layout_id, nest->close, argb);
        }
        recursive_nest_highlight(app, layout_id, range, &nest->nest_array, counter + 1);
    }
}

static void
recursive_nest_highlight(Application_Links *app, Text_Layout_ID layout_id, Range_i64 range,
                         Code_Index_File *file){
    recursive_nest_highlight(app, layout_id, range, &file->nest_array, 0);
}

static void
default_render_buffer(Application_Links *app, View_ID view_id, Face_ID face_id,
                      Buffer_ID buffer, Text_Layout_ID text_layout_id,
                      Rect_f32 rect){
    Profile_Scope_Block profile_block_270 ((app), SCu8((u8*)("render buffer"), (u64)(sizeof("render buffer") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "270" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "270" ":") - 1)));

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);
    Rect_f32 prev_clip = draw_set_clip(app, rect);

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);


    Face_Metrics metrics = get_face_metrics(app, face_id);
    u64 cursor_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("cursor_roundness"), (u64)(sizeof("cursor_roundness") - 1))));
    f32 cursor_roundness = metrics.normal_advance*cursor_roundness_100*0.01f;
    f32 mark_thickness = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("mark_thickness"), (u64)(sizeof("mark_thickness") - 1))));


    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.tokens != 0){
        draw_cpp_token_colors(app, text_layout_id, &token_array);


        b32 use_comment_keyword = def_get_config_b32(vars_save_string(SCu8((u8*)("use_comment_keyword"), (u64)(sizeof("use_comment_keyword") - 1))));
        if (use_comment_keyword){
            Comment_Highlight_Pair pairs[] = {
                {SCu8((u8*)("NOTE"), (u64)(sizeof("NOTE") - 1)), finalize_color(defcolor_comment_pop, 0)},
                {SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), finalize_color(defcolor_comment_pop, 1)},
            };
            draw_comment_highlights(app, buffer, text_layout_id, &token_array, pairs, ((sizeof(pairs))/(sizeof(*pairs))));
        }
# 319 "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp"
    }
    else{
        paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
    }

    i64 cursor_pos = view_correct_cursor(app, view_id);
    view_correct_mark(app, view_id);


    b32 use_scope_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_scope_highlight"), (u64)(sizeof("use_scope_highlight") - 1))));
    if (use_scope_highlight){
        Color_Array colors = finalize_color_array(defcolor_back_cycle);
        draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }

    b32 use_error_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_error_highlight"), (u64)(sizeof("use_error_highlight") - 1))));
    b32 use_jump_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_jump_highlight"), (u64)(sizeof("use_jump_highlight") - 1))));
    if (use_error_highlight || use_jump_highlight){

        String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
        Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
        if (use_error_highlight){
            draw_jump_highlights(app, buffer, text_layout_id, compilation_buffer,
                                 fcolor_id(defcolor_highlight_junk));
        }


        if (use_jump_highlight){
            Buffer_ID jump_buffer = get_locked_jump_buffer(app);
            if (jump_buffer != compilation_buffer){
                draw_jump_highlights(app, buffer, text_layout_id, jump_buffer,
                                     fcolor_id(defcolor_highlight_white));
            }
        }
    }


    b32 use_paren_helper = def_get_config_b32(vars_save_string(SCu8((u8*)("use_paren_helper"), (u64)(sizeof("use_paren_helper") - 1))));
    if (use_paren_helper){
        Color_Array colors = finalize_color_array(defcolor_text_cycle);
        draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }


    b32 highlight_line_at_cursor = def_get_config_b32(vars_save_string(SCu8((u8*)("highlight_line_at_cursor"), (u64)(sizeof("highlight_line_at_cursor") - 1))));
    if (highlight_line_at_cursor && is_active_view){
        i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
        draw_line_highlight(app, text_layout_id, line_number, fcolor_id(defcolor_highlight_cursor_line));
    }


    b64 show_whitespace = false;
    view_get_setting(app, view_id, ViewSetting_ShowWhitespace, &show_whitespace);
    if (show_whitespace){
        if (token_array.tokens == 0){
            draw_whitespace_highlight(app, buffer, text_layout_id, cursor_roundness);
        }
        else{
            draw_whitespace_highlight(app, text_layout_id, &token_array, cursor_roundness);
        }
    }


    switch (fcoder_mode){
        case FCoderMode_Original:
        {
            draw_original_4coder_style_cursor_mark_highlight(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness);
        }break;
        case FCoderMode_NotepadLike:
        {
            draw_notepad_style_cursor_highlight(app, view_id, buffer, text_layout_id, cursor_roundness);
        }break;
    }


    paint_fade_ranges(app, text_layout_id, buffer);


    draw_text_layout_default(app, text_layout_id);

    draw_set_clip(app, prev_clip);
}

static Rect_f32
default_draw_query_bars(Application_Links *app, Rect_f32 region, View_ID view_id, Face_ID face_id){
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;

    Query_Bar *space[32];
    Query_Bar_Ptr_Array query_bars = {};
    query_bars.ptrs = space;
    if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
        for (i32 i = 0; i < query_bars.count; i += 1){
            Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, 1);
            draw_query_bar(app, query_bars.ptrs[i], face_id, pair.min);
            region = pair.max;
        }
    }
    return(region);
}

static void
default_render_caller(Application_Links *app, Frame_Info frame_info, View_ID view_id){
    Profile_Scope_Block profile_block_422 ((app), SCu8((u8*)("default render caller"), (u64)(sizeof("default render caller") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "422" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "422" ":") - 1)));
    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    Rect_f32 region = draw_background_and_margin(app, view_id, is_active_view);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;
    f32 digit_advance = face_metrics.decimal_digit_advance;


    b64 showing_file_bar = false;
    if (view_get_setting(app, view_id, ViewSetting_ShowFileBar, &showing_file_bar) && showing_file_bar){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        draw_file_bar(app, view_id, buffer, face_id, pair.min);
        region = pair.max;
    }

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);

    Buffer_Point_Delta_Result delta = delta_apply(app, view_id,
                                                  frame_info.animation_dt, scroll);
    if (!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position)))){
        block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
        view_set_buffer_scroll(app, view_id, scroll, SetBufferScroll_NoCursorChange);
    }
    if (delta.still_animating){
        animate_in_n_milliseconds(app, 0);
    }


    region = default_draw_query_bars(app, region, view_id, face_id);


    if (show_fps_hud){
        Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
        draw_fps_hud(app, frame_info, face_id, pair.max);
        region = pair.min;
        animate_in_n_milliseconds(app, 1000);
    }


    b32 show_line_number_margins = def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1))));
    Rect_f32 line_number_rect = {};
    if (show_line_number_margins){
        Rect_f32_Pair pair = layout_line_number_margin(app, buffer, region, digit_advance);
        line_number_rect = pair.min;
        region = pair.max;
    }


    Buffer_Point buffer_point = scroll.position;
    Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);


    if (show_line_number_margins){
        draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
    }


    default_render_buffer(app, view_id, face_id, buffer, text_layout_id, region);

    text_layout_free(app, text_layout_id);
    draw_set_clip(app, prev_clip);
}

static void
default_whole_screen_render_caller(Application_Links *app, Frame_Info frame_info){
# 512 "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp"
}

i32 default_view_adjust(Application_Links *app){


    return(0);
}

void default_buffer_name_resolution(Application_Links *app, Buffer_Name_Conflict_Entry *conflicts, i32 conflict_count){
    Profile_Scope_Block profile_block_521 ((app), SCu8((u8*)("default buffer name resolution"), (u64)(sizeof("default buffer name resolution") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "521" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "521" ":") - 1)));
    if (conflict_count > 1){

        Scratch_Block scratch(app);

        i32 *unresolved = ((i32*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i32)*(conflict_count), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "526" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "526" ":") - 1)))));
        i32 unresolved_count = conflict_count;
        for (i32 i = 0; i < conflict_count; ++i){
            unresolved[i] = i;
        }


        i32 x = 0;
        for (;;){

            ++x;
            for (i32 i = 0; i < unresolved_count; ++i){
                i32 conflict_index = unresolved[i];
                Buffer_Name_Conflict_Entry *conflict = &conflicts[conflict_index];

                u64 size = conflict->base_name.size;
                size = (((size)<(conflict->unique_name_capacity))?(size):(conflict->unique_name_capacity));
                conflict->unique_name_len_in_out = size;
                block_copy(conflict->unique_name_in_out, conflict->base_name.str, size);

                if (conflict->file_name.str != 0){
                    Temp_Memory_Block temp(scratch);
                    String_Const_u8 uniqueifier = {};

                    String_Const_u8 file_name = string_remove_last_folder(conflict->file_name);
                    if (file_name.size > 0){
                        file_name = string_chop(file_name, 1);
                        u8 *end = file_name.str + file_name.size;
                        b32 past_the_end = false;
                        for (i32 j = 0; j < x; ++j){
                            file_name = string_remove_last_folder(file_name);
                            if (j + 1 < x){
                                file_name = string_chop(file_name, 1);
                            }
                            if (file_name.size == 0){
                                if (j + 1 < x){
                                    past_the_end = true;
                                }
                                break;
                            }
                        }
                        u8 *start = file_name.str + file_name.size;

                        uniqueifier = SCu8(start, end);
                        if (past_the_end){
                            uniqueifier = push_u8_stringf(scratch, "%.*s~%d",
                                                          (i32)(uniqueifier).size, (char*)(uniqueifier).str, i);
                        }
                    }
                    else{
                        uniqueifier = push_u8_stringf(scratch, "%d", i);
                    }

                    String_u8 builder = Su8(conflict->unique_name_in_out,
                                            conflict->unique_name_len_in_out,
                                            conflict->unique_name_capacity);
                    string_append(&builder, SCu8((u8*)(" <"), (u64)(sizeof(" <") - 1)));
                    string_append(&builder, uniqueifier);
                    string_append(&builder, SCu8((u8*)(">"), (u64)(sizeof(">") - 1)));
                    conflict->unique_name_len_in_out = builder.size;
                }
            }


            b32 has_conflicts = false;
            for (i32 i = 0; i < unresolved_count; ++i){
                i32 conflict_index = unresolved[i];
                Buffer_Name_Conflict_Entry *conflict = &conflicts[conflict_index];
                String_Const_u8 conflict_name = SCu8(conflict->unique_name_in_out,
                                                     conflict->unique_name_len_in_out);

                b32 hit_conflict = false;
                if (conflict->file_name.str != 0){
                    for (i32 j = 0; j < unresolved_count; ++j){
                        if (i == j) continue;

                        i32 conflict_j_index = unresolved[j];
                        Buffer_Name_Conflict_Entry *conflict_j = &conflicts[conflict_j_index];

                        String_Const_u8 conflict_name_j = SCu8(conflict_j->unique_name_in_out,
                                                               conflict_j->unique_name_len_in_out);

                        if (string_match(conflict_name, conflict_name_j)){
                            hit_conflict = true;
                            break;
                        }
                    }
                }

                if (hit_conflict){
                    has_conflicts = true;
                }
                else{
                    --unresolved_count;
                    unresolved[i] = unresolved[unresolved_count];
                    --i;
                }
            }

            if (!has_conflicts){
                break;
            }
        }
    }
}

static void
parse_async__inner(Async_Context *actx, Buffer_ID buffer_id,
                   String_Const_u8 contents, Token_Array *tokens, i32 limit_factor){
    Application_Links *app = actx->app;
    Profile_Block profile_block_636 ((app), SCu8((u8*)("async parse"), (u64)(sizeof("async parse") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "636" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "636" ":") - 1)));

    Arena arena = make_arena_system(((16) << 10));
    Code_Index_File *index = ((Code_Index_File*)linalloc_wrap_zero(linalloc_push((&arena), sizeof(Code_Index_File)*(1), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "639" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "639" ":") - 1)))));
    index->buffer = buffer_id;

    Generic_Parse_State state = {};
    generic_parse_init(app, &arena, contents, tokens, &state);

    b32 canceled = false;

    for (;;){
        if (generic_parse_full_input_breaks(index, &state, limit_factor)){
            break;
        }
        if (async_check_canceled(actx)){
            canceled = true;
            break;
        }
    }

    if (!canceled){
        acquire_global_frame_mutex(app);
        code_index_lock();
        code_index_set_file(buffer_id, arena, index);
        code_index_unlock();
        buffer_clear_layout_cache(app, buffer_id);
        release_global_frame_mutex(app);
    }
    else{
        linalloc_clear(&arena);
    }
}

static void
do_full_lex_async__inner(Async_Context *actx, Buffer_ID buffer_id){
    Application_Links *app = actx->app;
    Profile_Scope_Block profile_block_673 ((app), SCu8((u8*)("async lex"), (u64)(sizeof("async lex") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "673" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "673" ":") - 1)));
    Scratch_Block scratch(app);

    String_Const_u8 contents = {};
    {
        Profile_Block profile_block_678 ((app), SCu8((u8*)("async lex contents (before mutex)"), (u64)(sizeof("async lex contents (before mutex)") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "678" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "678" ":") - 1)));
        acquire_global_frame_mutex(app);
        Profile_Block profile_block_680 ((app), SCu8((u8*)("async lex contents (after mutex)"), (u64)(sizeof("async lex contents (after mutex)") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "680" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "680" ":") - 1)));
        contents = push_whole_buffer(app, scratch, buffer_id);
        release_global_frame_mutex(app);
    }

    i32 limit_factor = 10000;

    Token_List list = {};
    b32 canceled = false;

    Lex_State_Cpp state = {};
    lex_full_input_cpp_init(&state, contents);
    for (;;){
        Profile_Block profile_block_693 ((app), SCu8((u8*)("async lex block"), (u64)(sizeof("async lex block") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "693" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "693" ":") - 1)));
        if (lex_full_input_cpp_breaks(scratch, &list, &state, limit_factor)){
            break;
        }
        if (async_check_canceled(actx)){
            canceled = true;
            break;
        }
    }

    if (!canceled){
        Profile_Block profile_block_704 ((app), SCu8((u8*)("async lex save results (before mutex)"), (u64)(sizeof("async lex save results (before mutex)") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "704" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "704" ":") - 1)));
        acquire_global_frame_mutex(app);
        Profile_Block profile_block_706 ((app), SCu8((u8*)("async lex save results (after mutex)"), (u64)(sizeof("async lex save results (after mutex)") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "706" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "706" ":") - 1)));
        Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
        if (scope != 0){
            Base_Allocator *allocator = managed_scope_allocator(app, scope);
            Token_Array *tokens_ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
            base_free(allocator, tokens_ptr->tokens);
            Token_Array tokens = {};
            tokens.tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(list.total_count), (SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "713" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "713" ":") - 1)))).str);
            tokens.count = list.total_count;
            tokens.max = list.total_count;
            token_fill_memory_from_list(tokens.tokens, &list);
            block_copy((tokens_ptr), (&tokens), sizeof(*(tokens_ptr)));
        }
        buffer_mark_as_modified(buffer_id);
        release_global_frame_mutex(app);
    }
}

static void
do_full_lex_async(Async_Context *actx, String_Const_u8 data){
    if (data.size == sizeof(Buffer_ID)){
        Buffer_ID buffer = *(Buffer_ID*)data.str;
        do_full_lex_async__inner(actx, buffer);
    }
}

i32 default_begin_buffer(Application_Links *app, Buffer_ID buffer_id){
    Profile_Scope_Block profile_block_733 ((app), SCu8((u8*)("begin buffer"), (u64)(sizeof("begin buffer") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "733" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "733" ":") - 1)));

    Scratch_Block scratch(app);

    b32 treat_as_code = false;
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer_id);
    if (file_name.size > 0){
        String_Const_u8 treat_as_code_string = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
        String_Const_u8_Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code_string);
        String_Const_u8 ext = string_file_extension(file_name);
        for (i32 i = 0; i < extensions.count; ++i){
            if (string_match(ext, extensions.strings[i])){

                if (string_match(ext, SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1))) ||
                    string_match(ext, SCu8((u8*)("h"), (u64)(sizeof("h") - 1))) ||
                    string_match(ext, SCu8((u8*)("c"), (u64)(sizeof("c") - 1))) ||
                    string_match(ext, SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1))) ||
                    string_match(ext, SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)))){
                    treat_as_code = true;
                }
# 806 "/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp"
                break;
            }
        }
    }

    String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
    String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

    Command_Map_ID map_id = (treat_as_code)?(code_map_id):(file_map_id);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
    *map_id_ptr = map_id;

    Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer_id);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
    *eol_setting = setting;


    b32 wrap_lines = true;
    b32 use_lexer = false;
    if (treat_as_code){
        wrap_lines = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_code_wrapping"), (u64)(sizeof("enable_code_wrapping") - 1))));
        use_lexer = true;
    }

    String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer_id);
    if (buffer_name.size > 0 && buffer_name.str[0] == '*' && buffer_name.str[buffer_name.size - 1] == '*'){
        wrap_lines = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_output_wrapping"), (u64)(sizeof("enable_output_wrapping") - 1))));
    }

    if (use_lexer){
        Profile_Block profile_block_837 ((app), SCu8((u8*)("begin buffer kick off lexer"), (u64)(sizeof("begin buffer kick off lexer") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "837" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "837" ":") - 1)));
        Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
        *lex_task_ptr = async_task_no_dep(&global_async_system, do_full_lex_async, make_data((&buffer_id), sizeof(*(&buffer_id))));
    }

    {
        b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
        *wrap_lines_ptr = wrap_lines;
    }

    if (use_lexer){
        buffer_set_layout(app, buffer_id, layout_virt_indent_index_generic);
    }
    else{
        if (treat_as_code){
            buffer_set_layout(app, buffer_id, layout_virt_indent_literal_generic);
        }
        else{
            buffer_set_layout(app, buffer_id, layout_generic);
        }
    }


    return(0);
}

i32 default_new_file(Application_Links *app, Buffer_ID buffer_id){
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_base_name(app, scratch, buffer_id);
    if (!string_match(string_postfix(file_name, 2), SCu8((u8*)(".h"), (u64)(sizeof(".h") - 1)))) {
        return(0);
    }

    List_String_Const_u8 guard_list = {};
    for (u64 i = 0; i < file_name.size; ++i){
        u8 c[2] = {};
        u64 c_size = 1;
        u8 ch = file_name.str[i];
        if ('A' <= ch && ch <= 'Z'){
            c_size = 2;
            c[0] = '_';
            c[1] = ch;
        }
        else if ('0' <= ch && ch <= '9'){
            c[0] = ch;
        }
        else if ('a' <= ch && ch <= 'z'){
            c[0] = ch - ('a' - 'A');
        }
        else{
            c[0] = '_';
        }
        String_Const_u8 part = push_string_copy(scratch, SCu8(c, c_size));
        string_list_push(scratch, &guard_list, part);
    }
    String_Const_u8 guard = string_list_flatten(scratch, guard_list);

    Date_Time date_time = system_now_date_time_universal();
    date_time = system_local_date_time_from_universal(&date_time);
    String_Const_u8 date_string = date_time_format(scratch, "month day yyyy h:mimi ampm", &date_time);

    Buffer_Insertion insert = begin_buffer_insertion_at_buffered(app, buffer_id, 0, scratch, ((16) << 10));
    insertf(&insert,
            "/* date = %.*s */\n"
            "\n",
            (i32)(date_string).size, (char*)(date_string).str);
    insertf(&insert,
            "#ifndef %.*s\n"
            "#define %.*s\n"
            "\n"
            "#endif //%.*s\n",
            (i32)(guard).size, (char*)(guard).str,
            (i32)(guard).size, (char*)(guard).str,
            (i32)(guard).size, (char*)(guard).str);
    end_buffer_insertion(&insert);

    return(0);
}

i32 default_file_save(Application_Links *app, Buffer_ID buffer_id){

    Profile_Scope_Block profile_block_918 ((app), SCu8((u8*)("default file save"), (u64)(sizeof("default file save") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "918" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "918" ":") - 1)));

    b32 auto_indent = def_get_config_b32(vars_save_string(SCu8((u8*)("automatically_indent_text_on_save"), (u64)(sizeof("automatically_indent_text_on_save") - 1))));
    b32 is_virtual = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
    if (auto_indent && is_virtual){
        auto_indent_buffer(app, buffer_id, buffer_range(app, buffer_id));
    }

    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Line_Ending_Kind *eol = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                              ;
    switch (*eol){
        case LineEndingKind_LF:
        {
            rewrite_lines_to_lf(app, buffer_id);
        }break;
        case LineEndingKind_CRLF:
        {
            rewrite_lines_to_crlf(app, buffer_id);
        }break;
    }


    return(0);
}

i32 default_buffer_edit_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range){

    Profile_Scope_Block profile_block_946 ((app), SCu8((u8*)("default edit range"), (u64)(sizeof("default edit range") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "946" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "946" ":") - 1)));

    Range_i64 old_range = Ii64(old_cursor_range.min.pos, old_cursor_range.max.pos);

    buffer_shift_fade_ranges(buffer_id, old_range.max, (new_range.max - old_range.max));

    {
        code_index_lock();
        Code_Index_File *file = code_index_get_file(buffer_id);
        if (file != 0){
            code_index_shift(file, old_range, range_size(new_range));
        }
        code_index_unlock();
    }

    i64 insert_size = range_size(new_range);
    i64 text_shift = replace_range_shift(old_range, insert_size);

    Scratch_Block scratch(app);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));

    Base_Allocator *allocator = managed_scope_allocator(app, scope);
    b32 do_full_relex = false;

    if (async_task_is_running_or_pending(&global_async_system, *lex_task_ptr)){
        async_task_cancel(app, &global_async_system, *lex_task_ptr);
        buffer_unmark_as_modified(buffer_id);
        do_full_relex = true;
        *lex_task_ptr = 0;
    }

    Token_Array *ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (ptr != 0 && ptr->tokens != 0){
        Profile_Block profile_attempt_resync ((app), SCu8((u8*)("attempt resync"), (u64)(sizeof("attempt resync") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "981" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "981" ":") - 1)));

        i64 token_index_first = token_relex_first(ptr, old_range.first, 1);
        i64 token_index_resync_guess =
            token_relex_resync(ptr, old_range.one_past_last, 16);

        if (token_index_resync_guess - token_index_first >= 4000){
            do_full_relex = true;
        }
        else{
            Token *token_first = ptr->tokens + token_index_first;
            Token *token_resync = ptr->tokens + token_index_resync_guess;

            Range_i64 relex_range = Ii64(token_first->pos, token_resync->pos + token_resync->size + text_shift);
            String_Const_u8 partial_text = push_buffer_range(app, scratch, buffer_id, relex_range);

            Token_List relex_list = lex_full_input_cpp(scratch, partial_text);
            if (relex_range.one_past_last < buffer_get_size(app, buffer_id)){
                token_drop_eof(&relex_list);
            }

            Token_Relex relex = token_relex(relex_list, relex_range.first - text_shift, ptr->tokens, token_index_first, token_index_resync_guess);

            ((profile_attempt_resync).close_now());

            if (!relex.successful_resync){
                do_full_relex = true;
            }
            else{
                Profile_Block profile_block_1010 ((app), SCu8((u8*)("apply resync"), (u64)(sizeof("apply resync") - 1)), SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "1010" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "1010" ":") - 1)));

                i64 token_index_resync = relex.first_resync_index;

                Range_i64 head = Ii64(0, token_index_first);
                Range_i64 replaced = Ii64(token_index_first, token_index_resync);
                Range_i64 tail = Ii64(token_index_resync, ptr->count);
                i64 resynced_count = (token_index_resync_guess + 1) - token_index_resync;
                i64 relexed_count = relex_list.total_count - resynced_count;
                i64 tail_shift = relexed_count - (token_index_resync - token_index_first);

                i64 new_tokens_count = ptr->count + tail_shift;
                Token *new_tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(new_tokens_count), (SCu8((u8*)("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "1022" ":"), (u64)(sizeof("/home/tabletel/dev/4cc/code/custom/4coder_default_hooks.cpp" ":" "1022" ":") - 1)))).str);

                Token *old_tokens = ptr->tokens;
                block_copy_array_shift__inner((new_tokens),(old_tokens),sizeof(*(new_tokens)),(head),(0));
                token_fill_memory_from_list(new_tokens + replaced.first, &relex_list, relexed_count);
                for (i64 i = 0, index = replaced.first; i < relexed_count; i += 1, index += 1){
                    new_tokens[index].pos += relex_range.first;
                }
                for (i64 i = tail.first; i < tail.one_past_last; i += 1){
                    old_tokens[i].pos += text_shift;
                }
                block_copy_array_shift__inner((new_tokens),(ptr->tokens),sizeof(*(new_tokens)),(tail),(tail_shift));

                base_free(allocator, ptr->tokens);

                ptr->tokens = new_tokens;
                ptr->count = new_tokens_count;
                ptr->max = new_tokens_count;

                buffer_mark_as_modified(buffer_id);
            }
        }
    }

    if (do_full_relex){
        *lex_task_ptr = async_task_no_dep(&global_async_system, do_full_lex_async,
                                          make_data((&buffer_id), sizeof(*(&buffer_id))));
    }


    return(0);
}

i32 default_end_buffer(Application_Links *app, Buffer_ID buffer_id){
    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
    if (lex_task_ptr != 0){
        async_task_cancel(app, &global_async_system, *lex_task_ptr);
    }
    buffer_unmark_as_modified(buffer_id);
    code_index_lock();
    code_index_erase_file(buffer_id);
    code_index_unlock();

    return(0);
}

static void
default_view_change_buffer(Application_Links *app, View_ID view_id,
                           Buffer_ID old_buffer_id, Buffer_ID new_buffer_id){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    Buffer_ID *prev_buffer_id = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_previous_buffer), sizeof(Buffer_ID)));
 if (prev_buffer_id != 0){
  *prev_buffer_id = old_buffer_id;
 }
}

static void
set_all_default_hooks(Application_Links *app){
    set_custom_hook((app),(HookID_BufferViewerUpdate),(Void_Func*)(default_view_adjust));

    set_custom_hook((app),(HookID_ViewEventHandler),(Void_Func*)(default_view_input_handler));
    set_custom_hook((app),(HookID_Tick),(Void_Func*)(default_tick));
    set_custom_hook((app),(HookID_RenderCaller),(Void_Func*)(default_render_caller));
    set_custom_hook((app),(HookID_WholeScreenRenderCaller),(Void_Func*)(default_whole_screen_render_caller));

    set_custom_hook((app),(HookID_DeltaRule),(Void_Func*)(fixed_time_cubic_delta));
    set_custom_hook_memory_size(app, HookID_DeltaRule,
                                delta_ctx_size(fixed_time_cubic_delta_memory_size));

    set_custom_hook((app),(HookID_BufferNameResolver),(Void_Func*)(default_buffer_name_resolution));

    set_custom_hook((app),(HookID_BeginBuffer),(Void_Func*)(default_begin_buffer));
    set_custom_hook((app),(HookID_EndBuffer),(Void_Func*)(end_buffer_close_jump_list));
    set_custom_hook((app),(HookID_NewFile),(Void_Func*)(default_new_file));
    set_custom_hook((app),(HookID_SaveFile),(Void_Func*)(default_file_save));
    set_custom_hook((app),(HookID_BufferEditRange),(Void_Func*)(default_buffer_edit_range));
    set_custom_hook((app),(HookID_BufferRegion),(Void_Func*)(default_buffer_region));
    set_custom_hook((app),(HookID_ViewChangeBuffer),(Void_Func*)(default_view_change_buffer));

    set_custom_hook((app),(HookID_Layout),(Void_Func*)(layout_unwrapped));




}
# 148 "/home/tabletel/dev/4cc/code/custom/4coder_default_include.cpp" 2
# 398 "4coder_fleury.cpp" 2
#pragma warning(disable : 4706)
#pragma warning(disable : 4456)





# 1 "4coder_fleury_ubiquitous.h" 1



enum keybinding_mode
{
 KeyBindingMode_0,
 KeyBindingMode_1,
    KeyBindingMode_2,
    KeyBindingMode_3,
    KeyBindingMode_MAX
};

static keybinding_mode GlobalKeybindingMode;
static Face_ID global_styled_title_face = 0;
static Face_ID global_styled_label_face = 0;
static Face_ID global_small_code_face = 0;
static Rect_f32 global_cursor_rect = {0};
static Rect_f32 global_last_cursor_rect = {0};
static Rect_f32 global_mark_rect = {0};
static Rect_f32 global_last_mark_rect = {0};
static b32 global_dark_mode = 1;
static b32 global_battery_saver = 0;
static View_ID global_compilation_view = 0;
static b32 global_compilation_view_expanded = 0;
static Arena permanent_arena = {};
# 406 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_audio.h" 1





static b32 F4_AudioClipIsValid(Audio_Clip clip);
static b32 F4_AudioClipIsUnloadable(Audio_Clip clip);
static void F4_RequireWAV(Application_Links *app, Audio_Clip *clip, char *filename);
# 407 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_lang.h" 1



struct F4_Index_ParseCtx;



typedef void F4_Language_IndexFile(F4_Index_ParseCtx *ctx);



typedef void F4_Language_LexInit(void *state_ptr, String_Const_u8 contents);



typedef b32 F4_Language_LexFullInput(Arena *arena, Token_List *list, void *state_ptr, u64 max);





struct F4_Index_Note;
struct F4_Language_PosContextData
{
    F4_Language_PosContextData *next;
    F4_Index_Note *relevant_note;
    Token *query_token;
    int argument_index;
};


typedef F4_Language_PosContextData * F4_Language_PosContext(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos);






typedef void F4_Language_Highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, Color_Table color_table);



struct F4_Language
{
    F4_Language *next;
    u64 hash;
    String_Const_u8 name;
    u64 lex_state_size;
    F4_Language_IndexFile *IndexFile;
    F4_Language_LexInit *LexInit;
    F4_Language_LexFullInput *LexFullInput;
    F4_Language_PosContext *PosContext;
    F4_Language_Highlight *Highlight;
};

struct F4_Language_State
{
    b32 initialized;
    Arena arena;
    F4_Language *language_table[4096];
};
# 408 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_index.h" 1





enum F4_Index_NoteKind
{
    F4_Index_NoteKind_Null,
    F4_Index_NoteKind_Scope,
    F4_Index_NoteKind_Type,
    F4_Index_NoteKind_Constant,
    F4_Index_NoteKind_Function,
    F4_Index_NoteKind_Decl,
    F4_Index_NoteKind_Macro,
    F4_Index_NoteKind_CommentTag,
    F4_Index_NoteKind_CommentToDo,
    F4_Index_NoteKind_COUNT
};

typedef u32 F4_Index_NoteFlags;
enum
{
    F4_Index_NoteFlag_Prototype = (1<<0),
    F4_Index_NoteFlag_ProductType = (1<<1),
    F4_Index_NoteFlag_SumType = (1<<2),
};

struct F4_Index_File;

struct F4_Index_Note
{
    F4_Index_Note *next;
    F4_Index_Note *prev;
    F4_Index_Note *hash_next;
 F4_Index_Note *hash_prev;
    F4_Index_Note *parent;
    F4_Index_Note *next_sibling;
    F4_Index_Note *prev_sibling;
    F4_Index_Note *first_child;
    F4_Index_Note *last_child;

    u64 hash;
    String_Const_u8 string;
    F4_Index_NoteKind kind;
    F4_Index_NoteFlags flags;
    Range_i64 range;
    F4_Index_File *file;
 int file_generation;
};

struct F4_Index_File
{
    F4_Index_File *hash_next;
    Arena arena;
    Buffer_ID buffer;
    F4_Index_Note *first_note;
    F4_Index_Note *last_note;
 int generation;
};

struct F4_Index_State
{
    System_Mutex mutex;
    Arena arena;
    F4_Index_Note *note_table[16384];
 F4_Index_Note *free_note;
    F4_Index_File *file_table[16384];
    F4_Index_File *free_file;
};

struct F4_Index_ParseCtx
{
    b32 done;
    Application_Links *app;
    F4_Index_File *file;
    String_Const_u8 string;
    Token_Array tokens;
    Token_Iterator_Array it;
    F4_Index_Note *active_parent;
};

typedef u32 F4_Index_TokenSkipFlags;
enum
{
    F4_Index_TokenSkipFlag_SkipWhitespace = (1<<0),
};

static void F4_Index_Initialize(void);
static void F4_Index_Lock(void);
static void F4_Index_Unlock(void);
static F4_Index_File *F4_Index_LookupFile(Application_Links *app, Buffer_ID buffer);
static F4_Index_File *F4_Index_LookupOrMakeFile(Application_Links *app, Buffer_ID buffer);
static void F4_Index_EraseFile(Application_Links *app, Buffer_ID id);
static void F4_Index_ClearFile(F4_Index_File *file);
static F4_Index_Note *F4_Index_LookupNote(String_Const_u8 string, F4_Index_Note *parent);
static F4_Index_Note *F4_Index_LookupNote(String_Const_u8 string);
static F4_Index_Note *F4_Index_AllocateNote(void);
static void F4_Index_InsertNote(F4_Index_ParseCtx *ctx, F4_Index_Note *note, Range_i64 name_range, F4_Index_NoteKind note_kind, F4_Index_NoteFlags note_flags);
static F4_Index_Note *F4_Index_MakeNote(F4_Index_ParseCtx *ctx, Range_i64 name_range, F4_Index_NoteKind note_kind, F4_Index_NoteFlags note_flags);
static void F4_Index_ParseFile(Application_Links *app, F4_Index_File *file, String_Const_u8 string, Token_Array tokens);
static b32 F4_Index_ParseCtx_Inc(F4_Index_ParseCtx *ctx, F4_Index_TokenSkipFlags flags);
static b32 F4_Index_RequireToken(F4_Index_ParseCtx *ctx, String_Const_u8 string, F4_Index_TokenSkipFlags flags);
static b32 F4_Index_RequireTokenKind(F4_Index_ParseCtx *ctx, Token_Base_Kind kind, Token **token_out, F4_Index_TokenSkipFlags flags);
static b32 F4_Index_RequireTokenSubKind(F4_Index_ParseCtx *ctx, int sub_kind, Token **token_out, F4_Index_TokenSkipFlags flags);
static b32 F4_Index_PeekToken(F4_Index_ParseCtx *ctx, String_Const_u8 string);
static void F4_Index_ParseComment(F4_Index_ParseCtx *ctx, Token *token);
static void F4_Index_SkipSoftTokens(F4_Index_ParseCtx *ctx, b32 preproc);
static void F4_Index_SkipOpTokens(F4_Index_ParseCtx *ctx);
static String_Const_u8 F4_Index_StringFromRange(F4_Index_ParseCtx *ctx, Range_i64 range);
static String_Const_u8 F4_Index_StringFromToken(F4_Index_ParseCtx *ctx, Token *token);
static F4_Index_Note *F4_Index_PushParent(F4_Index_ParseCtx *ctx, F4_Index_Note *new_parent);
static void F4_Index_PopParent(F4_Index_ParseCtx *ctx, F4_Index_Note *last_parent);
static void F4_Index_Tick(Application_Links *app);
# 122 "4coder_fleury_index.h"
static b32 F4_Index_ParsePattern(F4_Index_ParseCtx *ctx, char *fmt, ...);
# 409 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_colors.h" 1





CUSTOM_ID(colors, fleury_color_syntax_crap);
CUSTOM_ID(colors, fleury_color_operators);
CUSTOM_ID(colors, fleury_color_inactive_pane_overlay);
CUSTOM_ID(colors, fleury_color_inactive_pane_background);
CUSTOM_ID(colors, fleury_color_file_progress_bar);
CUSTOM_ID(colors, fleury_color_brace_highlight);
CUSTOM_ID(colors, fleury_color_brace_line);
CUSTOM_ID(colors, fleury_color_brace_annotation);
CUSTOM_ID(colors, fleury_color_index_sum_type);
CUSTOM_ID(colors, fleury_color_index_product_type);
CUSTOM_ID(colors, fleury_color_index_function);
CUSTOM_ID(colors, fleury_color_index_macro);
CUSTOM_ID(colors, fleury_color_index_constant);
CUSTOM_ID(colors, fleury_color_index_comment_tag);
CUSTOM_ID(colors, fleury_color_index_decl);
CUSTOM_ID(colors, fleury_color_cursor_macro);
CUSTOM_ID(colors, fleury_color_cursor_power_mode);
CUSTOM_ID(colors, fleury_color_cursor_inactive);
CUSTOM_ID(colors, fleury_color_plot_cycle);
CUSTOM_ID(colors, fleury_color_token_highlight);
CUSTOM_ID(colors, fleury_color_token_minor_highlight);
CUSTOM_ID(colors, fleury_color_comment_user_name);
CUSTOM_ID(colors, fleury_color_lego_grab);
CUSTOM_ID(colors, fleury_color_lego_splat);
CUSTOM_ID(colors, fleury_color_error_annotation);

static ARGB_Color F4_ARGBFromID(Color_Table table, Managed_ID id, int subindex);
static ARGB_Color F4_ARGBFromID(Color_Table table, Managed_ID id);
# 410 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_render_helpers.h" 1





enum F4_RangeHighlightKind
{
    F4_RangeHighlightKind_Whole,
    F4_RangeHighlightKind_Underline,
    F4_RangeHighlightKind_MinorUnderline,
};

struct F4_Flash
{
    b32 active;
    f32 t;

    Buffer_ID buffer;
    Range_i64 range;
    ARGB_Color color;
    f32 decay_rate;
};

static void F4_DrawTooltipRect(Application_Links *app, Rect_f32 rect);
static void F4_RenderRangeHighlight(Application_Links *app, View_ID view_id, Text_Layout_ID text_layout_id, Range_i64 range, F4_RangeHighlightKind kind, ARGB_Color color);
static void F4_PushTooltip(String_Const_u8 string, ARGB_Color color);

static void F4_PushFlash(Application_Links *app, Buffer_ID buffer, Range_i64 range, ARGB_Color color, f32 decay_rate);
static void F4_UpdateFlashes(Application_Links *app, Frame_Info info);
static void F4_RenderFlashes(Application_Links *app, View_ID view, Text_Layout_ID text_layout);
# 411 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_brace.h" 1





static void F4_Brace_RenderHighlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id, i64 pos, ARGB_Color *colors, i32 color_count);
static void F4_Brace_RenderCloseBraceAnnotation(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id, i64 pos);
static void F4_Brace_RenderLines(Application_Links *app, Buffer_ID buffer, View_ID view, Text_Layout_ID text_layout_id, i64 pos);
# 412 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_error_annotations.h" 1





static void F4_RenderErrorAnnotations(Application_Links *app, Buffer_ID buffer,
                                        Text_Layout_ID text_layout_id,
                                        Buffer_ID jump_buffer);
# 413 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_divider_comments.h" 1





static void F4_RenderDividerComments(Application_Links *app, Buffer_ID buffer, View_ID view,
                                       Text_Layout_ID text_layout_id);
# 414 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_power_mode.h" 1







struct Particle
{
    f32 x;
    f32 y;
    f32 velocity_x;
    f32 velocity_y;
    f32 decay_rate;
    ARGB_Color color;
    f32 alpha;
    f32 roundness;
    f32 scale;
    String_Const_u8 string;
    u8 chrs[1];
};

static void F4_PowerMode_SetAllow(b32 allowed);
static b32 F4_PowerMode_IsEnabled(void);
static f32 F4_PowerMode_ScreenShake(void);
static f32 F4_PowerMode_ActiveCharactersPerMinute(void);
static void F4_PowerMode_CharacterPressed(void);
static Particle *
F4_PowerMode_Particle(f32 x, f32 y, f32 velocity_x, f32 velocity_y, f32 decay_rate, ARGB_Color color,
                      f32 roundness, f32 scale, String_Const_u8 str);
static Vec2_f32 F4_PowerMode_CameraOffsetFromView(Application_Links *app, View_ID view);
static void F4_PowerMode_Spawn(Application_Links *app, View_ID view, u8 character);
static void F4_PowerMode_Tick(Application_Links *app, Frame_Info frame_info);
static void F4_PowerMode_RenderBuffer(Application_Links *app, View_ID view, Face_ID face, Frame_Info frame_info);
static void F4_PowerMode_RenderWholeScreen(Application_Links *app, Frame_Info frame_info);
# 415 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_cursor.h" 1





static void F4_Cursor_RenderEmacsStyle(Application_Links *app, View_ID view_id, b32 is_active_view,
                                         Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                         f32 roundness, f32 outline_thickness, Frame_Info frame_info);

static void F4_Cursor_RenderNotepadStyle(Application_Links *app, View_ID view_id, b32 is_active_view,
                                           Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                           f32 roundness, f32 outline_thickness, Frame_Info frame_info);
# 416 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_plot.h" 1





enum Plot2DMode
{
    Plot2DMode_Line,
    Plot2DMode_Histogram,
};

typedef struct Plot2DInfo Plot2DInfo;
struct Plot2DInfo
{

    Application_Links *app;
    Face_ID title_face_id;
    Face_ID label_face_id;


    Plot2DMode mode;
    String_Const_u8 title;
    String_Const_u8 x_axis;
    String_Const_u8 y_axis;
    Rect_f32 screen_rect;


    Rect_f32 plot_view;


    int num_bins;
    int *bins;
    Range_f32 bin_data_range;
    int bin_group_count;


    Rect_f32 last_clip;
    int color_cycle_position;
    int current_bin_group;
};

enum Plot2DStyleFlags
{
    Plot2DStyleFlags_Lines = (1<<0),
    Plot2DStyleFlags_Points = (1<<1),
};

static void Plot2DBegin(Plot2DInfo *plot);
static void Plot2DPoints(Plot2DInfo *plot, i32 style_flags, float *x_data, float *y_data, int data_count);
static void Plot2DHistogram(Plot2DInfo *plot, float *data, int data_count);
static void Plot2DEnd(Plot2DInfo *plot);
# 417 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_calc.h" 1





static void F4_CLC_Tick(Frame_Info frame_info);
static void F4_CLC_RenderCode(Application_Links *app, Buffer_ID buffer,
                                View_ID view, Text_Layout_ID text_layout_id,
                                Frame_Info frame_info, Arena *arena, char *code_buffer,
                                i64 start_char_offset);
static void F4_CLC_RenderBuffer(Application_Links *app, Buffer_ID buffer, View_ID view,
                                  Text_Layout_ID text_layout_id, Frame_Info frame_info);
static void F4_CLC_RenderComments(Application_Links *app, Buffer_ID buffer, View_ID view,
                                    Text_Layout_ID text_layout_id, Frame_Info frame_info);
# 418 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_lego.h" 1





enum F4_LegoKind
{
    F4_LegoKind_Null,
    F4_LegoKind_String,
    F4_LegoKind_Macro,
    F4_LegoKind_File,
    F4_LegoKind_COUNT
};

struct F4_Lego
{
    b32 initialized;
    F4_LegoKind kind;
    Arena arena;
    String8 string;
};

static void F4_Lego_Store(F4_Lego *lego, F4_LegoKind kind, String8 string);
# 419 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_pos_context_tooltips.h" 1






static void F4_PosContext_Render(Application_Links *app, View_ID view, Buffer_ID buffer,
                                   Text_Layout_ID text_layout_id, i64 pos);
# 420 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_code_peek.h" 1







static void F4_CodePeek_Render(Application_Links *app, View_ID view_id, Face_ID face_id,
                                 Buffer_ID buffer, Frame_Info frame_info);
# 421 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_recent_files.h" 1





static void F4_RecentFiles_RefreshView(Application_Links *app, View_ID view);
static void F4_RecentFiles_Render(Application_Links *app, View_ID view, Face_ID face);
# 422 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_bindings.h" 1





static void F4_SetAbsolutelyNecessaryBindings(Mapping *mapping);
static void F4_SetDefaultBindings(Mapping *mapping);
# 423 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_base_commands.h" 1
# 424 "4coder_fleury.cpp" 2



# 1 "4coder_fleury_hooks.h" 1
# 9 "4coder_fleury_hooks.h"
static void F4_Tick(Application_Links *app, Frame_Info frame_info);
static i32 F4_BeginBuffer(Application_Links *app, Buffer_ID buffer_id);
static void F4_Render(Application_Links *app, Frame_Info frame_info, View_ID view_id);
static Layout_Item_List F4_Layout(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width);
static void F4_WholeScreenRender(Application_Links *app, Frame_Info frame_info);
static i32 F4_BufferEditRange(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range);
static Vec2_f32 F4_DeltaRule(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data)
{
    Vec2_f32 *velocity = (Vec2_f32*)data;
    if(velocity->x == 0.f)
    {
        velocity->x = 1.f;
        velocity->y = 1.f;
    }
    Smooth_Step step_x = smooth_camera_step(pending.x, velocity->x, 80.f, 1.f/4.f);
    Smooth_Step step_y = smooth_camera_step(pending.y, velocity->y, 80.f, 1.f/4.f);
    *velocity = V2f32(step_x.v, step_y.v);
    return(V2f32(step_x.p, step_y.p));
}


static void F4_RenderBuffer(Application_Links *app, View_ID view_id, Face_ID face_id, Buffer_ID buffer, Text_Layout_ID text_layout_id, Rect_f32 rect, Frame_Info frame_info);
# 428 "4coder_fleury.cpp" 2


# 1 "4coder_fleury_ubiquitous.cpp" 1

static struct
{
    String_Const_u8 string;
    ARGB_Color color;
}
global_tooltips[32] = {0};
static int global_tooltip_count = 0;
static Arena global_frame_arena;

static String_Const_u8
StringStripBorderCharacters(String_Const_u8 string)
{
    string.str += 1;
    string.size -= 2;
    return string;
}

static f32
RandomF32(f32 low, f32 high)
{
    return low + (high - low) * (((int)rand() % 10000) / 10000.f);
}

static f32
MinimumF32(f32 a, f32 b)
{
    return a < b ? a : b;
}

static f32
MaximumF32(f32 a, f32 b)
{
    return a > b ? a : b;
}

static b32
CharIsAlpha(int c)
{
    return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
}

static b32
CharIsDigit(int c)
{
    return (c >= '0' && c <= '9');
}

static b32
CharIsSymbol(int c)
{
    return (c == '~' || c == '`' || c == '!' || c == '#' ||
            c == '$' || c == '%' || c == '^' || c == '&' ||
            c == '*' || c == '(' || c == ')' || c == '-' ||
            c == '+' || c == '=' || c == '{' || c == '}' ||
            c == '[' || c == ']' || c == ':' || c == ';' ||
            c == '<' || c == '>' || c == ',' || c == '.' ||
            c == '?' || c == '/');
}

static double
GetFirstDoubleFromBuffer(char *buffer)
{
    char number_str[256];
    int number_write_pos = 0;
    double value = 0;
    for(int i = 0; buffer[i] && number_write_pos < sizeof(number_str); ++i)
    {
        if(CharIsDigit(buffer[i]) || buffer[i] == '.' || buffer[i] == '-')
        {
            number_str[number_write_pos++] = buffer[i];
        }
        else
        {
            number_str[number_write_pos++] = 0;
            break;
        }
    }
    number_str[sizeof(number_str)-1] = 0;
    value = atof(number_str);
    return value;
}

static unsigned int CStringCRC32(char *string);
static unsigned int StringCRC32(char *string, int string_length);
static unsigned int CRC32(unsigned char *buf, int len);
static int
StringMatchCaseSensitive(char *a, int a_length, char *b, int b_length)
{
    int match = 0;
    if(a && b && a[0] && b[0] && a_length == b_length)
    {
        match = 1;
        for(int i = 0; i < a_length; ++i)
        {
            if(a[i] != b[i])
            {
                match = 0;
                break;
            }
        }
    }
    return match;
}

static unsigned int
CRC32(unsigned char *buf, int len)
{
    static unsigned int init = 0xffffffff;
    static const unsigned int crc32_table[] =
    {
        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
    };

    unsigned int crc = init;
    while(len--)
    {
        crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
        buf++;
    }
    return crc;
}

static unsigned int
StringCRC32(char *string, int string_length)
{
    unsigned int hash = CRC32((unsigned char *)string, string_length);
    return hash;
}

static unsigned int
CStringCRC32(char *string)
{
    int string_length = (int)strlen(string);
    unsigned int hash = CRC32((unsigned char *)string, string_length);
    return hash;
}

static u64
BitOffset(u64 value)
{
    u64 offset = 0;
    for(u64 i = 0; i < 64; i += 1)
    {
        if(value == ((u64)1 << i))
        {
            offset = i;
            break;
        }
    }
    return offset;
}
# 431 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_audio.cpp" 1

static b32
F4_AudioClipIsValid(Audio_Clip clip)
{
    return clip.samples != 0 && clip.samples != (i16 *)0x00000001;
}

static b32
F4_AudioClipIsUnloadable(Audio_Clip clip)
{
    return clip.samples == (i16 *)0x00000001;
}

static void
F4_RequireWAV(Application_Links *app, Audio_Clip *clip, char *filename)
{
    if(!F4_AudioClipIsValid(*clip) && !F4_AudioClipIsUnloadable(*clip))
    {
        FILE *file = def_search_normal_fopen(&permanent_arena, filename, "rb");
        if(file != 0)
        {
            *clip = audio_clip_from_wav_FILE(&permanent_arena, file);
            fclose(file);
        }
        else
        {
            clip->samples = (i16 *)0x00000001;
        }
    }
}
# 432 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_lang.cpp" 1
static F4_Language_State f4_langs = {};

static F4_Language *
F4_LanguageFromString(String_Const_u8 name)
{
    F4_Language *result = 0;
    if(f4_langs.initialized)
    {
        u64 hash = table_hash_u8(name.str, name.size);
        u64 slot = hash % ((sizeof(f4_langs.language_table))/(sizeof(*f4_langs.language_table)));
        for(F4_Language *l = f4_langs.language_table[slot]; l; l = l->next)
        {
            if(l->hash == hash && string_match(l->name, name))
            {
                result = l;
                break;
            }
        }
    }
    return result;
}



static void
_F4_RegisterLanguage(String_Const_u8 name,
                     F4_Language_IndexFile *IndexFile,
                     F4_Language_LexInit *LexInit,
                     F4_Language_LexFullInput *LexFullInput,
                     F4_Language_PosContext *PosContext,
                     F4_Language_Highlight *Highlight,
                     u64 lex_state_size)
{
    if(f4_langs.initialized == 0)
    {
        f4_langs.initialized = 1;
        f4_langs.arena = make_arena_system(((16) << 10));
    }

    F4_Language *language = 0;
    u64 hash = table_hash_u8(name.str, name.size);
    u64 slot = hash % ((sizeof(f4_langs.language_table))/(sizeof(*f4_langs.language_table)));
    for(F4_Language *l = f4_langs.language_table[slot]; l; l = l->next)
    {
        if(l->hash == hash && string_match(l->name, name))
        {
            language = l;
            break;
        }
    }

    if(language == 0)
    {
        language = ((F4_Language*)linalloc_wrap_unintialized(linalloc_push((&f4_langs.arena), sizeof(F4_Language)*(1), SCu8((u8*)("4coder_fleury_lang.cpp" ":" "54" ":"), (u64)(sizeof("4coder_fleury_lang.cpp" ":" "54" ":") - 1)))));
        language->next = f4_langs.language_table[slot];
        f4_langs.language_table[slot] = language;
        language->hash = hash;
        language->name = push_string_copy(&f4_langs.arena, name);
        language->lex_state_size = lex_state_size;
        language->IndexFile = IndexFile;
        language->LexInit = LexInit;
        language->LexFullInput = LexFullInput;
  language->PosContext = PosContext;
        language->Highlight = Highlight;
    }
}

static F4_Language *
F4_LanguageFromBuffer(Application_Links *app, Buffer_ID buffer)
{
    F4_Language *language = 0;
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    String_Const_u8 extension = string_file_extension(file_name);
    language = F4_LanguageFromString(extension);
    return language;
}

static void
F4_Language_PosContext_PushData(Arena *arena,
                                F4_Language_PosContextData **first_ptr,
                                F4_Language_PosContextData **last_ptr,
                                F4_Index_Note *note,
                                Token *query,
                                int arg_index)
{
    F4_Language_PosContextData *first = *first_ptr;
    F4_Language_PosContextData *last = *last_ptr;
    F4_Language_PosContextData *func = ((F4_Language_PosContextData*)linalloc_wrap_zero(linalloc_push((arena), sizeof(F4_Language_PosContextData)*(1), SCu8((u8*)("4coder_fleury_lang.cpp" ":" "89" ":"), (u64)(sizeof("4coder_fleury_lang.cpp" ":" "89" ":") - 1)))));
    func->relevant_note = note;
    func->query_token = query;
    func->argument_index = arg_index;
    if(last == 0)
    {
        first = last = func;
    }
    else
    {
        last->next = func;
        last = last->next;
    }
    *first_ptr = first;
    *last_ptr = last;
}

static void
F4_Language_PosContext_PushData_Call(Arena *arena,
                                     F4_Language_PosContextData **first_ptr,
                                     F4_Language_PosContextData **last_ptr,
                                     String_Const_u8 string, int param_idx)
{
    F4_Language_PosContext_PushData(arena, first_ptr, last_ptr, F4_Index_LookupNote(string, 0), 0, param_idx);
}

static void
F4_Language_PosContext_PushData_Dot(Arena *arena,
                                    F4_Language_PosContextData **first_ptr,
                                    F4_Language_PosContextData **last_ptr,
                                    String_Const_u8 string, Token *query)
{
    F4_Language_PosContext_PushData(arena, first_ptr, last_ptr, F4_Index_LookupNote(string, 0), query, 0);
}

static Token_List
F4_Language_LexFullInput_NoBreaks(Application_Links *app, F4_Language *language, Arena *arena, String_Const_u8 text)
{
    Token_List list = {};
    if(language != 0)
    {
        Scratch_Block scratch(app, arena);
        void *state = ((u8*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(u8)*(language->lex_state_size), SCu8((u8*)("4coder_fleury_lang.cpp" ":" "131" ":"), (u64)(sizeof("4coder_fleury_lang.cpp" ":" "131" ":") - 1)))));
  language->LexInit(state, text);
        language->LexFullInput(arena, &list, state, max_u64);
    }
    return list;
}

# 1 "4coder_fleury_lang_list.h" 1






# 1 "generated/4coder_fleury_lexer_jai.h" 1
# 16 "generated/4coder_fleury_lexer_jai.h"
typedef u16 Token_Jai_Kind;
enum{
TokenJaiKind_EOF = 0,
TokenJaiKind_Whitespace = 1,
TokenJaiKind_LexError = 2,
TokenJaiKind_BlockComment = 3,
TokenJaiKind_LineComment = 4,
TokenJaiKind_Backslash = 5,
TokenJaiKind_LiteralInteger = 6,
TokenJaiKind_LiteralIntegerU = 7,
TokenJaiKind_LiteralIntegerL = 8,
TokenJaiKind_LiteralIntegerUL = 9,
TokenJaiKind_LiteralIntegerLL = 10,
TokenJaiKind_LiteralIntegerULL = 11,
TokenJaiKind_LiteralIntegerHex = 12,
TokenJaiKind_LiteralIntegerHexU = 13,
TokenJaiKind_LiteralIntegerHexL = 14,
TokenJaiKind_LiteralIntegerHexUL = 15,
TokenJaiKind_LiteralIntegerHexLL = 16,
TokenJaiKind_LiteralIntegerHexULL = 17,
TokenJaiKind_LiteralIntegerOct = 18,
TokenJaiKind_LiteralIntegerOctU = 19,
TokenJaiKind_LiteralIntegerOctL = 20,
TokenJaiKind_LiteralIntegerOctUL = 21,
TokenJaiKind_LiteralIntegerOctLL = 22,
TokenJaiKind_LiteralIntegerOctULL = 23,
TokenJaiKind_LiteralFloat32 = 24,
TokenJaiKind_LiteralFloat64 = 25,
TokenJaiKind_LiteralString = 26,
TokenJaiKind_LiteralStringWide = 27,
TokenJaiKind_LiteralStringUTF8 = 28,
TokenJaiKind_LiteralStringUTF16 = 29,
TokenJaiKind_LiteralStringUTF32 = 30,
TokenJaiKind_LiteralStringRaw = 31,
TokenJaiKind_LiteralStringWideRaw = 32,
TokenJaiKind_LiteralStringUTF8Raw = 33,
TokenJaiKind_LiteralStringUTF16Raw = 34,
TokenJaiKind_LiteralStringUTF32Raw = 35,
TokenJaiKind_LiteralCharacter = 36,
TokenJaiKind_LiteralCharacterWide = 37,
TokenJaiKind_LiteralCharacterUTF8 = 38,
TokenJaiKind_LiteralCharacterUTF16 = 39,
TokenJaiKind_LiteralCharacterUTF32 = 40,
TokenJaiKind_PPIncludeFile = 41,
TokenJaiKind_PPErrorMessage = 42,
TokenJaiKind_KeywordGeneric = 43,
TokenJaiKind_BraceOp = 44,
TokenJaiKind_BraceCl = 45,
TokenJaiKind_ParenOp = 46,
TokenJaiKind_BrackOp = 47,
TokenJaiKind_ParenCl = 48,
TokenJaiKind_BrackCl = 49,
TokenJaiKind_Semicolon = 50,
TokenJaiKind_DotDotDot = 51,
TokenJaiKind_Colon = 52,
TokenJaiKind_ColonColon = 53,
TokenJaiKind_ColonEq = 54,
TokenJaiKind_Dot = 55,
TokenJaiKind_Plus = 56,
TokenJaiKind_Minus = 57,
TokenJaiKind_Not = 58,
TokenJaiKind_Tilde = 59,
TokenJaiKind_Star = 60,
TokenJaiKind_And = 61,
TokenJaiKind_DotStar = 62,
TokenJaiKind_Div = 63,
TokenJaiKind_Mod = 64,
TokenJaiKind_MinusGrtr = 65,
TokenJaiKind_EqGrtr = 66,
TokenJaiKind_DotDot = 67,
TokenJaiKind_LeftLeft = 68,
TokenJaiKind_RightRight = 69,
TokenJaiKind_Less = 70,
TokenJaiKind_LessEq = 71,
TokenJaiKind_Grtr = 72,
TokenJaiKind_GrtrEq = 73,
TokenJaiKind_EqEq = 74,
TokenJaiKind_NotEq = 75,
TokenJaiKind_Xor = 76,
TokenJaiKind_Or = 77,
TokenJaiKind_AndAnd = 78,
TokenJaiKind_OrOr = 79,
TokenJaiKind_Ternary = 80,
TokenJaiKind_Eq = 81,
TokenJaiKind_PlusEq = 82,
TokenJaiKind_MinusEq = 83,
TokenJaiKind_StarEq = 84,
TokenJaiKind_DivEq = 85,
TokenJaiKind_ModEq = 86,
TokenJaiKind_LeftLeftEq = 87,
TokenJaiKind_RightRightEq = 88,
TokenJaiKind_Comma = 89,
TokenJaiKind_AlignOf = 90,
TokenJaiKind_Operator = 91,
TokenJaiKind_Null = 92,
TokenJaiKind_Inline = 93,
TokenJaiKind_Using = 94,
TokenJaiKind_Any = 95,
TokenJaiKind_Void = 96,
TokenJaiKind_String = 97,
TokenJaiKind_Bool = 98,
TokenJaiKind_Float = 99,
TokenJaiKind_Float32 = 100,
TokenJaiKind_Float64 = 101,
TokenJaiKind_Int = 102,
TokenJaiKind_U8 = 103,
TokenJaiKind_U16 = 104,
TokenJaiKind_U32 = 105,
TokenJaiKind_U64 = 106,
TokenJaiKind_S8 = 107,
TokenJaiKind_S16 = 108,
TokenJaiKind_S32 = 109,
TokenJaiKind_S64 = 110,
TokenJaiKind_Struct = 111,
TokenJaiKind_Union = 112,
TokenJaiKind_Enum = 113,
TokenJaiKind_SizeOf = 114,
TokenJaiKind_New = 115,
TokenJaiKind_Delete = 116,
TokenJaiKind_Defer = 117,
TokenJaiKind_Autocast = 118,
TokenJaiKind_Remove = 119,
TokenJaiKind_PushContext = 120,
TokenJaiKind_Uninitialized = 121,
TokenJaiKind_It = 122,
TokenJaiKind_ItIndex = 123,
TokenJaiKind_Context = 124,
TokenJaiKind_Break = 125,
TokenJaiKind_Case = 126,
TokenJaiKind_Continue = 127,
TokenJaiKind_Default = 128,
TokenJaiKind_Do = 129,
TokenJaiKind_Else = 130,
TokenJaiKind_For = 131,
TokenJaiKind_Goto = 132,
TokenJaiKind_If = 133,
TokenJaiKind_Return = 134,
TokenJaiKind_Switch = 135,
TokenJaiKind_While = 136,
TokenJaiKind_Cast = 137,
TokenJaiKind_LiteralTrue = 138,
TokenJaiKind_LiteralFalse = 139,
TokenJaiKind_Identifier = 140,
TokenJaiKind_PPInclude = 141,
TokenJaiKind_PPVersion = 142,
TokenJaiKind_PPDefine = 143,
TokenJaiKind_PPUndef = 144,
TokenJaiKind_PPIfDef = 145,
TokenJaiKind_PPIfNDef = 146,
TokenJaiKind_PPElse = 147,
TokenJaiKind_PPElIf = 148,
TokenJaiKind_PPEndIf = 149,
TokenJaiKind_PPError = 150,
TokenJaiKind_PPUsing = 151,
TokenJaiKind_PPLine = 152,
TokenJaiKind_PPIf = 153,
TokenJaiKind_PPImport = 154,
TokenJaiKind_PPPragma = 155,
TokenJaiKind_PPLoad = 156,
TokenJaiKind_PPUnknown = 157,
TokenJaiKind_PPDefined = 158,
TokenJaiKind_COUNT = 159,
};
char *token_jai_kind_names[] = {
"EOF",
"Whitespace",
"LexError",
"BlockComment",
"LineComment",
"Backslash",
"LiteralInteger",
"LiteralIntegerU",
"LiteralIntegerL",
"LiteralIntegerUL",
"LiteralIntegerLL",
"LiteralIntegerULL",
"LiteralIntegerHex",
"LiteralIntegerHexU",
"LiteralIntegerHexL",
"LiteralIntegerHexUL",
"LiteralIntegerHexLL",
"LiteralIntegerHexULL",
"LiteralIntegerOct",
"LiteralIntegerOctU",
"LiteralIntegerOctL",
"LiteralIntegerOctUL",
"LiteralIntegerOctLL",
"LiteralIntegerOctULL",
"LiteralFloat32",
"LiteralFloat64",
"LiteralString",
"LiteralStringWide",
"LiteralStringUTF8",
"LiteralStringUTF16",
"LiteralStringUTF32",
"LiteralStringRaw",
"LiteralStringWideRaw",
"LiteralStringUTF8Raw",
"LiteralStringUTF16Raw",
"LiteralStringUTF32Raw",
"LiteralCharacter",
"LiteralCharacterWide",
"LiteralCharacterUTF8",
"LiteralCharacterUTF16",
"LiteralCharacterUTF32",
"PPIncludeFile",
"PPErrorMessage",
"KeywordGeneric",
"BraceOp",
"BraceCl",
"ParenOp",
"BrackOp",
"ParenCl",
"BrackCl",
"Semicolon",
"DotDotDot",
"Colon",
"ColonColon",
"ColonEq",
"Dot",
"Plus",
"Minus",
"Not",
"Tilde",
"Star",
"And",
"DotStar",
"Div",
"Mod",
"MinusGrtr",
"EqGrtr",
"DotDot",
"LeftLeft",
"RightRight",
"Less",
"LessEq",
"Grtr",
"GrtrEq",
"EqEq",
"NotEq",
"Xor",
"Or",
"AndAnd",
"OrOr",
"Ternary",
"Eq",
"PlusEq",
"MinusEq",
"StarEq",
"DivEq",
"ModEq",
"LeftLeftEq",
"RightRightEq",
"Comma",
"AlignOf",
"Operator",
"Null",
"Inline",
"Using",
"Any",
"Void",
"String",
"Bool",
"Float",
"Float32",
"Float64",
"Int",
"U8",
"U16",
"U32",
"U64",
"S8",
"S16",
"S32",
"S64",
"Struct",
"Union",
"Enum",
"SizeOf",
"New",
"Delete",
"Defer",
"Autocast",
"Remove",
"PushContext",
"Uninitialized",
"It",
"ItIndex",
"Context",
"Break",
"Case",
"Continue",
"Default",
"Do",
"Else",
"For",
"Goto",
"If",
"Return",
"Switch",
"While",
"Cast",
"LiteralTrue",
"LiteralFalse",
"Identifier",
"PPInclude",
"PPVersion",
"PPDefine",
"PPUndef",
"PPIfDef",
"PPIfNDef",
"PPElse",
"PPElIf",
"PPEndIf",
"PPError",
"PPUsing",
"PPLine",
"PPIf",
"PPImport",
"PPPragma",
"PPLoad",
"PPUnknown",
"PPDefined",
};
# 8 "4coder_fleury_lang_list.h" 2
# 1 "generated/4coder_fleury_lexer_jai.cpp" 1
# 46 "generated/4coder_fleury_lexer_jai.cpp"
u64 jai_main_keys_hash_array[89] = {
0xac8da306275a3d43,0x665a25aa3b756401,0x0000000000000000,0x0000000000000000,
0xb1e237e936c3447d,0xb1e237e936fa66fd,0x0000000000000000,0xb1e237e935117d87,
0xac8da306275d1653,0x975f946c0976900b,0x0000000000000000,0x0000000000000000,
0x665ad32687d670fb,0x0000000000000000,0xb87f5d1e1491cffb,0x0000000000000000,
0x0000000000000000,0xac8da306275de2c9,0x0000000000000000,0x975f946c09769443,
0xac8da306275dfe43,0xac8da30627581ad5,0xe60fd2aaa2d8fea5,0x0000000000000000,
0x975f946c0976901b,0xd6e62de8686a297b,0xe60fd2aa0eefd08f,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0x975f946c09769559,
0x0000000000000000,0x89e0a030f49fb443,0xac8da306275a56c5,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x89e361d6d477dc99,0x0000000000000000,
0x0000000000000000,0xb1e237e936ccaf47,0xb87f5d1e91f824d1,0xe60fd2aa03f48729,
0xe60fd2aa0c43a4cd,0x0000000000000000,0x0000000000000000,0x975f946c097691ef,
0xac8da306275ab1eb,0xb1e237e936fa66cf,0x0000000000000000,0xe60fd2aaa969843f,
0xac8da306275de345,0x89e3641bfff00935,0xb1e237e9350ff699,0x665ad3fbd4976631,
0x0000000000000000,0xb87f5d7ca9937091,0x665ad3517fc73f73,0xac8da306275dfe69,
0x0000000000000000,0x665ad3416b60807b,0x0000000000000000,0xe60fd2aa9f8815d7,
0xb1e237e936ec2a63,0xb1e237e936cc5ca1,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0xb87f5d1e90910b39,0xac8da306275dfe75,0xac8da306275985a1,
0xb87f5d7d250cd24d,0x0000000000000000,0x0000000000000000,0xb1e237e936f1e2c3,
0x0000000000000000,0x0000000000000000,0x975f946c0976952f,0x0000000000000000,
0x0000000000000000,0x665ad3517fc73b05,0x0000000000000000,0x0000000000000000,
0xb87f5d1e139deaef,0x0000000000000000,0xb87f5d1e1237098f,0xe60fd2aa9f34bb7d,
0x0000000000000000,
};
u8 jai_main_keys_key_array_0[] = {0x69,0x6e,0x74,};
u8 jai_main_keys_key_array_1[] = {0x73,0x69,0x7a,0x65,0x5f,0x6f,0x66,};
u8 jai_main_keys_key_array_4[] = {0x65,0x6c,0x73,0x65,};
u8 jai_main_keys_key_array_5[] = {0x63,0x61,0x73,0x65,};
u8 jai_main_keys_key_array_7[] = {0x76,0x6f,0x69,0x64,};
u8 jai_main_keys_key_array_8[] = {0x75,0x36,0x34,};
u8 jai_main_keys_key_array_9[] = {0x73,0x38,};
u8 jai_main_keys_key_array_12[] = {0x64,0x65,0x66,0x61,0x75,0x6c,0x74,};
u8 jai_main_keys_key_array_14[] = {0x73,0x77,0x69,0x74,0x63,0x68,};
u8 jai_main_keys_key_array_17[] = {0x75,0x31,0x36,};
u8 jai_main_keys_key_array_19[] = {0x64,0x6f,};
u8 jai_main_keys_key_array_20[] = {0x73,0x36,0x34,};
u8 jai_main_keys_key_array_21[] = {0x41,0x6e,0x79,};
u8 jai_main_keys_key_array_22[] = {0x64,0x65,0x66,0x65,0x72,};
u8 jai_main_keys_key_array_24[] = {0x75,0x38,};
u8 jai_main_keys_key_array_25[] = {0x70,0x75,0x73,0x68,0x5f,0x63,0x6f,0x6e,0x74,0x65,0x78,0x74,};
u8 jai_main_keys_key_array_26[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 jai_main_keys_key_array_31[] = {0x69,0x66,};
u8 jai_main_keys_key_array_33[] = {0x69,0x74,0x5f,0x69,0x6e,0x64,0x65,0x78,};
u8 jai_main_keys_key_array_34[] = {0x66,0x6f,0x72,};
u8 jai_main_keys_key_array_38[] = {0x63,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,};
u8 jai_main_keys_key_array_41[] = {0x62,0x6f,0x6f,0x6c,};
u8 jai_main_keys_key_array_42[] = {0x72,0x65,0x6d,0x6f,0x76,0x65,};
u8 jai_main_keys_key_array_43[] = {0x75,0x6e,0x69,0x6f,0x6e,};
u8 jai_main_keys_key_array_44[] = {0x77,0x68,0x69,0x6c,0x65,};
u8 jai_main_keys_key_array_47[] = {0x78,0x78,};
u8 jai_main_keys_key_array_48[] = {0x6e,0x65,0x77,};
u8 jai_main_keys_key_array_49[] = {0x63,0x61,0x73,0x74,};
u8 jai_main_keys_key_array_51[] = {0x62,0x72,0x65,0x61,0x6b,};
u8 jai_main_keys_key_array_52[] = {0x75,0x33,0x32,};
u8 jai_main_keys_key_array_53[] = {0x6f,0x70,0x65,0x72,0x61,0x74,0x6f,0x72,};
u8 jai_main_keys_key_array_54[] = {0x74,0x72,0x75,0x65,};
u8 jai_main_keys_key_array_55[] = {0x61,0x6c,0x69,0x67,0x6e,0x6f,0x66,};
u8 jai_main_keys_key_array_57[] = {0x69,0x6e,0x6c,0x69,0x6e,0x65,};
u8 jai_main_keys_key_array_58[] = {0x66,0x6c,0x6f,0x61,0x74,0x36,0x34,};
u8 jai_main_keys_key_array_59[] = {0x73,0x31,0x36,};
u8 jai_main_keys_key_array_61[] = {0x63,0x6f,0x6e,0x74,0x65,0x78,0x74,};
u8 jai_main_keys_key_array_63[] = {0x66,0x6c,0x6f,0x61,0x74,};
u8 jai_main_keys_key_array_64[] = {0x6e,0x75,0x6c,0x6c,};
u8 jai_main_keys_key_array_65[] = {0x65,0x6e,0x75,0x6d,};
u8 jai_main_keys_key_array_69[] = {0x72,0x65,0x74,0x75,0x72,0x6e,};
u8 jai_main_keys_key_array_70[] = {0x73,0x33,0x32,};
u8 jai_main_keys_key_array_71[] = {0x2d,0x2d,0x2d,};
u8 jai_main_keys_key_array_72[] = {0x64,0x65,0x6c,0x65,0x74,0x65,};
u8 jai_main_keys_key_array_75[] = {0x67,0x6f,0x74,0x6f,};
u8 jai_main_keys_key_array_78[] = {0x69,0x74,};
u8 jai_main_keys_key_array_81[] = {0x66,0x6c,0x6f,0x61,0x74,0x33,0x32,};
u8 jai_main_keys_key_array_84[] = {0x73,0x74,0x72,0x69,0x6e,0x67,};
u8 jai_main_keys_key_array_86[] = {0x73,0x74,0x72,0x75,0x63,0x74,};
u8 jai_main_keys_key_array_87[] = {0x66,0x61,0x6c,0x73,0x65,};
String_Const_u8 jai_main_keys_key_array[89] = {
{jai_main_keys_key_array_0, 3},
{jai_main_keys_key_array_1, 7},
{0, 0},
{0, 0},
{jai_main_keys_key_array_4, 4},
{jai_main_keys_key_array_5, 4},
{0, 0},
{jai_main_keys_key_array_7, 4},
{jai_main_keys_key_array_8, 3},
{jai_main_keys_key_array_9, 2},
{0, 0},
{0, 0},
{jai_main_keys_key_array_12, 7},
{0, 0},
{jai_main_keys_key_array_14, 6},
{0, 0},
{0, 0},
{jai_main_keys_key_array_17, 3},
{0, 0},
{jai_main_keys_key_array_19, 2},
{jai_main_keys_key_array_20, 3},
{jai_main_keys_key_array_21, 3},
{jai_main_keys_key_array_22, 5},
{0, 0},
{jai_main_keys_key_array_24, 2},
{jai_main_keys_key_array_25, 12},
{jai_main_keys_key_array_26, 5},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{jai_main_keys_key_array_31, 2},
{0, 0},
{jai_main_keys_key_array_33, 8},
{jai_main_keys_key_array_34, 3},
{0, 0},
{0, 0},
{0, 0},
{jai_main_keys_key_array_38, 8},
{0, 0},
{0, 0},
{jai_main_keys_key_array_41, 4},
{jai_main_keys_key_array_42, 6},
{jai_main_keys_key_array_43, 5},
{jai_main_keys_key_array_44, 5},
{0, 0},
{0, 0},
{jai_main_keys_key_array_47, 2},
{jai_main_keys_key_array_48, 3},
{jai_main_keys_key_array_49, 4},
{0, 0},
{jai_main_keys_key_array_51, 5},
{jai_main_keys_key_array_52, 3},
{jai_main_keys_key_array_53, 8},
{jai_main_keys_key_array_54, 4},
{jai_main_keys_key_array_55, 7},
{0, 0},
{jai_main_keys_key_array_57, 6},
{jai_main_keys_key_array_58, 7},
{jai_main_keys_key_array_59, 3},
{0, 0},
{jai_main_keys_key_array_61, 7},
{0, 0},
{jai_main_keys_key_array_63, 5},
{jai_main_keys_key_array_64, 4},
{jai_main_keys_key_array_65, 4},
{0, 0},
{0, 0},
{0, 0},
{jai_main_keys_key_array_69, 6},
{jai_main_keys_key_array_70, 3},
{jai_main_keys_key_array_71, 3},
{jai_main_keys_key_array_72, 6},
{0, 0},
{0, 0},
{jai_main_keys_key_array_75, 4},
{0, 0},
{0, 0},
{jai_main_keys_key_array_78, 2},
{0, 0},
{0, 0},
{jai_main_keys_key_array_81, 7},
{0, 0},
{0, 0},
{jai_main_keys_key_array_84, 6},
{0, 0},
{jai_main_keys_key_array_86, 6},
{jai_main_keys_key_array_87, 5},
{0, 0},
};
Lexeme_Table_Value jai_main_keys_value_array[89] = {
{4, TokenJaiKind_Int},
{4, TokenJaiKind_SizeOf},
{0, 0},
{0, 0},
{4, TokenJaiKind_Else},
{4, TokenJaiKind_Case},
{0, 0},
{4, TokenJaiKind_Void},
{4, TokenJaiKind_U64},
{4, TokenJaiKind_S8},
{0, 0},
{0, 0},
{4, TokenJaiKind_Default},
{0, 0},
{4, TokenJaiKind_Switch},
{0, 0},
{0, 0},
{4, TokenJaiKind_U16},
{0, 0},
{4, TokenJaiKind_Do},
{4, TokenJaiKind_S64},
{4, TokenJaiKind_Any},
{4, TokenJaiKind_Defer},
{0, 0},
{4, TokenJaiKind_U8},
{4, TokenJaiKind_PushContext},
{4, TokenJaiKind_Using},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenJaiKind_If},
{0, 0},
{4, TokenJaiKind_ItIndex},
{4, TokenJaiKind_For},
{0, 0},
{0, 0},
{0, 0},
{4, TokenJaiKind_Continue},
{0, 0},
{0, 0},
{4, TokenJaiKind_Bool},
{4, TokenJaiKind_Remove},
{4, TokenJaiKind_Union},
{4, TokenJaiKind_While},
{0, 0},
{0, 0},
{4, TokenJaiKind_Autocast},
{4, TokenJaiKind_New},
{4, TokenJaiKind_Cast},
{0, 0},
{4, TokenJaiKind_Break},
{4, TokenJaiKind_U32},
{4, TokenJaiKind_Operator},
{8, TokenJaiKind_LiteralTrue},
{4, TokenJaiKind_AlignOf},
{0, 0},
{4, TokenJaiKind_Inline},
{4, TokenJaiKind_Float64},
{4, TokenJaiKind_S16},
{0, 0},
{4, TokenJaiKind_Context},
{0, 0},
{4, TokenJaiKind_Float},
{4, TokenJaiKind_Null},
{4, TokenJaiKind_Enum},
{0, 0},
{0, 0},
{0, 0},
{4, TokenJaiKind_Return},
{4, TokenJaiKind_S32},
{4, TokenJaiKind_Uninitialized},
{4, TokenJaiKind_Delete},
{0, 0},
{0, 0},
{4, TokenJaiKind_Goto},
{0, 0},
{0, 0},
{4, TokenJaiKind_It},
{0, 0},
{0, 0},
{4, TokenJaiKind_Float32},
{0, 0},
{0, 0},
{4, TokenJaiKind_String},
{0, 0},
{4, TokenJaiKind_Struct},
{8, TokenJaiKind_LiteralFalse},
{0, 0},
};
i32 jai_main_keys_slot_count = 89;
u64 jai_main_keys_seed = 0x58cb0283ffd83e33;
u64 jai_pp_directives_hash_array[26] = {
0x6417a3d9dfc55afb,0x0000000000000000,0x8b4204d7b211c19b,0x8c86ef570f6ef2d7,
0x6417a3d9cb655ea1,0x0000000000000000,0x8c86ef5753b78877,0x8c86ef528e7779ed,
0x0000000000000000,0x8b4204d7b211c001,0xbc36b9ef7cd828fb,0x0000000000000000,
0x6417a3d9cbec23db,0x0000000000000000,0xb6b15ef12b1b4453,0x0000000000000000,
0x6417a3d9d9f9efdb,0x8b4204d7b3ae6191,0x0000000000000000,0x0000000000000000,
0x6417a3d9ded4990b,0xb6b15ee3161a294f,0x0000000000000000,0x8b4204d7b3afca57,
0x8c86ef5446fe6a5b,0x0000000000000000,
};
u8 jai_pp_directives_key_array_0[] = {0x65,0x6e,0x64,0x69,0x66,};
u8 jai_pp_directives_key_array_2[] = {0x65,0x6c,0x69,0x66,};
u8 jai_pp_directives_key_array_3[] = {0x64,0x65,0x66,0x69,0x6e,0x65,};
u8 jai_pp_directives_key_array_4[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 jai_pp_directives_key_array_6[] = {0x69,0x6d,0x70,0x6f,0x72,0x74,};
u8 jai_pp_directives_key_array_7[] = {0x70,0x72,0x61,0x67,0x6d,0x61,};
u8 jai_pp_directives_key_array_9[] = {0x65,0x6c,0x73,0x65,};
u8 jai_pp_directives_key_array_10[] = {0x69,0x66,};
u8 jai_pp_directives_key_array_12[] = {0x75,0x6e,0x64,0x65,0x66,};
u8 jai_pp_directives_key_array_14[] = {0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,};
u8 jai_pp_directives_key_array_16[] = {0x69,0x66,0x64,0x65,0x66,};
u8 jai_pp_directives_key_array_17[] = {0x6c,0x6f,0x61,0x64,};
u8 jai_pp_directives_key_array_20[] = {0x65,0x72,0x72,0x6f,0x72,};
u8 jai_pp_directives_key_array_21[] = {0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,};
u8 jai_pp_directives_key_array_23[] = {0x6c,0x69,0x6e,0x65,};
u8 jai_pp_directives_key_array_24[] = {0x69,0x66,0x6e,0x64,0x65,0x66,};
String_Const_u8 jai_pp_directives_key_array[26] = {
{jai_pp_directives_key_array_0, 5},
{0, 0},
{jai_pp_directives_key_array_2, 4},
{jai_pp_directives_key_array_3, 6},
{jai_pp_directives_key_array_4, 5},
{0, 0},
{jai_pp_directives_key_array_6, 6},
{jai_pp_directives_key_array_7, 6},
{0, 0},
{jai_pp_directives_key_array_9, 4},
{jai_pp_directives_key_array_10, 2},
{0, 0},
{jai_pp_directives_key_array_12, 5},
{0, 0},
{jai_pp_directives_key_array_14, 7},
{0, 0},
{jai_pp_directives_key_array_16, 5},
{jai_pp_directives_key_array_17, 4},
{0, 0},
{0, 0},
{jai_pp_directives_key_array_20, 5},
{jai_pp_directives_key_array_21, 7},
{0, 0},
{jai_pp_directives_key_array_23, 4},
{jai_pp_directives_key_array_24, 6},
{0, 0},
};
Lexeme_Table_Value jai_pp_directives_value_array[26] = {
{5, TokenJaiKind_PPEndIf},
{0, 0},
{5, TokenJaiKind_PPElIf},
{5, TokenJaiKind_PPDefine},
{5, TokenJaiKind_PPUsing},
{0, 0},
{5, TokenJaiKind_PPImport},
{5, TokenJaiKind_PPPragma},
{0, 0},
{5, TokenJaiKind_PPElse},
{5, TokenJaiKind_PPIf},
{0, 0},
{5, TokenJaiKind_PPUndef},
{0, 0},
{5, TokenJaiKind_PPVersion},
{0, 0},
{5, TokenJaiKind_PPIfDef},
{5, TokenJaiKind_PPLoad},
{0, 0},
{0, 0},
{5, TokenJaiKind_PPError},
{5, TokenJaiKind_PPInclude},
{0, 0},
{5, TokenJaiKind_PPLine},
{5, TokenJaiKind_PPIfNDef},
{0, 0},
};
i32 jai_pp_directives_slot_count = 26;
u64 jai_pp_directives_seed = 0xd71e895862a43342;
u64 jai_pp_keys_hash_array[2] = {
0x0000000000000000,0x6f10bd7e78f1fcc3,
};
u8 jai_pp_keys_key_array_1[] = {0x64,0x65,0x66,0x69,0x6e,0x65,0x64,};
String_Const_u8 jai_pp_keys_key_array[2] = {
{0, 0},
{jai_pp_keys_key_array_1, 7},
};
Lexeme_Table_Value jai_pp_keys_value_array[2] = {
{0, 0},
{4, TokenJaiKind_PPDefined},
};
i32 jai_pp_keys_slot_count = 2;
u64 jai_pp_keys_seed = 0x567b5b0cc8c5535f;
struct Lex_State_Jai{
u32 flags_ZF0;
u32 flags_KF0;
u16 flags_ZB0;
u8 *base;
u8 *delim_first;
u8 *delim_one_past_last;
u8 *emit_ptr;
u8 *ptr;
u8 *opl_ptr;
};
static void
lex_full_input_jai_init(Lex_State_Jai *state_ptr, String_Const_u8 input){
state_ptr->flags_ZF0 = 0;
state_ptr->flags_KF0 = 0;
state_ptr->flags_ZB0 = 0;
state_ptr->base = input.str;
state_ptr->delim_first = input.str;
state_ptr->delim_one_past_last = input.str;
state_ptr->emit_ptr = input.str;
state_ptr->ptr = input.str;
state_ptr->opl_ptr = input.str + input.size;
}
static b32
lex_full_input_jai_breaks(Arena *arena, Token_List *list, Lex_State_Jai *state_ptr, u64 max){
b32 result = false;
u64 emit_counter = 0;
Lex_State_Jai state;
block_copy((&state), (state_ptr), sizeof(*(&state)));
{
state_label_1:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:
case 0x13:case 0x14:case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:
case 0x1a:case 0x1b:case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x40:
case 0x60:case 0x7f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
if (((((state.flags_KF0)&(0x2))!=0))){
state.ptr += 1;
goto state_label_4;
}
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_ZB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
case 0x21:
{
state.ptr += 1;
goto state_label_58;
}break;
case 0x22:
{
if (((((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_26;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x23:
{
if ((!(((state.flags_ZB0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_23;
}
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
case 0x25:
{
state.ptr += 1;
goto state_label_63;
}break;
case 0x26:
{
state.ptr += 1;
goto state_label_59;
}break;
case 0x27:
{
state.ptr += 1;
state.flags_ZF0 |= 0x40;
goto state_label_32;
}break;
case 0x28:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_ParenOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x29:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_ParenCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_62;
}break;
case 0x2b:
{
state.ptr += 1;
goto state_label_61;
}break;
case 0x2c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Comma;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2d:
{
state.ptr += 1;
goto state_label_54;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_6;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_7;
}break;
case 0x30:
{
state.ptr += 1;
goto state_label_9;
}break;
case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:case 0x37:
case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x3a:
{
state.ptr += 1;
goto state_label_53;
}break;
case 0x3b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Semicolon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
if ((!(((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_56;
}
state.ptr += 1;
goto state_label_25;
}break;
case 0x3d:
{
state.ptr += 1;
goto state_label_55;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_57;
}break;
case 0x3f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Ternary;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
state.flags_ZF0 |= 0x4;
goto state_label_27;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
case 0x55:
{
state.ptr += 1;
state.flags_ZF0 |= 0x20;
goto state_label_29;
}break;
case 0x5b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BrackOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_5;
}break;
case 0x5d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BrackCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x5e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Xor;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x75:
{
state.ptr += 1;
state.flags_ZF0 |= 0x10;
goto state_label_28;
}break;
case 0x7b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BraceOp;
token.kind = 11;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
goto state_label_60;
}break;
case 0x7d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BraceCl;
token.kind = 12;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x7e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Tilde;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_2:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_pp_keys_hash_array, jai_pp_keys_key_array, jai_pp_keys_value_array, jai_pp_keys_slot_count, jai_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_main_keys_hash_array, jai_main_keys_key_array, jai_main_keys_value_array, jai_main_keys_slot_count, jai_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenJaiKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x09:case 0x0a:case 0x0b:case 0x0c:case 0x0d:
case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:case 0x13:case 0x14:
case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:case 0x1a:case 0x1b:
case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x20:case 0x21:case 0x22:
case 0x23:case 0x25:case 0x26:case 0x27:case 0x28:case 0x29:case 0x2a:
case 0x2b:case 0x2c:case 0x2d:case 0x2e:case 0x2f:case 0x3a:case 0x3b:
case 0x3c:case 0x3d:case 0x3e:case 0x3f:case 0x40:case 0x5b:case 0x5c:
case 0x5d:case 0x5e:case 0x60:case 0x7b:case 0x7c:case 0x7d:case 0x7e:
case 0x7f:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_pp_keys_hash_array, jai_pp_keys_key_array, jai_pp_keys_value_array, jai_pp_keys_slot_count, jai_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_main_keys_hash_array, jai_main_keys_key_array, jai_main_keys_value_array, jai_main_keys_slot_count, jai_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenJaiKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
}
}
{
state_label_3:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_ZB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
}
}
{
state_label_4:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_4;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_5:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x0a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_5;
}break;
}
}
{
state_label_6:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_DotStar;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_66;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
}
}
{
state_label_7:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_DivEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_8:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_9:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x58:case 0x78:
{
state.ptr += 1;
state.flags_ZF0 |= 0x1;
goto state_label_14;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_10:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_11:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2b:case 0x2d:
{
state.ptr += 1;
goto state_label_12;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_12:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_13:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_14:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
}
}
{
state_label_15:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_16:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_17:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_19;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_21;
}break;
}
}
{
state_label_18:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_22;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_19:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_20:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_22;
}break;
}
}
{
state_label_21:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_22:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenJaiKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenJaiKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_23:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x20:
{
state.ptr += 1;
goto state_label_23;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.delim_first = state.ptr;
state.flags_ZB0 |= 0x1;
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_24:
if (state.ptr == state.opl_ptr){
if ((true)){
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_pp_directives_hash_array, jai_pp_directives_key_array, jai_pp_directives_value_array, jai_pp_directives_slot_count, jai_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenJaiKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenJaiKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenJaiKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(jai_pp_directives_hash_array, jai_pp_directives_key_array, jai_pp_directives_value_array, jai_pp_directives_slot_count, jai_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenJaiKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenJaiKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenJaiKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_25:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x2e:case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:
case 0x34:case 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x41:
case 0x42:case 0x43:case 0x44:case 0x45:case 0x46:case 0x47:case 0x48:
case 0x49:case 0x4a:case 0x4b:case 0x4c:case 0x4d:case 0x4e:case 0x4f:
case 0x50:case 0x51:case 0x52:case 0x53:case 0x54:case 0x55:case 0x56:
case 0x57:case 0x58:case 0x59:case 0x5a:case 0x5c:case 0x5f:case 0x61:
case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:case 0x68:
case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:case 0x6f:
case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:case 0x76:
case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_25;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_26:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x2e:case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:
case 0x34:case 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x41:
case 0x42:case 0x43:case 0x44:case 0x45:case 0x46:case 0x47:case 0x48:
case 0x49:case 0x4a:case 0x4b:case 0x4c:case 0x4d:case 0x4e:case 0x4f:
case 0x50:case 0x51:case 0x52:case 0x53:case 0x54:case 0x55:case 0x56:
case 0x57:case 0x58:case 0x59:case 0x5a:case 0x5c:case 0x5f:case 0x61:
case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:case 0x68:
case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:case 0x6f:
case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:case 0x76:
case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_26;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_27:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_28:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x38:
{
state.ptr += 1;
state.flags_ZF0 |= 0x8;
goto state_label_30;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_29:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_30:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_31:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
state.delim_first = state.ptr;
goto state_label_45;
}break;
}
}
{
state_label_32:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x22:
{
if ((!(((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenJaiKind_LiteralString;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x27:
{
if (((((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenJaiKind_LiteralCharacterWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenJaiKind_LiteralCharacterUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenJaiKind_LiteralCharacterUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenJaiKind_LiteralCharacterUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenJaiKind_LiteralCharacter;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_33;
}break;
}
}
{
state_label_33:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_34;
}break;
case 0x55:
{
state.ptr += 1;
goto state_label_37;
}break;
case 0x75:
{
state.ptr += 1;
goto state_label_41;
}break;
case 0x78:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_34:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_35;
}break;
}
}
{
state_label_35:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_36:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_37:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_38;
}break;
}
}
{
state_label_38:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_39;
}break;
}
}
{
state_label_39:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_40;
}break;
}
}
{
state_label_40:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_41;
}break;
}
}
{
state_label_41:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_42;
}break;
}
}
{
state_label_42:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_43;
}break;
}
}
{
state_label_43:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_44;
}break;
}
}
{
state_label_44:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_45:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_45;
}break;
case 0x20:case 0x29:case 0x5c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x28:
{
state.delim_one_past_last = state.ptr;
state.ptr += 1;
goto state_label_46;
}break;
}
}
{
state_label_46:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_46;
}break;
case 0x29:
{
state.ptr += 1;
goto state_label_47;
}break;
}
}
{
state_label_47:
u64 delim_length = state.delim_one_past_last - state.delim_first;
u64 parse_length = 0;
for (;;){
if (parse_length == delim_length){
goto state_label_48;
}
if (state.ptr == state.opl_ptr){
goto state_label_48;
}
if (*state.ptr == state.delim_first[parse_length]){
state.ptr += 1;
parse_length += 1;
}
else{
goto state_label_46;
}
}
}
{
state_label_48:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_46;
}
}
switch (*state.ptr){
default:
{
goto state_label_46;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringWideRaw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF8Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF16Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenJaiKind_LiteralStringUTF32Raw;
token.kind = 10;
break;
}
token.sub_kind = TokenJaiKind_LiteralStringRaw;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_49:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_ZB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
}
}
{
state_label_50:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
case 0x2f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_51:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_52:
if (state.ptr == state.opl_ptr){
if ((true)){
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_53:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Colon;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Colon;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_ColonColon;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_ColonEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_54:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_MinusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_MinusGrtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_55:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EqEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_EqGrtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_56:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
state.ptr += 1;
goto state_label_64;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LessEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_57:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_GrtrEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_65;
}break;
}
}
{
state_label_58:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_NotEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_59:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x26:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_AndAnd;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_60:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_OrOr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_61:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_PlusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_62:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_StarEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_63:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_ModEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_64:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_LeftLeftEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_65:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_RightRightEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_66:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_DotDot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_DotDot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_ZB0;
do{
token.sub_kind = TokenJaiKind_DotDotDot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
state.flags_ZB0 = 0;
goto state_label_1;
}break;
}
}
end:;
block_copy((state_ptr), (&state), sizeof(*(state_ptr)));
return(result);
}
static Token_List
lex_full_input_jai(Arena *arena, String_Const_u8 input){
Lex_State_Jai state = {};
lex_full_input_jai_init(&state, input);
Token_List list = {};
lex_full_input_jai_breaks(arena, &list, &state, max_u64);
return(list);
}
# 9 "4coder_fleury_lang_list.h" 2
# 1 "4coder_fleury_lang_cpp.cpp" 1

static void
F4_CPP_ParseMacroDefinition(F4_Index_ParseCtx *ctx)
{
    Token *name = 0;
    if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
    {
        F4_Index_Note *last_parent = F4_Index_PushParent(ctx, 0);
        F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Macro, 0);
        F4_Index_PopParent(ctx, last_parent);
        F4_Index_SkipSoftTokens(ctx, 1);
    }
}

static b32
F4_CPP_SkipParseBody(F4_Index_ParseCtx *ctx)
{
    b32 body_found = 0;
    int nest = 0;

    for(;!ctx->done;)
    {
        Token *name = 0;

        if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Comment, &name))
        {
            F4_Index_ParseComment(ctx, name);
        }
        else if(F4_Index_ParsePattern(ctx, "%b", TokenCppKind_PPDefine, &name))
        {
            F4_CPP_ParseMacroDefinition(ctx);
        }
        else if(F4_Index_ParsePattern(ctx, "%t", "{"))
        {
            nest += 1;
            body_found = 1;
        }
        else if(F4_Index_ParsePattern(ctx, "%t", "}"))
        {
            nest -= 1;
            if(nest == 0)
            {
                break;
            }
        }
        else if(body_found == 0)
        {
            break;
        }
        else
        {
            F4_Index_ParseCtx_Inc(ctx, F4_Index_TokenSkipFlag_SkipWhitespace);
        }
    }
    return body_found;
}

static b32
F4_CPP_ParseDecl(F4_Index_ParseCtx *ctx, Token **name)
{
    Token *base_type = 0;
    return (F4_Index_ParsePattern(ctx, "%k%o%k%o%t",
                                  TokenBaseKind_Identifier, &base_type,
                                  TokenBaseKind_Identifier, name,
                                  ";") ||
            F4_Index_ParsePattern(ctx, "%k%o%k%o%t",
                                  TokenBaseKind_Keyword, &base_type,
                                  TokenBaseKind_Identifier, name,
                                  ";") ||
            F4_Index_ParsePattern(ctx, "%k%o%k%t",
                                  TokenBaseKind_Identifier, &base_type,
                                  TokenBaseKind_Identifier, name,
                                  "=") ||
            F4_Index_ParsePattern(ctx, "%k%o%k%t",
                                  TokenBaseKind_Keyword, &base_type,
                                  TokenBaseKind_Identifier, name,
                                  "="));
}

static void
F4_CPP_ParseStructOrUnionBodyIFuckingHateCPlusPlus(F4_Index_ParseCtx *ctx, F4_Index_NoteFlags note_flags)
{
    Token *name = 0;
    b32 valid = 0;
    b32 need_end_name = 0;

    if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
    {
        valid = 1;
    }
    else
    {
        need_end_name = 1;
    }

    if(F4_CPP_SkipParseBody(ctx))
    {
    }
    else
    {
        note_flags |= F4_Index_NoteFlag_Prototype;
    }

    if(need_end_name)
    {
        if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
        {
            valid = 1;
        }
    }

    if(valid)
    {
        F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, note_flags);
    }
}

static b32
F4_CPP_ParseFunctionBodyIFuckingHateCPlusPlus(F4_Index_ParseCtx *ctx, b32 *prototype_ptr)
{
    b32 valid = 0;
    b32 prototype = 0;

    for(;!ctx->done;)
    {
        Token *token = token_it_read(&ctx->it);
        if(token == 0) { break; }
        if(token->sub_kind == TokenCppKind_Semicolon)
        {
            valid = 1;
            prototype = 1;
            break;
        }
        else if(token->sub_kind == TokenCppKind_ParenCl)
        {
        }
        else if(token->kind == TokenBaseKind_ScopeOpen)
        {
            valid = 1;
            break;
        }
        F4_Index_ParseCtx_Inc(ctx, 0);
    }

    if(valid)
    {
        if(prototype == 0)
        {
            F4_CPP_SkipParseBody(ctx);
        }
    }

    *prototype_ptr = prototype;

    return valid;
}

static void
F4_CPP_ParseEnumBodyIFuckingHateCPlusPlus(F4_Index_ParseCtx *ctx)
{
    if(F4_Index_ParsePattern(ctx, "%t", "{"))
    {
        for(;!ctx->done;)
        {
            Token *constant = 0;
            if(F4_Index_ParsePattern(ctx, "%k%t", TokenBaseKind_Identifier, &constant, ","))
            {
                F4_Index_MakeNote(ctx, Ii64(constant), F4_Index_NoteKind_Constant, 0);
            }
            else if(F4_Index_ParsePattern(ctx, "%k%t", TokenBaseKind_Identifier, &constant, "="))
            {
                F4_Index_MakeNote(ctx, Ii64(constant), F4_Index_NoteKind_Constant, 0);

                for(;!ctx->done;)
                {
                    Token *token = token_it_read(&ctx->it);
                    if(token->kind == TokenBaseKind_StatementClose)
                    {
                        F4_Index_ParseCtx_Inc(ctx, 0);
                        break;
                    }
                    else if(token->kind == TokenBaseKind_ScopeClose ||
                            token->kind == TokenBaseKind_ScopeOpen)
                    {
                        break;
                    }
                    F4_Index_ParseCtx_Inc(ctx, 0);
                }
            }
            else if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &constant))
            {
                F4_Index_MakeNote(ctx, Ii64(constant), F4_Index_NoteKind_Constant, 0);
            }
            else if(F4_Index_ParsePattern(ctx, "%t", "}"))
            {
                break;
            }
            else
            {
                F4_Index_ParseCtx_Inc(ctx, 0);
            }
        }
    }
}

static void F4_CPP_IndexFile(F4_Index_ParseCtx *ctx)
{
    int scope_nest = 0;
    for(b32 handled = 0; !ctx->done;)
    {
        handled = 0;

        Token *name = 0;
        Token *base_type = 0;
        F4_Index_Note *containing_struct = 0;
        F4_Index_Note *note = 0;

        if(0){}




        else if(F4_Index_ParsePattern(ctx, "%t%t%t", "extern", "C", "{"))
        {
            handled = 1;
        }


        else if(F4_Index_ParsePattern(ctx, "%t", "{"))
        {
            handled = 1;
            scope_nest += 1;
        }
        else if(F4_Index_ParsePattern(ctx, "%t", "}"))
        {
            handled = 1;
            scope_nest -= 1;
            if(scope_nest < 0)
            {
                scope_nest = 0;
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%t", "struct"))
        {
            handled = 1;
            F4_CPP_ParseStructOrUnionBodyIFuckingHateCPlusPlus(ctx, F4_Index_NoteFlag_ProductType);
        }
        else if(F4_Index_ParsePattern(ctx, "%t%t", "typedef", "struct"))
        {
            handled = 1;
            F4_CPP_ParseStructOrUnionBodyIFuckingHateCPlusPlus(ctx, 0);
            if (F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, F4_Index_NoteFlag_ProductType);
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%t", "union"))
        {
            handled = 1;
            F4_CPP_ParseStructOrUnionBodyIFuckingHateCPlusPlus(ctx, F4_Index_NoteFlag_SumType);
        }
        else if (F4_Index_ParsePattern(ctx, "%t%t", "typedef", "union"))
        {
            handled = 1;
            F4_CPP_ParseStructOrUnionBodyIFuckingHateCPlusPlus(ctx, F4_Index_NoteFlag_SumType);
            if (F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, F4_Index_NoteFlag_SumType);
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%t%t%k", "typedef", "enum", TokenBaseKind_Identifier, &name) ||
                F4_Index_ParsePattern(ctx, "%t%t", "typedef", "enum"))
        {
            handled = 1;
            b32 prototype = 0;
            b32 possible_name_at_end = name == 0;
            if(F4_Index_ParsePattern(ctx, "%t", ";"))
            {
                prototype = 1;
            }
            if(prototype == 0)
            {
                F4_CPP_ParseEnumBodyIFuckingHateCPlusPlus(ctx);
            }
            if(possible_name_at_end)
            {
                if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
                {}
            }
            if(name != 0)
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, prototype ? F4_Index_NoteFlag_Prototype : 0);
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%t%k", "enum", TokenBaseKind_Identifier, &name) ||
                F4_Index_ParsePattern(ctx, "%t", "enum"))
        {
            handled = 1;
            b32 prototype = 0;
            if(F4_Index_ParsePattern(ctx, "%t", ";"))
            {
                prototype = 1;
            }
            if(prototype == 0)
            {
                F4_CPP_ParseEnumBodyIFuckingHateCPlusPlus(ctx);
            }
            if(name != 0)
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, prototype ? F4_Index_NoteFlag_Prototype : 0);
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%t", "typedef"))
        {
            handled = 1;
            int nest = 0;
            b32 sum_type = 0;
            for(;!ctx->done;)
            {
                if(F4_Index_ParsePattern(ctx, "%t", "("))
                {
                    nest += 1;
                }
                else if(F4_Index_ParsePattern(ctx, "%t", "("))
                {
                    nest -= 1;
                }
                else if(nest == 0 && F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Identifier, &name))
                {
                    String8 namestr = F4_Index_StringFromToken(ctx, name);
                    F4_Index_Note *namenote = F4_Index_LookupNote(namestr, 0);
                    if(namenote != 0 && namenote->kind == F4_Index_NoteKind_Type &&
                       namenote->flags & F4_Index_NoteFlag_SumType)
                    {
                        sum_type = 1;
                    }
                }
                else if(F4_Index_ParsePattern(ctx, "%t", ";"))
                {
                    break;
                }
                else
                {
                    F4_Index_ParseCtx_Inc(ctx, 0);
                }
            }
            if(name != 0)
            {
                F4_Index_NoteFlags note_flags = 0;
                if(sum_type)
                {
                    note_flags |= F4_Index_NoteFlag_SumType;
                }
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, note_flags);
            }
        }


        else if(scope_nest == 0 &&
                (F4_Index_ParsePattern(ctx, "%k%o%k%t",
                                       TokenBaseKind_Identifier, &base_type,
                                       TokenBaseKind_Identifier, &name,
                                       "(") ||
                 F4_Index_ParsePattern(ctx, "%k%o%k%t",
                                       TokenBaseKind_Keyword, &base_type,
                                       TokenBaseKind_Identifier, &name,
                                       "(")))
        {
            handled = 1;
            b32 prototype = 0;
            if(F4_CPP_ParseFunctionBodyIFuckingHateCPlusPlus(ctx, &prototype))
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Function, prototype ? F4_Index_NoteFlag_Prototype : 0);
            }
        }


        else if(scope_nest == 0 &&
                (F4_Index_ParsePattern(ctx, "%k%o%n%t%k%t",
                                       TokenBaseKind_Identifier, &base_type,
                                       F4_Index_NoteKind_Type, &containing_struct,
                                       "::",
                                       TokenBaseKind_Identifier, &name,
                                       "(") ||
                 F4_Index_ParsePattern(ctx, "%k%o%n%t%k%t",
                                       TokenBaseKind_Keyword, &base_type,
                                       F4_Index_NoteKind_Type, &containing_struct,
                                       "::",
                                       TokenBaseKind_Identifier, &name,
                                       "(")))
        {
            handled = 1;
            b32 prototype = 0;
            if(F4_CPP_ParseFunctionBodyIFuckingHateCPlusPlus(ctx, &prototype))
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Function, prototype ? F4_Index_NoteFlag_ProductType : 0);
            }
        }


        else if(scope_nest == 0 && F4_CPP_ParseDecl(ctx, &name))
        {
            handled = 1;
            F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Decl, 0);
        }


        else if(0 && F4_Index_ParsePattern(ctx, "%n%t%k",
                                           F4_Index_NoteKind_Macro, &note,
                                           "(",
                                           TokenBaseKind_Identifier, &name))
        {
            b32 valid = 0;
            b32 prototype = 0;

            for(;!ctx->done;)
            {
                Token *token = token_it_read(&ctx->it);
                if(token == 0) { break; }
                if(token->sub_kind == TokenCppKind_Semicolon)
                {
                    prototype = 1;
                    valid = 1;
                    break;
                }
                else if(token->sub_kind == TokenCppKind_ParenCl)
                {
                }
                else if(token->kind == TokenBaseKind_ScopeOpen)
                {
                    valid = 1;
                    break;
                }
                F4_Index_ParseCtx_Inc(ctx, 0);
            }

            if(valid)
            {
                handled = 1;
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Function, prototype ? F4_Index_NoteFlag_ProductType : 0);
                F4_CPP_SkipParseBody(ctx);
            }
        }


        else if(F4_Index_ParsePattern(ctx, "%k", TokenBaseKind_Comment, &name))
        {
            handled = 1;
            F4_Index_ParseComment(ctx, name);
        }


        else if(F4_Index_ParsePattern(ctx, "%b", TokenCppKind_PPDefine, &name))
        {
            handled = 1;
            F4_CPP_ParseMacroDefinition(ctx);
        }


        if(handled == 0)
        {
            F4_Index_ParseCtx_Inc(ctx, 0);
        }
    }
}

static F4_Language_PosContextData * F4_CPP_PosContext(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos)
{
    int count = 0;
    F4_Language_PosContextData *first = 0;
    F4_Language_PosContextData *last = 0;

    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);


    {
        int paren_nest = 0;
        int arg_idx = 0;
        for(int i = 0; count < 4; i += 1)
        {
            Token *token = token_it_read(&it);
            if(token)
            {
                if(paren_nest == 0 &&
                   token->sub_kind == TokenCppKind_ParenOp &&
                   token_it_dec_non_whitespace(&it))
                {
                    Token *name = token_it_read(&it);
                    if(name && name->kind == TokenBaseKind_Identifier)
                    {
                        F4_Language_PosContext_PushData_Call(arena, &first, &last, push_buffer_range(app, arena, buffer, Ii64(name)), arg_idx);
                        count += 1;
                        arg_idx = 0;
                    }
                }
                else if(token->sub_kind == TokenCppKind_ParenOp)
                {
                    paren_nest -= 1;
                }
                else if(token->sub_kind == TokenCppKind_ParenCl && i > 0)
                {
                    paren_nest += 1;
                }
                else if(token->sub_kind == TokenCppKind_Comma && i > 0 && paren_nest == 0)
                {
                    arg_idx += 1;
                }
            }
            else { break; }
            if(!token_it_dec_non_whitespace(&it))
            {
                break;
            }
        }
    }


    {
# 559 "4coder_fleury_lang_cpp.cpp"
    }

    return first;
}

static void F4_CPP_Highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, Color_Table color_table)
{
}
# 10 "4coder_fleury_lang_list.h" 2
# 1 "4coder_fleury_lang_jai.cpp" 1

static void
F4_Jai_ParseDeclSet(F4_Index_ParseCtx *ctx, F4_Index_Note *parent)
{
    F4_Index_Note *last_parent = F4_Index_PushParent(ctx, parent);
    for(;!ctx->done;)
    {
        Token *name = 0;
        if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Identifier, &name, F4_Index_TokenSkipFlag_SkipWhitespace) &&
           F4_Index_RequireToken(ctx, SCu8((u8*)(":"), (u64)(sizeof(":") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace))
        {
            F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Decl, 0);

            for(;!ctx->done;)
            {
                Token *token = token_it_read(&ctx->it);
                if(token->sub_kind == TokenJaiKind_Comma ||
                   token->sub_kind == TokenJaiKind_Semicolon)
                {
                    F4_Index_ParseCtx_Inc(ctx, F4_Index_TokenSkipFlag_SkipWhitespace);
                    break;
                }
                else if(token->kind == TokenBaseKind_ScopeClose ||
                        token->sub_kind == TokenJaiKind_ParenCl)
                {
                    goto end;
                }
                F4_Index_ParseCtx_Inc(ctx, F4_Index_TokenSkipFlag_SkipWhitespace);
            }

        }
        else
        {
            break;
        }
    }

    end:;
    F4_Index_PopParent(ctx, last_parent);
}

static void
F4_Jai_ParseDeclSet_Braces(F4_Index_ParseCtx *ctx, F4_Index_Note *parent)
{
    if(F4_Index_RequireToken(ctx, SCu8((u8*)("{"), (u64)(sizeof("{") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace))
    {
        F4_Jai_ParseDeclSet(ctx, parent);
        F4_Index_RequireToken(ctx, SCu8((u8*)("}"), (u64)(sizeof("}") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace);
    }
}

static void
F4_Jai_ParseDeclSet_Parens(F4_Index_ParseCtx *ctx, F4_Index_Note *parent)
{
    if(F4_Index_RequireToken(ctx, SCu8((u8*)("("), (u64)(sizeof("(") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace))
    {
        F4_Jai_ParseDeclSet(ctx, parent);
        F4_Index_RequireToken(ctx, SCu8((u8*)(")"), (u64)(sizeof(")") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace);
    }
}

static void F4_Jai_IndexFile(F4_Index_ParseCtx *ctx)
{
    int scope_nest = 0;
    for(;!ctx->done;)
    {
        Token *name = 0;
        F4_Index_TokenSkipFlags flags = F4_Index_TokenSkipFlag_SkipWhitespace;


        {
            Token *token = token_it_read(&ctx->it);
            if(token)
            {
                if(token->kind == TokenBaseKind_ScopeOpen)
                {
                    scope_nest += 1;
                }
                else if(token->kind == TokenBaseKind_ScopeClose)
                {
                    scope_nest -= 1;
                }
                if(scope_nest < 0)
                {
                    scope_nest = 0;
                }
            }
        }

        if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Identifier, &name, flags))
        {


            if(F4_Index_RequireToken(ctx, SCu8((u8*)("::"), (u64)(sizeof("::") - 1)), flags))
            {

                if(F4_Index_PeekToken(ctx, SCu8((u8*)("("), (u64)(sizeof("(") - 1))) ||
                   (F4_Index_RequireToken(ctx, SCu8((u8*)("inline"), (u64)(sizeof("inline") - 1)), flags) &&
                    F4_Index_PeekToken(ctx, SCu8((u8*)("("), (u64)(sizeof("(") - 1)))))
                {
                    F4_Index_Note *parent = F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Function, 0);
                    F4_Jai_ParseDeclSet_Parens(ctx, parent);
                }

                else if(F4_Index_RequireToken(ctx, SCu8((u8*)("struct"), (u64)(sizeof("struct") - 1)), flags))
                {
                    F4_Index_Note *parent = F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, F4_Index_NoteFlag_ProductType);
                    F4_Jai_ParseDeclSet_Braces(ctx, parent);
                }

                else if(F4_Index_RequireToken(ctx, SCu8((u8*)("union"), (u64)(sizeof("union") - 1)), flags))
                {
                    F4_Index_Note *parent = F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, F4_Index_NoteFlag_SumType);
                    F4_Jai_ParseDeclSet_Braces(ctx, parent);
                }

                else if(F4_Index_RequireToken(ctx, SCu8((u8*)("enum"), (u64)(sizeof("enum") - 1)), flags))
                {
                    F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Type, 0);
                }

                else if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Identifier, 0, flags) ||
                        F4_Index_RequireTokenKind(ctx, TokenBaseKind_LiteralInteger, 0, flags) ||
                        F4_Index_RequireTokenKind(ctx, TokenBaseKind_LiteralFloat, 0, flags) ||
                        F4_Index_RequireTokenKind(ctx, TokenBaseKind_LiteralString, 0, flags))
                {
                    F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Constant, 0);
                }
            }
        }


        else if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Comment, &name, F4_Index_TokenSkipFlag_SkipWhitespace))
        {
            F4_Index_ParseComment(ctx, name);
        }

        else
        {
            F4_Index_ParseCtx_Inc(ctx, flags);
        }
    }
}

static Token *
_F4_Jai_FindDecl(Application_Links *app, Buffer_ID buffer, i64 pos, Token *decl_name)
{
    Token *result = 0;
    Scratch_Block scratch(app);

    int scope_nest = 0;
    String_Const_u8 decl_name_str = push_buffer_range(app, scratch, buffer, Ii64(decl_name));
    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
    for(;;)
    {
        Token *token = token_it_read(&it);
        if(token)
        {
            if(scope_nest == 0 &&
               token->sub_kind == TokenJaiKind_Colon &&
               token_it_dec_non_whitespace(&it))
            {
                Token *name_candidate = token_it_read(&it);
                if(name_candidate && name_candidate->kind == TokenBaseKind_Identifier)
                {
                    String_Const_u8 name_candidate_string = push_buffer_range(app, scratch, buffer, Ii64(name_candidate));
                    if(string_match(name_candidate_string, decl_name_str))
                    {
                        result = name_candidate;
                        break;
                    }
                }
            }
            else if(token->sub_kind == TokenJaiKind_BraceCl)
            {
                scope_nest += 1;
            }
            else if(token->sub_kind == TokenJaiKind_BraceOp)
            {
                scope_nest -= 1;
            }
        }
        else { break; }
        if(!token_it_dec_non_whitespace(&it))
        {
            break;
        }
    }
    return result;
}

static F4_Language_PosContextData * F4_Jai_PosContext(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos)
{
    int count = 0;
    F4_Language_PosContextData *first = 0;
    F4_Language_PosContextData *last = 0;

    Token_Array tokens = get_token_array_from_buffer(app, buffer);


    {
        Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);

        int paren_nest = 0;
        int arg_idx = 0;
        for(int i = 0; count < 4; i += 1)
        {
            Token *token = token_it_read(&it);
            if(token)
            {
                if(paren_nest == 0 &&
                   token->sub_kind == TokenJaiKind_ParenOp &&
                   token_it_dec_non_whitespace(&it))
                {
                    Token *name = token_it_read(&it);
                    if(name && name->kind == TokenBaseKind_Identifier)
                    {
                        F4_Language_PosContext_PushData_Call(arena, &first, &last, push_buffer_range(app, arena, buffer, Ii64(name)), arg_idx);
      count += 1;
                        arg_idx = 0;
                    }
                }
                else if(token->sub_kind == TokenJaiKind_ParenOp)
                {
                    paren_nest -= 1;
                }
                else if(token->sub_kind == TokenJaiKind_ParenCl && i > 0)
                {
                    paren_nest += 1;
                }
                else if(token->sub_kind == TokenJaiKind_Comma && i > 0 && paren_nest == 0)
                {
                    arg_idx += 1;
                }
            }
            else { break; }
            if(!token_it_dec_non_whitespace(&it))
            {
                break;
            }
        }
    }


    {
        Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);

        Token *last_query_candidate = 0;
        for(int i = 0; i < 3; i += 1)
        {
            Token *token = token_it_read(&it);
            if(token)
            {
                if(i == 0 && token->kind == TokenBaseKind_Identifier)
                {
                    last_query_candidate = token;
                }
                else if((i == 0 || i == 1) &&
         token->sub_kind == TokenJaiKind_Dot &&
                        token_it_dec_non_whitespace(&it))
                {
                    Token *decl_name = token_it_read(&it);
                    if(decl_name && decl_name->kind == TokenBaseKind_Identifier)
                    {
                        Token *decl_start = _F4_Jai_FindDecl(app, buffer, decl_name->pos, decl_name);
                        if(decl_start)
                        {
                            Token_Iterator_Array it2 = token_iterator_pos(0, &tokens, decl_start->pos);
                            b32 found_colon = 0;
                            Token *base_type = 0;
                            for(;;)
                            {
                                Token *token2 = token_it_read(&it2);
                                if(token2)
                                {
                                    if(token2->sub_kind == TokenJaiKind_Colon)
                                    {
                                        found_colon = 1;
                                    }
                                    else if(found_colon && token2->kind == TokenBaseKind_Identifier)
                                    {
                                        base_type = token2;
                                    }
                                    else if(found_colon && token2->kind == TokenBaseKind_StatementClose)
                                    {
                                        break;
                                    }
                                }
                                else { break; }
                                if(!token_it_inc_non_whitespace(&it2)) { break; }
                            }

                            if(base_type != 0)
                            {
                                F4_Language_PosContext_PushData_Dot(arena, &first, &last,
                                                                    push_buffer_range(app, arena, buffer, Ii64(base_type)), last_query_candidate);
                            }
                        }
                    }
                }
            }
            else { break; }
            if(!token_it_dec_non_whitespace(&it))
            {
                break;
            }
        }
    }

    return first;
}

static void F4_Jai_Highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, Color_Table color_table)
{
}
# 11 "4coder_fleury_lang_list.h" 2
# 1 "4coder_fleury_lang_metadesk.cpp" 1

struct F4_MD_LexerState
{
    String_Const_u8 string;
    u8 *at;
    u8 *one_past_last;
};

enum F4_MD_TokenSubKind
{
    F4_MD_TokenSubKind_Null,
    F4_MD_TokenSubKind_Tag,
};

static void F4_MD_IndexFile(F4_Index_ParseCtx *ctx)
{
    for(;!ctx->done;)
    {
        Token *name = 0;
        if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Identifier, &name, F4_Index_TokenSkipFlag_SkipWhitespace))
        {
            if(F4_Index_RequireToken(ctx, SCu8((u8*)(":"), (u64)(sizeof(":") - 1)), F4_Index_TokenSkipFlag_SkipWhitespace))
            {
                F4_Index_MakeNote(ctx, Ii64(name), F4_Index_NoteKind_Constant, 0);
            }
        }
        else if(F4_Index_RequireTokenKind(ctx, TokenBaseKind_Comment, &name, F4_Index_TokenSkipFlag_SkipWhitespace))
        {
            F4_Index_ParseComment(ctx, name);
        }
        else
        {
            F4_Index_ParseCtx_Inc(ctx, F4_Index_TokenSkipFlag_SkipWhitespace);
        }
    }
}

static void F4_MD_LexInit(void *state_ptr, String_Const_u8 contents)
{
    F4_MD_LexerState *state = (F4_MD_LexerState *)state_ptr;
    state->string = contents;
    state->at = contents.str;
    state->one_past_last = contents.str + contents.size;
}

static b32
F4_MD_CharIsSymbol(u8 c)
{
    return (c == '~' || c == '!' || c == '@' || c == '#' || c == '$' ||
            c == '%' || c == '^' || c == '&' || c == '*' || c == '(' ||
            c == ')' || c == '-' || c == '=' || c == '+' || c == '[' ||
            c == ']' || c == '{' || c == '}' || c == ':' || c == ';' ||
            c == ',' || c == '<' || c == '.' || c == '>' || c == '/' ||
            c == '?' || c == '|' || c == '\\');
}

static b32 F4_MD_LexFullInput(Arena *arena, Token_List *list, void *state_ptr, u64 max)
{
    b32 result = false;
    F4_MD_LexerState state_ = *(F4_MD_LexerState *)state_ptr;
    F4_MD_LexerState *state = &state_;
    u64 emit_counter = 0;
    i64 strmax = (i64)state->string.size;
    for(i64 i = (i64)(state->at - state->string.str);
        i < strmax && state->at + i < state->one_past_last;)
    {
        i64 start_i = i;
        u8 chr = state->string.str[i];


        if(i+1 < strmax &&
           state->string.str[i] == '/' &&
           state->string.str[i+1] == '/')
        {
            Token token = { i, 1, TokenBaseKind_Comment, 0 };
            token.size += 1;
            for(i64 j = i+2; j < strmax && state->string.str[j] != '\n'; j += 1, token.size += 1);
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(i+1 < strmax &&
                state->string.str[i] == '/' &&
                state->string.str[i+1] == '*')
        {
            Token token = { i, 1, TokenBaseKind_Comment, 0 };
            token.size += 1;
            for(i64 j = i+2; j+1 < strmax && !(state->string.str[j] == '*' && state->string.str[j+1] == '/'); j += 1, token.size += 1);
            token.size += 2;
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(character_is_alpha(chr))
        {
            Token token = { i, 1, TokenBaseKind_Identifier, 0 };
            for(i64 j = i+1; j < (i64)state->string.size &&
                (character_is_alpha_numeric(state->string.str[j]) ||
                 state->string.str[j] == '_');
                j += 1, token.size += 1);
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(character_is_whitespace(chr))
        {
            Token token = { i, 1, TokenBaseKind_Whitespace, 0 };
            for(i64 j = i+1; j < (i64)state->string.size &&
                character_is_whitespace(state->string.str[j]);
                j += 1, token.size += 1);
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr >= '0' && chr <= '9')
        {
            Token token = { i, 1, TokenBaseKind_LiteralFloat, 0 };
            for(i64 j = i+1; j < (i64)state->string.size &&
                (character_is_alpha_numeric(state->string.str[j]) ||
                 state->string.str[j] == '_' ||
                 state->string.str[j] == '.');
                j += 1, token.size += 1);
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '"')
        {
            Token token = { i, 1, TokenBaseKind_LiteralString, 0 };
            for(i64 j = i+1; j < (i64)state->string.size && state->string.str[j] != '"';
                j += 1, token.size += 1);
            token.size += 1;
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '`')
        {
            Token token = { i, 1, TokenBaseKind_LiteralString, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '\'')
        {
            Token token = { i, 1, TokenBaseKind_LiteralString, 0 };
            for(i64 j = i+1; j < (i64)state->string.size && state->string.str[j] != '\'';
                j += 1, token.size += 1);
            token.size += 1;
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(i+2 < strmax &&
                state->string.str[i] == '"' &&
                state->string.str[i+1] == '"' &&
                state->string.str[i+2] == '"')
        {
            Token token = { i, 1, TokenBaseKind_LiteralString, 0 };
            for(i64 j = i+1; j+2 < (i64)state->string.size &&
                !(state->string.str[j] == '"' &&
                  state->string.str[j+1] == '"' &&
                  state->string.str[j+2] == '"');
                j += 1, token.size += 1);
            token.size += 3;
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(i+2 < strmax &&
                state->string.str[i] == '`' &&
                state->string.str[i+1] == '`' &&
                state->string.str[i+2] == '`')
        {
            Token token = { i, 3, TokenBaseKind_LiteralString, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(i+2 < strmax &&
                state->string.str[i] == '\'' &&
                state->string.str[i+1] == '\'' &&
                state->string.str[i+2] == '\'')
        {
            Token token = { i, 1, TokenBaseKind_LiteralString, 0 };
            for(i64 j = i+1; j+2 < (i64)state->string.size &&
                !(state->string.str[j] == '\'' &&
                  state->string.str[j+1] == '\'' &&
                  state->string.str[j+2] == '\'');
                j += 1, token.size += 1);
            token.size += 3;
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '@')
        {
            Token token = { i, 1, TokenBaseKind_Identifier, 0 };
            token.sub_kind = F4_MD_TokenSubKind_Tag;
            for(i64 j = i+1; j < (i64)state->string.size &&
                (character_is_alpha_numeric(state->string.str[j]) ||
                 state->string.str[j] == '_');
                j += 1, token.size += 1);
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '{')
        {
            Token token = { i, 1, TokenBaseKind_ScopeOpen, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '}')
        {
            Token token = { i, 1, TokenBaseKind_ScopeClose, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == '(' || chr == '[')
        {
            Token token = { i, 1, TokenBaseKind_ParentheticalOpen, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == ')' || chr == ']')
        {
            Token token = { i, 1, TokenBaseKind_ParentheticalClose, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(chr == ',' || chr == ';' || (chr == '-' && i+1 < strmax && state->string.str[i+1] == '>'))
        {
            Token token = { i, 1, TokenBaseKind_StatementClose, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else if(F4_MD_CharIsSymbol(chr))
        {
            Token token = { i, 1, TokenBaseKind_Operator, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }


        else
        {
            Token token = {i, 1, TokenBaseKind_LexError, 0 };
            token_list_push(arena, list, &token);
            i += token.size;
        }

        if(state->at >= state->one_past_last)
        {
            goto eof;
        }
        else if(start_i == i)
        {
            i += 1;
            state->at = state->string.str + i;
        }
        else
        {
            state->at = state->string.str + i;
            emit_counter += 1;
            if(emit_counter >= max)
            {
                goto end;
            }
        }
    }


    eof:;
    {
        result = true;
        Token token = { (i64)state->string.size, 1, TokenBaseKind_EOF, 0 };
        token_list_push(arena, list, &token);
    }

    end:;
    *(F4_MD_LexerState *)state_ptr = *state;
    return result;
}

static F4_Language_PosContextData * F4_MD_PosContext(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos)
{
    return 0;
}

static void F4_MD_Highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, Color_Table color_table)
{
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);

    for(;;)
    {
        Token *token = token_it_read(&it);
        if(!token || token->pos >= visible_range.one_past_last)
        {
            break;
        }
        if(token->sub_kind == F4_MD_TokenSubKind_Tag)
        {
            paint_text_color(app, text_layout_id, Ii64(token), F4_ARGBFromID(color_table, fleury_color_index_comment_tag, 0));
        }
        if(!token_it_inc_all(&it))
        {
            break;
        }
    }
}
# 12 "4coder_fleury_lang_list.h" 2


static void
F4_RegisterLanguages(void)
{

    {
        String_Const_u8 extensions[] =
        {
            SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1)), SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)), SCu8((u8*)("c"), (u64)(sizeof("c") - 1)), SCu8((u8*)("cxx"), (u64)(sizeof("cxx") - 1)),
            SCu8((u8*)("C"), (u64)(sizeof("C") - 1)), SCu8((u8*)("h"), (u64)(sizeof("h") - 1)), SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1)),
        };
        for(int i = 0; i < ((sizeof(extensions))/(sizeof(*extensions))); i += 1)
        {
            _F4_RegisterLanguage(extensions[i], F4_CPP_IndexFile, (F4_Language_LexInit *)lex_full_input_cpp_init, (F4_Language_LexFullInput *)lex_full_input_cpp_breaks, (F4_Language_PosContext *)F4_CPP_PosContext, (F4_Language_Highlight *)F4_CPP_Highlight, sizeof(Lex_State_Cpp))





                                              ;
        }
    }


    {
        _F4_RegisterLanguage(SCu8((u8*)("jai"), (u64)(sizeof("jai") - 1)), F4_Jai_IndexFile, (F4_Language_LexInit *)lex_full_input_jai_init, (F4_Language_LexFullInput *)lex_full_input_jai_breaks, (F4_Language_PosContext *)F4_Jai_PosContext, (F4_Language_Highlight *)F4_Jai_Highlight, sizeof(Lex_State_Jai))





                                          ;
    }


    {
        String_Const_u8 extensions[] =
        {


            SCu8((u8*)("md"), (u64)(sizeof("md") - 1)), SCu8((u8*)("mc"), (u64)(sizeof("mc") - 1)), SCu8((u8*)("metacode"), (u64)(sizeof("metacode") - 1)), SCu8((u8*)("meta"), (u64)(sizeof("meta") - 1)), SCu8((u8*)("metadesk"), (u64)(sizeof("metadesk") - 1)),
        };
        for(int i = 0; i < ((sizeof(extensions))/(sizeof(*extensions))); i += 1)
        {
            _F4_RegisterLanguage(extensions[i], F4_MD_IndexFile, (F4_Language_LexInit *)lex_full_input_cpp_init, (F4_Language_LexFullInput *)lex_full_input_cpp_breaks, (F4_Language_PosContext *)F4_MD_PosContext, (F4_Language_Highlight *)F4_MD_Highlight, sizeof(Lex_State_Cpp))





                                              ;
        }
    }
}
# 139 "4coder_fleury_lang.cpp" 2
# 433 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_index.cpp" 1
static F4_Index_State f4_index = {};

static void
F4_Index_Initialize(void)
{
    f4_index.mutex = system_mutex_make();
    f4_index.arena = make_arena_system(((16) << 10));
}

static void
F4_Index_Lock(void)
{
    system_mutex_acquire(f4_index.mutex);
}

static void
F4_Index_Unlock(void)
{
    system_mutex_release(f4_index.mutex);
}

static u64
_F4_Index_FileHash(Application_Links *app, Buffer_ID id)
{
    Scratch_Block scratch(app);
    String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, id);
    return table_hash_u8(unique_name.str, unique_name.size);
}

static F4_Index_File *
_F4_Index_LookupFile(Application_Links *app, u64 hash, Buffer_ID buffer)
{
    F4_Index_File *result = 0;
    u64 slot = hash % ((sizeof(f4_index.file_table))/(sizeof(*f4_index.file_table)));
    for(F4_Index_File *file = f4_index.file_table[slot]; file; file = file->hash_next)
    {
        if(file->buffer == buffer)
        {
            result = file;
            break;
        }
    }
    return result;
}

static F4_Index_File *
F4_Index_LookupFile(Application_Links *app, Buffer_ID buffer)
{
    return _F4_Index_LookupFile(app, _F4_Index_FileHash(app, buffer), buffer);
}

static F4_Index_File *
F4_Index_LookupOrMakeFile(Application_Links *app, Buffer_ID buffer)
{
    F4_Index_File *result = 0;
    u64 hash = _F4_Index_FileHash(app, buffer);
    u64 slot = hash % ((sizeof(f4_index.file_table))/(sizeof(*f4_index.file_table)));


    {
        result = _F4_Index_LookupFile(app, hash, buffer);
        if(result)
        {
            goto end;
        }
    }


    {
        if(f4_index.free_file)
        {
            result = f4_index.free_file;
            f4_index.free_file = f4_index.free_file->hash_next;
            memset(result, 0, sizeof(*result));
        }
        else
        {
            result = ((F4_Index_File*)linalloc_wrap_zero(linalloc_push((&f4_index.arena), sizeof(F4_Index_File)*(1), SCu8((u8*)("4coder_fleury_index.cpp" ":" "78" ":"), (u64)(sizeof("4coder_fleury_index.cpp" ":" "78" ":") - 1)))));
        }

        if(result != 0)
        {
            result->hash_next = f4_index.file_table[slot];
            f4_index.file_table[slot] = result;
            result->buffer = buffer;
            result->arena = make_arena_system(((16) << 10));
        }
    }

    end:;
    return result;
}

static void
F4_Index_EraseFile(Application_Links *app, Buffer_ID id)
{
    u64 hash = _F4_Index_FileHash(app, id);
    F4_Index_File *file = _F4_Index_LookupFile(app, hash, id);
    if(file)
    {
        u64 slot = hash % ((sizeof(f4_index.file_table))/(sizeof(*f4_index.file_table)));
        {
            F4_Index_File *prev = 0;
            for(F4_Index_File *hash_file = f4_index.file_table[slot]; hash_file; prev = hash_file, hash_file = hash_file->hash_next)
            {
                if(file == hash_file)
                {
                    if(prev)
                    {
                        prev->hash_next = file->hash_next;
                    }
                    else
                    {
                        f4_index.file_table[slot] = file->hash_next;
                    }
                    break;
                }
            }
        }
        file->hash_next = f4_index.free_file;
        f4_index.free_file = file;
    }
}

static void
_F4_Index_FreeNoteTree(F4_Index_Note *note)
{
    for(F4_Index_Note *child = note->first_child; child; child = child->next_sibling)
    {
        _F4_Index_FreeNoteTree(child);
    }

    F4_Index_Note *prev = note->prev;
    F4_Index_Note *next = note->next;
    F4_Index_Note *hash_prev = note->hash_prev;
    F4_Index_Note *hash_next = note->hash_next;

    u64 hash = note->hash;
    u64 slot = hash % ((sizeof(f4_index.note_table))/(sizeof(*f4_index.note_table)));

    if(prev)
    {
        prev->next = next;
    }
    if(next)
    {
        next->prev = prev;
    }

    if(prev == 0)
    {
        if(next)
        {
            next->hash_prev = hash_prev;
            next->hash_next = hash_next;
            if(hash_prev)
            {
                hash_prev->hash_next = next;
            }
            if(hash_next)
            {
                hash_next->hash_prev = next;
            }
        }
        else
        {
            if(hash_prev)
            {
                hash_prev->hash_next = hash_next;
            }
            if(hash_next)
            {
                hash_next->hash_prev = hash_prev;
            }
        }

        if(hash_prev == 0)
        {
            f4_index.note_table[slot] = next ? next : hash_next;
        }
    }
}

static void
F4_Index_ClearFile(F4_Index_File *file)
{
    if(file)
    {
        file->generation += 1;
        for(F4_Index_Note *note = file->first_note;
            note; note = note->next_sibling)
        {
            _F4_Index_FreeNoteTree(note);
        }
        linalloc_clear(&file->arena);
        file->first_note = file->last_note = 0;
    }
}

static F4_Index_Note *
F4_Index_LookupNote(String_Const_u8 string, F4_Index_Note *parent)
{
    F4_Index_Note *result = 0;
    u64 hash = table_hash_u8(string.str, string.size);
    u64 slot = hash % ((sizeof(f4_index.note_table))/(sizeof(*f4_index.note_table)));
    for(F4_Index_Note *note = f4_index.note_table[slot]; note; note = note->hash_next)
    {
        if(note->hash == hash && note->parent == parent)
        {
            if(string_match(string, note->string))
            {
                result = note;
                break;
            }
        }
    }
    return result;
}

static F4_Index_Note *
F4_Index_LookupNote(String_Const_u8 string)
{
    return F4_Index_LookupNote(string, 0);
}

static F4_Index_Note *
F4_Index_AllocateNote(void)
{
    F4_Index_Note *result = 0;
    if(f4_index.free_note)
    {
        result = f4_index.free_note;
        f4_index.free_note = f4_index.free_note->hash_next;
        memset(result, 0, sizeof(*result));
    }
    else
    {
        result = ((F4_Index_Note*)linalloc_wrap_zero(linalloc_push((&f4_index.arena), sizeof(F4_Index_Note)*(1), SCu8((u8*)("4coder_fleury_index.cpp" ":" "238" ":"), (u64)(sizeof("4coder_fleury_index.cpp" ":" "238" ":") - 1)))));
    }
    return result;
}

static void
F4_Index_InsertNote(F4_Index_ParseCtx *ctx, F4_Index_Note *note, Range_i64 name_range, F4_Index_NoteKind note_kind, F4_Index_NoteFlags note_flags)
{
    F4_Index_File *file = ctx->file;
    F4_Index_Note *parent = ctx->active_parent;
    String_Const_u8 string = F4_Index_StringFromRange(ctx, name_range);
    Range_i64 range = name_range;

    if(file)
    {
        u64 hash = table_hash_u8(string.str, string.size);
        u64 slot = hash % ((sizeof(f4_index.note_table))/(sizeof(*f4_index.note_table)));


        {
            F4_Index_Note *list_head = F4_Index_LookupNote(string);
            F4_Index_Note *list_tail = list_head;
            for(F4_Index_Note *note = list_tail; note; list_tail = note, note = note->next);
            if(list_tail != 0)
            {
                list_tail->next = note;
                note->prev = list_tail;
                note->hash_next = 0;
                note->hash_prev = 0;
            }
            else
            {
                note->hash_next = f4_index.note_table[slot];
                if(f4_index.note_table[slot])
                {
                    f4_index.note_table[slot]->hash_prev = note;
                }
                f4_index.note_table[slot] = note;
                note->hash_prev = 0;
                note->prev = 0;
            }
        }
        note->next = 0;


        {
            note->parent = parent;
            if(parent)
            {
                note->prev_sibling = parent->last_child;
                note->next_sibling = 0;
                if(parent->last_child == 0)
                {
                    parent->first_child = parent->last_child = note;
                }
                else
                {
                    parent->last_child->next_sibling = note;
                    parent->last_child = parent->last_child->next_sibling;
                }
            }
            else
            {
                note->prev_sibling = file->last_note;
                note->next_sibling = 0;
                if(file->last_note == 0)
                {
                    file->first_note = file->last_note = note;
                }
                else
                {
                    file->last_note->next_sibling = note;
                    file->last_note = file->last_note->next_sibling;
                }
            }
        }


        {
            note->hash = hash;
            note->string = push_string_copy(&file->arena, string);
            note->kind = note_kind;
            note->flags = note_flags;
            note->range = range;
            note->file = file;
            note->file_generation = file->generation;
        }
    }
}

static F4_Index_Note *
F4_Index_MakeNote(F4_Index_ParseCtx *ctx, Range_i64 name_range, F4_Index_NoteKind note_kind, F4_Index_NoteFlags note_flags)
{
    F4_Index_Note *result = F4_Index_AllocateNote();
    F4_Index_InsertNote(ctx, result, name_range, note_kind, note_flags);
    return result;
}

static void
_F4_Index_Parse(Application_Links *app, F4_Index_File *file, String_Const_u8 string, Token_Array tokens, F4_Language *language)
{
    F4_Index_ParseCtx ctx =
    {
        false,
        app,
        file,
        string,
        tokens,
        token_iterator_pos(0, &ctx.tokens, 0),
    };
    if(language != 0)
    {
        language->IndexFile(&ctx);
    }
}

static void
F4_Index_ParseFile(Application_Links *app, F4_Index_File *file, String_Const_u8 string, Token_Array tokens)
{
    F4_Index_Lock();
    F4_Language *lang = F4_LanguageFromBuffer(app, file->buffer);
    _F4_Index_Parse(app, file, string, tokens, lang);
    F4_Index_Unlock();
}

static String_Const_u8
F4_Index_StringFromRange(F4_Index_ParseCtx *ctx, Range_i64 range)
{
    String_Const_u8 string = string_substring(ctx->string, range);
    return string;
}

static String_Const_u8
F4_Index_StringFromToken(F4_Index_ParseCtx *ctx, Token *token)
{
    return F4_Index_StringFromRange(ctx, Ii64(token));
}

static F4_Index_Note *
F4_Index_PushParent(F4_Index_ParseCtx *ctx, F4_Index_Note *new_parent)
{
    F4_Index_Note *n = ctx->active_parent;
    ctx->active_parent = new_parent;
    return n;
}

static void
F4_Index_PopParent(F4_Index_ParseCtx *ctx, F4_Index_Note *last_parent)
{
    ctx->active_parent = last_parent;
}

static b32
F4_Index_ParseCtx_Inc(F4_Index_ParseCtx *ctx, F4_Index_TokenSkipFlags flags)
{
    if(flags & F4_Index_TokenSkipFlag_SkipWhitespace)
    {
        ctx->done = !token_it_inc_non_whitespace(&ctx->it);
    }
    else
    {
        ctx->done = !token_it_inc_all(&ctx->it);
    }
    return ctx->done;
}

static b32
F4_Index_RequireToken(F4_Index_ParseCtx *ctx, String_Const_u8 string, F4_Index_TokenSkipFlags flags)
{
    b32 result = 0;
    Token *token = token_it_read(&ctx->it);
    if(token)
    {
        String_Const_u8 token_string =
            string_substring(ctx->string, Ii64(token->pos, token->pos+token->size));
        if(string_match(string, token_string))
        {
            result = 1;
        }
    }
    else
    {
        ctx->done = 1;
    }
    if(result)
    {
        F4_Index_ParseCtx_Inc(ctx, flags);
    }
    return result;
}

static b32
F4_Index_RequireTokenKind(F4_Index_ParseCtx *ctx, Token_Base_Kind kind, Token **token_out, F4_Index_TokenSkipFlags flags)
{
    b32 result = 0;
    Token *token = token_it_read(&ctx->it);
    if(token)
    {
        if(token->kind == kind)
        {
            result = 1;
            if(token_out)
            {
                *token_out = token;
            }
        }
    }
    else
    {
        ctx->done = 1;
    }if(result)
    {
        F4_Index_ParseCtx_Inc(ctx, flags);
    }
    return result;
}

static b32
F4_Index_RequireTokenSubKind(F4_Index_ParseCtx *ctx, int sub_kind, Token **token_out, F4_Index_TokenSkipFlags flags)
{
    b32 result = 0;
    Token *token = token_it_read(&ctx->it);
    if(token)
    {
        if(token->sub_kind == sub_kind)
        {
            result = 1;
            if(token_out)
            {
                *token_out = token;
            }
        }
    }
    else
    {
        ctx->done = 1;
    }if(result)
    {
        F4_Index_ParseCtx_Inc(ctx, flags);
    }
    return result;
}

static b32
F4_Index_PeekToken(F4_Index_ParseCtx *ctx, String_Const_u8 string)
{
    b32 result = 0;
    Token *token = token_it_read(&ctx->it);
    if(token)
    {
        String_Const_u8 token_string =
            string_substring(ctx->string, Ii64(token->pos, token->pos+token->size));
        if(string_match(string, token_string))
        {
            result = 1;
        }
    }
    else
    {
        ctx->done = 1;
    }
    return result;
}

static void
F4_Index_ParseComment(F4_Index_ParseCtx *ctx, Token *token)
{
    String_Const_u8 string = F4_Index_StringFromToken(ctx, token);

    for(u64 i = 0; i < string.size; i += 1)
    {
        if(string.str[i] == '@')
        {
            Range_i64 range = Ii64(token);
            range.min += i;
            F4_Index_MakeNote(ctx, range, F4_Index_NoteKind_CommentTag, 0);
            break;
        }
        else if(i+4 < string.size && string_match(SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), string_substring(string, Ii64(i, i + 4))))
        {
            Range_i64 range = Ii64(token);
            range.min += i;
            F4_Index_MakeNote(ctx, range, F4_Index_NoteKind_CommentToDo, 0);
        }
    }
}

static void
F4_Index_SkipSoftTokens(F4_Index_ParseCtx *ctx, b32 preproc)
{
    for(;!ctx->done;)
    {
        Token *token = token_it_read(&ctx->it);
        if(preproc)
        {
            if(!(token->flags & TokenBaseFlag_PreprocessorBody) ||
               token->kind == TokenBaseKind_Preprocessor)
            {
                break;
            }
        }
        else
        {
            if(token->kind == TokenBaseKind_StatementClose ||
               token->kind == TokenBaseKind_ScopeOpen ||
               token->kind == TokenBaseKind_ParentheticalOpen)
            {
                break;
            }
        }
        if(!token_it_inc_non_whitespace(&ctx->it))
        {
            break;
        }
    }
}

static void
F4_Index_SkipOpTokens(F4_Index_ParseCtx *ctx)
{
    int paren_nest = 0;
    for(;!ctx->done;)
    {
        Token *token = token_it_read(&ctx->it);
        if(token->kind == TokenBaseKind_ParentheticalOpen)
        {
            paren_nest += 1;
        }
        else if(token->kind == TokenBaseKind_ParentheticalClose)
        {
            paren_nest -= 1;
            if(paren_nest < 0)
            {
                paren_nest = 0;
            }
        }
        else if(token->kind != TokenBaseKind_Operator && paren_nest == 0)
        {
            break;
        }
        F4_Index_ParseCtx_Inc(ctx, F4_Index_TokenSkipFlag_SkipWhitespace);
    }
}

static b32
F4_Index_ParsePattern(F4_Index_ParseCtx *ctx, char *fmt, ...)
{
    b32 parsed = 1;

    F4_Index_ParseCtx ctx_restore = *ctx;
    F4_Index_TokenSkipFlags flags = F4_Index_TokenSkipFlag_SkipWhitespace;

    va_list args;
    
# 591 "4coder_fleury_index.cpp" 3 4
   __builtin_va_start(
# 591 "4coder_fleury_index.cpp"
   args
# 591 "4coder_fleury_index.cpp" 3 4
   ,
# 591 "4coder_fleury_index.cpp"
   fmt
# 591 "4coder_fleury_index.cpp" 3 4
   )
# 591 "4coder_fleury_index.cpp"
                      ;
    for(int i = 0; fmt[i];)
    {
        if(fmt[i] == '%')
        {
            switch(fmt[i+1])
            {
                case 't':
                {
                    char *cstring = 
# 600 "4coder_fleury_index.cpp" 3 4
                                   __builtin_va_arg(
# 600 "4coder_fleury_index.cpp"
                                   args
# 600 "4coder_fleury_index.cpp" 3 4
                                   ,
# 600 "4coder_fleury_index.cpp"
                                   char *
# 600 "4coder_fleury_index.cpp" 3 4
                                   )
# 600 "4coder_fleury_index.cpp"
                                                       ;
                    String8 string = SCu8((u8 *)cstring, cstring_length(cstring));
                    parsed = parsed && F4_Index_RequireToken(ctx, string, flags);
                }break;

                case 'k':
                {
                    Token_Base_Kind kind = (Token_Base_Kind)
# 607 "4coder_fleury_index.cpp" 3 4
                                                           __builtin_va_arg(
# 607 "4coder_fleury_index.cpp"
                                                           args
# 607 "4coder_fleury_index.cpp" 3 4
                                                           ,
# 607 "4coder_fleury_index.cpp"
                                                           int
# 607 "4coder_fleury_index.cpp" 3 4
                                                           )
# 607 "4coder_fleury_index.cpp"
                                                                            ;
                    Token **output_token = 
# 608 "4coder_fleury_index.cpp" 3 4
                                          __builtin_va_arg(
# 608 "4coder_fleury_index.cpp"
                                          args
# 608 "4coder_fleury_index.cpp" 3 4
                                          ,
# 608 "4coder_fleury_index.cpp"
                                          Token **
# 608 "4coder_fleury_index.cpp" 3 4
                                          )
# 608 "4coder_fleury_index.cpp"
                                                                ;
                    parsed = parsed && F4_Index_RequireTokenKind(ctx, kind, output_token, flags);
                }break;

                case 'b':
                {
                    i16 kind = (i16)
# 614 "4coder_fleury_index.cpp" 3 4
                                   __builtin_va_arg(
# 614 "4coder_fleury_index.cpp"
                                   args
# 614 "4coder_fleury_index.cpp" 3 4
                                   ,
# 614 "4coder_fleury_index.cpp"
                                   int
# 614 "4coder_fleury_index.cpp" 3 4
                                   )
# 614 "4coder_fleury_index.cpp"
                                                    ;
                    Token **output_token = 
# 615 "4coder_fleury_index.cpp" 3 4
                                          __builtin_va_arg(
# 615 "4coder_fleury_index.cpp"
                                          args
# 615 "4coder_fleury_index.cpp" 3 4
                                          ,
# 615 "4coder_fleury_index.cpp"
                                          Token **
# 615 "4coder_fleury_index.cpp" 3 4
                                          )
# 615 "4coder_fleury_index.cpp"
                                                                ;
                    parsed = parsed && F4_Index_RequireTokenSubKind(ctx, kind, output_token, flags);
                }break;

                case 'n':
                {
                    F4_Index_NoteKind kind = (F4_Index_NoteKind)
# 621 "4coder_fleury_index.cpp" 3 4
                                                               __builtin_va_arg(
# 621 "4coder_fleury_index.cpp"
                                                               args
# 621 "4coder_fleury_index.cpp" 3 4
                                                               ,
# 621 "4coder_fleury_index.cpp"
                                                               int
# 621 "4coder_fleury_index.cpp" 3 4
                                                               )
# 621 "4coder_fleury_index.cpp"
                                                                                ;
                    F4_Index_Note **output_note = 
# 622 "4coder_fleury_index.cpp" 3 4
                                                 __builtin_va_arg(
# 622 "4coder_fleury_index.cpp"
                                                 args
# 622 "4coder_fleury_index.cpp" 3 4
                                                 ,
# 622 "4coder_fleury_index.cpp"
                                                 F4_Index_Note **
# 622 "4coder_fleury_index.cpp" 3 4
                                                 )
# 622 "4coder_fleury_index.cpp"
                                                                               ;
                    Token *token = 0;
                    parsed = parsed && F4_Index_RequireTokenKind(ctx, TokenBaseKind_Identifier, &token, flags);
                    parsed = parsed && !!token;
                    if (parsed)
                    {
                        String8 token_string = F4_Index_StringFromToken(ctx, token);
                        F4_Index_Note *note = F4_Index_LookupNote(token_string, 0);
                        b32 kind_match = 0;
                        for(F4_Index_Note *n = note; n; n = n->next)
                        {
                            if(n->kind == kind)
                            {
                                kind_match = 1;
                                note = n;
                                break;
                            }
                        }
                        if (note && kind_match)
                        {
                            *output_note = note;
                            parsed = 1;
                        }
                        else
                        {
                            parsed = 0;
                        }
                    }
                }break;

                case 's':
                {
                    F4_Index_SkipSoftTokens(ctx, 0);
                }break;

                case 'o':
                {
                    F4_Index_SkipOpTokens(ctx);
                }break;

                default: break;
            }
            i += 1;
        }
        else
        {
            i += 1;
        }
    }

    
# 672 "4coder_fleury_index.cpp" 3 4
   __builtin_va_end(
# 672 "4coder_fleury_index.cpp"
   args
# 672 "4coder_fleury_index.cpp" 3 4
   )
# 672 "4coder_fleury_index.cpp"
               ;

    if(parsed == 0)
    {
        *ctx = ctx_restore;
    }
    return parsed;
}

static void
F4_Index_Tick(Application_Links *app)
{
    Scratch_Block scratch(app);
    for (Buffer_Modified_Node *node = global_buffer_modified_set.first; node != 0;node = node->next)
    {
        Temp_Memory_Block temp(scratch);
        Buffer_ID buffer_id = node->buffer;

        String_Const_u8 contents = push_whole_buffer(app, scratch, buffer_id);
        Token_Array tokens = get_token_array_from_buffer(app, buffer_id);
        if(tokens.count == 0) { continue; }

        F4_Index_Lock();
        F4_Index_File *file = F4_Index_LookupOrMakeFile(app, buffer_id);
        if(file)
        {
            Profile_Scope_Block profile_block_698 ((app), SCu8((u8*)("[f] reparse"), (u64)(sizeof("[f] reparse") - 1)), SCu8((u8*)("4coder_fleury_index.cpp" ":" "698" ":"), (u64)(sizeof("4coder_fleury_index.cpp" ":" "698" ":") - 1)));
            F4_Index_ClearFile(file);
            F4_Index_ParseFile(app, file, contents, tokens);
        }
        F4_Index_Unlock();
        buffer_clear_layout_cache(app, buffer_id);
    }
}
# 434 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_colors.cpp" 1

typedef u32 F4_SyntaxFlags;
enum
{
    F4_SyntaxFlag_Functions = (1<<0),
    F4_SyntaxFlag_Macros = (1<<1),
    F4_SyntaxFlag_Types = (1<<2),
    F4_SyntaxFlag_Operators = (1<<3),
    F4_SyntaxFlag_Constants = (1<<4),
    F4_SyntaxFlag_Literals = (1<<5),
    F4_SyntaxFlag_Preprocessor = (1<<6),
    F4_SyntaxFlag_Keywords = (1<<7),
    F4_SyntaxFlag_HighlightAll = (1<<15),
};


struct F4_SyntaxOptions
{
    String8 name;
    F4_SyntaxFlags flags;
};

static f32 f4_syntax_flag_transitions[32] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,};
static F4_SyntaxOptions f4_syntax_opts[] =
{
    { SCu8((u8*)("All"), (u64)(sizeof("All") - 1)), 0xffffffff },
    { SCu8((u8*)("None"), (u64)(sizeof("None") - 1)), 0 },
    { SCu8((u8*)("Functions Only"), (u64)(sizeof("Functions Only") - 1)), F4_SyntaxFlag_Functions },
    { SCu8((u8*)("Macros Only"), (u64)(sizeof("Macros Only") - 1)), F4_SyntaxFlag_Macros },
    { SCu8((u8*)("Function-Likes Only"), (u64)(sizeof("Function-Likes Only") - 1)), F4_SyntaxFlag_Functions | F4_SyntaxFlag_Macros },
    { SCu8((u8*)("Types Only"), (u64)(sizeof("Types Only") - 1)), F4_SyntaxFlag_Types },
    { SCu8((u8*)("Externals Only"), (u64)(sizeof("Externals Only") - 1)), F4_SyntaxFlag_Functions | F4_SyntaxFlag_Macros | F4_SyntaxFlag_Types | F4_SyntaxFlag_Constants },
};
static i32 f4_active_syntax_opt_idx = 0;

static b32
F4_ARGBIsValid(ARGB_Color color)
{
    return color != 0xFF990099;
}

static void
F4_TickColors(Application_Links *app, Frame_Info frame_info)
{
    F4_SyntaxOptions opts = f4_syntax_opts[f4_active_syntax_opt_idx];
    for(int i = 0; i < sizeof(F4_SyntaxFlags)*8; i += 1)
    {
        f32 delta = ((f32)!!(opts.flags & (1<<i)) - f4_syntax_flag_transitions[i]) * frame_info.animation_dt * 8.f;
        f4_syntax_flag_transitions[i] += delta;
        if(fabsf(delta) > 0.001f)
        {
            animate_in_n_milliseconds(app, 0);
        }
    }
}

CUSTOM_COMMAND(f4_switch_syntax_option, "4coder_fleury_colors.cpp", 57, Normal)
CUSTOM_DOC("Switches the syntax highlighting mode.")
{
    f4_active_syntax_opt_idx = (f4_active_syntax_opt_idx + 1) % ((sizeof(f4_syntax_opts))/(sizeof(*f4_syntax_opts)));
}

static String8
F4_SyntaxOptionString(void)
{
    return f4_syntax_opts[f4_active_syntax_opt_idx].name;
}

typedef u32 ColorFlags;
enum
{
    ColorFlag_Macro = (1<<0),
    ColorFlag_PowerMode = (1<<1),
};

struct ColorCtx
{
    Token token;
    Buffer_ID buffer;
    ColorFlags flags;
    keybinding_mode mode;
};

static ColorCtx
ColorCtx_Token(Token token, Buffer_ID buffer)
{
    ColorCtx ctx = {0};
    ctx.token = token;
    ctx.buffer = buffer;
    return ctx;
}

static ColorCtx
ColorCtx_Cursor(ColorFlags flags, keybinding_mode mode)
{
    ColorCtx ctx = {0};
    ctx.flags = flags;
    ctx.mode = mode;
    return ctx;
}

static ARGB_Color
F4_ARGBFromID(Color_Table table, Managed_ID id, int subindex)
{
    ARGB_Color result = 0;
    FColor color = fcolor_id(id);
    if (color.a_byte == 0){
        if (color.id != 0){
            result = finalize_color(table, color.id, subindex);
        }
    }
    else{
        result = color.argb;
    }
    return(result);
}

static ARGB_Color
F4_ARGBFromID(Color_Table table, Managed_ID id)
{
    return F4_ARGBFromID(table, id, 0);
}

static ARGB_Color
F4_GetColor(Application_Links *app, ColorCtx ctx)
{
    Color_Table table = active_color_table;
    ARGB_Color default_color = F4_ARGBFromID(table, defcolor_text_default);
    ARGB_Color color = default_color;
    f32 t = 1;




    if(ctx.token.size != 0)
    {
        Scratch_Block scratch(app);

        switch(ctx.token.kind)
        {
            case TokenBaseKind_Identifier:
            {
                String_Const_u8 string = push_buffer_range(app, scratch, ctx.buffer, Ii64(ctx.token.pos, ctx.token.pos + ctx.token.size));
                F4_Index_Note *note = F4_Index_LookupNote(string);
                if(note)
                {
                    color = 0xffff0000;
                    switch(note->kind)
                    {
                        case F4_Index_NoteKind_Type:
                        {
                            do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Types)]; }while(0);
                            color = F4_ARGBFromID(table,
                                                  note->flags & F4_Index_NoteFlag_SumType
                                                  ? fleury_color_index_sum_type
                                                  : fleury_color_index_product_type);
                        }break;

                        case F4_Index_NoteKind_Macro:
                        {
                            do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Macros)]; }while(0);
                            color = F4_ARGBFromID(table, fleury_color_index_macro);
                        }break;

                        case F4_Index_NoteKind_Function:
                        {
                            do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Functions)]; }while(0);
                            color = F4_ARGBFromID(table, fleury_color_index_function);
                        }break;

                        case F4_Index_NoteKind_Constant:
                        {
                            do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Constants)]; }while(0);
                            color = F4_ARGBFromID(table, fleury_color_index_constant);
                        }break;

                        case F4_Index_NoteKind_Decl:
                        {
                            do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Constants)]; }while(0);
                            color = F4_ARGBFromID(table, fleury_color_index_decl);
                        }break;

                        default: color = 0xffff00ff; break;
                    }

                    if(!F4_ARGBIsValid(color)) { color = default_color; }
                }

            }break;

            case TokenBaseKind_Preprocessor: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Preprocessor)]; }while(0); color = F4_ARGBFromID(table, defcolor_preproc); } break;
            case TokenBaseKind_Keyword: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Keywords)]; }while(0); color = F4_ARGBFromID(table, defcolor_keyword); } break;
            case TokenBaseKind_Comment: { color = F4_ARGBFromID(table, defcolor_comment); } break;
            case TokenBaseKind_LiteralString: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0); color = F4_ARGBFromID(table, defcolor_str_constant); } break;
            case TokenBaseKind_LiteralInteger: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0); color = F4_ARGBFromID(table, defcolor_int_constant); } break;
            case TokenBaseKind_LiteralFloat: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0); color = F4_ARGBFromID(table, defcolor_float_constant); } break;
            case TokenBaseKind_Operator: { do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Operators)]; }while(0); color = F4_ARGBFromID(table, fleury_color_operators); if(!F4_ARGBIsValid(color)) { color = default_color; } } break;

            case TokenBaseKind_ScopeOpen:
            case TokenBaseKind_ScopeClose:
            case TokenBaseKind_ParentheticalOpen:
            case TokenBaseKind_ParentheticalClose:
            case TokenBaseKind_StatementClose:
            {
                color = F4_ARGBFromID(table, fleury_color_syntax_crap);
                if(!F4_ARGBIsValid(color)) { color = default_color; }
                break;
            }

            default:
            {
                switch(ctx.token.sub_kind)
                {
                    case TokenCppKind_LiteralTrue:
                    case TokenCppKind_LiteralFalse:
                    {
                        color = F4_ARGBFromID(table, defcolor_bool_constant);
                        do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0);
                        break;
                    }
                    case TokenCppKind_LiteralCharacter:
                    case TokenCppKind_LiteralCharacterWide:
                    case TokenCppKind_LiteralCharacterUTF8:
                    case TokenCppKind_LiteralCharacterUTF16:
                    case TokenCppKind_LiteralCharacterUTF32:
                    {
                        color = F4_ARGBFromID(table, defcolor_char_constant);
                        do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0);
                        break;
                    }
                    case TokenCppKind_PPIncludeFile:
                    {
                        color = F4_ARGBFromID(table, defcolor_include);
                        do{ t = f4_syntax_flag_transitions[BitOffset(F4_SyntaxFlag_Literals)]; }while(0);
                        break;
                    }
                }
            }break;

        }
    }


    else
    {
        if(ctx.flags & ColorFlag_Macro)
        {
            color = F4_ARGBFromID(table, fleury_color_cursor_macro);
        }
        else if(ctx.flags & ColorFlag_PowerMode)
        {
            color = F4_ARGBFromID(table, fleury_color_cursor_power_mode);
        }
        else
        {
            color = F4_ARGBFromID(table, defcolor_cursor, ctx.mode);
        }
    }

    return color_blend(default_color, t, color);
}

static void
F4_SyntaxHighlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array)
{
    Color_Table table = active_color_table;
    Buffer_ID buffer = text_layout_get_buffer(app, text_layout_id);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);
    ARGB_Color comment_tag_color = F4_ARGBFromID(table, fleury_color_index_comment_tag, 0);

    for(;;)
    {
        Token *token = token_it_read(&it);
        if(!token || token->pos >= visible_range.one_past_last)
        {
            break;
        }
        ARGB_Color argb = F4_GetColor(app, ColorCtx_Token(*token, buffer));
        paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), argb);


        if(F4_ARGBIsValid(comment_tag_color))
        {
            if(token->kind == TokenBaseKind_Comment)
            {
                Scratch_Block scratch(app);
                String_Const_u8 string = push_buffer_range(app, scratch, buffer, Ii64(token->pos, token->pos + token->size));
                for(u64 i = 0; i < string.size; i += 1)
                {
                    if(string.str[i] == '@')
                    {
                        u64 j = i+1;
                        for(; j < string.size; j += 1)
                        {
                            if(character_is_whitespace(string.str[j]))
                            {
                                break;
                            }
                        }
                        paint_text_color(app, text_layout_id, Ii64(token->pos + (i64)i, token->pos + (i64)j), comment_tag_color);
                    }
                }
            }
        }

        if(!token_it_inc_all(&it))
        {
            break;
        }
    }

    F4_Language *lang = F4_LanguageFromBuffer(app, buffer);
    if(lang != 0 && lang->Highlight != 0)
    {
        lang->Highlight(app, text_layout_id, array, table);
    }

}
# 435 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_render_helpers.cpp" 1
static F4_Flash f4_flashes[64];

static void
F4_DrawTooltipRect(Application_Links *app, Rect_f32 rect)
{
    ARGB_Color background_color = fcolor_resolve(fcolor_id(defcolor_back));
    ARGB_Color border_color = fcolor_resolve(fcolor_id(defcolor_margin_active));

    background_color &= 0x00ffffff;
    background_color |= 0xd0000000;

    border_color &= 0x00ffffff;
    border_color |= 0xd0000000;

    draw_rectangle(app, rect, 4.f, background_color);
    draw_rectangle_outline(app, rect, 4.f, 3.f, border_color);
}

static void
F4_RenderRangeHighlight(Application_Links *app, View_ID view_id, Text_Layout_ID text_layout_id,
                        Range_i64 range, F4_RangeHighlightKind kind, ARGB_Color color)
{
    Rect_f32 range_start_rect = text_layout_character_on_screen(app, text_layout_id, range.start);
    Rect_f32 range_end_rect = text_layout_character_on_screen(app, text_layout_id, range.end-1);
    Rect_f32 total_range_rect = {0};
    total_range_rect.x0 = MinimumF32(range_start_rect.x0, range_end_rect.x0);
    total_range_rect.y0 = MinimumF32(range_start_rect.y0, range_end_rect.y0);
    total_range_rect.x1 = MaximumF32(range_start_rect.x1, range_end_rect.x1);
    total_range_rect.y1 = MaximumF32(range_start_rect.y1, range_end_rect.y1);

    switch (kind) {
        case F4_RangeHighlightKind_Underline: {
            total_range_rect.y0 = total_range_rect.y1 - 1.f;
            total_range_rect.y1 += 1.f;
        } break;

        case F4_RangeHighlightKind_MinorUnderline: {
            total_range_rect.y0 = total_range_rect.y1 - 1.f;
            total_range_rect.y1 += 1.f;
        }
    }
    draw_rectangle(app, total_range_rect, 4.f, color);
}

static void
F4_PushTooltip(String_Const_u8 string, ARGB_Color color)
{
    if(global_tooltip_count < ((sizeof(global_tooltips))/(sizeof(*global_tooltips))))
    {
        String_Const_u8 string_copy = push_string_copy(&global_frame_arena, string);
        global_tooltips[global_tooltip_count].color = color;
        global_tooltips[global_tooltip_count].string = string_copy;
        global_tooltip_count += 1;
    }
}

static void
F4_PushFlash(Application_Links *app, Buffer_ID buffer, Range_i64 range, ARGB_Color color, f32 decay_rate)
{
    F4_Flash *flash = 0;
    for(int i = 0; i < ((sizeof(f4_flashes))/(sizeof(*f4_flashes))); i += 1)
    {
        if(f4_flashes[i].active == 0)
        {
            flash = f4_flashes + i;
            break;
        }
    }
    if(flash)
    {
        flash->active = 1;
        flash->t = 1;
        flash->buffer = buffer;
        flash->range = range;
        flash->color = color;
        flash->decay_rate = decay_rate;
    }
}

static void
F4_UpdateFlashes(Application_Links *app, Frame_Info frame)
{
    for(int i = 0; i < ((sizeof(f4_flashes))/(sizeof(*f4_flashes))); i += 1)
    {
        F4_Flash *flash = f4_flashes + i;
        if(flash->active)
        {
            animate_in_n_milliseconds(app, 0);
            flash->t += (0 - flash->t) * flash->decay_rate * frame.animation_dt;
            if(flash->t <= 0.05f)
            {
                flash->active = 0;
            }
        }
    }
}

static void
F4_RenderFlashes(Application_Links *app, View_ID view, Text_Layout_ID text_layout)
{
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    for(int i = 0; i < ((sizeof(f4_flashes))/(sizeof(*f4_flashes))); i += 1)
    {
        F4_Flash *flash = f4_flashes + i;
        if(flash->active && flash->buffer == buffer)
        {
            F4_RenderRangeHighlight(app, view, text_layout, flash->range, F4_RangeHighlightKind_Whole,
                                    argb_color_blend(flash->color, flash->t, 0, 1-flash->t));
        }
    }
}
# 436 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_brace.cpp" 1



static void
F4_Brace_RenderHighlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                         i64 pos, ARGB_Color *colors, i32 color_count)
{
    if(!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_brace_highlight"), (u64)(sizeof("f4_disable_brace_highlight") - 1)))))
    {
        Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("[F4] Brace Highlight"), (u64)(sizeof("[F4] Brace Highlight") - 1)), SCu8((u8*)("4coder_fleury_brace.cpp" ":" "10" ":"), (u64)(sizeof("4coder_fleury_brace.cpp" ":" "10" ":") - 1)));
        Token_Array token_array = get_token_array_from_buffer(app, buffer);
        if (token_array.tokens != 0)
        {
            Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
            Token *token = token_it_read(&it);
            if(token != 0 && token->kind == TokenBaseKind_ScopeOpen)
            {
                pos = token->pos + token->size;
            }
            else
            {
                if(token_it_dec_all(&it))
                {
                    token = token_it_read(&it);
                    if (token->kind == TokenBaseKind_ScopeClose &&
                        pos == token->pos + token->size)
                    {
                        pos = token->pos;
                    }
                }
            }
        }
        draw_enclosures(app, text_layout_id, buffer,
                        pos, FindNest_Scope,
                        RangeHighlightKind_CharacterHighlight,
                        0, 0, colors, color_count);
    }
}



static void
F4_Brace_RenderCloseBraceAnnotation(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                    i64 pos)
{
    if(!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_close_brace_annotation"), (u64)(sizeof("f4_disable_close_brace_annotation") - 1)))))
    {
        Profile_Scope_Block profile_block_48 ((app), SCu8((u8*)("[F4] Brace Annotation"), (u64)(sizeof("[F4] Brace Annotation") - 1)), SCu8((u8*)("4coder_fleury_brace.cpp" ":" "48" ":"), (u64)(sizeof("4coder_fleury_brace.cpp" ":" "48" ":") - 1)));

        Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
        Token_Array token_array = get_token_array_from_buffer(app, buffer);
        Face_ID face_id = global_small_code_face;

        if(token_array.tokens != 0)
        {
            Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
            Token *token = token_it_read(&it);

            if(token != 0 && token->kind == TokenBaseKind_ScopeOpen)
            {
                pos = token->pos + token->size;
            }
            else if(token_it_dec_all(&it))
            {
                token = token_it_read(&it);
                if (token->kind == TokenBaseKind_ScopeClose &&
                    pos == token->pos + token->size)
                {
                    pos = token->pos;
                }
            }
        }

        Scratch_Block scratch(app);
        Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, RangeHighlightKind_CharacterHighlight);

        for (i32 i = ranges.count - 1; i >= 0; i -= 1)
        {
            Range_i64 range = ranges.ranges[i];
# 89 "4coder_fleury_brace.cpp"
            if (get_line_number_from_pos(app, buffer, range.start) == get_line_number_from_pos(app, buffer, range.end))
            {
                continue;
            }


            i64 line = get_line_number_from_pos(app, buffer, range.end);
            i64 last_char = get_line_end_pos(app, buffer, line)-1;

            Rect_f32 close_scope_rect = text_layout_character_on_screen(app, text_layout_id, last_char);
            Vec2_f32 close_scope_pos = { close_scope_rect.x0 + 12, close_scope_rect.y0 };


            Token *start_token = 0;
            i64 token_count = 0;
            {
                Token_Iterator_Array it = token_iterator_pos(0, &token_array, range.start-1);
                int paren_nest = 0;

                for(;;)
                {
                    Token *token = token_it_read(&it);

                    if(token)
                    {
                        token_count += 1;

                        if(token->kind == TokenBaseKind_ParentheticalClose)
                        {
                            ++paren_nest;
                        }
                        else if(token->kind == TokenBaseKind_ParentheticalOpen)
                        {
                            --paren_nest;
                        }
                        else if(paren_nest == 0 &&
                                (token->kind == TokenBaseKind_ScopeClose ||
                                 (token->kind == TokenBaseKind_StatementClose && token->sub_kind != TokenCppKind_Colon)))
                        {
                            break;
                        }
                        else if((token->kind == TokenBaseKind_Identifier || token->kind == TokenBaseKind_Keyword ||
                                 token->kind == TokenBaseKind_Comment) &&
                                !paren_nest)
                        {
                            start_token = token;
                            break;
                        }

                    }
                    else
                    {
                        break;
                    }

                    if(!token_it_dec_non_whitespace(&it))
                    {
                        break;
                    }
                }
            }


            if(start_token)
            {
                ARGB_Color color = finalize_color(defcolor_comment, 0);
                Color_Array colors = finalize_color_array(fleury_color_brace_annotation);
                if (colors.count >= 1 && F4_ARGBIsValid(colors.vals[0])) {
                    color = colors.vals[(ranges.count - i - 1) % colors.count];
                }

                String_Const_u8 start_line = push_buffer_line(app, scratch, buffer,
                                                              get_line_number_from_pos(app, buffer, start_token->pos));

                u64 first_non_whitespace_offset = 0;
                for(u64 c = 0; c < start_line.size; ++c)
                {
                    if(start_line.str[c] <= 32)
                    {
                        ++first_non_whitespace_offset;
                    }
                    else
                    {
                        break;
                    }
                }
                start_line.str += first_non_whitespace_offset;
                start_line.size -= first_non_whitespace_offset;

                if(start_line.str[start_line.size - 1] == 13)
                {
                    start_line.size -= 1;
                }

                draw_string(app, face_id, start_line, close_scope_pos, color);
            }
        }
    }

}



static void
F4_Brace_RenderLines(Application_Links *app, Buffer_ID buffer, View_ID view,
                     Text_Layout_ID text_layout_id, i64 pos)
{
    if(!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_brace_lines"), (u64)(sizeof("f4_disable_brace_lines") - 1)))))
    {
        Profile_Scope_Block profile_block_198 ((app), SCu8((u8*)("[F4] Brace Lines"), (u64)(sizeof("[F4] Brace Lines") - 1)), SCu8((u8*)("4coder_fleury_brace.cpp" ":" "198" ":"), (u64)(sizeof("4coder_fleury_brace.cpp" ":" "198" ":") - 1)));

        Face_ID face_id = get_face_id(app, buffer);
        Token_Array token_array = get_token_array_from_buffer(app, buffer);
        Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

        if (token_array.tokens != 0)
        {
            Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
            Token *token = token_it_read(&it);
            if(token != 0 && token->kind == TokenBaseKind_ScopeOpen)
            {
                pos = token->pos + token->size;
            }
            else
            {

                if(token_it_dec_all(&it))
                {
                    token = token_it_read(&it);

                    if (token->kind == TokenBaseKind_ScopeClose &&
                        pos == token->pos + token->size)
                    {
                        pos = token->pos;
                    }
                }
            }
        }

        Face_Metrics metrics = get_face_metrics(app, face_id);

        Scratch_Block scratch(app);
        Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, RangeHighlightKind_CharacterHighlight);

        Rect_f32 line_number_rect = {};
        b32 show_line_number_margins = def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1))));
        if(show_line_number_margins)
        {
            Rect_f32 rect = view_get_screen_rect(app, view);

            Face_Metrics face_metrics = get_face_metrics(app, face_id);
            f32 digit_advance = face_metrics.decimal_digit_advance;

            Rect_f32_Pair pair = layout_line_number_margin(app, buffer, rect, digit_advance);
            line_number_rect = pair.min;
            line_number_rect.x1 += 4;
        }

        float x_offset = view_get_screen_rect(app, view).x0 + 4 -
            view_get_buffer_scroll(app, view).position.pixel_shift.x +
            (line_number_rect.x1 - line_number_rect.x0);
        float x_position = 0.f;

        u64 vw_indent = def_get_config_u64(app, vars_save_string(SCu8((u8*)("virtual_whitespace_regular_indent"), (u64)(sizeof("virtual_whitespace_regular_indent") - 1))));

        for (i32 i = ranges.count - 1; i >= 0; i -= 1)
        {
            Range_i64 range = ranges.ranges[i];

            Rect_f32 range_start_rect = text_layout_character_on_screen(app, text_layout_id, range.start);
            Rect_f32 range_end_rect = text_layout_character_on_screen(app, text_layout_id, range.end);

            if(def_enable_virtual_whitespace)
            {
                x_position = (ranges.count - i - 1) * metrics.space_advance * vw_indent;
            }
            else
            {
                String_Const_u8 line = push_buffer_line(app, scratch, buffer, get_line_number_from_pos(app, buffer, range.end));
                for(u64 char_idx = 0; char_idx < line.size; char_idx += 1)
                {
                    if(!character_is_whitespace(line.str[char_idx]))
                    {
                        x_position = metrics.space_advance * char_idx;
                        break;
                    }
                }
            }

            float y_start = 0;
            float y_end = 10000;
            if(range.start >= visible_range.start)
            {
                y_start = range_start_rect.y0 + metrics.line_height;
            }
            if(range.end <= visible_range.end)
            {
                y_end = range_end_rect.y0;
            }

            Rect_f32 line_rect = {0};
            line_rect.x0 = x_position+x_offset;
            line_rect.x1 = x_position+1+x_offset;
            line_rect.y0 = y_start;
            line_rect.y1 = y_end;

            Color_Array colors = finalize_color_array(fleury_color_brace_line);
            if (colors.count >= 1 && F4_ARGBIsValid(colors.vals[0])) {
                draw_rectangle(app, line_rect, 0.5f,
                               colors.vals[(ranges.count - i - 1) % colors.count]);
            }
        }
    }
}
# 437 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_error_annotations.cpp" 1


static void
F4_RenderErrorAnnotations(Application_Links *app, Buffer_ID buffer,
                          Text_Layout_ID text_layout_id,
                          Buffer_ID jump_buffer)
{
    if(def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_error_annotations"), (u64)(sizeof("f4_disable_error_annotations") - 1)))))
    {
        return;
    }

    Profile_Scope_Block profile_block_13 ((app), SCu8((u8*)("[Fleury] Error Annotations"), (u64)(sizeof("[Fleury] Error Annotations") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "13" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "13" ":") - 1)));

    Heap *heap = &global_heap;
    Scratch_Block scratch(app);

    Locked_Jump_State jump_state = {};
    {
        Profile_Scope_Block profile_block_20 ((app), SCu8((u8*)("[Fleury] Error Annotations (Get Locked Jump State)"), (u64)(sizeof("[Fleury] Error Annotations (Get Locked Jump State)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "20" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "20" ":") - 1)));
        jump_state = get_locked_jump_state(app, heap);
    }

    Face_ID face = global_small_code_face;
    Face_Metrics metrics = get_face_metrics(app, face);

    if(jump_buffer != 0 && jump_state.view != 0)
    {
        Managed_Scope buffer_scopes[2];
        {
            Profile_Scope_Block profile_block_31 ((app), SCu8((u8*)("[Fleury] Error Annotations (Buffer Get Managed Scope)"), (u64)(sizeof("[Fleury] Error Annotations (Buffer Get Managed Scope)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "31" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "31" ":") - 1)));
            buffer_scopes[0] = buffer_get_managed_scope(app, jump_buffer);
            buffer_scopes[1] = buffer_get_managed_scope(app, buffer);
        }

        Managed_Scope comp_scope = 0;
        {
            Profile_Scope_Block profile_block_38 ((app), SCu8((u8*)("[Fleury] Error Annotations (Get Managed Scope)"), (u64)(sizeof("[Fleury] Error Annotations (Get Managed Scope)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "38" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "38" ":") - 1)));
            comp_scope = get_managed_scope_with_multiple_dependencies(app, buffer_scopes, ((sizeof(buffer_scopes))/(sizeof(*buffer_scopes))));
        }

        Managed_Object *buffer_markers_object = 0;
        {
            Profile_Scope_Block profile_block_44 ((app), SCu8((u8*)("[Fleury] Error Annotations (Scope Attachment)"), (u64)(sizeof("[Fleury] Error Annotations (Scope Attachment)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "44" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "44" ":") - 1)));
            buffer_markers_object = ((Managed_Object*)managed_scope_get_attachment((app), (comp_scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));
        }


        i32 buffer_marker_count = 0;
        Marker *buffer_markers = 0;
        {
            Profile_Scope_Block profile_block_52 ((app), SCu8((u8*)("[Fleury] Error Annotations (Load Managed Object Data)"), (u64)(sizeof("[Fleury] Error Annotations (Load Managed Object Data)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "52" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "52" ":") - 1)));
            buffer_marker_count = managed_object_get_item_count(app, *buffer_markers_object);
            buffer_markers = ((Marker*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Marker)*(buffer_marker_count), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "54" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "54" ":") - 1)))));
            managed_object_load_data(app, *buffer_markers_object, 0, buffer_marker_count, buffer_markers);
        }

        i64 last_line = -1;

        for(i32 i = 0; i < buffer_marker_count; i += 1)
        {
            Profile_Scope_Block profile_block_62 ((app), SCu8((u8*)("[Fleury] Error Annotations (Buffer Loop)"), (u64)(sizeof("[Fleury] Error Annotations (Buffer Loop)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "62" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "62" ":") - 1)));

            i64 jump_line_number = get_line_from_list(app, jump_state.list, i);
            i64 code_line_number = get_line_number_from_pos(app, buffer, buffer_markers[i].pos);

            if(code_line_number != last_line)
            {
                Profile_Scope_Block profile_block_69 ((app), SCu8((u8*)("[Fleury] Error Annotations (Jump Line)"), (u64)(sizeof("[Fleury] Error Annotations (Jump Line)") - 1)), SCu8((u8*)("4coder_fleury_error_annotations.cpp" ":" "69" ":"), (u64)(sizeof("4coder_fleury_error_annotations.cpp" ":" "69" ":") - 1)));

                String_Const_u8 jump_line = push_buffer_line(app, scratch, jump_buffer, jump_line_number);


                {
                    u64 index = string_find_first(jump_line, SCu8((u8*)("error"), (u64)(sizeof("error") - 1)), StringMatch_CaseInsensitive);
                    if(index == jump_line.size)
                    {
                        index = string_find_first(jump_line, SCu8((u8*)("warning"), (u64)(sizeof("warning") - 1)), StringMatch_CaseInsensitive);
                        if(index == jump_line.size)
                        {
                            index = 0;
                        }
                    }
                    jump_line.str += index;
                    jump_line.size -= index;
                }


                {
                    Range_i64 line_range = Ii64(code_line_number);

                    Range_f32 y1 = text_layout_line_on_screen(app, text_layout_id, line_range.min);
                    Range_f32 y2 = text_layout_line_on_screen(app, text_layout_id, line_range.max);
                    Range_f32 y = range_union(y1, y2);
                    Rect_f32 last_character_on_line_rect =
                        text_layout_character_on_screen(app, text_layout_id, get_line_end_pos(app, buffer, code_line_number)-1);

                    if(range_size(y) > 0.f)
                    {
                        Rect_f32 region = text_layout_region(app, text_layout_id);
                        Vec2_f32 draw_position =
                        {
                            region.x1 - metrics.max_advance*jump_line.size -
                                (y.max-y.min)/2 - metrics.line_height/2,
                            y.min + (y.max-y.min)/2 - metrics.line_height/2,
                        };

                        if(draw_position.x < last_character_on_line_rect.x1 + 30)
                        {
                            draw_position.x = last_character_on_line_rect.x1 + 30;
                        }

                        draw_string(app, face, jump_line, draw_position, fcolor_id(fleury_color_error_annotation));

                        Mouse_State mouse_state = get_mouse_state(app);
                        if(mouse_state.x >= region.x0 && mouse_state.x <= region.x1 &&
                           mouse_state.y >= y.min && mouse_state.y <= y.max)
                        {
                            F4_PushTooltip(jump_line, 0xffff0000);
                        }
                    }
                }
            }

            last_line = code_line_number;
        }
    }
}
# 438 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_divider_comments.cpp" 1


String_Const_u8 strong_divider_comment_signifier = SCu8((u8*)("//~"), (u64)(sizeof("//~") - 1));
String_Const_u8 weak_divider_comment_signifier = SCu8((u8*)("//-"), (u64)(sizeof("//-") - 1));

static i64
_F4_Boundary_DividerComment(Application_Links *app, Buffer_ID buffer,
                            Side side, Scan_Direction direction, i64 pos,
                            String_Const_u8 signifier)
{
    i64 result = pos;
    Scratch_Block scratch(app);

    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    if(tokens.tokens != 0)
    {
        Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
        switch(direction)
        {
            case Scan_Forward:
            {
                for(;token_it_inc_non_whitespace(&it);)
                {
                    Token *token = token_it_read(&it);
                    if(token == 0)
                    {
                        break;
                    }
                    if(token->kind == TokenBaseKind_Comment)
                    {
                        String_Const_u8 str = push_buffer_range(app, scratch, buffer, Ii64(token));
                        if(str.size >= signifier.size &&
                           string_match(string_substring(str, Ii64(0, signifier.size)), signifier))
                        {
                            result = token->pos;
                            break;
                        }
                    }
                }
            }break;

            case Scan_Backward:
            {
                for(;token_it_dec_non_whitespace(&it);)
                {
                    Token *token = token_it_read(&it);
                    if(token == 0)
                    {
                        break;
                    }
                    if(token->kind == TokenBaseKind_Comment)
                    {
                        String_Const_u8 str = push_buffer_range(app, scratch, buffer, Ii64(token));
                        if(str.size >= signifier.size &&
                           string_match(string_substring(str, Ii64(0, signifier.size)), signifier))
                        {
                            result = token->pos;
                            break;
                        }
                    }
                }
            }break;

        }
    }
    return(result);
}

static i64
F4_Boundary_DividerComment(Application_Links *app, Buffer_ID buffer,
                           Side side, Scan_Direction direction, i64 pos,
                           String_Const_u8 signifier)
{
    return _F4_Boundary_DividerComment(app, buffer, side, direction, pos, strong_divider_comment_signifier);
}

CUSTOM_COMMAND(f4_move_to_next_divider_comment, "4coder_fleury_divider_comments.cpp", 77, Normal)
CUSTOM_DOC("Seek right for next divider comment in the buffer.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), F4_Boundary_DividerComment, 0));
}

CUSTOM_COMMAND(f4_move_to_prev_divider_comment, "4coder_fleury_divider_comments.cpp", 84, Normal)
CUSTOM_DOC("Seek left for previous divider comment in the buffer.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), F4_Boundary_DividerComment, 0));
}

static void
F4_RenderDividerComments(Application_Links *app, Buffer_ID buffer, View_ID view,
                         Text_Layout_ID text_layout_id)
{
    if(!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_divider_comments"), (u64)(sizeof("f4_disable_divider_comments") - 1)))))
    {
        Profile_Scope_Block profile_block_97 ((app), SCu8((u8*)("[F4] Divider Comments"), (u64)(sizeof("[F4] Divider Comments") - 1)), SCu8((u8*)("4coder_fleury_divider_comments.cpp" ":" "97" ":"), (u64)(sizeof("4coder_fleury_divider_comments.cpp" ":" "97" ":") - 1)));

        Token_Array token_array = get_token_array_from_buffer(app, buffer);
        Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
        Scratch_Block scratch(app);

        if(token_array.tokens != 0)
        {
            i64 first_index = token_index_from_pos(&token_array, visible_range.first);
            Token_Iterator_Array it = token_iterator_index(0, &token_array, first_index);

            Token *token = 0;
            for(;;)
            {
                token = token_it_read(&it);

                if(token->pos >= visible_range.one_past_last || !token || !token_it_inc_non_whitespace(&it))
                {
                    break;
                }

                if(token->kind == TokenBaseKind_Comment)
                {
                    Rect_f32 comment_first_char_rect = text_layout_character_on_screen(app, text_layout_id, token->pos);
                    Rect_f32 comment_last_char_rect = text_layout_character_on_screen(app, text_layout_id, token->pos+token->size-1);
                    String_Const_u8 token_string = push_buffer_range(app, scratch, buffer, Ii64(token));
                    String_Const_u8 signifier_substring = string_substring(token_string, Ii64(0, 3));
                    f32 roundness = 4.f;


                    if(string_match(signifier_substring, strong_divider_comment_signifier))
                    {
                        Rect_f32 rect =
                        {
                            comment_first_char_rect.x0,
                            comment_first_char_rect.y0-2,
                            10000,
                            comment_first_char_rect.y0,
                        };
                        draw_rectangle(app, rect, roundness, fcolor_resolve(fcolor_id(defcolor_comment)));
                    }


                    else if(string_match(signifier_substring, weak_divider_comment_signifier))
                    {
                        f32 dash_size = 8;
                        Rect_f32 rect =
                        {
                            comment_last_char_rect.x1,
                            (comment_last_char_rect.y0 + comment_last_char_rect.y1)/2 - 1,
                            comment_last_char_rect.x1 + dash_size,
                            (comment_last_char_rect.y0 + comment_last_char_rect.y1)/2 + 1,
                        };

                        for(int i = 0; i < 1000; i += 1)
                        {
                            draw_rectangle(app, rect, roundness, fcolor_resolve(fcolor_id(defcolor_comment)));
                            rect.x0 += dash_size*1.5f;
                            rect.x1 += dash_size*1.5f;
                        }
                    }

                }
            }
        }
    }
}
# 439 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_power_mode.cpp" 1


Audio_Clip f4_powermode_music = {};
Audio_Control f4_powermode_music_ctrl = {};
Audio_Clip f4_powermode_keystroke_sounds[10] = {};

static struct
{
    b32 allowed;
    b32 enabled;
    f32 enabled_t;
    int ticks_to_enable;
    int ticks_to_disable;

    int particle_count;
    Particle particles[4096];

    int keypress_history_count;
    struct
    {
        u64 time;
    }
    keypress_history[64];

    f32 screen_shake;
}
power_mode;

static void
F4_PowerMode_SetAllow(b32 allowed)
{
    power_mode.allowed = allowed;
}

CUSTOM_COMMAND(f4_powermode_allow, "4coder_fleury_power_mode.cpp", 35, Normal)
CUSTOM_DOC("Allow power mode.")
{ F4_PowerMode_SetAllow(1); }

CUSTOM_COMMAND(f4_powermode_disallow, "4coder_fleury_power_mode.cpp", 39, Normal)
CUSTOM_DOC("Disallow power mode.")
{ F4_PowerMode_SetAllow(0); }

static b32
F4_PowerMode_IsEnabled(void)
{
    return power_mode.enabled;
}

static f32
F4_PowerMode_ScreenShake(void)
{
    return power_mode.screen_shake;
}

static f32
F4_PowerMode_ActiveCharactersPerMinute(void)
{
    f32 result = 0.f;
    if(power_mode.allowed && power_mode.keypress_history_count > 1)
    {
        u64 total_time__microseconds = power_mode.keypress_history[power_mode.keypress_history_count-1].time - power_mode.keypress_history[0].time;
        f32 total_time__seconds = (f32)(((f64)total_time__microseconds) / 1000.0 / 1000.0);
        f32 total_time__minutes = total_time__seconds / 60.f;
        result = (f32)power_mode.keypress_history_count / total_time__minutes;
    }
    return result;
}

static void
F4_PowerMode_CharacterPressed(void)
{
    u64 now = system_now_time();

    if(power_mode.keypress_history_count > 0)
    {
        u64 last_keypress_time = power_mode.keypress_history[power_mode.keypress_history_count-1].time;
        u64 microseconds_since_last_keypress = now - last_keypress_time;
        f32 seconds_since_last_keypress = (f32)((f64)microseconds_since_last_keypress / 1000.0 / 1000.0);
        if(seconds_since_last_keypress > 10.f)
        {
            power_mode.keypress_history_count = 0;
        }
    }

    if(power_mode.keypress_history_count >= ((sizeof(power_mode.keypress_history))/(sizeof(*power_mode.keypress_history))))
    {
        memmove(power_mode.keypress_history + 0, power_mode.keypress_history + 1,
                (((sizeof(power_mode.keypress_history))/(sizeof(*power_mode.keypress_history))) - 1) * sizeof(power_mode.keypress_history[0]));
        power_mode.keypress_history_count -= 1;
    }
    power_mode.keypress_history[power_mode.keypress_history_count].time = now;
    power_mode.keypress_history_count += 1;

    if(F4_PowerMode_IsEnabled())
    {
        int rando = (int)rand();
        def_audio_play_clip(f4_powermode_keystroke_sounds[rando % ((sizeof(f4_powermode_keystroke_sounds))/(sizeof(*f4_powermode_keystroke_sounds)))], 0);
    }
}

static Particle *
F4_PowerMode_Particle(f32 x, f32 y, f32 velocity_x, f32 velocity_y, f32 decay_rate, ARGB_Color color,
                      f32 roundness, f32 scale, String_Const_u8 str)
{
    Particle *result = 0;
    if(power_mode.particle_count < ((sizeof(power_mode.particles))/(sizeof(*power_mode.particles))))
    {
        int i = power_mode.particle_count++;
        result = power_mode.particles + i;
        result->x = x;
        result->y = y;
        result->velocity_x = velocity_x;
        result->velocity_y = velocity_y;
        result->decay_rate = decay_rate;
        result->color = color;
        result->alpha = 1.f;
        result->roundness = roundness;
        result->scale = scale;
        result->string = str;
    }
    return result;
}

static Vec2_f32
F4_PowerMode_CameraOffsetFromView(Application_Links *app, View_ID view)
{
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    Face_ID face = get_face_id(app, buffer);
    Face_Metrics metrics = get_face_metrics(app, face);

    Vec2_f32 v =
    {
        scroll.position.pixel_shift.x,
        scroll.position.pixel_shift.y + scroll.position.line_number*metrics.line_height,
    };

    return v;
}

static void
F4_PowerMode_Spawn(Application_Links *app, View_ID view, u8 character)
{
    if(F4_PowerMode_IsEnabled())
    {
        Vec2_f32 camera = F4_PowerMode_CameraOffsetFromView(app, view);

        for(int i = 0; i < 60; ++i)
        {
            String_Const_u8 string = {};
            ARGB_Color color = 0xffffffff;
            f32 decay_rate = 1.f;
            f32 scale = RandomF32(0.5f, 6.f);
            if(RandomF32(0, 1) < 0.01f)
            {
                f32 random = RandomF32(0, 1);
                if(random < 0.03f)
                {
                    string = SCu8((u8*)("CRITICAL HIT!!!"), (u64)(sizeof("CRITICAL HIT!!!") - 1));
                    color = 0xffff6060;
                    decay_rate = 0.05f;
                    scale = 0;
                }
                else if(random < 0.33f)
                {
                    string = SCu8((u8*)("EPIC COMBO!!!"), (u64)(sizeof("EPIC COMBO!!!") - 1));
                    scale = 0;
                }
                else if(random < 0.66f)
                {
                    string = SCu8((u8*)("SLICK TYPING DUDE!!!!!!"), (u64)(sizeof("SLICK TYPING DUDE!!!!!!") - 1));
                    scale = 0;
                }
                else
                {
                    string = SCu8((u8*)("WHOOOOOAAAAAAAA!!!!!!!"), (u64)(sizeof("WHOOOOOAAAAAAAA!!!!!!!") - 1));
                    scale = 0;
                }
            }

            f32 movement_angle = RandomF32(-3.1415926535897f*3.f/2.f, 3.1415926535897f*1.f/3.f);
            f32 velocity_magnitude = RandomF32(20.f, 180.f);
            f32 velocity_x = cosf(movement_angle)*velocity_magnitude;
            f32 velocity_y = sinf(movement_angle)*velocity_magnitude;
            Particle *p = F4_PowerMode_Particle(global_cursor_rect.x0 + 4 + camera.x,
                                                global_cursor_rect.y0 + 8 + camera.y,
                                                velocity_x, velocity_y, decay_rate,
                                                color,
                                                RandomF32(1.5f, 8.f),
                                                scale,
                                                string);
            if(i < 30 && character)
            {
                p->chrs[0] = character;
                p->string = {p->chrs, 1};
            }
        }

        power_mode.screen_shake += RandomF32(6.f, 16.f);
    }
}

static void
F4_PowerMode_Tick(Application_Links *app, Frame_Info frame_info)
{

    if(power_mode.enabled && power_mode.allowed)
    {
        for(int i = 0; i < ((sizeof(f4_powermode_keystroke_sounds))/(sizeof(*f4_powermode_keystroke_sounds))); i += 1)
        {
            char path[256];
            snprintf(path, sizeof(path), "sounds/PowerKey-%03d.wav", i+1);
            F4_RequireWAV(app, &f4_powermode_keystroke_sounds[i], path);
            f4_powermode_keystroke_sounds[i].channel_volume[0] = 0.25f;
            f4_powermode_keystroke_sounds[i].channel_volume[1] = 0.25f;
        }
    }

    power_mode.screen_shake -= power_mode.screen_shake * frame_info.animation_dt * 12.f;
    if(F4_PowerMode_ActiveCharactersPerMinute() > 200.f)
    {
        if(power_mode.ticks_to_enable > 0)
        {
            power_mode.ticks_to_enable -= 1;
            animate_in_n_milliseconds(app, 0);
        }
        if(power_mode.ticks_to_enable <= 0)
        {
            if(power_mode.enabled == 0)
            {
                power_mode.enabled = 1;
                F4_RequireWAV(app, &f4_powermode_music, "sounds/chtulthu.wav");
            }

            power_mode.ticks_to_disable = 120;

            f32 right_volume = 0.4f;
            f32 left_volume = 0.4f;
            View_ID active_view = get_active_view(app, Access_Always);
            Rect_f32 active_view_rect = view_get_screen_rect(app, active_view);
            Rect_f32 screen_rect = global_get_screen_rectangle(app);
            if((active_view_rect.x0 + active_view_rect.x1) / 2 > (screen_rect.x0 + screen_rect.y1) / 2)
            {
                left_volume *= 0.2f;
            }
            else
            {
                right_volume *= 0.2f;
            }

            f4_powermode_music_ctrl.channel_volume[0] += (left_volume - f4_powermode_music_ctrl.channel_volume[0]) * frame_info.animation_dt;
            f4_powermode_music_ctrl.channel_volume[1] += (right_volume - f4_powermode_music_ctrl.channel_volume[1]) * frame_info.animation_dt;
            if(!def_audio_is_playing(&f4_powermode_music_ctrl))
            {
                def_audio_play_clip(f4_powermode_music, &f4_powermode_music_ctrl);
            }
        }
    }
    else
    {
        if(power_mode.ticks_to_disable > 0)
        {
            power_mode.ticks_to_disable -= 1;
            animate_in_n_milliseconds(app, 0);
        }

        if(power_mode.ticks_to_disable <= 0)
        {
            power_mode.enabled = 0;
            power_mode.ticks_to_enable = 440;
            f4_powermode_music_ctrl.channel_volume[0] -= f4_powermode_music_ctrl.channel_volume[0] * frame_info.animation_dt;
            f4_powermode_music_ctrl.channel_volume[1] -= f4_powermode_music_ctrl.channel_volume[1] * frame_info.animation_dt;
            if(f4_powermode_music_ctrl.channel_volume[0] > 0.05f ||
               f4_powermode_music_ctrl.channel_volume[1] > 0.05f)
            {
                animate_in_n_milliseconds(app, 0);
            }
        }
    }

    power_mode.enabled_t += ((f32)(!!power_mode.enabled) - power_mode.enabled_t) * frame_info.animation_dt;
}

static void
F4_PowerMode_RenderBuffer(Application_Links *app, View_ID view, Face_ID face, Frame_Info frame_info)
{
    Profile_Scope_Block profile_block_287 ((app), SCu8((u8*)("[Fleury] Power Mode"), (u64)(sizeof("[Fleury] Power Mode") - 1)), SCu8((u8*)("4coder_fleury_power_mode.cpp" ":" "287" ":"), (u64)(sizeof("4coder_fleury_power_mode.cpp" ":" "287" ":") - 1)));

    Buffer_Scroll buffer_scroll = view_get_buffer_scroll(app, view);
    Face_Metrics metrics = get_face_metrics(app, face);

    if(power_mode.particle_count > 0)
    {
        animate_in_n_milliseconds(app, 0);
    }

    f32 camera_x = buffer_scroll.position.pixel_shift.x;
    f32 camera_y = buffer_scroll.position.pixel_shift.y + buffer_scroll.position.line_number*metrics.line_height;

    for(int i = 0; i < power_mode.particle_count;)
    {

        {
            power_mode.particles[i].x += power_mode.particles[i].velocity_x * frame_info.animation_dt;
            power_mode.particles[i].y += power_mode.particles[i].velocity_y * frame_info.animation_dt;
            power_mode.particles[i].velocity_x -= power_mode.particles[i].velocity_x * frame_info.animation_dt * 1.5f;
            power_mode.particles[i].velocity_y -= power_mode.particles[i].velocity_y * frame_info.animation_dt * 1.5f;
            power_mode.particles[i].velocity_y += 10.f * frame_info.animation_dt;
            power_mode.particles[i].alpha -= power_mode.particles[i].decay_rate * 0.3f * frame_info.animation_dt;
        }

        if(power_mode.particles[i].alpha <= 0.f)
        {
            power_mode.particles[i] = power_mode.particles[--power_mode.particle_count];
        }
        else
        {

            {
                Rect_f32 rect =
                {
                    power_mode.particles[i].x - power_mode.particles[i].scale - camera_x,
                    power_mode.particles[i].y - power_mode.particles[i].scale - camera_y,
                    power_mode.particles[i].x + power_mode.particles[i].scale - camera_x,
                    power_mode.particles[i].y + power_mode.particles[i].scale - camera_y,
                };
                f32 roundness = power_mode.particles[i].roundness;
                ARGB_Color color = power_mode.particles[i].color;
                color &= 0x00ffffff;
                color |= ((u32)(power_mode.particles[i].alpha * 60.f)) << 24;
                draw_rectangle(app, rect, roundness, color);
                if(power_mode.particles[i].string.size > 0)
                {
                    draw_string(app, face, power_mode.particles[i].string, rect.p0, color);
                }
            }

            ++i;
        }
    }
}

static void
F4_PowerMode_RenderWholeScreen(Application_Links *app, Frame_Info frame_info)
{
    Scratch_Block scratch(app);
    Rect_f32 rect = global_get_screen_rectangle(app);


    if(power_mode.enabled_t > 0.1f)
    {
        ARGB_Color color = fcolor_resolve(fcolor_change_alpha(fcolor_id(fleury_color_cursor_power_mode), 0.1f*power_mode.enabled_t));
        Rect_f32 glow_rect = rect;
        for(int i = 0; i < 15; i += 1)
        {
            draw_rectangle_outline(app, glow_rect, 0.f, 15.f - (f32)i, color);
        }
    }

    if(power_mode.allowed)
    {
        Face_ID face_id = get_face_id(app, 0);
        String_Const_u8 string = push_stringf(scratch, "CPM: %.2f", F4_PowerMode_ActiveCharactersPerMinute());
        f32 advance = get_string_advance(app, face_id, string);
        draw_string(app, face_id, string, V2f32(rect.x1 - advance, rect.y0), 0xffffffff);
    }
}
# 440 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_cursor.cpp" 1


static int global_cursor_count = 1;
static i64 global_cursor_positions[16] = {0};
static i64 global_mark_positions[16] = {0};
static int global_hide_region_boundary = 0;

enum Cursor_Type
{
 cursor_none,
 cursor_insert,
 cursor_open_range,
 cursor_close_range,
};

static void
C4_RenderCursorSymbolThingy(Application_Links *app, Rect_f32 rect,
                            f32 roundness, f32 thickness,
                            ARGB_Color color, Cursor_Type type)
{
    f32 line_height = rect.y1 - rect.y0;
    f32 bracket_width = 0.5f*line_height;

    if(type == cursor_open_range)
    {
        Rect_f32 start_top, start_side, start_bottom;

  Vec2_f32 start_p = {rect.x0, rect.y0};

        start_top.x0 = start_p.x + thickness;
        start_top.x1 = start_p.x + bracket_width;
        start_top.y0 = start_p.y;
        start_top.y1 = start_p.y + thickness;

        start_bottom.x0 = start_top.x0;
        start_bottom.x1 = start_top.x1;
        start_bottom.y1 = start_p.y + line_height;
        start_bottom.y0 = start_bottom.y1 - thickness;

        start_side.x0 = start_p.x;
        start_side.x1 = start_p.x + thickness;
        start_side.y0 = start_top.y0;
        start_side.y1 = start_bottom.y1;

        draw_rectangle(app, start_top, roundness, color);
        draw_rectangle(app, start_side, roundness, color);


    }
    else if(type == cursor_close_range)
 {
  Rect_f32 end_top, end_side, end_bottom;

  Vec2_f32 end_p = {rect.x0, rect.y0};

  end_top.x0 = end_p.x;
  end_top.x1 = end_p.x - bracket_width;
  end_top.y0 = end_p.y;
  end_top.y1 = end_p.y + thickness;

  end_side.x1 = end_p.x;
  end_side.x0 = end_p.x + thickness;
  end_side.y0 = end_p.y;
  end_side.y1 = end_p.y + line_height;

  end_bottom.x0 = end_top.x0;
  end_bottom.x1 = end_top.x1;
  end_bottom.y1 = end_p.y + line_height;
  end_bottom.y0 = end_bottom.y1 - thickness;

  draw_rectangle(app, end_bottom, roundness, color);
  draw_rectangle(app, end_side, roundness, color);
 }
 else if(type == cursor_insert)
 {
  Rect_f32 side;
  side.x0 = rect.x0;
  side.x1 = rect.x0 + thickness;
  side.y0 = rect.y0;
  side.y1 = rect.y1;

  draw_rectangle(app, side, roundness, color);
 }
}

static void
DoTheCursorInterpolation(Application_Links *app, Frame_Info frame_info,
                         Rect_f32 *rect, Rect_f32 *last_rect, Rect_f32 target)
{
    *last_rect = *rect;

    float x_change = target.x0 - rect->x0;
    float y_change = target.y0 - rect->y0;

    float cursor_size_x = (target.x1 - target.x0);
    float cursor_size_y = (target.y1 - target.y0) * (1 + fabsf(y_change) / 60.f);

    b32 should_animate_cursor = !global_battery_saver && !def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_cursor_trails"), (u64)(sizeof("f4_disable_cursor_trails") - 1))));
    if(should_animate_cursor)
    {
        if(fabs(x_change) > 1.f || fabs(y_change) > 1.f)
        {
            animate_in_n_milliseconds(app, 0);
        }
    }
    else
    {
        *rect = *last_rect = target;
        cursor_size_y = target.y1 - target.y0;
    }

    if(should_animate_cursor)
    {
        rect->x0 += (x_change) * frame_info.animation_dt * 30.f;
        rect->y0 += (y_change) * frame_info.animation_dt * 30.f;
        rect->x1 = rect->x0 + cursor_size_x;
        rect->y1 = rect->y0 + cursor_size_y;
    }

    if(target.y0 > last_rect->y0)
    {
        if(rect->y0 < last_rect->y0)
        {
            rect->y0 = last_rect->y0;
        }
    }
    else
    {
        if(rect->y1 > last_rect->y1)
        {
            rect->y1 = last_rect->y1;
        }
    }

}

static void
F4_Cursor_RenderEmacsStyle(Application_Links *app, View_ID view_id, b32 is_active_view,
                           Buffer_ID buffer, Text_Layout_ID text_layout_id,
                           f32 roundness, f32 outline_thickness, Frame_Info frame_info)
{
    Rect_f32 view_rect = view_get_screen_rect(app, view_id);
    Rect_f32 clip = draw_set_clip(app, view_rect);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);

    ColorFlags flags = 0;
    flags |= !!global_keyboard_macro_is_recording * ColorFlag_Macro;
    flags |= !!power_mode.enabled * ColorFlag_PowerMode;
    ARGB_Color cursor_color = F4_GetColor(app, ColorCtx_Cursor(flags, GlobalKeybindingMode));
    ARGB_Color mark_color = cursor_color;
    ARGB_Color inactive_cursor_color = F4_ARGBFromID(active_color_table, fleury_color_cursor_inactive, 0);

    if(!F4_ARGBIsValid(inactive_cursor_color))
    {
        inactive_cursor_color = cursor_color;
    }

    if(is_active_view == 0)
    {
        cursor_color = inactive_cursor_color;
        mark_color = inactive_cursor_color;
    }


    {
        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);
        global_cursor_positions[0] = cursor_pos;
        global_mark_positions[0] = mark_pos;
    }

    if(!has_highlight_range)
    {

        for(int i = 0; i < 1 ; ++i)
        {
            i64 cursor_pos = global_cursor_positions[0];
            i64 mark_pos = global_mark_positions[0];

   Cursor_Type cursor_type = cursor_none;
   Cursor_Type mark_type = cursor_none;
   if(cursor_pos <= mark_pos)
   {
    cursor_type = cursor_open_range;
    mark_type = cursor_close_range;
   }
   else
   {
    cursor_type = cursor_close_range;
    mark_type = cursor_open_range;
   }

   if(global_hide_region_boundary)
   {
    cursor_type = cursor_insert;
    mark_type = cursor_none;
   }

            Rect_f32 target_cursor = text_layout_character_on_screen(app, text_layout_id, cursor_pos);
            Rect_f32 target_mark = text_layout_character_on_screen(app, text_layout_id, mark_pos);


            {
                if(is_active_view)
                {

                    if(cursor_pos < visible_range.start || cursor_pos > visible_range.end)
                    {
                        f32 width = target_cursor.x1 - target_cursor.x0;
                        target_cursor.x0 = view_rect.x0;
                        target_cursor.x1 = target_cursor.x0 + width;
                    }

                    DoTheCursorInterpolation(app, frame_info, &global_cursor_rect,
                                             &global_last_cursor_rect, target_cursor);


                    if(mark_pos > visible_range.end)
                    {
                        target_mark.x0 = 0;
                        target_mark.y0 = view_rect.y1;
                        target_mark.y1 = view_rect.y1;
                    }

                    if(mark_pos < visible_range.start || mark_pos > visible_range.end)
                    {
                        f32 width = target_mark.x1 - target_mark.x0;
                        target_mark.x0 = view_rect.x0;
                        target_mark.x1 = target_mark.x0 + width;
                    }

                    DoTheCursorInterpolation(app, frame_info, &global_mark_rect, &global_last_mark_rect,
                                             target_mark);
                }


                {
                    C4_RenderCursorSymbolThingy(app, global_cursor_rect, roundness, 4.f, cursor_color, cursor_type);
     C4_RenderCursorSymbolThingy(app, target_cursor, roundness, 4.f, cursor_color, cursor_type);
                }


                for(int glow = 0; glow < 20; ++glow)
                {
                    f32 alpha = 0.1f - (power_mode.enabled ? (glow*0.005f) : (glow*0.015f));
                    if(alpha > 0)
                    {
                        Rect_f32 glow_rect = target_cursor;
                        glow_rect.x0 -= glow;
                        glow_rect.y0 -= glow;
                        glow_rect.x1 += glow;
                        glow_rect.y1 += glow;
                        C4_RenderCursorSymbolThingy(app, glow_rect, roundness + glow*0.7f, 2.f,
                                                    fcolor_resolve(fcolor_change_alpha(fcolor_argb(cursor_color), alpha)), cursor_type);
                    }
                    else
                    {
                        break;
                    }
                }

            }



            C4_RenderCursorSymbolThingy(app, global_mark_rect, roundness, 2.f,
                                        fcolor_resolve(fcolor_change_alpha(fcolor_argb(mark_color), 0.5f)), mark_type);
   C4_RenderCursorSymbolThingy(app, target_mark, roundness, 2.f,
                                        fcolor_resolve(fcolor_change_alpha(fcolor_argb(mark_color), 0.75f)), mark_type);
        }
    }

    draw_set_clip(app, clip);
}

static b32
F4_Cursor_DrawHighlightRange(Application_Links *app, View_ID view_id,
                             Buffer_ID buffer, Text_Layout_ID text_layout_id,
                             f32 roundness)
{
    b32 has_highlight_range = false;
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    Buffer_ID *highlight_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_highlight_buffer), sizeof(Buffer_ID)));
    if (*highlight_buffer != 0){
        if (*highlight_buffer != buffer){
            view_disable_highlight_range(app, view_id);
        }
        else{
            has_highlight_range = true;
            Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
            Marker marker_range[2];
            if (managed_object_load_data(app, *highlight, 0, 2, marker_range)){
                Range_i64 range = Ii64(marker_range[0].pos, marker_range[1].pos);
                draw_character_block(app, text_layout_id, range, roundness,
                                     fcolor_id(defcolor_highlight));
            }
        }
    }
    return(has_highlight_range);
}

static void
F4_Cursor_RenderNotepadStyle(Application_Links *app, View_ID view_id, b32 is_active_view,
                             Buffer_ID buffer, Text_Layout_ID text_layout_id,
                             f32 roundness, f32 outline_thickness, Frame_Info frame_info)
{
    Rect_f32 view_rect = view_get_screen_rect(app, view_id);
    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);
    if(!has_highlight_range)
    {
        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);

        if (cursor_pos != mark_pos)
        {
            Range_i64 range = Ii64(cursor_pos, mark_pos);
            draw_character_block(app, text_layout_id, range, roundness, fcolor_id(defcolor_highlight));
        }


        {
            ARGB_Color cursor_color = F4_GetColor(app, ColorCtx_Cursor(0, GlobalKeybindingMode));
            ARGB_Color ghost_color = fcolor_resolve(fcolor_change_alpha(fcolor_argb(cursor_color), 0.5f));
            Rect_f32 rect = text_layout_character_on_screen(app, text_layout_id, cursor_pos);
            rect.x1 = rect.x0 + outline_thickness;
            if(rect.x0 < view_rect.x0)
            {
                rect.x0 = view_rect.x0;
                rect.x1 = view_rect.x0 + outline_thickness;
            }

            if(is_active_view)
            {
                DoTheCursorInterpolation(app, frame_info, &global_cursor_rect, &global_last_cursor_rect, rect);
            }
            draw_rectangle(app, global_cursor_rect, roundness, ghost_color);
            draw_rectangle(app, rect, roundness, cursor_color);
        }
    }
}

static void
F4_HighlightCursorMarkRange(Application_Links *app, View_ID view_id)
{
    Rect_f32 view_rect = view_get_screen_rect(app, view_id);
    Rect_f32 clip = draw_set_clip(app, view_rect);

    f32 lower_bound_y;
    f32 upper_bound_y;

    if(global_last_cursor_rect.y0 < global_last_mark_rect.y0)
    {
        lower_bound_y = global_last_cursor_rect.y0;
        upper_bound_y = global_last_mark_rect.y1;
    }
    else
    {
        lower_bound_y = global_last_mark_rect.y0;
        upper_bound_y = global_last_cursor_rect.y1;
    }

    draw_rectangle(app, Rf32(view_rect.x0, lower_bound_y, view_rect.x0 + 4, upper_bound_y), 3.f,
                   fcolor_resolve(fcolor_change_alpha(fcolor_id(defcolor_comment), 0.5f)));
    draw_set_clip(app, clip);
}
# 441 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_plot.cpp" 1

 static void
Plot2DBegin(Plot2DInfo *plot)
{
    Scratch_Block scratch(plot->app);

    Rect_f32 rect = plot->screen_rect;
    Rect_f32 plot_view = plot->plot_view;

    if(plot->title.str)
    {
        Face_Metrics metrics = get_face_metrics(plot->app, plot->title_face_id);
        draw_string(plot->app, plot->title_face_id, plot->title, V2f32(rect.x0, rect.y0 - metrics.line_height), fcolor_resolve(fcolor_id(defcolor_comment)));
    }

    if(plot->x_axis.str)
    {
        draw_string(plot->app, plot->label_face_id, plot->x_axis, V2f32(rect.x0, rect.y1), fcolor_resolve(fcolor_id(defcolor_comment)));
    }

    if(plot->y_axis.str)
    {
        draw_string_oriented(plot->app, plot->label_face_id, fcolor_resolve(fcolor_id(defcolor_comment)), plot->y_axis,
                             V2f32(rect.x0 - 10, rect.y0 + 5), 0, V2f32(0.f, 1.f));
    }

    plot->last_clip = draw_set_clip(plot->app, rect);
    f32 rect_width = rect.x1 - rect.x0;
    f32 rect_height = rect.y1 - rect.y0;
    draw_rectangle(plot->app, rect, 4.f, fcolor_resolve(fcolor_id(defcolor_back)));


    if(plot->mode != Plot2DMode_Histogram)
    {
        Face_Metrics metrics = get_face_metrics(plot->app, plot->label_face_id);

        ARGB_Color grid_line_color = fcolor_resolve(fcolor_id(defcolor_comment));
        grid_line_color &= 0x00ffffff;
        grid_line_color |= 0x91000000;

        float tick_increment_x = (plot_view.x1 - plot_view.x0) / 10.f + 1.f;
        float tick_increment_y = (plot_view.y1 - plot_view.y0) / 10.f + 1.f;

        tick_increment_x = powf(10.f, floorf(log10f(tick_increment_x)));
        tick_increment_y = powf(10.f, floorf(log10f(tick_increment_y)));

  if(tick_increment_x <= 0)
  {
   tick_increment_x = 1;
  }
  if(tick_increment_y <= 0)
  {
   tick_increment_y = 1;
  }


        {
            for(float x = plot_view.x0 - fmodf(plot_view.x0, tick_increment_x);
                x <= plot_view.x1; x += tick_increment_x)
            {
                Rect_f32 line_rect = {0};
                {
                    line_rect.x0 = rect.x0 + rect_width * (x - plot_view.x0) / (plot_view.x1 - plot_view.x0);
                    line_rect.y0 = rect.y0;
                    line_rect.x1 = line_rect.x0+1;
                    line_rect.y1 = rect.y1;
                }

                draw_rectangle(plot->app, line_rect, 1.f, grid_line_color);


                {
                    float nearest_y_tick = (plot_view.y1 + plot_view.y0) / 2;
                    nearest_y_tick -= fmodf(nearest_y_tick, tick_increment_y);

                    String_Const_u8 str = push_stringf(scratch, "%.*f", tick_increment_y >= 1 ? 0 : 3, x);
                    draw_string(plot->app, plot->label_face_id, str,
                                V2f32(line_rect.x0,
                                      rect.y0 + rect_height -
                                      rect_height * (nearest_y_tick - plot_view.y0) / (plot_view.y1 - plot_view.y0)),
                                grid_line_color);
                }

            }
        }


        {
            for(float y = plot_view.y0 - fmodf(plot_view.y0, tick_increment_y);
                y <= plot_view.y1; y += tick_increment_y)
            {
                Rect_f32 line_rect = {0};
                {
                    line_rect.x0 = rect.x0;
                    line_rect.y0 = rect.y0 + rect_height - rect_height * (y - plot_view.y0) / (plot_view.y1 - plot_view.y0);
                    line_rect.x1 = rect.x1;
                    line_rect.y1 = line_rect.y0+1;
                }

                draw_rectangle(plot->app, line_rect, 1.f, grid_line_color);


                {
                    float nearest_x_tick = (plot_view.x1 + plot_view.x0) / 2;
                    nearest_x_tick -= fmodf(nearest_x_tick, tick_increment_x);

                    String_Const_u8 str = push_stringf(scratch, "%.*f", tick_increment_y >= 1 ? 0 : 3, y);
                    draw_string(plot->app, plot->label_face_id, str,
                                V2f32(rect.x0 + rect_width * (nearest_x_tick - plot_view.x0) / (plot_view.x1 - plot_view.x0),
                                      line_rect.y0),
                                grid_line_color);
                }
            }
        }
    }
}

static void
Plot2DPoints(Plot2DInfo *plot, i32 style_flags,
             float *x_data, float *y_data, int data_count)
{
    Rect_f32 rect = plot->screen_rect;
    Rect_f32 plot_view = plot->plot_view;

    f32 rect_width = rect.x1 - rect.x0;
    f32 rect_height = rect.y1 - rect.y0;


    {
        Color_Array plot_cycle = finalize_color_array(fleury_color_plot_cycle);
        ARGB_Color function_color =
            plot_cycle.vals[(plot->color_cycle_position++) % plot_cycle.count];

        for(int i = 0; i < data_count; ++i)
        {
            f32 point_x = rect_width * (x_data[i] - plot->plot_view.x0) / (plot->plot_view.x1 - plot->plot_view.x0);
            f32 point_y = rect_height - rect_height * (y_data[i] - plot->plot_view.y0) / (plot->plot_view.y1 - plot->plot_view.y0);

            if(style_flags & Plot2DStyleFlags_Lines)
            {
                Rect_f32 point_rect =
                {
                    plot->screen_rect.x0 + point_x - 1,
                    plot->screen_rect.y0 + point_y - 1,
                    plot->screen_rect.x0 + point_x + 1,
                    plot->screen_rect.y0 + point_y + 1,
                };


                draw_rectangle(plot->app, point_rect, 2.f, function_color);
            }

            if(style_flags & Plot2DStyleFlags_Points)
            {
                Rect_f32 point_rect =
                {
                    plot->screen_rect.x0 + point_x - 4,
                    plot->screen_rect.y0 + point_y - 4,
                    plot->screen_rect.x0 + point_x + 4,
                    plot->screen_rect.y0 + point_y + 4,
                };

                draw_rectangle(plot->app, point_rect, 6.f, function_color);
            }
        }
    }

}

static void
Plot2DHistogram(Plot2DInfo *plot, float *data, int data_count)
{
    if(plot->bins && plot->num_bins > 0)
    {
        for(int i = 0; i < data_count; ++i)
        {
            float t = (data[i] - plot->bin_data_range.min) / (plot->bin_data_range.max - plot->bin_data_range.min);
            int bin_to_go_in = (int)(plot->num_bins * t);
            if(bin_to_go_in >= 0 && bin_to_go_in < plot->num_bins)
            {
                ++plot->bins[bin_to_go_in + plot->current_bin_group*plot->num_bins];
            }
        }
        ++plot->current_bin_group;
    }
}

static void
Plot2DEnd(Plot2DInfo *plot)
{
    if(plot->mode == Plot2DMode_Histogram)
    {
        f32 bin_screen_width = ((plot->screen_rect.x1-plot->screen_rect.x0) / plot->num_bins) / plot->bin_group_count;

        for(int bin_group = 0; bin_group < plot->bin_group_count; ++bin_group)
        {
            int total_data = 0;

            for(int i = 0; i < plot->num_bins; ++i)
            {
                total_data += plot->bins[i + bin_group*plot->num_bins];
            }

            Color_Array plot_cycle = finalize_color_array(fleury_color_plot_cycle);
            ARGB_Color color =
                plot_cycle.vals[bin_group % plot_cycle.count];

            for(int i = 0; i < plot->num_bins; ++i)
            {
                int bin_index = i + bin_group*plot->num_bins;
                Rect_f32 bin_rect = {0};
                bin_rect.x0 = plot->screen_rect.x0 + ((float)i/plot->num_bins)*(plot->screen_rect.x1-plot->screen_rect.x0) + bin_screen_width*bin_group;
                bin_rect.x1 = bin_rect.x0 + bin_screen_width;
                bin_rect.y0 = bin_rect.y1 = plot->screen_rect.y1;
                bin_rect.y0 -= ((float)plot->bins[bin_index] / total_data) * (plot->screen_rect.y1 - plot->screen_rect.y0);
                draw_rectangle(plot->app, bin_rect, 4.f, color);
            }
        }
    }

    draw_rectangle_outline(plot->app, plot->screen_rect, 4.f, 3.f, fcolor_resolve(fcolor_id(defcolor_margin_active)));
    draw_set_clip(plot->app, plot->last_clip);
}
# 442 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_calc.cpp" 1
static f32 global_calc_time = 0.f;

static void
F4_CLC_Tick(Frame_Info frame_info)
{
    global_calc_time += frame_info.literal_dt;
}

enum CalcTokenType
{
    CalcTokenType_Invalid,
    CalcTokenType_Identifier,
    CalcTokenType_SourceCodeIdentifier,
    CalcTokenType_Number,
    CalcTokenType_Symbol,
    CalcTokenType_StringConstant,
};

typedef struct CalcToken CalcToken;
struct CalcToken
{
    CalcTokenType type;
    char *string;
    int string_length;
};

static CalcToken
GetNextCalcToken(char *buffer)
{
    CalcToken token = { CalcTokenType_Invalid };

    enum
    {
        ReadMode_Normal,
        ReadMode_SingleLineComment,
        ReadMode_MultilineComment,
    };
    int read_mode = 0;

    if(buffer)
    {
        for(int i = 0; buffer[i]; ++i)
        {
            if(read_mode == ReadMode_SingleLineComment)
            {
                if(buffer[i] == '\n')
                {
                    read_mode = ReadMode_Normal;
                }
            }
            else if(read_mode == ReadMode_MultilineComment)
            {
                if(buffer[i] == '#' && buffer[i+1] == '#')
                {
                    read_mode = ReadMode_Normal;
                }
                else if(buffer[i] == '*' && buffer[i+1] == '/')
                {
                    read_mode = ReadMode_Normal;
                }
            }
            else
            {
                if(buffer[i] == '#')
                {
                    if(buffer[i+1] == '#')
                    {
                        read_mode = ReadMode_MultilineComment;
                    }
                    else
                    {
                        read_mode = ReadMode_SingleLineComment;
                    }
                }
                else if(buffer[i] == '/' && (buffer[i+1] == '/' || buffer[i+1] == '*'))
                {
                    if(buffer[i+1] == '/')
                    {
                        read_mode = ReadMode_SingleLineComment;
                    }
                    else
                    {
                        read_mode = ReadMode_MultilineComment;
                    }
                }
                else if(buffer[i] == '@')
                {
                    token.type = CalcTokenType_SourceCodeIdentifier;
                    token.string = buffer+i+1;
                    int j;
                    for(j = i+1; buffer[j] &&
                        (CharIsDigit(buffer[j]) || buffer[j] == '_' ||
                         CharIsAlpha(buffer[j]));
                        ++j);
                    token.string_length = j - i - 1;
                    break;
                }
                else if(CharIsAlpha(buffer[i]))
                {
                    token.type = CalcTokenType_Identifier;
                    token.string = buffer+i;
                    int j;
                    for(j = i+1; buffer[j] &&
                        (CharIsDigit(buffer[j]) || buffer[j] == '_' ||
                         CharIsAlpha(buffer[j]));
                        ++j);
                    token.string_length = j - i;
                    break;
                }
                else if(CharIsDigit(buffer[i]))
                {
                    token.type = CalcTokenType_Number;
                    token.string = buffer+i;
                    int j;
                    for(j = i+1; buffer[j] &&
                        (CharIsDigit(buffer[j]) || buffer[j] == '.' ||
                         CharIsAlpha(buffer[j]));
                        ++j);
                    token.string_length = j - i;
                    break;
                }
                else if(CharIsSymbol(buffer[i]))
                {
                    token.type = CalcTokenType_Symbol;
                    token.string = buffer+i;


                    int j = i+1;


                    token.string_length = j - i;
                    break;
                }
                else if(buffer[i] == '"' || buffer[i] == '\'')
                {
                    int starting_char = buffer[i];
                    token.type = CalcTokenType_StringConstant;
                    token.string = buffer+i;
                    int j;
                    for(j = i+1; buffer[j] && buffer[j] != starting_char; ++j);
                    token.string_length = j - i + 1;
                    break;
                }
            }
        }
    }

    return token;
}

static CalcToken
NextCalcToken(char **at)
{
    CalcToken token = GetNextCalcToken(*at);
    *at = token.string + token.string_length;
    return token;
}

static CalcToken
PeekCalcToken(char **at)
{
    CalcToken token = GetNextCalcToken(*at);
    return token;
}

static int
CalcTokenMatch(CalcToken token, char *str)
{
    int match = 0;

    if(token.string && token.string_length > 0 &&
       token.type != CalcTokenType_Invalid)
    {
        match = 1;
        for(int i = 0; i < token.string_length; ++i)
        {
            if(token.string[i] == str[i])
            {
                if(i == token.string_length-1)
                {
                    if(str[i+1] != 0)
                    {
                        match = 0;
                        break;
                    }
                }
            }
            else
            {
                match = 0;
                break;
            }
        }
    }
    return match;
}

static int
RequireCalcToken(char **at, char *str)
{
    int result = 0;
    CalcToken token = GetNextCalcToken(*at);
    if(CalcTokenMatch(token, str))
    {
        result = 1;
        *at = token.string + token.string_length;
    }
    return result;
}

static int
RequireCalcTokenType(char **at, CalcTokenType type, CalcToken *token_ptr)
{
    int result = 0;
    CalcToken token = GetNextCalcToken(*at);
    if(token.type == type)
    {
        result = 1;
        *at = token.string + token.string_length;
        if(token_ptr)
        {
            *token_ptr = token;
        }
    }
    return result;
}

static int
RequireNewline(char **at)
{
    int result = 0;

    CalcToken next_token = PeekCalcToken(at);
    char *newline = 0;
    for(int i = 0; (*at)[i]; ++i)
    {
        if((*at)[i] == '\n')
        {
            newline = (*at)+i;
            break;
        }
    }

    if(newline)
    {
        if(next_token.string > newline)
        {
            result = 1;
        }
    }

    return result;
}

static int
RequireEndOfBuffer(char **at)
{
    int result = 0;
    CalcToken next_token = PeekCalcToken(at);
    result = next_token.string == 0;
    return result;
}
# 298 "4coder_fleury_calc.cpp"
enum CalcNodeType
{

    CalcNodeType_Invalid,CalcNodeType_Error,CalcNodeType_Number,CalcNodeType_StringConstant,CalcNodeType_Array,CalcNodeType_Identifier,CalcNodeType_SourceCodeIdentifier,CalcNodeType_FunctionCall,CalcNodeType_Add,CalcNodeType_Subtract,CalcNodeType_Multiply,CalcNodeType_Divide,CalcNodeType_Modulus,CalcNodeType_RaiseToPower,CalcNodeType_Negate,CalcNodeType_Assignment,CalcNodeType_ArrayIndex,

};

static int
CalcOperatorPrecedence(CalcNodeType type)
{
    static int precedence_table[] =
    {

        0,0,0,0,0,0,0,0,1,1,2,2,2,0,0,0,0,

    };
    return precedence_table[type];
}

enum CalcType
{

    CalcType_Error, CalcType_None, CalcType_Number, CalcType_Array, CalcType_String, CalcType_SourceCodeReference,

};

static char *
CalcTypeName(CalcType type)
{
    static char *name_table[] =
    {

        "error", "none", "number", "array", "string", "source code reference",

    };
    return name_table[type];
}



typedef struct CalcNode CalcNode;
struct CalcNode
{
    CalcNodeType type;
    double value;
    union
    {
        CalcNode *operand;
        CalcNode *left;
    };
    CalcNode *right;
    union
    {
        CalcNode *first_parameter;
        CalcNode *first_member;
    };
    CalcNode *next;
    CalcToken token;
    int num_params;
    String_Const_u8 error_string;
    char *at_source;
};

static CalcNode *
AllocateCalcNode(Arena *arena, CalcNodeType type, char *at_source)
{
    CalcNode *node = ((CalcNode*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(CalcNode)*(1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "364" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "364" ":") - 1)))));
    memset(node, 0, sizeof(*node));
    node->type = type;
    node->at_source = at_source;
    return node;
}

static CalcNode *
ErrorCalcNode(Arena *arena, char *format, ...)
{
    CalcNode *node = ((CalcNode*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(CalcNode)*(1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "374" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "374" ":") - 1)))));
    memset(node, 0, sizeof(*node));
    node->type = CalcNodeType_Error;
    va_list args;
    
# 378 "4coder_fleury_calc.cpp" 3 4
   __builtin_va_start(
# 378 "4coder_fleury_calc.cpp"
   args
# 378 "4coder_fleury_calc.cpp" 3 4
   ,
# 378 "4coder_fleury_calc.cpp"
   format
# 378 "4coder_fleury_calc.cpp" 3 4
   )
# 378 "4coder_fleury_calc.cpp"
                         ;
    node->error_string = push_stringfv(arena, format, args);
    
# 380 "4coder_fleury_calc.cpp" 3 4
   __builtin_va_end(
# 380 "4coder_fleury_calc.cpp"
   args
# 380 "4coder_fleury_calc.cpp" 3 4
   )
# 380 "4coder_fleury_calc.cpp"
               ;
    return node;
}

static CalcNode *ParseCalcExpression(Arena *arena, char **at_ptr);

static CalcNode *
ParseCalcUnaryExpression(Arena *arena, char **at_ptr)
{
    CalcNode *expression = 0;
    CalcToken token = PeekCalcToken(at_ptr);
    char *at_source = token.string;

    if(CalcTokenMatch(token, "-"))
    {
        NextCalcToken(at_ptr);
        expression = AllocateCalcNode(arena, CalcNodeType_Negate, at_source);
        expression->operand = ParseCalcUnaryExpression(arena, at_ptr);
    }
    else if(token.type == CalcTokenType_SourceCodeIdentifier)
    {
        NextCalcToken(at_ptr);
        expression = AllocateCalcNode(arena, CalcNodeType_SourceCodeIdentifier, at_source);
        expression->token = token;
    }
    else if(token.type == CalcTokenType_Identifier)
    {
        NextCalcToken(at_ptr);


        if(RequireCalcToken(at_ptr, "("))
        {
            expression = AllocateCalcNode(arena, CalcNodeType_FunctionCall, at_source);
            expression->token = token;

            CalcNode **target_param = &expression->first_parameter;
            for(;;)
            {
                CalcToken next_token = PeekCalcToken(at_ptr);
                if(next_token.type == CalcTokenType_Invalid ||
                   CalcTokenMatch(next_token, ")"))
                {
                    break;
                }

                CalcNode *param = ParseCalcExpression(arena, at_ptr);

                if(param)
                {
                    *target_param = param;
                    target_param = &(*target_param)->next;
                    RequireCalcToken(at_ptr, ",");
                }
                else
                {
                    expression = ErrorCalcNode(arena, "Invalid parameter.");
                    goto end_parse;
                }
            }

            if(!RequireCalcToken(at_ptr, ")"))
            {
                expression = ErrorCalcNode(arena, "Missing ')'.");
                goto end_parse;
            }
        }


        else
        {
            expression = AllocateCalcNode(arena, CalcNodeType_Identifier, at_source);
            expression->token = token;
        }
    }
    else if(CalcTokenMatch(token, "("))
    {
        NextCalcToken(at_ptr);
        expression = ParseCalcExpression(arena, at_ptr);
        RequireCalcToken(at_ptr, ")");
    }
    else if(token.type == CalcTokenType_Number)
    {
        NextCalcToken(at_ptr);
        expression = AllocateCalcNode(arena, CalcNodeType_Number, at_source);
        expression->value = GetFirstDoubleFromBuffer(token.string);
    }
    else if(token.type == CalcTokenType_StringConstant)
    {
        NextCalcToken(at_ptr);
        expression = AllocateCalcNode(arena, CalcNodeType_StringConstant, at_source);
        expression->token = token;
    }
    else if(CalcTokenMatch(token, "["))
    {
        NextCalcToken(at_ptr);

        expression = AllocateCalcNode(arena, CalcNodeType_Array, at_source);
        CalcNode **target_member = &expression->first_member;

        for(;;)
        {
            token = PeekCalcToken(at_ptr);
            if(CalcTokenMatch(token, "]") || token.type == CalcTokenType_Invalid)
            {
                break;
            }

            CalcNode *member_expression = ParseCalcExpression(arena, at_ptr);
            if(!RequireCalcToken(at_ptr, ","))
            {
                expression = ErrorCalcNode(arena, "Missing ','.");
                goto end_parse;
            }
            if(member_expression)
            {
                *target_member = member_expression;
                target_member = &(*target_member)->next;
            }
            else
            {
                break;
            }
        }

        RequireCalcToken(at_ptr, "]");
    }

    if(RequireCalcToken(at_ptr, "^"))
    {
        CalcNode *old_expr = expression;
        expression = AllocateCalcNode(arena, CalcNodeType_RaiseToPower, at_source);
        expression->left = old_expr;
        expression->right = ParseCalcUnaryExpression(arena, at_ptr);
    }


    if(expression)
    {
        while(RequireCalcToken(at_ptr, "["))
        {
            CalcNode *old_expr = expression;
            expression = AllocateCalcNode(arena, CalcNodeType_ArrayIndex, at_source);
            expression->token = token;
            expression->left = old_expr;
            expression->right = ParseCalcExpression(arena, at_ptr);

            if(!expression->right)
            {
                expression = ErrorCalcNode(arena, "Missing array index inside of '[' and ']'.");
                goto end_parse;
            }

            if(!RequireCalcToken(at_ptr, "]"))
            {
                expression = ErrorCalcNode(arena, "Missing ']'.");
                goto end_parse;
            }
        }
    }

    end_parse:;
    return expression;
}

static CalcNodeType
GetCalcBinaryOperatorTypeFromToken(CalcToken token)
{
    CalcNodeType type = CalcNodeType_Invalid;
    switch(token.type)
    {
        case CalcTokenType_Symbol:
        {
            if(token.string[0] == '+')
            {
                type = CalcNodeType_Add;
            }
            else if(token.string[0] == '-')
            {
                type = CalcNodeType_Subtract;
            }
            else if(token.string[0] == '*')
            {
                type = CalcNodeType_Multiply;
            }
            else if(token.string[0] == '/')
            {
                type = CalcNodeType_Divide;
            }
            else if(token.string[0] == '%')
            {
                type = CalcNodeType_Modulus;
            }
            break;
        }
        default: break;
    }
    return type;
}

static CalcNode *
ParseCalcExpression_(Arena *arena, char **at_ptr, int precedence_in)
{
    CalcNode *expression = ParseCalcUnaryExpression(arena, at_ptr);

    if(expression)
    {
        CalcToken token = PeekCalcToken(at_ptr);
        CalcNodeType operator_type = GetCalcBinaryOperatorTypeFromToken(token);

        char *at_source = token.string;

        if(token.string && operator_type != CalcNodeType_Invalid &&
           operator_type != CalcNodeType_Number)
        {
            for(int precedence = CalcOperatorPrecedence(operator_type);
                precedence >= precedence_in;
                --precedence)
            {
                for(;;)
                {
                    token = PeekCalcToken(at_ptr);

                    operator_type = GetCalcBinaryOperatorTypeFromToken(token);
                    int operator_precedence = CalcOperatorPrecedence(operator_type);

                    if(operator_precedence != precedence)
                    {
                        break;
                    }

                    if(operator_type == CalcNodeType_Invalid)
                    {
                        break;
                    }

                    NextCalcToken(at_ptr);

                    CalcNode *right = ParseCalcExpression_(arena, at_ptr, precedence+1);
                    CalcNode *existing_expression = expression;
                    expression = AllocateCalcNode(arena, operator_type, at_source);
                    expression->type = operator_type;
                    expression->left = existing_expression;
                    expression->right = right;

                    if(!right)
                    {
                        goto end_parse;
                    }
                }
            }

            end_parse:;
        }
    }


    return expression;
}

static CalcNode *
ParseCalcExpression(Arena *arena, char **at_ptr)
{
    return ParseCalcExpression_(arena, at_ptr, 1);
}

static CalcNode *
ParseCalcCode(Arena *arena, char **at_ptr)
{
    CalcNode *root = 0;
    CalcNode **target = &root;

    for(;;)
    {
        CalcToken token = PeekCalcToken(at_ptr);


        if(token.type == CalcTokenType_Identifier)
        {
            char *at_source = token.string;

            char *at_reset = *at_ptr;
            NextCalcToken(at_ptr);


            if(RequireCalcToken(at_ptr, "="))
            {
                CalcNode *identifier = AllocateCalcNode(arena, CalcNodeType_Identifier, at_source);
                identifier->token = token;

                CalcNode *assignment = AllocateCalcNode(arena, CalcNodeType_Assignment, at_source);
                assignment->left = identifier;
                assignment->right = ParseCalcExpression(arena, at_ptr);

                if(assignment == 0)
                {
                    break;
                }

                if(assignment->right == 0)
                {
                    assignment = ErrorCalcNode(arena, "Syntax error.");
                    *target = assignment;
                    break;
                }
                else if(assignment->right->type == CalcNodeType_Error)
                {
                    assignment = assignment->right;
                    *target = assignment;
                    break;
                }

                *target = assignment;
                target = &(*target)->next;
                goto end_parse;
            }
            else
            {
                *at_ptr = at_reset;
            }
        }


        {
            CalcNode *expression = ParseCalcExpression(arena, at_ptr);
            if(expression == 0)
            {
                break;
            }
            *target = expression;
            target = &(*target)->next;
            goto end_parse;
        }

        end_parse:;

        if(!RequireCalcToken(at_ptr, ";") && !RequireNewline(at_ptr) &&
           !RequireEndOfBuffer(at_ptr))
        {
            *target = ErrorCalcNode(arena, "Expected end-of-statement (semicolon or newline).");
            target = &(*target)->next;
            break;
        }
    }

    return root;
}

typedef struct CalcInterpretGraph CalcInterpretGraph;
struct CalcInterpretGraph
{
    CalcInterpretGraph *next;
    CalcNode *parent_call;
    Plot2DMode mode;
    String_Const_u8 plot_title;
    String_Const_u8 x_axis;
    String_Const_u8 y_axis;
    int num_function_samples;
    Rect_f32 plot_view;
    int num_bins;
    Range_f32 bin_data_range;
    union
    {
        float *x_data;
        float *data;
    };
    float *y_data;
    int data_count;
    i32 style_flags;
};

typedef struct CalcValue CalcValue;
struct CalcValue
{
    union
    {
        struct
        {
            String_Const_u8 as_string;
        };

        struct
        {
            int array_count;
            CalcValue *as_array;
        };

        struct
        {
            String_Const_u8 as_error;
        };

        struct
        {
            double as_f64;
        };

        struct
        {
            i64 as_token_offset;
        };
    };

    CalcType type;
};

typedef struct CalcInterpretResult CalcInterpretResult;
struct CalcInterpretResult
{
    CalcValue value;
    CalcInterpretGraph *first_graph;
};

typedef struct CalcSymbolKey CalcSymbolKey;
struct CalcSymbolKey
{
    char *string;
    i32 string_length;
    b32 deleted;
};

typedef struct CalcSymbolValue CalcSymbolValue;
struct CalcSymbolValue
{
    CalcValue value;
};

typedef struct CalcSymbolTable CalcSymbolTable;
struct CalcSymbolTable
{
    unsigned int size;
    CalcSymbolKey *keys;
    CalcSymbolValue *values;
};

static CalcValue
CalcValueNone(void)
{
    CalcValue calc_value = {0};
    calc_value.type = CalcType_None;
    return calc_value;
}

static CalcValue
CalcValueF64(double num)
{
    CalcValue val = {0};
    val.type = CalcType_Number;
    val.as_f64 = num;
    return val;
}

static CalcValue
CalcValueError(String_Const_u8 string)
{
    CalcValue val = {0};
    val.type = CalcType_Error;
    val.as_error = string;
    return val;
}

static CalcValue
CalcValueString(String_Const_u8 string)
{
    CalcValue val = {0};
    val.type = CalcType_String;
    val.as_string = string;
    return val;
}

static CalcValue
CalcValueSourceCodeReference(i64 token_position)
{
    CalcValue val = {0};
    val.type = CalcType_SourceCodeReference;
    val.as_token_offset = token_position;
    return val;
}

typedef struct CalcInterpretContext CalcInterpretContext;
struct CalcInterpretContext
{
    Application_Links *app;
    Buffer_ID buffer;
    Text_Layout_ID text_layout_id;
    Arena *arena;
    CalcSymbolTable *symbol_table;
    f32 current_time;


    struct
    {
        String_Const_u8 plot_title;
        String_Const_u8 x_axis;
        String_Const_u8 y_axis;
        Rect_f32 plot_view;
        int num_function_samples;
        int num_bins;
        f32 bin_range_low;
        f32 bin_range_high;
    };
};


static CalcInterpretResult
InterpretCalcExpression(CalcInterpretContext *context, CalcNode *root);

static CalcValue
CalcValueArray(CalcInterpretContext *context, CalcNode *first_member)
{
    CalcValue val = {0};
    val.type = CalcType_Array;

    CalcType array_type = CalcType_None;
    int count = 0;

    for(CalcNode *member = first_member; member; member = member->next)
    {
        ++count;
    }

    CalcValue *array = ((CalcValue*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(CalcValue)*(count), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "900" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "900" ":") - 1)))));

    int write_pos = 0;

    for(CalcNode *member = first_member; member; member = member->next)
    {
        CalcInterpretResult result = InterpretCalcExpression(context, member);

        if(member == first_member)
        {
            array_type = result.value.type;
            if(array_type == CalcType_Error)
            {
                val = result.value;
                goto end_create;
            }
            else if(array_type == CalcType_None)
            {
                val = CalcValueError(SCu8((u8*)("Cannot make arrays of 'none' type."), (u64)(sizeof("Cannot make arrays of 'none' type.") - 1)));
                goto end_create;
            }
        }
        else
        {
            if(result.value.type != array_type)
            {
                val = CalcValueError(SCu8((u8*)("Cannot have multiple types in an array."), (u64)(sizeof("Cannot have multiple types in an array.") - 1)));
                goto end_create;
            }
        }

        array[write_pos++] = result.value;
    }

    if(array && count)
    {
        val.as_array = array;
        val.array_count = count;
    }

    end_create:;
    return val;
}

static CalcSymbolTable
CalcSymbolTableInit(Arena *arena, unsigned int size)
{
    CalcSymbolTable table = {0};
    table.size = size;
    table.keys = ((CalcSymbolKey*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(CalcSymbolKey)*(size), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "949" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "949" ":") - 1)))));
    table.values = ((CalcSymbolValue*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(CalcSymbolValue)*(size), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "950" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "950" ":") - 1)))));
    memset(table.keys, 0, sizeof(*table.keys)*size);
    memset(table.values, 0, sizeof(*table.values)*size);
    return table;
}

static CalcSymbolValue *
CalcSymbolTableLookup_(CalcSymbolTable *table, char *string, int length)
{
    CalcSymbolValue *result = 0;

    unsigned int hash = StringCRC32(string, length) % table->size;
    unsigned int original_hash = hash;

    CalcSymbolValue *value = 0;

    for(;;)
    {
        if(table->keys[hash].string || table->keys[hash].deleted)
        {
            if(!table->keys[hash].deleted &&
               StringMatchCaseSensitive(table->keys[hash].string, table->keys[hash].string_length,
                                        string, length))
            {
                value = table->values + hash;
                break;
            }
            else
            {
                if(++hash >= table->size)
                {
                    hash = 0;
                }
                if(hash == original_hash)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }
    }

    if(value)
    {
        result = value;
    }

    return result;
}

static CalcValue
CalcSymbolTableLookup(CalcSymbolTable *table, char *string, int string_length)
{
    CalcValue result = {0};
    CalcSymbolValue *value = CalcSymbolTableLookup_(table, string, string_length);
    if(value)
    {
        result = value->value;
    }
    else
    {
        result.type = CalcType_Error;
    }
    return result;
}

static CalcSymbolValue *
CalcSymbolTableAdd(CalcSymbolTable *table, char *string, int string_length, CalcValue value)
{
    CalcSymbolValue *result = 0;

    unsigned int hash = StringCRC32(string, string_length) % table->size;
    unsigned int original_hash = hash;
    unsigned int found_hash = 0;
    int found = 0;

    for(;;)
    {
        if(table->keys[hash].string || table->keys[hash].deleted)
        {
            if(!table->keys[hash].deleted &&
               StringMatchCaseSensitive(table->keys[hash].string, table->keys[hash].string_length,
                                        string, string_length))
            {
                found = 1;
                found_hash = hash;
                break;
            }
            else if(table->keys[hash].deleted)
            {
                found = 1;
                found_hash = hash;
            }

            if(++hash >= table->size)
            {
                hash = 0;
            }
            if(hash == original_hash)
            {
                break;
            }
        }
        else
        {
            found = 1;
            found_hash = hash;
            break;
        }
    }

    if(found)
    {
        table->keys[found_hash].string = string;
        table->keys[found_hash].string_length = string_length;
        table->values[found_hash].value = value;
        result = table->values + found_hash;
    }

    return result;
}

static void
CalcSymbolTableRemove(CalcSymbolTable *table, char *string, int length)
{
    unsigned int hash = StringCRC32(string, length) % table->size;
    unsigned int original_hash = hash;

    for(;;)
    {
        if(table->keys[hash].string || table->keys[hash].deleted)
        {
            if(!table->keys[hash].deleted &&
               StringMatchCaseSensitive(table->keys[hash].string, table->keys[hash].string_length,
                                        string, length))
            {
                table->keys[hash].deleted = 1;
                break;
            }

            if(++hash >= table->size)
            {
                hash = 0;
            }
            if(hash == original_hash)
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
}

static void
GetDataFromSourceCode(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                      i64 start_pos, Arena *arena, float **data_ptr, int *data_count_ptr)
{
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

    if(token_array.tokens != 0)
    {
        Token_Iterator_Array it = token_iterator_pos(0, &token_array, start_pos);
        Token *token = 0;

        b32 found = 0;


        for(;;)
        {
            token = token_it_read(&it);
            if(token->pos >= start_pos + 30 || !token ||
               !token_it_inc_non_whitespace(&it))
            {
                found = 0;
                break;
            }

            if(token->kind == TokenBaseKind_ScopeOpen)
            {
                found = 1;
                break;
            }
        }


        if(found)
        {
            struct DataChunk
            {
                DataChunk *next;
                u64 value_count;
                float values[1024];
            };

            u64 total_value_count = 0;
            DataChunk *data_chunk = ((DataChunk*)linalloc_wrap_zero(linalloc_push((arena), sizeof(DataChunk)*(1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1152" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1152" ":") - 1)))));
            DataChunk *first_data_chunk = data_chunk;
            DataChunk *last_data_chunk = data_chunk;

            b32 is_negative = 0;
            int data_count;
            float *data;
            for(;;)
            {
                token = token_it_read(&it);
                if(!token || !token_it_inc_non_whitespace(&it))
                {
                    goto end_read_data;
                }

                if(token->kind == TokenBaseKind_Operator &&
                   token->sub_kind == TokenCppKind_Minus)
                {
                    is_negative = 1;
                }

                if(token->kind == TokenBaseKind_LiteralFloat ||
                   token->kind == TokenBaseKind_LiteralInteger)
                {
                    Range_i64 token_range =
                    {
                        token->pos,
                        token->pos + (token->size > 256 ? 256 : token->size),
                    };

                    u8 token_buffer[256];
                    buffer_read_range(app, buffer, token_range, token_buffer);

                    float sign = is_negative ? -1.f : 1.f;
                    is_negative = 0;

                    float value = sign * (float)GetFirstDoubleFromBuffer((char *)token_buffer);
                    if(last_data_chunk->value_count >= ((sizeof(last_data_chunk->values))/(sizeof(*last_data_chunk->values))))
                    {
                        DataChunk *new_chunk = ((DataChunk*)linalloc_wrap_zero(linalloc_push((arena), sizeof(DataChunk)*(1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1191" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1191" ":") - 1)))));
                        last_data_chunk->next = new_chunk;
                        last_data_chunk = new_chunk;
                    }
                    last_data_chunk->values[last_data_chunk->value_count++] = value;
                    total_value_count += 1;
                }
                else if(token->kind == TokenBaseKind_ScopeClose)
                {
                    break;
                }
            }

            data_count = 0;
            data = ((float*)linalloc_wrap_zero(linalloc_push((arena), sizeof(float)*(total_value_count), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1205" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1205" ":") - 1)))));
            for(DataChunk *chunk = first_data_chunk; chunk; chunk = chunk->next)
            {
                for(int i = 0; i < ((sizeof(chunk->values))/(sizeof(*chunk->values))); i += 1)
                {
                    data[data_count] = chunk->values[i];
                    data_count += 1;
                }
            }

            *data_ptr = data;
            *data_count_ptr = data_count;

            end_read_data:;
        }

    }
}

static void
GraphCalcExpression(Application_Links *app, Face_ID face_id,
                    Rect_f32 rect, CalcInterpretGraph *first_graph,
                    CalcInterpretContext *context)
{
    CalcNode *parent_call = first_graph->parent_call;
    Rect_f32 plot_view = first_graph->plot_view;

    int plot_count = 0;
    for(CalcInterpretGraph *graph = first_graph; graph && graph->parent_call == parent_call;
        graph = graph->next)
    {
        ++plot_count;
    }

    Plot2DInfo plot_data = {0};
    {
        plot_data.mode = first_graph->mode;
        plot_data.title = first_graph->plot_title;
        plot_data.x_axis = first_graph->x_axis;
        plot_data.y_axis = first_graph->y_axis;
        plot_data.screen_rect = rect;
        plot_data.app = app;
        plot_data.title_face_id = global_styled_title_face;
        plot_data.label_face_id = global_styled_label_face;
        plot_data.plot_view = plot_view;
        plot_data.num_bins = first_graph->num_bins;
        plot_data.bin_data_range = first_graph->bin_data_range;

        if(first_graph->num_bins > 0)
        {
            plot_data.bin_group_count = plot_count;
            plot_data.bins = ((int*)linalloc_wrap_zero(linalloc_push((context->arena), sizeof(int)*(plot_data.num_bins*plot_data.bin_group_count), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1256" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1256" ":") - 1)))));
        }
    }
    Plot2DBegin(&plot_data);

    for(CalcInterpretGraph *graph = first_graph; graph && graph->parent_call == parent_call;
        graph = graph->next)
    {

        switch(plot_data.mode)
        {


            case Plot2DMode_Line:
            {
                Plot2DPoints(&plot_data, graph->style_flags, graph->x_data, graph->y_data, graph->data_count);
                break;
            }


            case Plot2DMode_Histogram:
            {
                Plot2DHistogram(&plot_data, graph->data, graph->data_count);
                break;
            }

            default: break;
        }
    }

    Plot2DEnd(&plot_data);
}

typedef struct CalcFindInputResult CalcFindInputResult;
struct CalcFindInputResult
{
    CalcNode *unknown;
    int number_unknowns;
};

static CalcFindInputResult
FindUnknownForGraph(CalcSymbolTable *table, CalcNode *expression)
{
    CalcFindInputResult result = {0};

    if(expression && expression->type != CalcNodeType_Invalid)
    {
        if(expression->type == CalcNodeType_Identifier)
        {
            CalcSymbolValue *symbol_value =
                CalcSymbolTableLookup_(table, expression->token.string,
                                       expression->token.string_length);

            if(!symbol_value)
            {
                result.unknown = expression;
                ++result.number_unknowns;
            }
        }
        else
        {
            CalcFindInputResult results[] =
            {
                FindUnknownForGraph(table, expression->left),
                FindUnknownForGraph(table, expression->right),
                FindUnknownForGraph(table, expression->first_parameter),
                FindUnknownForGraph(table, expression->next),
            };

            for(int i = 0; i < ((sizeof(results))/(sizeof(*results))); ++i)
            {
                if(results[i].unknown)
                {
                    if(!result.unknown)
                    {
                        result.unknown = results[i].unknown;
                        ++result.number_unknowns;
                    }
                    else
                    {
                        if(!StringMatchCaseSensitive(results[i].unknown->token.string, results[i].unknown->token.string_length,
                                                     result.unknown->token.string, result.unknown->token.string_length))
                        {
                            ++result.number_unknowns;
                        }
                    }
                }
            }
        }
    }

    return result;
}


typedef CalcInterpretResult CalcBuiltInFunction(CalcInterpretContext *context, int param_count, CalcInterpretResult *params);

static
CalcInterpretResult CalcSin(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    CalcInterpretResult result = {0};
    result.value = CalcValueF64(sin(params[0].value.as_f64));
    return result;
}

static
CalcInterpretResult CalcCos(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    CalcInterpretResult result = {0};
    result.value = CalcValueF64(cos(params[0].value.as_f64));
    return result;
}

static
CalcInterpretResult CalcTan(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    CalcInterpretResult result = {0};
    result.value = CalcValueF64(tan(params[0].value.as_f64));
    return result;
}

static
CalcInterpretResult CalcAbs(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    CalcInterpretResult result = {0};
    result.value = CalcValueF64(fabs(params[0].value.as_f64));
    return result;
}

static
CalcInterpretResult CalcPlotTitle(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    context->plot_title = params[0].value.as_string;
    context->plot_title.str += 1;
    context->plot_title.size -= 2;
    CalcInterpretResult result = {0};
    result.value = CalcValueNone();
    return result;
}

static
CalcInterpretResult CalcPlotFunctionSamples(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    context->num_function_samples = (int)params[0].value.as_f64;
    CalcInterpretResult result = {0};
    result.value = CalcValueNone();
    return result;
}

static
CalcInterpretResult CalcPlotBinCount(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    context->num_bins = (int)params[0].value.as_f64;
    CalcInterpretResult result = {0};
    result.value = CalcValueNone();
    return result;
}

static
CalcInterpretResult CalcPlotBinRange(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    context->bin_range_low = (f32)params[0].value.as_f64;
    context->bin_range_high = (f32)params[1].value.as_f64;
    CalcInterpretResult result = {0};
    result.value = CalcValueNone();
    return result;
}

static
CalcInterpretResult CalcTime(CalcInterpretContext *context, int param_count, CalcInterpretResult *params)
{
    CalcInterpretResult result = {0};
    result.value = CalcValueF64((f64)context->current_time);
    animate_in_n_milliseconds(context->app, 0);
    return result;
}

static void
GenerateLinePlotData(CalcInterpretContext *context, CalcNode *expression,
                     CalcNode *input_variable, float **x_data, float **y_data,
                     int *data_count, i32 *style_flags_ptr)
{
    CalcInterpretResult expression_result = InterpretCalcExpression(context, expression);

    *x_data = 0;
    *y_data = 0;
    *data_count = 0;
    *style_flags_ptr = 0;

    i32 style_flags = 0;


    if(expression_result.value.type == CalcType_Array)
    {
        style_flags |= Plot2DStyleFlags_Points;


        if(expression_result.value.array_count == 2 &&
           expression_result.value.as_array[0].type == CalcType_Array &&
           expression_result.value.as_array[1].type == CalcType_Array &&
           expression_result.value.as_array[0].array_count > 0 &&
           expression_result.value.as_array[0].array_count ==
           expression_result.value.as_array[1].array_count &&
           expression_result.value.as_array[0].as_array[0].type ==
           expression_result.value.as_array[1].as_array[0].type &&
           expression_result.value.as_array[0].as_array[0].type == CalcType_Number)
        {
            int values_to_plot = expression_result.value.as_array[0].array_count;
            float *x_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1464" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1464" ":") - 1)))));
            float *y_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1465" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1465" ":") - 1)))));

            for(int i = 0; i < values_to_plot; ++i)
            {
                x_values[i] = (float)expression_result.value.as_array[0].as_array[i].as_f64;
                y_values[i] = (float)expression_result.value.as_array[1].as_array[i].as_f64;
            }

            *x_data = x_values;
            *y_data = y_values;
            *data_count = values_to_plot;
        }


        else if(expression_result.value.array_count > 0 &&
                expression_result.value.as_array[0].type == CalcType_Number)
        {
            int values_to_plot = expression_result.value.array_count;
            float *x_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1483" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1483" ":") - 1)))));
            float *y_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1484" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1484" ":") - 1)))));

            for(int i = 0; i < values_to_plot; ++i)
            {
                x_values[i] = (float)i;
                y_values[i] = (float)expression_result.value.as_array[i].as_f64;
            }

            *x_data = x_values;
            *y_data = y_values;
            *data_count = values_to_plot;
        }

    }



    else if(expression_result.value.type == CalcType_SourceCodeReference)
    {
        style_flags |= Plot2DStyleFlags_Points;

        float *y_values = 0;
        int values_to_plot = 0;
        GetDataFromSourceCode(context->app, context->buffer, context->text_layout_id,
                              expression_result.value.as_token_offset, context->arena,
                              &y_values, &values_to_plot);


        if(y_values && values_to_plot)
        {
            float *x_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1514" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1514" ":") - 1)))));
            for(int i = 0; i < values_to_plot; ++i)
            {
                x_values[i] = (float)i;
            }
            *x_data = x_values;
            *y_data = y_values;
            *data_count = values_to_plot;
        }
    }



    else
    {
        style_flags |= Plot2DStyleFlags_Lines;

        CalcNode *input_node = input_variable;
        CalcSymbolValue *symbol_value_ptr = 0;
        if(input_node)
        {
            CalcValue value = CalcValueF64(0);
            symbol_value_ptr =
                CalcSymbolTableAdd(context->symbol_table, input_node->token.string,
                                   input_node->token.string_length, value);
        }


        int values_to_plot = context->num_function_samples;
        float *x_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1543" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1543" ":") - 1)))));
        float *y_values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1544" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1544" ":") - 1)))));
        {
            for(int i = 0; i < values_to_plot; ++i)
            {
                double new_x_value = (context->plot_view.x0 + (i / (float)values_to_plot) *
                                      (context->plot_view.x1 - context->plot_view.x0));
                if(symbol_value_ptr)
                {
                    symbol_value_ptr->value.as_f64 = new_x_value;
                }

                CalcInterpretResult result = InterpretCalcExpression(context, expression);
                if(result.value.type != CalcType_Number)
                {
                    break;
                }
                else
                {
                    x_values[i] = (float)new_x_value;
                    y_values[i] = (float)result.value.as_f64;
                }
            }
        }

        if(input_node)
        {
            CalcSymbolTableRemove(context->symbol_table, input_node->token.string,
                                  input_node->token.string_length);
        }

        *x_data = x_values;
        *y_data = y_values;
        *data_count = values_to_plot;
    }

    *style_flags_ptr = style_flags;
}

static void
GenerateHistogramPlotData(CalcInterpretContext *context, CalcNode *expression,
                          CalcNode *input_variable, float **data, int *data_count)
{
    CalcInterpretResult expression_result = InterpretCalcExpression(context, expression);

    *data = 0;
    *data_count = 0;


    if(expression_result.value.type == CalcType_Array)
    {

        if(expression_result.value.array_count > 0 &&
           expression_result.value.as_array[0].type == CalcType_Number)
        {
            int values_to_plot = expression_result.value.array_count;
            float *values = ((float*)linalloc_wrap_unintialized(linalloc_push((context->arena), sizeof(float)*(values_to_plot), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1599" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1599" ":") - 1)))));

            for(int i = 0; i < values_to_plot; ++i)
            {
                values[i] = (float)expression_result.value.as_array[i].as_f64;
            }

            *data = values;
            *data_count = values_to_plot;
        }

    }


    else if(expression_result.value.type == CalcType_SourceCodeReference)
    {
        float *values = 0;
        int values_to_plot = 0;
        GetDataFromSourceCode(context->app, context->buffer, context->text_layout_id,
                              expression_result.value.as_token_offset, context->arena,
                              &values, &values_to_plot);


        if(values && values_to_plot)
        {
            *data = values;
            *data_count = values_to_plot;
        }
    }


    else
    {

    }

}

static CalcInterpretResult
CallCalcBuiltInFunction(CalcInterpretContext *context, CalcNode *root)
{



    CalcInterpretResult result = {0};

    b32 function_valid = 0;

    if(!root || root->type != CalcNodeType_FunctionCall)
    {
        result.value = CalcValueError(SCu8((u8*)("Internal parsing error, function call expected."), (u64)(sizeof("Internal parsing error, function call expected.") - 1)));
        goto end_func_call;
    }

    static struct
    {
        char *name;
        CalcBuiltInFunction *proc;
        CalcType return_type;
        int required_parameter_count;
        CalcType parameter_types[4];
    }
    functions[] =
    {
        { "sin", CalcSin, CalcType_Number, 1, { CalcType_Number }, },
        { "cos", CalcCos, CalcType_Number, 1, { CalcType_Number }, },
        { "tan", CalcTan, CalcType_Number, 1, { CalcType_Number }, },
        { "abs", CalcAbs, CalcType_Number, 1, { CalcType_Number }, },

        {
            "plot_title",
            CalcPlotTitle,
            CalcType_None,
            1, { CalcType_String },
        },

        {
            "plot_function_samples",
            CalcPlotFunctionSamples,
            CalcType_None,
            1, { CalcType_Number },
        },

        {
            "plot_bin_count",
            CalcPlotBinCount,
            CalcType_None,
            1, { CalcType_Number },
        },

        {
            "plot_bin_range",
            CalcPlotBinRange,
            CalcType_None,
            2, { CalcType_Number, CalcType_Number },
        },

        { "time", CalcTime, CalcType_Number, },

    };

    for(int i = 0; i < ((sizeof(functions))/(sizeof(*functions))); ++i)
    {
        if(CalcTokenMatch(root->token, functions[i].name))
        {
            function_valid = 1;

            int param_count = 0;
            CalcInterpretResult param_results[4] = {0};
            for(CalcNode *param = root->first_parameter; param; param = param->next)
            {
                param_results[param_count++] = InterpretCalcExpression(context, param);
                if(param_count >= ((sizeof(param_results))/(sizeof(*param_results))))
                {
                    break;
                }
            }

            int correct_call = 1;

            if(param_count < functions[i].required_parameter_count)
            {
                String_Const_u8 error_string = push_stringf(context->arena, "%s expects at least %i parameters.",
                                                            functions[i].name, functions[i].required_parameter_count);
                result.value = CalcValueError(error_string);
                correct_call = 0;
            }

            if(correct_call)
            {
                for(int j = 0; j < param_count; ++j)
                {
                    if(param_results[j].value.type != functions[i].parameter_types[j])
                    {
                        correct_call = 0;
                        String_Const_u8 error_string = push_stringf(context->arena, "'%s' expects a '%s' for parameter %i.",
                                                                    functions[i].name, CalcTypeName(functions[i].parameter_types[j]),
                                                                    j+1);
                        result.value = CalcValueError(error_string);
                        break;
                    }
                }
            }

            if(correct_call)
            {
                result = functions[i].proc(context, param_count, param_results);
            }
        }
        else if(i == ((sizeof(functions))/(sizeof(*functions))) - 1)
        {
            if(CalcTokenMatch(root->token, "plot_xaxis") ||
               CalcTokenMatch(root->token, "plot_yaxis"))
            {
                function_valid = 1;
                int is_y_axis = CalcTokenMatch(root->token, "plot_yaxis");

                result.value = CalcValueNone();

                CalcNode *title_param = 0;
                CalcNode *low_param = 0;
                CalcNode *high_param = 0;

                CalcInterpretResult title_result = {0};
                CalcInterpretResult low_result = {0};
                CalcInterpretResult high_result = {0};

                for(CalcNode *param = root->first_parameter;
                    param; param = param->next)
                {
                    CalcInterpretResult interpret =
                        InterpretCalcExpression(context, param);

                    if(interpret.value.type == CalcType_String)
                    {
                        if(title_param)
                        {
                            result.value = CalcValueError(is_y_axis
                                                          ? SCu8((u8*)("plot_yaxis only accepts one string."), (u64)(sizeof("plot_yaxis only accepts one string.") - 1))
                                                          : SCu8((u8*)("plot_xaxis only accepts one string."), (u64)(sizeof("plot_xaxis only accepts one string.") - 1)));
                            goto end_func_call;
                        }
                        else
                        {
                            title_param = param;
                            title_result = interpret;
                        }
                    }
                    else if(interpret.value.type == CalcType_Number)
                    {
                        if(low_param)
                        {
                            if(high_param)
                            {
                                result.value = CalcValueError(is_y_axis
                                                              ? SCu8((u8*)("plot_yaxis only accepts two numbers."), (u64)(sizeof("plot_yaxis only accepts two numbers.") - 1))
                                                              : SCu8((u8*)("plot_xaxis only accepts two numbers."), (u64)(sizeof("plot_xaxis only accepts two numbers.") - 1)));

                                goto end_func_call;
                            }
                            else
                            {
                                high_param = param;
                                high_result = interpret;
                            }
                        }
                        else
                        {
                            low_param = param;
                            low_result = interpret;
                        }
                    }
                    else
                    {
                        result = interpret;
                        break;
                    }
                }

                if(low_param && high_param)
                {
                    if(is_y_axis)
                    {
                        if(title_result.value.as_string.size)
                        {
                            context->y_axis = StringStripBorderCharacters(title_result.value.as_string);
                        }
                        else
                        {
                            context->y_axis = {};
                        }

                        context->plot_view.y0 = (f32)low_result.value.as_f64;
                        context->plot_view.y1 = (f32)high_result.value.as_f64;
                    }
                    else
                    {
                        if(title_result.value.as_string.size)
                        {
                            context->x_axis = StringStripBorderCharacters(title_result.value.as_string);
                        }
                        else
                        {
                            context->x_axis = {};
                        }

                        context->plot_view.x0 = (f32)low_result.value.as_f64;
                        context->plot_view.x1 = (f32)high_result.value.as_f64;
                    }
                }
                else
                {
                    result.value = CalcValueError(is_y_axis
                                                  ? SCu8((u8*)("plot_yaxis needs two bounds (title optional)."), (u64)(sizeof("plot_yaxis needs two bounds (title optional).") - 1))
                                                  : SCu8((u8*)("plot_xaxis needs two bounds (title optional)."), (u64)(sizeof("plot_xaxis needs two bounds (title optional).") - 1)));
                }
            }

            else if(CalcTokenMatch(root->token, "plot") ||
                    CalcTokenMatch(root->token, "plot_histogram"))
            {
                function_valid = 1;

                struct
                {
                    char *name;
                    Plot2DMode mode;
                }
                plot_functions[] =
                {
                    { "plot", Plot2DMode_Line, },
                    { "plot_histogram", Plot2DMode_Histogram, },
                };

                Plot2DMode mode = Plot2DMode_Line;
                for(int j = 0; j < ((sizeof(plot_functions))/(sizeof(*plot_functions))); ++j)
                {
                    if(CalcTokenMatch(root->token, plot_functions[j].name))
                    {
                        mode = plot_functions[j].mode;
                    }
                }

                result.value = CalcValueNone();

                CalcInterpretGraph **target = &result.first_graph;
                for(CalcNode *graph_expression = root->first_parameter;
                    graph_expression; graph_expression = graph_expression->next)
                {
                    CalcFindInputResult input_find = FindUnknownForGraph(context->symbol_table,
                                                                         graph_expression);
                    if(input_find.number_unknowns <= 1)
                    {
                        CalcNode *input_variable = input_find.unknown;
                        CalcInterpretGraph *new_graph = ((CalcInterpretGraph*)linalloc_wrap_zero(linalloc_push((context->arena), sizeof(CalcInterpretGraph)*(1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "1893" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "1893" ":") - 1)))));

                        new_graph->next = 0;
                        new_graph->parent_call = root;

                        new_graph->mode = mode;
                        new_graph->plot_title = context->plot_title;
                        new_graph->x_axis = context->x_axis;
                        new_graph->y_axis = context->y_axis;

                        new_graph->num_function_samples = context->num_function_samples;
                        new_graph->plot_view = context->plot_view;
                        new_graph->num_bins = context->num_bins;
                        new_graph->bin_data_range.min = context->bin_range_low;
                        new_graph->bin_data_range.max = context->bin_range_high;


                        {
                            if(mode == Plot2DMode_Line)
                            {
                                GenerateLinePlotData(context, graph_expression,
                                                     input_variable, &new_graph->x_data,
                                                     &new_graph->y_data,
                                                     &new_graph->data_count,
                                                     &new_graph->style_flags);
                            }
                            else if(mode == Plot2DMode_Histogram)
                            {
                                GenerateHistogramPlotData(context, graph_expression,
                                                          input_variable, &new_graph->data,
                                                          &new_graph->data_count);
                            }
                        }

                        *target = new_graph;
                        target = &(*target)->next;
                    }
                    else
                    {
                        result.value = CalcValueError(SCu8((u8*)("Too many unknowns in graphing expression."), (u64)(sizeof("Too many unknowns in graphing expression.") - 1)));
                        break;
                    }
                }
            }

        }
    }

    end_func_call:;

    if(!function_valid)
    {
        result.value = CalcValueError(SCu8((u8*)("Unknown function."), (u64)(sizeof("Unknown function.") - 1)));
    }

    return result;
}

static CalcInterpretResult
InterpretCalcExpression(CalcInterpretContext *context, CalcNode *root)
{
    CalcInterpretResult result = {0};

    if(root == 0)
    {
        result.value = CalcValueError(SCu8((u8*)("Syntax error."), (u64)(sizeof("Syntax error.") - 1)));
    }
    else
    {
        switch(root->type)
        {
            case CalcNodeType_Error:
            {
                result.value = CalcValueError(root->error_string);
                break;
            }

            case CalcNodeType_Number:
            {
                result.value = CalcValueF64(root->value);
                break;
            }

            case CalcNodeType_Array:
            {
                result.value = CalcValueArray(context, root->first_member);
                break;
            }

            case CalcNodeType_ArrayIndex:
            {
                result = InterpretCalcExpression(context, root->left);
                if(result.value.type == CalcType_Array)
                {
                    CalcInterpretResult index = InterpretCalcExpression(context, root->right);

                    if(index.value.type == CalcType_Number)
                    {
                        int array_index = (int)index.value.as_f64;
                        if(array_index >= 0 && array_index < result.value.array_count)
                        {
                            result.value = result.value.as_array[array_index];
                        }
                        else
                        {
                            result.value = CalcValueError(SCu8((u8*)("Array index out of bounds."), (u64)(sizeof("Array index out of bounds.") - 1)));
                        }
                    }
                    else
                    {
                        result.value = CalcValueError(SCu8((u8*)("Cannot use non-numbers to index arrays."), (u64)(sizeof("Cannot use non-numbers to index arrays.") - 1)));
                        goto end_interpret;
                    }
                }
                else
                {
                    result.value = CalcValueError(SCu8((u8*)("Cannot index a non-array."), (u64)(sizeof("Cannot index a non-array.") - 1)));
                    goto end_interpret;
                }

                break;
            }

            case CalcNodeType_StringConstant:
            {
                result.value = CalcValueString({(u8 *)root->token.string, (u64)root->token.string_length});
                break;
            }

            case CalcNodeType_Add:
            case CalcNodeType_Subtract:
            case CalcNodeType_Multiply:
            case CalcNodeType_Divide:
            case CalcNodeType_Modulus:
            case CalcNodeType_RaiseToPower:
            {
                if(root->left && root->right)
                {
                    CalcInterpretResult left_result = InterpretCalcExpression(context, root->left);
                    CalcInterpretResult right_result = InterpretCalcExpression(context, root->right);

                    if(left_result.value.type == CalcType_Error)
                    {
                        result = left_result;
                        goto end_interpret;
                    }
                    else if(right_result.value.type == CalcType_Error)
                    {
                        result = right_result;
                        goto end_interpret;
                    }

                    else if(left_result.value.type != CalcType_Number ||
                            right_result.value.type != CalcType_Number)
                    {
                        result.value = CalcValueError(SCu8((u8*)("Cannot use non-numbers in expressions."), (u64)(sizeof("Cannot use non-numbers in expressions.") - 1)));
                        goto end_interpret;
                    }

                    switch(root->type)
                    {
                        case CalcNodeType_Add: result.value = CalcValueF64(left_result.value.as_f64 + right_result.value.as_f64); break;
                        case CalcNodeType_Subtract: result.value = CalcValueF64(left_result.value.as_f64 - right_result.value.as_f64); break;
                        case CalcNodeType_Multiply: result.value = CalcValueF64(left_result.value.as_f64 * right_result.value.as_f64); break;
                        case CalcNodeType_Divide:
                        {
                            if(right_result.value.as_f64 == 0)
                            {
                                result.value = CalcValueF64(
# 2061 "4coder_fleury_calc.cpp" 3 4
                                                           (__builtin_nanf (""))
# 2061 "4coder_fleury_calc.cpp"
                                                              );
                            }
                            else
                            {
                                result.value = CalcValueF64(left_result.value.as_f64 / right_result.value.as_f64);
                            }
                            break;
                        }
                        case CalcNodeType_Modulus:
                        {
                            if(right_result.value.as_f64 == 0)
                            {
                                result.value = CalcValueF64(
# 2073 "4coder_fleury_calc.cpp" 3 4
                                                           (__builtin_nanf (""))
# 2073 "4coder_fleury_calc.cpp"
                                                              );
                            }
                            else
                            {
                                result.value = CalcValueF64(fmod(left_result.value.as_f64, right_result.value.as_f64));
                            }
                            break;
                        }
                        case CalcNodeType_RaiseToPower:
                        {
                            result.value = CalcValueF64(pow(left_result.value.as_f64, right_result.value.as_f64));
                            break;
                        }
                    }

                }
                else
                {
                    result.value = CalcValueError(SCu8((u8*)("Binary operators require two operands."), (u64)(sizeof("Binary operators require two operands.") - 1)));
                }

                break;
            }

            case CalcNodeType_Negate:
            {
                result = InterpretCalcExpression(context, root->operand);
                if(result.value.type == CalcType_Number)
                {
                    result.value = CalcValueF64(-result.value.as_f64);
                }
                break;
            }

            case CalcNodeType_FunctionCall:
            {
                result = CallCalcBuiltInFunction(context, root);
                break;
            }

            case CalcNodeType_Identifier:
            {
                result.value = CalcSymbolTableLookup(context->symbol_table, root->token.string, root->token.string_length);
                if(result.value.type == CalcType_Error)
                {
                    result.value = CalcValueError(push_stringf(context->arena, "'%.*s' is not declared.", root->token.string_length, root->token.string));
                }

                break;
            }

            case CalcNodeType_SourceCodeIdentifier:
            {
                Token_Array token_array = get_token_array_from_buffer(context->app, context->buffer);
                Range_i64 visible_range = text_layout_get_visible_range(context->app, context->text_layout_id);
                i64 first_index = token_index_from_pos(&token_array, visible_range.first);
                Token_Iterator_Array it = token_iterator_index(0, &token_array, first_index);
                Token *token = 0;

                for(;;)
                {
                    token = token_it_read(&it);

                    if(token->pos >= visible_range.one_past_last + 4096 || !token || !token_it_inc_non_whitespace(&it))
                    {
                        break;
                    }

                    if(token->kind == TokenBaseKind_Identifier)
                    {
                        String_Const_u8 token_string;
                        {
                            Range_i64 token_range =
                            {
                                token->pos,
                                token->pos + (token->size > (i64)256
                                              ? (i64)256
                                              : token->size),
                            };

                            u8 token_buffer[256] = {0};
                            buffer_read_range(context->app, context->buffer, token_range, token_buffer);
                            token_string = { token_buffer, (u64)(token_range.end - token_range.start) };
                        }

                        if(StringMatchCaseSensitive((char *)token_string.str, (int)token_string.size,
                                                    root->token.string, root->token.string_length))
                        {
                            result.value = CalcValueSourceCodeReference(token->pos);
                            break;
                        }
                    }
                }

                break;
            }

            default: break;
        }
    }

    end_interpret:;
    return result;
}

static int
IdentifierExistsInCalcExpression(CalcNode *root, char *string, int string_length)
{
    int result = 0;

    if(root && root->type != CalcNodeType_Invalid)
    {
        if(StringMatchCaseSensitive(root->token.string, root->token.string_length, string, string_length))
        {
            result = 1;
        }
        else
        {
            result |= IdentifierExistsInCalcExpression(root->left, string, string_length);
            result |= IdentifierExistsInCalcExpression(root->right, string, string_length);
            result |= IdentifierExistsInCalcExpression(root->first_parameter, string, string_length);
            result |= IdentifierExistsInCalcExpression(root->next, string, string_length);
        }
    }

    return result;
}

static CalcInterpretResult
InterpretCalcCode(CalcInterpretContext *context, CalcNode *root)
{
    CalcInterpretResult result = {0};
    CalcInterpretResult last_result = result;

    if(root)
    {
        last_result = result;

        if(root->type == CalcNodeType_Error)
        {
            result.value = CalcValueError(root->error_string);
            goto end_interpret;
        }
        else if(root->type == CalcNodeType_Assignment)
        {
            if(root->left->type == CalcNodeType_Identifier)
            {
                if(!IdentifierExistsInCalcExpression(root->right, root->left->token.string, root->left->token.string_length))
                {
                    CalcInterpretResult right_result = InterpretCalcExpression(context, root->right);
                    CalcSymbolTableAdd(context->symbol_table, root->left->token.string,
                                       root->left->token.string_length, right_result.value);
                    result = InterpretCalcExpression(context, root->right);
                    result.first_graph = last_result.first_graph;
                }
                else
                {
                    result.value = CalcValueError(SCu8((u8*)("Recursive definition."), (u64)(sizeof("Recursive definition.") - 1)));
                    result.first_graph = last_result.first_graph;
                }
            }
            else
            {
                result.value = CalcValueError(SCu8((u8*)("Assignment to non-identifier."), (u64)(sizeof("Assignment to non-identifier.") - 1)));
                result.first_graph = last_result.first_graph;
            }
        }
        else
        {
            result = InterpretCalcExpression(context, root);
            if(last_result.first_graph)
            {
                for(CalcInterpretGraph *graph = last_result.first_graph; graph; graph = graph->next)
                {
                    if(graph->next == 0)
                    {
                        graph->next = result.first_graph;
                        break;
                    }
                }

                result.first_graph = last_result.first_graph;
            }
            else if(result.value.type == CalcType_Error)
            {
                goto end_interpret;
            }
        }
    }

    end_interpret:;

    return result;
}

static CalcInterpretContext
CalcInterpretContextInit(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                         Arena *arena, CalcSymbolTable *symbol_table, f32 current_time)
{
    CalcInterpretContext context = {0};
    context.app = app;
    context.buffer = buffer;
    context.text_layout_id = text_layout_id;
    context.arena = arena;
    context.symbol_table = symbol_table;
    context.current_time = current_time;


    {
        context.plot_title = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        context.x_axis = SCu8((u8*)("x"), (u64)(sizeof("x") - 1));
        context.y_axis = SCu8((u8*)("y"), (u64)(sizeof("y") - 1));
        context.plot_view = Rf32(-1, -1, +1, +1);
        context.num_function_samples = 128;
        context.num_bins = 10;
        context.bin_range_low = -1;
        context.bin_range_high = 1;
    }

    return context;
}

static void
F4_CLC_RenderCode(Application_Links *app, Buffer_ID buffer,
                  View_ID view, Text_Layout_ID text_layout_id,
                  Frame_Info frame_info, Arena *arena, char *code_buffer,
                  i64 start_char_offset)
{
    Profile_Scope_Block profile_block_2301 ((app), SCu8((u8*)("[Fleury] Render Calc Code"), (u64)(sizeof("[Fleury] Render Calc Code") - 1)), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "2301" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "2301" ":") - 1)));

    f32 current_time = global_calc_time;
    CalcSymbolTable symbol_table = CalcSymbolTableInit(arena, 1024);


    {

        {
            CalcValue value = CalcValueF64(3.1415926535897);
            CalcSymbolTableAdd(&symbol_table, "pi", 2, value);
        }


        {
            CalcValue value = CalcValueF64(2.71828);
            CalcSymbolTableAdd(&symbol_table, "e", 1, value);
        }
    }

    CalcInterpretContext context_ = CalcInterpretContextInit(app, buffer, text_layout_id, arena,
                                                             &symbol_table, current_time);
    CalcInterpretContext *context = &context_;

    char *at = code_buffer;
    CalcNode *expr = ParseCalcCode(arena, &at);

    Rect_f32 last_graph_rect = {0};

    for(CalcNode *interpret_expression = expr; interpret_expression;
        interpret_expression = interpret_expression->next)
    {
        char *at_source = interpret_expression->at_source;


        Vec2_f32 result_layout_position = {0};
        if(at_source)
        {
            i64 offset = (i64)(at_source - code_buffer);
            for(int i = 0; at_source[i] && at_source[i] != '\n'; ++i)
            {
                ++offset;
            }
            i64 buffer_offset = start_char_offset + offset;
            Rect_f32 last_character_rect = text_layout_character_on_screen(app, text_layout_id,
                                                                           buffer_offset);
            result_layout_position.x = last_character_rect.x0;
            result_layout_position.y = last_character_rect.y0;
            result_layout_position.x += 20;
        }

        CalcInterpretResult result = InterpretCalcCode(context, interpret_expression);

        if(result_layout_position.x > 0 && result_layout_position.y > 0)
        {


            {
                String_Const_u8 result_string = {0};

                switch(result.value.type)
                {
                    case CalcType_Error:
                    {
                        if(expr == 0 || !result.value.as_error.size)
                        {
                            result_string = push_stringf(arena, "(error: Parse failure.)");
                        }
                        else
                        {
                            result_string = push_stringf(arena, "(error: %.*s)", (i32)(result.value.as_error).size, (char*)(result.value.as_error).str);
                        }
                        break;
                    }
                    case CalcType_Number:
                    {
                        result_string = push_stringf(arena, "= %f", result.value.as_f64);
                        break;
                    }
                    case CalcType_String:
                    {
                        result_string = push_stringf(arena, "= %.*s", (i32)(result.value.as_string).size, (char*)(result.value.as_string).str);
                        break;
                    }
                    default: break;
                }

                Vec2_f32 point = result_layout_position;

                u32 color = finalize_color(defcolor_comment, 0);
                color &= 0x00ffffff;
                color |= 0x80000000;
                draw_string(app, get_face_id(app, buffer), result_string, point, color);
            }


            {
                Rect_f32 view_rect = view_get_screen_rect(app, view);

                Rect_f32 graph_rect = {0};
                {
                    graph_rect.x0 = view_rect.x1 - 30 - 300;
                    graph_rect.y0 = result_layout_position.y + 30 - 100;
                    graph_rect.x1 = graph_rect.x0 + 300;
                    graph_rect.y1 = graph_rect.y0 + 200;
                }

                CalcNode *last_parent_call = 0;
                for(CalcInterpretGraph *graph = result.first_graph; graph;
                    graph = graph->next)
                {
                    if(last_parent_call == 0 || graph->parent_call != last_parent_call)
                    {
                        if(last_graph_rect.x0 != 0 && rect_overlap(graph_rect, last_graph_rect))
                        {
                            graph_rect.y0 = last_graph_rect.y1 + 50;
                            graph_rect.y1 = graph_rect.y0 + 200;
                        }

                        last_graph_rect = graph_rect;

                        GraphCalcExpression(app, get_face_id(app, buffer), graph_rect, graph, context);


                        {
                            f32 rect_height = graph_rect.y1 - graph_rect.y0;
                            graph_rect.y0 += rect_height + 50;
                            graph_rect.y1 += rect_height + 50;
                            result_layout_position.y += rect_height + 50;
                        }

                        last_parent_call = graph->parent_call;
                    }
                }
            }
        }
    }
}

static void
F4_CLC_RenderBuffer(Application_Links *app, Buffer_ID buffer, View_ID view,
                    Text_Layout_ID text_layout_id, Frame_Info frame_info)
{
    Scratch_Block scratch(app);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    String_Const_u8 code_string = push_whole_buffer(app, scratch, buffer);
    F4_CLC_RenderCode(app, buffer, view, text_layout_id, frame_info, scratch,
                      (char *)code_string.str, visible_range.start);
}

static void
F4_CLC_RenderComments(Application_Links *app, Buffer_ID buffer, View_ID view,
                      Text_Layout_ID text_layout_id, Frame_Info frame_info)
{
    if(def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_calc_comments"), (u64)(sizeof("f4_disable_calc_comments") - 1)))))
    {
        return;
    }

    Profile_Scope_Block profile_block_2460 ((app), SCu8((u8*)("[Fleury] Calc Comments"), (u64)(sizeof("[Fleury] Calc Comments") - 1)), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "2460" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "2460" ":") - 1)));

    Scratch_Block scratch(app);
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

    if(token_array.tokens != 0)
    {
        i64 first_index = token_index_from_pos(&token_array, visible_range.first);
        Token_Iterator_Array it = token_iterator_index(0, &token_array, first_index);

        Token *token = 0;
        for(;;)
        {
            token = token_it_read(&it);

            if(token->pos >= visible_range.one_past_last || !token || !token_it_inc_non_whitespace(&it))
            {
                break;
            }

            if(token->kind == TokenBaseKind_Comment)
            {
                Range_i64 token_range =
                {
                    token->pos,
                    token->pos + (token->size > 1024
                                  ? 1024
                                  : token->size),
                };

                u32 token_buffer_size = (u32)(token_range.end - token_range.start);
                if(token_buffer_size < 4)
                {
                    token_buffer_size = 4;
                }
                u8 *token_buffer = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(token_buffer_size+1), SCu8((u8*)("4coder_fleury_calc.cpp" ":" "2496" ":"), (u64)(sizeof("4coder_fleury_calc.cpp" ":" "2496" ":") - 1)))));
                buffer_read_range(app, buffer, token_range, token_buffer);
                token_buffer[token_buffer_size] = 0;

                if((token_buffer[0] == '/' && token_buffer[1] == '/' && token_buffer[2] == 'c' &&
                    character_is_whitespace(token_buffer[3])) ||
                   (token_buffer[0] == '/' && token_buffer[1] == '*' && token_buffer[2] == 'c'))
                {
                    int is_multiline_comment = (token_buffer[1] == '*');
                    if(is_multiline_comment)
                    {
                        if(token_buffer[token_buffer_size-1] == '/' &&
                           token_buffer[token_buffer_size-2] == '*')
                        {
                            token_buffer[token_buffer_size-2] = 0;
                        }
                    }
                    char *at = (char *)token_buffer + 3;
                    F4_CLC_RenderCode(app, buffer, view, text_layout_id, frame_info, scratch, at, token_range.start + 3);
                }
            }
        }
    }
}
# 443 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_lego.cpp" 1

static F4_Lego f4_legos[12];

static F4_Lego *
F4_LegoFromIndex(int index)
{
    F4_Lego *result = 0;
    if(index >= 0 && index < 12)
    {
        result = f4_legos + index;
    }
    return result;
}

static void
_F4_Lego_Initialize(F4_Lego *lego)
{
    if(lego == 0)
    {
        return;
    }
    if(lego->initialized == 0)
    {
        memset(lego, 0, sizeof(*lego));
        lego->initialized = 1;
        lego->arena = make_arena(get_base_allocator_system());
    }
}

static void
F4_Lego_Store(F4_Lego *lego, F4_LegoKind kind, String8 string)
{
    _F4_Lego_Initialize(lego);
    linalloc_clear(&lego->arena);
    lego->kind = kind;
    lego->string = push_string_copy(&lego->arena, string);
}

static F4_Lego *
F4_LegoFromUserInput(User_Input in)
{
    F4_Lego *lego = 0;
    Input_Event event = in.event;
    if(event.kind == InputEventKind_KeyStroke &&
       event.key.code >= KeyCode_F1 && event.key.code <= KeyCode_F24)
    {
        int index = event.key.code - KeyCode_F1;
        index = index % 4;
        lego = F4_LegoFromIndex(index);
    }
    return lego;
}

static void
F4_Lego_BufferPlace(Application_Links *app, View_ID view, Buffer_ID buffer, i64 pos, F4_Lego *lego)
{
    switch(lego->kind)
    {
        case F4_LegoKind_String:
        {
            buffer_replace_range(app, buffer, Ii64(pos, pos), lego->string);
            view_set_mark(app, view, seek_pos(pos));
            view_set_cursor_and_preferred_x(app, view, seek_pos(pos + (i32)lego->string.size));

            F4_PushFlash(app, buffer, Ii64(pos, pos+lego->string.size), fcolor_resolve(fcolor_id(fleury_color_lego_splat)), 0.8f);
        }break;
        default: break;
    }
}

CUSTOM_COMMAND(f4_lego_buffer_place, "4coder_fleury_lego.cpp", 71, Normal)
CUSTOM_DOC("Will place the lego, determined by the pressed F-key, at the cursor in the active buffer.")
{
    F4_Lego *lego = F4_LegoFromUserInput(get_current_input(app));
    View_ID view = get_active_view(app, Access_Write);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Write);
    if(buffer)
    {
        F4_Lego_BufferPlace(app, view, buffer, view_get_cursor_pos(app, view), lego);
    }
}

CUSTOM_COMMAND(f4_lego_store_token, "4coder_fleury_lego.cpp", 83, Normal)
CUSTOM_DOC("Will store the token under the cursor into the lego determined by the associated F-key.")
{
    Scratch_Block scratch(app);
    F4_Lego *lego = F4_LegoFromUserInput(get_current_input(app));
    if(lego)
    {
        View_ID view = get_active_view(app, Access_Always);
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        Token *token = get_token_from_pos(app, buffer, view_get_cursor_pos(app, view));
        if(token != 0)
        {
            F4_Lego_Store(lego, F4_LegoKind_String, push_token_lexeme(app, scratch, buffer, token));
            F4_PushFlash(app, buffer, Ii64(token), fcolor_resolve(fcolor_id(fleury_color_lego_grab)), 0.8f);
        }
    }
}

CUSTOM_COMMAND(f4_lego_store_range, "4coder_fleury_lego.cpp", 101, Normal)
CUSTOM_DOC("Will store the selected range into the lego determined by the associated F-key.")
{
    Scratch_Block scratch(app);
    F4_Lego *lego = F4_LegoFromUserInput(get_current_input(app));
    if(lego)
    {
        View_ID view = get_active_view(app, Access_Always);
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        Range_i64 range = Ii64(view_get_cursor_pos(app, view), view_get_mark_pos(app, view));
        F4_Lego_Store(lego, F4_LegoKind_String, push_buffer_range(app, scratch, buffer, range));
        F4_PushFlash(app, buffer, range, fcolor_resolve(fcolor_id(fleury_color_lego_grab)), 0.8f);
    }
}

CUSTOM_COMMAND(f4_lego_store_line, "4coder_fleury_lego.cpp", 116, Normal)
CUSTOM_DOC("Will store the selected range into the lego determined by the associated F-key.")
{
    Scratch_Block scratch(app);
    F4_Lego *lego = F4_LegoFromUserInput(get_current_input(app));
    if(lego)
    {
        View_ID view = get_active_view(app, Access_Always);
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        i64 cursor_pos = view_get_cursor_pos(app, view);
        i64 line_num = get_line_number_from_pos(app, buffer, cursor_pos);
        Range_i64 range = get_line_pos_range(app, buffer, line_num);
        F4_Lego_Store(lego, F4_LegoKind_String, push_buffer_range(app, scratch, buffer, range));
        F4_PushFlash(app, buffer, range, fcolor_resolve(fcolor_id(fleury_color_lego_grab)), 0.8f);
    }
}

static void
F4_Lego_StoreClickedToken(Application_Links *app, F4_Lego *lego)
{
    Scratch_Block scratch(app);
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    Token *token = get_token_from_pos(app, buffer, pos);
    if(token != 0)
    {
        F4_Lego_Store(lego, F4_LegoKind_String, push_token_lexeme(app, scratch, buffer, token));
        F4_PushFlash(app, buffer, Ii64(token), fcolor_resolve(fcolor_id(fleury_color_lego_grab)), 0.8f);
    }
}

CUSTOM_COMMAND(f4_lego_click_store_token_1, "4coder_fleury_lego.cpp", 149, Normal)
CUSTOM_DOC("Sets the cursor to the clicked position, and then stores the token under that position into the F1 slot.")
{
    F4_Lego_StoreClickedToken(app, F4_LegoFromIndex(0));
}

CUSTOM_COMMAND(f4_lego_click_store_token_2, "4coder_fleury_lego.cpp", 155, Normal)
CUSTOM_DOC("Sets the cursor to the clicked position, and then stores the token under that position into the F2 slot.")
{
    F4_Lego_StoreClickedToken(app, F4_LegoFromIndex(1));
}
# 444 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_pos_context_tooltips.cpp" 1
static Vec2_f32
_F4_PosContext_RenderDefinitionTokens(Application_Links *app, Face_ID face,
                                      String_Const_u8 backing_string,
                                      Token_Array tokens, b32 do_render,
                                      int highlight_arg, Vec2_f32 text_position,
                                      f32 max_x)
{
    Scratch_Block scratch(app);
    Vec2_f32 starting_text_pos = text_position;
    Face_Metrics metrics = get_face_metrics(app, face);

    Token_Iterator_Array it = token_iterator_pos(0, &tokens, 0);
    b32 found_first_open_paren = 0;
    for(int arg_idx = 0;;)
    {
        Token *token = token_it_read(&it);
        if(token == 0) { break; }

        if(token->kind == TokenBaseKind_Whitespace)
        {
            text_position.x += get_string_advance(app, face, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
        }
        else
        {
            ARGB_Color color = finalize_color(defcolor_text_default, 0);
            if(token->kind == TokenBaseKind_StatementClose)
            {
                String_Const_u8 str = string_substring(backing_string, Ii64(token));
                if(string_match(str, SCu8((u8*)(","), (u64)(sizeof(",") - 1))))
                {
                    arg_idx += 1;
                }
            }
            else if(token->kind == TokenBaseKind_ParentheticalOpen)
            {
                found_first_open_paren = 1;
            }


            b32 highlight = 0;
            if(found_first_open_paren && arg_idx == highlight_arg &&
               (token->kind == TokenBaseKind_Identifier ||
                token->kind == TokenBaseKind_Operator ||
                token->kind == TokenBaseKind_Keyword))
            {
                color = finalize_color(fleury_color_token_highlight, 0);
                highlight = 1;
            }

            Vec2_f32 start_pos = text_position;
            String_Const_u8 token_string = string_substring(backing_string,
                                                            Ii64(token->pos, token->pos+token->size));
            f32 string_advance = get_string_advance(app, face, token_string);
            if(text_position.x + string_advance >= max_x)
            {
                text_position.x = starting_text_pos.x;
                text_position.y += metrics.line_height;
            }
            if(do_render)
            {
                draw_string(app, face, token_string, text_position, color);
            }
            text_position.x += string_advance;
            if(highlight)
            {
                if(do_render)
                {
                    draw_rectangle(app, Rf32(start_pos.x, start_pos.y + metrics.line_height,
                                             text_position.x, start_pos.y + metrics.line_height + 2.f),
                                   1.f, color);
                }
            }
        }

        if(token_it_inc_all(&it) == 0)
        {
            break;
        }
    }
    return text_position;
}

static void
F4_PosContext_Render(Application_Links *app, View_ID view, Buffer_ID buffer,
                     Text_Layout_ID text_layout_id, i64 pos)
{
    if(def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_poscontext"), (u64)(sizeof("f4_disable_poscontext") - 1)))))
    {
        return;
    }

    Profile_Scope_Block profile_block_92 ((app), SCu8((u8*)("[F4] Pos Context Rendering"), (u64)(sizeof("[F4] Pos Context Rendering") - 1)), SCu8((u8*)("4coder_fleury_pos_context_tooltips.cpp" ":" "92" ":"), (u64)(sizeof("4coder_fleury_pos_context_tooltips.cpp" ":" "92" ":") - 1)));
    Scratch_Block scratch(app);

    Rect_f32 cursor_rect = text_layout_character_on_screen(app, text_layout_id, pos);
    Rect_f32 view_rect = view_get_screen_rect(app, view);
    Face_ID face = global_small_code_face;
    Face_Metrics metrics = get_face_metrics(app, face);
    F4_Language *language = F4_LanguageFromBuffer(app, buffer);
    f32 padding = 4.f;

    if(language != 0)
    {

        b32 render_at_cursor = 1;
        if(def_get_config_b32(vars_save_string(SCu8((u8*)("f4_poscontext_draw_at_bottom_of_buffer"), (u64)(sizeof("f4_poscontext_draw_at_bottom_of_buffer") - 1)))))
        {
            render_at_cursor = 0;
        }

        Vec2_f32 tooltip_position =
        {
            global_cursor_rect.x0,
            global_cursor_rect.y1,
        };

        F4_Language_PosContextData *ctx_list = language->PosContext(app, scratch, buffer, pos);
        if(render_at_cursor == 0)
        {
            f32 height = 0;
            for(F4_Language_PosContextData *ctx = ctx_list; ctx; ctx = ctx->next)
            {
                height += metrics.line_height + 2*padding;
            }
            tooltip_position = V2f32(view_rect.x0, view_rect.y1 - height);
        }

        for(F4_Language_PosContextData *ctx = ctx_list; ctx; ctx = ctx->next)
        {
            F4_Index_Note *note = ctx->relevant_note;
            if(note != 0 && note->file != 0)
            {


                if(note->kind == F4_Index_NoteKind_Function ||
                   note->kind == F4_Index_NoteKind_Macro)
                {


                    Range_i64 definition_range = note->range;
                    {
                        Token_Array defbuffer_tokens = get_token_array_from_buffer(app, note->file->buffer);
                        Token_Iterator_Array it = token_iterator_pos(0, &defbuffer_tokens, note->range.min);
                        int paren_nest = 0;
                        for(;token_it_inc_all(&it);)
                        {
                            Token *token = token_it_read(&it);
                            if(token)
                            {
                                if(token->kind == TokenBaseKind_ParentheticalOpen)
                                {
                                    paren_nest += 1;
                                }
                                if(token->kind == TokenBaseKind_ParentheticalClose)
                                {
                                    paren_nest -= 1;
                                    if(paren_nest == 0)
                                    {
                                        definition_range.max = token->pos + token->size;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    String_Const_u8 definition_string = push_buffer_range(app, scratch, note->file->buffer, definition_range);
                    Token_Array definition_tokens = token_array_from_text(app, scratch, definition_string);


                    f32 max_x = view_rect.x1-view_rect.x0;
                    Vec2_f32 end_draw_position = _F4_PosContext_RenderDefinitionTokens(app, face, definition_string, definition_tokens,
                                                                                       false, 0, V2f32(0, 0), max_x);
                    Vec2_f32 needed_size =
                    {
                        (end_draw_position.y > 0) ? max_x : end_draw_position.x,
                        end_draw_position.y,
                    };

                    Rect_f32 draw_rect =
                    {
                        tooltip_position.x,
                        tooltip_position.y,
                        tooltip_position.x + needed_size.x + 2*padding,
                        tooltip_position.y + needed_size.y + metrics.line_height + 2*padding,
                    };
                    if(draw_rect.x1 > view_rect.x1)
                    {
                        f32 width = rect_width(draw_rect);
                        draw_rect.x0 = (f32)(int)(view_rect.x1 - width);
                        draw_rect.x1 = view_rect.x1;
                    }
                    if(draw_rect.y1 > view_rect.y1)
                    {
                        f32 height = rect_height(draw_rect);
                        draw_rect.y0 = (f32)(int)(view_rect.y1 - height);
                        draw_rect.y1 = view_rect.y1;
                    }

                    F4_DrawTooltipRect(app, draw_rect);


                    {
                        Vec2_f32 text_position =
                        {
                            draw_rect.x0 + padding,
                            draw_rect.y0 + padding,
                        };

                        _F4_PosContext_RenderDefinitionTokens(app, face, definition_string, definition_tokens,
                                                              true, ctx->argument_index,
                                                              text_position,
                                                              view_rect.x1);
                    }

                    f32 advance = draw_rect.y1 - draw_rect.y0;
                    tooltip_position.y += advance;
                }
                else if(note->kind == F4_Index_NoteKind_Type)
                {
                    Token_Array defbuffer_tokens = get_token_array_from_buffer(app, note->file->buffer);
                    for(F4_Index_Note *member = note->first_child; member; member = member->next_sibling)
                    {

                        Range_i64 member_range = member->range;
                        Token_Iterator_Array it = token_iterator_pos(0, &defbuffer_tokens, member->range.min);
                        for(;;)
                        {
                            Token *token = token_it_read(&it);
                            if(token)
                            {
                                if(token->kind == TokenBaseKind_StatementClose)
                                {
                                    member_range.max = token->pos;
                                    break;
                                }
                            }
                            else { break; }
                            if(!token_it_inc_non_whitespace(&it))
                            {
                                break;
                            }
                        }

                        String_Const_u8 member_string = push_buffer_range(app, scratch, note->file->buffer, member_range);

                        Vec2_f32 needed_size = { get_string_advance(app, face, member_string), 0, };
                        Rect_f32 draw_rect =
                        {
                            tooltip_position.x,
                            tooltip_position.y,
                            tooltip_position.x + needed_size.x + 2*padding,
                            tooltip_position.y + needed_size.y + metrics.line_height + 2*padding,
                        };

                        F4_DrawTooltipRect(app, draw_rect);
                        draw_string(app, face, member_string, V2f32(draw_rect.x0 + padding, draw_rect.y0 + padding), finalize_color(defcolor_text_default, 0));

                        f32 advance = draw_rect.y1 - draw_rect.y0;
                        tooltip_position.y += advance;
                    }
                }

            }

        }
    }
}
# 445 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_code_peek.cpp" 1

 static b32 global_code_peek_open = 0;

static void
F4_CodePeek_Render(Application_Links *app, View_ID view_id, Face_ID face_id,
                   Buffer_ID buffer, Frame_Info frame_info)
{
    Scratch_Block scratch(app);
    Buffer_ID peek_buf = get_buffer_by_name(app, SCu8((u8*)("*peek*"), (u64)(sizeof("*peek*") - 1)), AccessFlag_Read);

    if(!global_code_peek_open && buffer != peek_buf)
    {
        return;
    }

    Rect_f32 view_rect = view_get_screen_rect(app, view_id);

    struct Peek
    {
        Peek *next;
        String_Const_u8 string;
        Code_Index_Note *note;
    };

    Peek *first = 0;
    Peek *last = 0;
    int peek_count = 0;
# 46 "4coder_fleury_code_peek.cpp"
    {Peek *p = ((Peek*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(Peek)*(1), SCu8((u8*)("4coder_fleury_code_peek.cpp" ":" "46" ":"), (u64)(sizeof("4coder_fleury_code_peek.cpp" ":" "46" ":") - 1)))));p->string = push_token_or_word_under_active_cursor(app, scratch);p->note = code_index_note_from_string(p->string);if(last == 0){first = last = p;}else{last->next = p;last = last->next;}peek_count += 1;};


    {
        Token_Array token_array = get_token_array_from_buffer(app, peek_buf);
        Token_Iterator_Array it = token_iterator_pos(0, &token_array, 0);
        for(;token_it_inc_non_whitespace(&it);)
        {
            Token *token = token_it_read(&it);
            if(token == 0)
            {
                break;
            }
            if(token->kind == TokenBaseKind_Identifier)
            {
                {Peek *p = ((Peek*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(Peek)*(1), SCu8((u8*)("4coder_fleury_code_peek.cpp" ":" "61" ":"), (u64)(sizeof("4coder_fleury_code_peek.cpp" ":" "61" ":") - 1)))));p->string = push_buffer_range(app, scratch, peek_buf, Ii64(token->pos, token->pos + token->size));p->note = code_index_note_from_string(p->string);if(last == 0){first = last = p;}else{last->next = p;last = last->next;}peek_count += 1;};
            }
        }
    }



    f32 peek_height = (f32)((view_rect.y1 - view_rect.y0) * (0.5f + 0.4f*((((peek_count / 4)<(1))?(peek_count / 4):(1))))) / peek_count;
    Rect_f32 rect = {0};
    {
        rect.x0 = view_rect.x0;
        rect.x1 = view_rect.x1;
        rect.y0 = view_rect.y1 - peek_height*peek_count;
        rect.y1 = rect.y0 + peek_height;
    }

    for(Peek *peek = first; peek; peek = peek->next)
    {
        Code_Index_Note *note = peek->note;
        if(note)
        {
            Code_Index_File *file = note->file;
            Buffer_ID match_buffer = file->buffer;

            F4_DrawTooltipRect(app, rect);


            {
                Rect_f32 inner_rect = rect_inner(rect, 30);

                Buffer_Point buffer_point =
                {
                    get_line_number_from_pos(app, match_buffer, note->pos.min),
                    0,
                };
                Text_Layout_ID text_layout_id = text_layout_create(app, match_buffer, inner_rect, buffer_point);

                Rect_f32 prev_prev_clip = draw_set_clip(app, inner_rect);
                {
                    Token_Array match_token_array = get_token_array_from_buffer(app, match_buffer);
                    if(match_token_array.tokens != 0)
                    {
                        F4_SyntaxHighlight(app, text_layout_id, &match_token_array);
                    }
                    else
                    {
                        Range_i64 visible_range = Ii64(note->pos.min, note->pos.max);
                        paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
                    }

                    draw_text_layout_default(app, text_layout_id);
                }
                draw_set_clip(app, prev_prev_clip);
                text_layout_free(app, text_layout_id);
            }
        }

        f32 height = (rect.y1 - rect.y0);
        rect.y0 += height;
        rect.y1 += height;
    }

}

CUSTOM_COMMAND(f4_code_peek, "4coder_fleury_code_peek.cpp", 125, Normal)
CUSTOM_DOC("Toggles code peek.")
{
    global_code_peek_open ^= 1;
}

CUSTOM_COMMAND(f4_code_peek_yank, "4coder_fleury_code_peek.cpp", 131, Normal)
CUSTOM_DOC("Yanks the current cursor identifier into the *peek* buffer.")
{
    Scratch_Block scratch(app);
    String_Const_u8 string = push_token_or_word_under_active_cursor(app, scratch);
    Code_Index_Note *note = code_index_note_from_string(string);
    Buffer_ID buffer = get_buffer_by_name(app, SCu8((u8*)("*peek*"), (u64)(sizeof("*peek*") - 1)), Access_Read | Access_Write);
    if(buffer != 0 && note != 0)
    {
        buffer_replace_range(app, buffer, Ii64(buffer_get_size(app, buffer)), SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        buffer_replace_range(app, buffer, Ii64(buffer_get_size(app, buffer)), string);
    }
}

CUSTOM_COMMAND(f4_code_peek_clear, "4coder_fleury_code_peek.cpp", 145, Normal)
CUSTOM_DOC("Clears the *peek* buffer.")
{
    Buffer_ID buffer = get_buffer_by_name(app, SCu8((u8*)("*peek*"), (u64)(sizeof("*peek*") - 1)), Access_Read | Access_Write);
    if(buffer)
    {
        clear_buffer(app, buffer);
    }
}
# 446 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_recent_files.cpp" 1
CUSTOM_ID(attachment, f4_recentfiles_viewstate);

struct F4_RecentFiles_ViewState
{
    int recent_buffer_count;
    Buffer_ID recent_buffers[16];
};

static void
F4_RecentFiles_RefreshView(Application_Links *app, View_ID view)
{
    Buffer_ID buffer = view_get_buffer(app, view, AccessFlag_Read);
    if(buffer)
    {
        Managed_Scope scope = view_get_managed_scope(app, view);
        F4_RecentFiles_ViewState *state = ((F4_RecentFiles_ViewState*)managed_scope_get_attachment((app), (scope), (f4_recentfiles_viewstate), sizeof(F4_RecentFiles_ViewState)));
        if(state != 0)
        {
            b32 need_push = 1;
            if(state->recent_buffer_count > 0 && state->recent_buffers[0] == buffer)
            {
                need_push = 0;
            }
            if(need_push)
            {
                if(state->recent_buffer_count >= 16)
                {
                    state->recent_buffer_count -= 1;
                }
                memmove(state->recent_buffers + 1, state->recent_buffers + 0,
                        sizeof(state->recent_buffers[0])*state->recent_buffer_count);
                state->recent_buffers[0] = buffer;
                state->recent_buffer_count += 1;


                {
                    for(int i = 1; i < state->recent_buffer_count; i += 1)
                    {
                        if(state->recent_buffers[i] == buffer)
                        {
                            memmove(state->recent_buffers + i, state->recent_buffers + i + 1,
                                    sizeof(state->recent_buffers[0])*(state->recent_buffer_count-i-1));
                            state->recent_buffer_count -= 1;
                        }
                    }
                }
            }
        }
    }
}

static void
F4_RecentFiles_Render(Application_Links *app, View_ID view, Face_ID face)
{

    Scratch_Block scratch(app);
    Rect_f32 view_rect = view_get_screen_rect(app, view);
    Face_Metrics metrics = get_face_metrics(app, face);

    Managed_Scope scope = view_get_managed_scope(app, view);
    F4_RecentFiles_ViewState *state = ((F4_RecentFiles_ViewState*)managed_scope_get_attachment((app), (scope), (f4_recentfiles_viewstate), sizeof(F4_RecentFiles_ViewState)));

    if(state != 0)
    {
        Vec2_f32 p = view_rect.p0;
        for(int i = 0; i < state->recent_buffer_count; i += 1)
        {
            Buffer_ID buffer = state->recent_buffers[i];
            String_Const_u8 string = push_buffer_unique_name(app, scratch, buffer);
            draw_string(app, face, string, p, 0xffffffff);
            p.y += metrics.line_height;
        }
    }

}

CUSTOM_COMMAND(f4_recent_files_menu, "4coder_fleury_recent_files.cpp", 77, UI)
CUSTOM_DOC("Lists the recent files used in the current panel.")
{
    View_ID view = get_active_view(app, Access_Read);
    Managed_Scope scope = view_get_managed_scope(app, view);
    F4_RecentFiles_ViewState *state = ((F4_RecentFiles_ViewState*)managed_scope_get_attachment((app), (scope), (f4_recentfiles_viewstate), sizeof(F4_RecentFiles_ViewState)));

    if(state != 0)
    {
        Scratch_Block scratch(app);
        Lister_Block lister(app, scratch);
        lister_set_query(lister, "Recent Buffers:");
        lister_set_default_handlers(lister);

        for(int i = 1; i < state->recent_buffer_count; i += 1)
        {
            Buffer_ID buffer = state->recent_buffers[i];
            String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);
            Buffer_ID *buf = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(1), SCu8((u8*)("4coder_fleury_recent_files.cpp" ":" "95" ":"), (u64)(sizeof("4coder_fleury_recent_files.cpp" ":" "95" ":") - 1)))));
            *buf = buffer;
            lister_add_item(lister, buffer_name, SCu8((u8*)(""), (u64)(sizeof("") - 1)), buf, 0);
        }

        Lister_Result l_result = run_lister(app, lister);
        if(!l_result.canceled && l_result.user_data)
        {
            Buffer_ID buffer = *(Buffer_ID *)l_result.user_data;
            if(buffer != 0)
            {
                view_set_buffer(app, view, buffer, 0);
            }
        }
    }
}
# 447 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_bindings.cpp" 1

struct Command_Map_ID_Pair
{
 Command_Map_ID From;
 Command_Map_ID To;
};
static Command_Map_ID_Pair GlobalCommandMapReroute[4] = {};

CUSTOM_COMMAND(switch_to_keybinding_0, "4coder_fleury_bindings.cpp", 9, Normal)
CUSTOM_DOC("Switch the keybindings to mode 0.")
{
 GlobalKeybindingMode = KeyBindingMode_0;
}

CUSTOM_COMMAND(switch_to_keybinding_1, "4coder_fleury_bindings.cpp", 15, Normal)
CUSTOM_DOC("Switch the keybindings to mode 1.")
{
 GlobalKeybindingMode = KeyBindingMode_1;
}

CUSTOM_COMMAND(switch_to_keybinding_2, "4coder_fleury_bindings.cpp", 21, Normal)
CUSTOM_DOC("Switch the keybindings to mode 2.")
{
 GlobalKeybindingMode = KeyBindingMode_2;
}

CUSTOM_COMMAND(switch_to_keybinding_3, "4coder_fleury_bindings.cpp", 27, Normal)
CUSTOM_DOC("Switch the keybindings to mode 3.")
{
 GlobalKeybindingMode = KeyBindingMode_3;
}

static Implicit_Map_Result
F4_ImplicitMap(Application_Links *app, String_ID lang, String_ID mode, Input_Event *event)
{
    Implicit_Map_Result result = {};

    View_ID view = get_this_ctx_view(app, Access_Always);

 Command_Map_ID orig_id = default_get_map_id(app, view);
    Command_Map_ID map_id = orig_id;
 if(GlobalKeybindingMode == KeyBindingMode_1)
 {
  for(int PairIndex = 0;
   PairIndex < ((sizeof(GlobalCommandMapReroute))/(sizeof(*GlobalCommandMapReroute)));
   ++PairIndex)
  {
   if(GlobalCommandMapReroute[PairIndex].From == map_id)
   {
    map_id = GlobalCommandMapReroute[PairIndex].To;
    break;
   }
  }
 }

 Command_Binding binding = map_get_binding_recursive(&framework_mapping, map_id, event);
 if(!binding.custom)
 {
  binding = map_get_binding_recursive(&framework_mapping, orig_id, event);
 }


    result.map = 0;
    result.command = binding.custom;

    return(result);
}




static void
F4_SetAbsolutelyNecessaryBindings(Mapping *mapping)
{
    String_ID global_map_id = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
    String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

 String_ID global_command_map_id = vars_save_string(SCu8((u8*)("keys_global_1"), (u64)(sizeof("keys_global_1") - 1)));
 String_ID file_command_map_id = vars_save_string(SCu8((u8*)("keys_file_1"), (u64)(sizeof("keys_file_1") - 1)));
    String_ID code_command_map_id = vars_save_string(SCu8((u8*)("keys_code_1"), (u64)(sizeof("keys_code_1") - 1)));

 implicit_map_function = F4_ImplicitMap;

 Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_map_id));
    map_set_binding_l(m, map, fleury_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);

    map = mapping_get_or_make_map(m, (file_map_id));
    map_set_parent(m, map, (global_map_id));
    map_set_binding_text_input(map, fleury_write_text_input);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map = mapping_get_or_make_map(m, (code_map_id));
    map_set_parent(m, map, (file_map_id));
    map_set_binding_text_input(map, fleury_write_text_and_auto_indent);
    map_set_binding_l(m, map, f4_lego_click_store_token_1, InputEventKind_MouseButton, (MouseCode_Right), 0);
    map_set_binding_l(m, map, f4_lego_click_store_token_2, InputEventKind_MouseButton, (MouseCode_Middle), 0);

    map = mapping_get_or_make_map(m, (global_command_map_id));
 map_set_parent(m, map, (global_map_id));
 GlobalCommandMapReroute[0].From = global_map_id;
 GlobalCommandMapReroute[0].To = global_command_map_id;

    map = mapping_get_or_make_map(m, (file_command_map_id));
 map_set_parent(m, map, (global_command_map_id));
 GlobalCommandMapReroute[1].From = file_map_id;
 GlobalCommandMapReroute[1].To = file_command_map_id;

    map = mapping_get_or_make_map(m, (code_command_map_id));
 map_set_parent(m, map, (file_command_map_id));
 GlobalCommandMapReroute[2].From = code_map_id;
 GlobalCommandMapReroute[2].To = code_command_map_id;

}

static void
F4_SetDefaultBindings(Mapping *mapping)
{
    String_ID global_map_id = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
    String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);
    map = mapping_get_or_make_map(m, (global_map_id));
    map_set_binding_l(m, map, keyboard_macro_start_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, 0);
    map_set_binding_l(m, map, keyboard_macro_finish_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, keyboard_macro_replay, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Alt, 0);
    map_set_binding_l(m, map, change_active_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, 0);
    map_set_binding_l(m, map, change_active_panel_backwards, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, interactive_new, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_in_other, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Alt, 0);
    map_set_binding_l(m, map, interactive_kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_switch_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Alt, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer_lister, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);


    {
        map_set_binding_l(m, map, open_panel_vsplit, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, 0);
        map_set_binding_l(m, map, open_panel_hsplit, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Control, 0);
        map_set_binding_l(m, map, close_panel, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, KeyCode_Shift, 0);
        map_set_binding_l(m, map, f4_search_for_definition__project_wide, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Control, 0);
        map_set_binding_l(m, map, f4_search_for_definition__current_file, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Control, KeyCode_Shift, 0);
        map_set_binding_l(m, map, fleury_toggle_battery_saver, InputEventKind_KeyStroke, (KeyCode_Tick), KeyCode_Alt, 0);
        map_set_binding_l(m, map, move_right_token_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Shift, KeyCode_Control, 0);
        map_set_binding_l(m, map, move_left_token_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Shift, KeyCode_Control, 0);
    }

    map = mapping_get_or_make_map(m, (file_map_id));
    map_set_parent(m, map, (global_map_id));
    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, fleury_home, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, replace_in_range, InputEventKind_KeyStroke, (KeyCode_A), KeyCode_Control, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, center_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, 0);
    map_set_binding_l(m, map, left_adjust_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Control, 0);
    map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
    map_set_binding_l(m, map, reopen, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
    map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Alt, 0);
    map_set_binding_l(m, map, reverse_search, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Control, 0);
    map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, view_buffer_other_panel, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Control, 0);
    map_set_binding_l(m, map, swap_panels, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Control, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);


    {
        map_set_binding_l(m, map, fleury_write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);
        map_set_binding_l(m, map, move_right_token_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Shift, KeyCode_Control, 0);
        map_set_binding_l(m, map, move_left_token_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Shift, KeyCode_Control, 0);
    }

    map = mapping_get_or_make_map(m, (code_map_id));
    map_set_parent(m, map, (file_map_id));
    map_set_binding_text_input(map, fleury_write_text_and_auto_indent);
    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Alt, 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Control, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Control, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Alt, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);

}
# 448 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_base_commands.cpp" 1




CUSTOM_COMMAND(f4_leave_event_unhandled, "4coder_fleury_base_commands.cpp", 5, Normal)
CUSTOM_DOC("when bound to keystroke, ensures the event falls through to text insertion")
{
    leave_current_input_unhandled(app);
}

static void
F4_Search(Application_Links *app, Scan_Direction dir)
{
    Scratch_Block scratch(app);
    View_ID view = get_active_view(app, Access_Read);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Read);
    if(view && buffer)
    {
        i64 cursor = view_get_cursor_pos(app, view);
        i64 mark = view_get_mark_pos(app, view);
        i64 cursor_line = get_line_number_from_pos(app, buffer, cursor);
        i64 mark_line = get_line_number_from_pos(app, buffer, mark);
        String_Const_u8 query_init = (fcoder_mode != FCoderMode_NotepadLike || cursor == mark || cursor_line != mark_line) ? SCu8() : push_buffer_range(app, scratch, buffer, Ii64(cursor, mark));
        isearch(app, dir, cursor, query_init);
    }
}

CUSTOM_COMMAND(f4_search, "4coder_fleury_base_commands.cpp", 28, Normal)
CUSTOM_DOC("Searches the current buffer forward. If something is highlighted, will fill search query with it.")
{
    F4_Search(app, Scan_Forward);
}

CUSTOM_COMMAND(f4_reverse_search, "4coder_fleury_base_commands.cpp", 34, Normal)
CUSTOM_DOC("Searches the current buffer backwards. If something is highlighted, will fill search query with it.")
{
    F4_Search(app, Scan_Backward);
}

CUSTOM_COMMAND(f4_write_text_input, "4coder_fleury_base_commands.cpp", 40, Normal)
CUSTOM_DOC("Inserts whatever text was used to trigger this command.")
{
    write_text_input(app);
    F4_PowerMode_CharacterPressed();
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    F4_PowerMode_Spawn(app, get_active_view(app, Access_ReadWriteVisible), insert.str ? insert.str[0] : 0);
}

CUSTOM_COMMAND(f4_write_text_and_auto_indent, "4coder_fleury_base_commands.cpp", 50, Normal)
CUSTOM_DOC("Inserts text and auto-indents the line on which the cursor sits if any of the text contains 'layout punctuation' such as ;:{}()[]# and new lines.")
{
    write_text_and_auto_indent(app);
    F4_PowerMode_CharacterPressed();
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    F4_PowerMode_Spawn(app, get_active_view(app, Access_ReadWriteVisible), insert.str ? insert.str[0] : 0);
}

CUSTOM_COMMAND(f4_write_zero_struct, "4coder_fleury_base_commands.cpp", 60, Normal)
CUSTOM_DOC("At the cursor, insert a ' = {0};'.")
{
    write_string(app, SCu8((u8*)(" = {0};"), (u64)(sizeof(" = {0};") - 1)));
    F4_PowerMode_CharacterPressed();
    F4_PowerMode_Spawn(app, get_active_view(app, Access_ReadWriteVisible), 0);
}

CUSTOM_COMMAND(f4_home, "4coder_fleury_base_commands.cpp", 68, Normal)
CUSTOM_DOC("Goes to the beginning of the line.")
{
    seek_pos_of_visual_line(app, Side_Min);
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.pixel_shift.x = 0;
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
}

CUSTOM_COMMAND(f4_toggle_battery_saver, "4coder_fleury_base_commands.cpp", 78, Normal)
CUSTOM_DOC("Toggles battery saving mode.")
{
    global_battery_saver = !global_battery_saver;
}

CUSTOM_COMMAND(f4_toggle_compilation_expand, "4coder_fleury_base_commands.cpp", 84, Normal)
CUSTOM_DOC("Expand the compilation window.")
{
    Buffer_ID buffer = view_get_buffer(app, global_compilation_view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    if(global_compilation_view_expanded ^= 1)
    {
        view_set_split_pixel_size(app, global_compilation_view, (i32)(metrics.line_height*32.f));
    }
    else
    {
        view_set_split_pixel_size(app, global_compilation_view, (i32)(metrics.line_height*4.f));
    }
}

static void
F4_GoToDefinition(Application_Links *app, F4_Index_Note *note, b32 same_panel)
{
    if(note != 0 && note->file != 0)
    {
        View_ID view = get_active_view(app, Access_Always);
        Rect_f32 region = view_get_buffer_region(app, view);
        f32 view_height = rect_height(region);
        Buffer_ID buffer = note->file->buffer;
        if(!same_panel)
        {
            view = get_next_view_looped_primary_panels(app, view, Access_Always);
        }
        point_stack_push_view_cursor(app, view);
        view_set_buffer(app, view, buffer, 0);
        i64 line_number = get_line_number_from_pos(app, buffer, note->range.min);
        Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
        scroll.position.line_number = line_number;
        scroll.target.line_number = line_number;
        scroll.position.pixel_shift.y = scroll.target.pixel_shift.y = -view_height*0.5f;
        view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
        view_set_cursor(app, view, seek_pos(note->range.min));
        view_set_mark(app, view, seek_pos(note->range.min));
    }
}

static F4_Index_Note *
F4_FindMostIntuitiveNoteInDuplicateChain(F4_Index_Note *note, Buffer_ID cursor_buffer, i64 cursor_pos)
{
    F4_Index_Note *result = note;
    if(note != 0)
    {
        F4_Index_Note *best_note_based_on_cursor = 0;
        for(F4_Index_Note *candidate = note; candidate; candidate = candidate->next)
        {
            F4_Index_File *file = candidate->file;
            if(file != 0)
            {
                if(cursor_buffer == file->buffer &&
                   candidate->range.min <= cursor_pos && cursor_pos <= candidate->range.max)
                {
                    if(candidate->next)
                    {
                        best_note_based_on_cursor = candidate->next;
                        break;
                    }
                    else
                    {
                        best_note_based_on_cursor = note;
                        break;
                    }
                }
            }
        }

        if(best_note_based_on_cursor)
        {
            result = best_note_based_on_cursor;
        }
        else if(note->flags & F4_Index_NoteFlag_Prototype)
        {
            for(F4_Index_Note *candidate = note; candidate; candidate = candidate->next)
            {
                if(!(candidate->flags & F4_Index_NoteFlag_Prototype))
                {
                    result = candidate;
                    break;
                }
            }
        }
    }
    return result;
}

CUSTOM_COMMAND(f4_go_to_definition, "4coder_fleury_base_commands.cpp", 174, Normal)
CUSTOM_DOC("Goes to the definition of the identifier under the cursor.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_token_or_word_under_active_cursor(app, scratch);
    F4_Index_Note *note = F4_Index_LookupNote(string);
    note = F4_FindMostIntuitiveNoteInDuplicateChain(note, buffer, view_get_cursor_pos(app, view));
    F4_GoToDefinition(app, note, 0);
}

CUSTOM_COMMAND(f4_go_to_definition_same_panel, "4coder_fleury_base_commands.cpp", 186, Normal)
CUSTOM_DOC("Goes to the definition of the identifier under the cursor in the same panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_token_or_word_under_active_cursor(app, scratch);
    F4_Index_Note *note = F4_Index_LookupNote(string);
    note = F4_FindMostIntuitiveNoteInDuplicateChain(note, buffer, view_get_cursor_pos(app, view));
    F4_GoToDefinition(app, note, 1);
}

static void
_F4_PushListerOptionForNote(Application_Links *app, Arena *arena, Lister *lister, F4_Index_Note *note)
{
    if(note && note->file)
    {
        F4_Index_File *file = note->file;
        Buffer_ID buffer = file->buffer;

        Tiny_Jump *jump = ((Tiny_Jump*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Tiny_Jump)*(1), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "206" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "206" ":") - 1)))));
        jump->buffer = buffer;
        jump->pos = note->range.first;

        String_Const_u8 buffer_name = push_buffer_unique_name(app, arena, buffer);
        String_Const_u8 name = push_stringf(arena, "[%.*s] %.*s", (i32)(buffer_name).size, (char*)(buffer_name).str, (i32)(note->string).size, (char*)(note->string).str);
        String_Const_u8 sort = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        switch(note->kind)
        {
            case F4_Index_NoteKind_Type:
            {
                sort = push_stringf(arena, "type [%s] [%s]",
                                    note->flags & F4_Index_NoteFlag_Prototype ? "prototype" : "def",
                                    note->flags & F4_Index_NoteFlag_SumType ? "sum" : "product");
            }break;

            case F4_Index_NoteKind_Function:
            {
                sort = push_stringf(arena, "function [%s]", note->flags & F4_Index_NoteFlag_Prototype ? "prototype" : "def");
            }break;

            case F4_Index_NoteKind_Macro:
            {
                sort = SCu8((u8*)("macro"), (u64)(sizeof("macro") - 1));
            }break;

            case F4_Index_NoteKind_Constant:
            {
                sort = SCu8((u8*)("constant"), (u64)(sizeof("constant") - 1));
            }break;

            case F4_Index_NoteKind_CommentTag:
            {
                sort = SCu8((u8*)("comment tag"), (u64)(sizeof("comment tag") - 1));
            }break;

            case F4_Index_NoteKind_CommentToDo:
            {
                sort = SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1));
            }break;

            default: break;
        }
        lister_add_item(lister, name, sort, jump, 0);
    }
}

static void
F4_JumpToLocation(Application_Links *app, View_ID view, Buffer_ID buffer, i64 pos)
{




    view_set_active(app, view);
    Buffer_Seek seek = seek_pos(pos);
    set_view_to_location(app, view, buffer, seek);

    if (auto_center_after_jumps)
    {
        center_view(app);
    }
    view_set_cursor(app, view, seek);
    view_set_mark(app, view, seek);
}

CUSTOM_COMMAND(f4_search_for_definition__project_wide, "4coder_fleury_base_commands.cpp", 272, UI)
CUSTOM_DOC("List all definitions in the index and jump to the one selected by the user.")
{
    char *query = "Index (Project):";

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    F4_Index_Lock();
    {
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0; buffer = get_buffer_next(app, buffer, Access_Always))
        {
            F4_Index_File *file = F4_Index_LookupFile(app, buffer);
            if(file != 0)
            {
                for(F4_Index_Note *note = file->first_note; note; note = note->next_sibling)
                {
                    _F4_PushListerOptionForNote(app, scratch, lister, note);
                }
            }
        }
    }
    F4_Index_Unlock();

    Lister_Result l_result = run_lister(app, lister);
    Tiny_Jump result = {};
    if (!l_result.canceled && l_result.user_data != 0){
        block_copy((&result), ((Tiny_Jump*)l_result.user_data), sizeof(*(&result)));
    }

    if (result.buffer != 0)
    {
        View_ID view = get_this_ctx_view(app, Access_Always);
        point_stack_push_view_cursor(app, view);
        F4_JumpToLocation(app, view, result.buffer, result.pos);
    }
}

CUSTOM_COMMAND(f4_search_for_definition__current_file, "4coder_fleury_base_commands.cpp", 313, UI)
CUSTOM_DOC("List all definitions in the current file and jump to the one selected by the user.")
{
    char *query = "Index (File):";

    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    F4_Index_Lock();
    {
        F4_Index_File *file = F4_Index_LookupFile(app, buffer);
        if(file != 0)
        {
            for(F4_Index_Note *note = file->first_note; note; note = note->next_sibling)
            {
                _F4_PushListerOptionForNote(app, scratch, lister, note);
            }
        }
    }
    F4_Index_Unlock();

    Lister_Result l_result = run_lister(app, lister);
    Tiny_Jump result = {};
    if (!l_result.canceled && l_result.user_data != 0){
        block_copy((&result), ((Tiny_Jump*)l_result.user_data), sizeof(*(&result)));
    }

    if (result.buffer != 0)
    {
        View_ID view_id = get_this_ctx_view(app, Access_Always);
        point_stack_push_view_cursor(app, view_id);
        F4_JumpToLocation(app, view_id, result.buffer, result.pos);
    }
}

CUSTOM_COMMAND(f4_toggle_enclosure_side, "4coder_fleury_base_commands.cpp", 353, Normal)
CUSTOM_DOC("Moves the cursor between the open/close brace/paren/bracket of the closest enclosure.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);


    {
        Token_Array tokens = get_token_array_from_buffer(app, buffer);

        Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
        Token *token = token_it_read(&it);
        if(token)
        {
            if(token->kind == TokenBaseKind_ScopeOpen ||
               token->kind == TokenBaseKind_ParentheticalOpen)
            {
                pos += 1;
                goto end;
            }
        }

        token_it_dec_all(&it);
        token = token_it_read(&it);
        if(token)
        {
            if(token->kind == TokenBaseKind_ScopeClose ||
               token->kind == TokenBaseKind_ParentheticalClose)
            {
                pos -= 1;
                goto end;
            }
        }

        end:;
    }

    Scratch_Block scratch(app);
    Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos,
                                                  FindNest_Scope | FindNest_Paren);
    if(ranges.count > 0)
    {
        Range_i64 nearest_range = ranges.ranges[0];
        if(pos == nearest_range.min+1)
        {
            pos = nearest_range.max;
        }
        else
        {
            pos = nearest_range.min;
        }
        view_set_cursor(app, view, seek_pos(pos));
        no_mark_snap_to_cursor_if_shift(app, view);
    }
}

CUSTOM_COMMAND(f4_open_project, "4coder_fleury_base_commands.cpp", 410, UI)
CUSTOM_DOC("Open a project by navigating to the project file.")
{
    for(;;)
    {
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "Open Project:", view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0)
        {
            file_name = result.file_name_in_text_field;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                         (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder)
        {
            set_hot_directory(app, full_file_name);
            continue;
        }

        if(character_is_slash(file_name.str[file_name.size - 1]))
        {
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            if (string_looks_like_drive_letter(file_name)){
                set_hot_directory(app, file_name);
                continue;
            }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        set_hot_directory(app, full_file_name);
        load_project(app);
        break;
    }
}

CUSTOM_COMMAND(f4_setup_new_project, "4coder_fleury_base_commands.cpp", 461, Normal)
CUSTOM_DOC("Sets up a blank 4coder project provided some user folder.")
{
    Scratch_Block scratch(app);
    Query_Bar_Group bar_group(app);


    u8 project_folder_absolute[1024];
    {
        Query_Bar path_bar = {};
        path_bar.prompt = SCu8((u8*)("Absolute Path To Project Folder: "), (u64)(sizeof("Absolute Path To Project Folder: ") - 1));
        path_bar.string = SCu8(project_folder_absolute, (u64)0);
        path_bar.string_capacity = sizeof(project_folder_absolute);
        if(query_user_string(app, &path_bar))
        {
            String_Const_u8 full_file_name = push_u8_stringf(scratch, "%.*s/",
                                                             (i32)(path_bar.string).size, (char*)(path_bar.string).str);
            set_hot_directory(app, full_file_name);

            String_Const_u8 project_file_path = push_u8_stringf(scratch, "%.*s/project.4coder", (i32)(path_bar.string).size, (char*)(path_bar.string).str);
            FILE *file = fopen((char *)project_file_path.str, "wb");
            if(file)
            {

                char *string = R"PROJ(version(1);
                  
                  project_name = "New Project";
                  
                  patterns =
                  {
                      "*.c",
                      "*.cpp",
                      "*.jai",
                      "*.odin",
                      "*.zig",
                      "*.h",
                      "*.inc",
                      "*.bat",
                      "*.sh",
                      "*.4coder",
                      "*.txt",
                  };
                  
                  blacklist_patterns =
                  {
                      ".*",
                  };
                  
                  load_paths =
                  {
                      {
                          { {"."}, .recursive = true, .relative = true }, .os = "win"
                      },
                  };
                  
                  command_list =
                  {
                      {
                          .name = "build",
                          .out = "*compilation*",
                          .footer_panel = true,
                          .save_dirty_files = true,
                          .cursor_at_end = false,
                          .cmd =
                          {
                              { "echo Windows build command not implemented for 4coder project.", .os = "win" },
        { "echo Linux build command not implemented for 4coder project.", .os = "linux" },
                          },
                      },
                      
                      {
                          .name = "run",
                          .out = "*compilation*",
                          .footer_panel = true,
                          .save_dirty_files = true,
                          .cursor_at_end = false,
                          .cmd =
                          {
                              { "echo Windows run command not implemented for 4coder project.", .os = "win" },
        { "echo Linux run command not implemented for 4coder project.", .os = "linux" },
                          },
                      },
                      
                  };
                  
                  fkey_command[1] = "build";
                  fkey_command[2] = "run";
        )PROJ";

                fprintf(file, "%s", string);
                fclose(file);
                load_project(app);
            }
            else
            {

            }
        }
    }

    load_project(app);
}

static i64
F4_Boundary_TokenAndWhitespace(Application_Links *app, Buffer_ID buffer,
                               Side side, Scan_Direction direction, i64 pos)
{
    i64 result = boundary_non_whitespace(app, buffer, side, direction, pos);
    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    if (tokens.tokens != 0){
        switch (direction){
            case Scan_Forward:
            {
                i64 buffer_size = buffer_get_size(app, buffer);
                result = buffer_size;
                if(tokens.count > 0)
                {
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);

                    if(token == 0)
                    {
                        break;
                    }


                    if(token->kind == TokenBaseKind_Comment ||
                       token->kind == TokenBaseKind_LiteralString)
                    {
                        result = boundary_non_whitespace(app, buffer, side, direction, pos);
                        break;
                    }


                    else
                    {
                        if (token->kind == TokenBaseKind_Whitespace)
                        {


                        }

                        if (side == Side_Max){
                            result = token->pos + token->size;

                            token_it_inc_all(&it);
                            Token *ws = token_it_read(&it);
                            if(ws != 0 && ws->kind == TokenBaseKind_Whitespace &&
                               get_line_number_from_pos(app, buffer, ws->pos + ws->size) ==
                               get_line_number_from_pos(app, buffer, token->pos))
                            {
                                result = ws->pos + ws->size;
                            }
                        }
                        else{
                            if (token->pos <= pos){
                                token_it_inc_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            if (token != 0){
                                result = token->pos;
                            }
                        }
                    }

                }
            }break;

            case Scan_Backward:
            {
                result = 0;
                if (tokens.count > 0){
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);

                    Token_Iterator_Array it2 = it;
                    token_it_dec_non_whitespace(&it2);
                    Token *token2 = token_it_read(&it2);


                    if(token->kind == TokenBaseKind_Comment ||
                       token->kind == TokenBaseKind_LiteralString ||
                       (token2 &&
                        token2->kind == TokenBaseKind_Comment ||
                        token2->kind == TokenBaseKind_LiteralString))
                    {
                        result = boundary_non_whitespace(app, buffer, side, direction, pos);
                        break;
                    }

                    if (token->kind == TokenBaseKind_Whitespace){
                        token_it_dec_non_whitespace(&it);
                        token = token_it_read(&it);
                    }
                    if (token != 0){
                        if (side == Side_Min){
                            if (token->pos >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos;
                        }
                        else{
                            if (token->pos + token->size >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos + token->size;
                        }
                    }
                }
            }break;
        }
    }
    return(result);
}


static i64
F4_Boundary_CursorTokenOrBlankLine_TEST(Application_Links *app, Buffer_ID buffer,
                                        Side side, Scan_Direction direction, i64 pos)
{
    Scratch_Block scratch(app);

    Range_i64_Array scopes = get_enclosure_ranges(app, scratch, buffer, pos, FindNest_Scope);

    Range_i64 outer_scope = scopes.ranges[scopes.count - 1];


    View_ID view = get_active_view(app, Access_Always);
    i64 active_cursor_pos = view_get_cursor_pos(app, view);
    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    Token_Iterator_Array active_cursor_it = token_iterator_pos(0, &tokens, active_cursor_pos);
    Token *active_cursor_token = token_it_read(&active_cursor_it);

    String_Const_u8 cursor_string = push_buffer_range(app, scratch, buffer, Ii64(active_cursor_token));
    i64 cursor_offset = pos - active_cursor_token->pos;


    i64 result = get_pos_of_blank_line_grouped(app, buffer, direction, pos);
    result = view_get_character_legal_pos_from_pos(app, view, result);
    if (tokens.tokens != 0)
    {


        if (active_cursor_token->kind == TokenBaseKind_Identifier && !(scopes.count == 0))
        {


            result = pos;
            Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);

            for (;;)
            {
                b32 done = false;

                switch (direction)
                {


                    case Scan_Forward:
                    {
                        if (!token_it_inc_non_whitespace(&it) || it.ptr->pos >= outer_scope.end) {
                            done = true;
                        }
                    } break;

                    case Scan_Backward:
                    {
                        if (!token_it_dec_non_whitespace(&it) || it.ptr->pos < outer_scope.start) {
                            done = true;
                        }
                    } break;
                }

                if (!done)
                {
                    Token *token = token_it_read(&it);
                    String_Const_u8 token_string = push_buffer_range(app, scratch, buffer, Ii64(token));
                    if (string_match(cursor_string, token_string)) {
                        result = token->pos + cursor_offset;
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
        }
    }

    return result ;
}

CUSTOM_COMMAND(f4_move_left, "4coder_fleury_base_commands.cpp", 756, Normal)
CUSTOM_DOC("Moves the cursor one character to the left.")
{
    Scratch_Block scratch(app);
    Input_Modifier_Set mods = system_get_keyboard_modifiers(scratch);
    View_ID view = get_active_view(app, Access_ReadVisible);
    if(fcoder_mode != FCoderMode_NotepadLike || view_get_cursor_pos(app, view) == view_get_mark_pos(app, view) ||
       has_modifier(&mods, KeyCode_Shift))
    {
        view_set_cursor_by_character_delta(app, view, -1);
    }
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(f4_move_right, "4coder_fleury_base_commands.cpp", 770, Normal)
CUSTOM_DOC("Moves the cursor one character to the right.")
{
    Scratch_Block scratch(app);
    Input_Modifier_Set mods = system_get_keyboard_modifiers(scratch);
    View_ID view = get_active_view(app, Access_ReadVisible);
    if(fcoder_mode != FCoderMode_NotepadLike || view_get_cursor_pos(app, view) == view_get_mark_pos(app, view) ||
       has_modifier(&mods, KeyCode_Shift))
    {
        view_set_cursor_by_character_delta(app, view, +1);
    }
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(f4_move_up_token_occurrence, "4coder_fleury_base_commands.cpp", 784, Normal)
CUSTOM_DOC("Moves the cursor to the previous occurrence of the token that the cursor is over.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), F4_Boundary_CursorTokenOrBlankLine_TEST, 0));
}

CUSTOM_COMMAND(f4_move_down_token_occurrence, "4coder_fleury_base_commands.cpp", 791, Normal)
CUSTOM_DOC("Moves the cursor to the next occurrence of the token that the cursor is over.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), F4_Boundary_CursorTokenOrBlankLine_TEST, 0));
}

CUSTOM_COMMAND(f4_move_right_token_boundary, "4coder_fleury_base_commands.cpp", 798, Normal)
CUSTOM_DOC("Seek right for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), F4_Boundary_TokenAndWhitespace, 0));
}

CUSTOM_COMMAND(f4_move_left_token_boundary, "4coder_fleury_base_commands.cpp", 805, Normal)
CUSTOM_DOC("Seek left for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), F4_Boundary_TokenAndWhitespace, 0));
}

CUSTOM_COMMAND(f4_backspace_token_boundary, "4coder_fleury_base_commands.cpp", 812, Normal)
CUSTOM_DOC("Deletes left to a token boundary.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Backward, push_boundary_list__inner((scratch), F4_Boundary_TokenAndWhitespace, 0));
}

CUSTOM_COMMAND(f4_delete_token_boundary, "4coder_fleury_base_commands.cpp", 819, Normal)
CUSTOM_DOC("Deletes right to a token boundary.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Forward, push_boundary_list__inner((scratch), F4_Boundary_TokenAndWhitespace, 0));
}

CUSTOM_COMMAND(f4_backspace_alpha_numeric_or_camel_boundary, "4coder_fleury_base_commands.cpp", 826, Normal)
CUSTOM_DOC("Deletes left to a alphanumeric or camel boundary.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric, boundary_alpha_numeric_camel, 0)

                                                                                                     );
}

CUSTOM_COMMAND(f4_delete_alpha_numeric_or_camel_boundary, "4coder_fleury_base_commands.cpp", 835, Normal)
CUSTOM_DOC("Deletes right to an alphanumeric or camel boundary.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric, boundary_alpha_numeric_camel, 0)

                                                                                                    );
}

CUSTOM_COMMAND(f4_home_first_non_whitespace, "4coder_fleury_base_commands.cpp", 844, Normal)
CUSTOM_DOC("Goes to the beginning of the line.")
{
    View_ID view = get_active_view(app, Access_Read);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Read);
    if(view && buffer)
    {
        i64 start_pos = view_get_cursor_pos(app, view);
        seek_pos_of_visual_line(app, Side_Min);
        i64 end_pos = view_get_cursor_pos(app, view);
        i64 line = get_line_number_from_pos(app, buffer, start_pos);



        if(start_pos == end_pos && start_pos == get_line_start_pos(app, buffer, line))
        {
            Scratch_Block scratch(app);
            String_Const_u8 string = push_buffer_line(app, scratch, buffer, line);
            for(u64 i = 0; i < string.size; i += 1)
            {
                if(!character_is_whitespace(string.str[i]))
                {
                    view_set_cursor_by_character_delta(app, view, (i64)i);
                    break;
                }
            }
        }



        else
        {
            Scratch_Block scratch(app);
            String_Const_u8 string = push_buffer_range(app, scratch, buffer, Ii64(start_pos, end_pos));

            b32 skipped_non_whitespace = 0;
            {
                for(i64 i = string.size-1; i >= 0; i -= 1)
                {
                    if(!character_is_whitespace(string.str[i]))
                    {
                        skipped_non_whitespace = 1;
                        break;
                    }
                }
            }

            if(skipped_non_whitespace)
            {
                for(i64 i = 0; i < (i64)string.size; i += 1)
                {
                    if(!character_is_whitespace(string.str[i]))
                    {
                        view_set_cursor_by_character_delta(app, view, i);
                        break;
                    }
                }
            }
        }


        {
            Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
            scroll.target.pixel_shift.x = 0;
            view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
        }
    }
}

static void
F4_ReIndentLine(Application_Links *app, Buffer_ID buffer, i64 line, i64 indent_delta)
{
    Scratch_Block scratch(app);
    String_Const_u8 line_string = push_buffer_line(app, scratch, buffer, line);
    i64 line_start_pos = get_line_start_pos(app, buffer, line);

    Range_i64 line_indent_range = Ii64(0, 0);
    i64 tabs_at_beginning = 0;
    i64 spaces_at_beginning = 0;
    for(u64 i = 0; i < line_string.size; i += 1)
    {
        if(line_string.str[i] == '\t')
        {
            tabs_at_beginning += 1;
        }
        else if(character_is_whitespace(line_string.str[i]))
        {
            spaces_at_beginning += 1;
        }
        else if(!character_is_whitespace(line_string.str[i]))
        {
            line_indent_range.max = (i64)i;
            break;
        }
    }


    {
        Range_i64 indent_range =
        {
            line_indent_range.min + line_start_pos,
            line_indent_range.max + line_start_pos,
        };

        i64 indent_width = (i64)def_get_config_u64(app, vars_save_string(SCu8((u8*)("indent_width"), (u64)(sizeof("indent_width") - 1))));
        b32 indent_with_tabs = def_get_config_b32(vars_save_string(SCu8((u8*)("indent_with_tabs"), (u64)(sizeof("indent_with_tabs") - 1))));
        i64 spaces_per_indent_level = indent_width;
        i64 indent_level = spaces_at_beginning / spaces_per_indent_level + tabs_at_beginning;
        i64 new_indent_level = indent_level + indent_delta;

        String_Const_u8 indent_string = indent_with_tabs ? SCu8((u8*)("\t"), (u64)(sizeof("\t") - 1)) : push_stringf(scratch, "%.*s", (((indent_width)<(16))?(indent_width):(16)),
                                                                                      "                ");
        buffer_replace_range(app, buffer, indent_range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
        for(i64 i = 0; i < new_indent_level; i += 1)
        {
            buffer_replace_range(app, buffer, Ii64(line_start_pos), indent_string);
        }
    }

}

static void
F4_ReIndentLineRange(Application_Links *app, Buffer_ID buffer, Range_i64 range, i64 indent_delta)
{
    for(i64 i = range.min; i <= range.max; i += 1)
    {
        F4_ReIndentLine(app, buffer, i, indent_delta);
    }
}

static Range_i64
F4_LineRangeFromPosRange(Application_Links *app, Buffer_ID buffer, Range_i64 pos_range)
{
    Range_i64 lines_range =
        Ii64(get_line_number_from_pos(app, buffer, pos_range.min),
             get_line_number_from_pos(app, buffer, pos_range.max));
    return lines_range;
}

static Range_i64
F4_PosRangeFromLineRange(Application_Links *app, Buffer_ID buffer, Range_i64 line_range)
{
    if(line_range.min > line_range.max)
    {
        i64 swap = line_range.max;
        line_range.max = line_range.min;
        line_range.min = swap;
    }
    Range_i64 pos_range =
        Ii64(get_line_start_pos(app, buffer, line_range.min),
             get_line_end_pos(app, buffer, line_range.max));
    return pos_range;
}

static void
F4_ReIndentPosRange(Application_Links *app, Buffer_ID buffer, Range_i64 range, i64 indent_delta)
{
    F4_ReIndentLineRange(app, buffer,
                         F4_LineRangeFromPosRange(app, buffer, range),
                         indent_delta);
}

static void
F4_AdjustCursorAndMarkForIndentation(Application_Links *app, View_ID view, i64 original_cursor, i64 original_mark, Range_i64 original_line_range)
{
    Buffer_ID buffer = view_get_buffer(app, view, Access_Read);
    Scratch_Block scratch(app);
    if(original_cursor == original_mark)
    {
        i64 start_pos = get_line_start_pos(app, buffer, original_line_range.min);
        i64 new_pos = start_pos;
        String_Const_u8 line = push_buffer_line(app, scratch, buffer, original_line_range.min);
        for(u64 i = 0; i < line.size; i += 1)
        {
            if(!character_is_whitespace(line.str[i]))
            {
                new_pos = start_pos + (i64)i;
                break;
            }
        }

        view_set_cursor(app, view, seek_pos(new_pos));
        view_set_mark(app, view, seek_pos(new_pos));
    }
    else
    {
        Range_i64 range = F4_PosRangeFromLineRange(app, buffer, original_line_range);
        view_set_cursor(app, view, seek_pos(original_cursor > original_mark ? range.max : range.min));
        view_set_mark(app, view, seek_pos(original_cursor > original_mark ? range.min : range.max));
    }
}

CUSTOM_COMMAND(f4_autocomplete_or_indent, "4coder_fleury_base_commands.cpp", 1036, Normal)
CUSTOM_DOC("Tries to autocomplete the word currently being typed, and inserts indentation if such a word is not found.")
{
    Profile_Scope_Block profile_block_1039 ((app), SCu8((u8*)("[F4] Word Complete"), (u64)(sizeof("[F4] Word Complete") - 1)), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1039" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1039" ":") - 1)));

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if(buffer != 0)
    {
        Managed_Scope scope = view_get_managed_scope(app, view);

        b32 first_completion = false;
        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (*rewrite != Rewrite_WordComplete){
            first_completion = true;
        }

        set_next_rewrite(app, view, Rewrite_WordComplete);

        Word_Complete_Iterator *it = word_complete_get_shared_iter(app);
        static b32 initialized = false;
        static Range_i64 range = {};

        if(first_completion || !initialized)
        {
            Profile_Scope_Block profile_block_1062 ((app), SCu8((u8*)("[F4] Word Complete State Init"), (u64)(sizeof("[F4] Word Complete State Init") - 1)), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1062" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1062" ":") - 1)));
            initialized = false;
            i64 pos = view_get_cursor_pos(app, view);
            Range_i64 needle_range = get_word_complete_needle_range(app, buffer, pos);
            if(range_size(needle_range) > 0)
            {
                initialized = true;
                range = needle_range;
                word_complete_iter_init(buffer, needle_range, it);
            }
        }


        if(initialized)
        {
            Profile_Scope_Block profile_block_1077 ((app), SCu8((u8*)("[F4] Word Complete Apply"), (u64)(sizeof("[F4] Word Complete Apply") - 1)), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1077" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1077" ":") - 1)));

            word_complete_iter_next(it);
            String_Const_u8 str = word_complete_iter_read(it);

            buffer_replace_range(app, buffer, range, str);

            range.max = range.min + str.size;
            view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
        }


        else if(initialized == 0)
        {
            i64 pos = view_get_cursor_pos(app, view);
            i64 mark = view_get_mark_pos(app, view);
            Range_i64 pos_range = Ii64(pos, mark);
            Range_i64 line_range = F4_LineRangeFromPosRange(app, buffer, pos_range);

            History_Group group = history_group_begin(app, buffer);
            F4_ReIndentPosRange(app, buffer, Ii64(pos, mark), +1);
            F4_AdjustCursorAndMarkForIndentation(app, view, pos, mark, line_range);
            history_group_end(group);
            no_mark_snap_to_cursor(app, view);
        }
    }
}

CUSTOM_COMMAND(f4_unindent, "4coder_fleury_base_commands.cpp", 1105, Normal)
CUSTOM_DOC("Unindent the selected range.")
{
    Scratch_Block scratch(app);

    View_ID view = get_active_view(app, Access_ReadWrite);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWrite);
    i64 pos = view_get_cursor_pos(app, view);
    i64 mark = view_get_mark_pos(app, view);
    Range_i64 pos_range = Ii64(pos, mark);
    Range_i64 line_range = F4_LineRangeFromPosRange(app, buffer, pos_range);
    History_Group group = history_group_begin(app, buffer);
    F4_ReIndentPosRange(app, buffer, Ii64(pos, mark), -1);
    F4_AdjustCursorAndMarkForIndentation(app, view, pos, mark, line_range);
    history_group_end(group);
    no_mark_snap_to_cursor(app, view);
}

static void
F4_GenerateHotDirectoryFileList_Project(Application_Links *app, Lister *lister)
{
# 1203 "4coder_fleury_base_commands.cpp"
}

static File_Name_Result
F4_GetFileNameFromUser_Project(Application_Links *app, Arena *arena, String_Const_u8 query, View_ID view)
{
    Lister_Handlers handlers = lister_get_default_handlers();
    handlers.refresh = F4_GenerateHotDirectoryFileList_Project;
    handlers.write_character = lister__write_character__file_path;
    handlers.backspace = lister__backspace_text_field__file_path;

    Lister_Result l_result = run_lister_with_refresh_handler(app, arena, query, handlers);

    File_Name_Result result = {};
    result.canceled = l_result.canceled;
    if (!l_result.canceled){
        result.clicked = l_result.activated_by_click;
        if (l_result.user_data != 0){
            String_Const_u8 name = SCu8((u8*)l_result.user_data);
            result.file_name_activated = name;
            result.is_folder = character_is_slash(string_get_character(name, name.size - 1));
        }
        result.file_name_in_text_field = string_front_of_path(l_result.text_field);

        String_Const_u8 path = {};
        if (l_result.user_data == 0 && result.file_name_in_text_field.size == 0 && l_result.text_field.size > 0){
            result.file_name_in_text_field = string_front_folder_of_path(l_result.text_field);
            path = string_remove_front_folder_of_path(l_result.text_field);
        }
        else{
            path = string_remove_front_of_path(l_result.text_field);
        }
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        result.path_in_text_field = path;
    }

    return(result);
}

CUSTOM_COMMAND(f4_interactive_open_or_new_in_project, "4coder_fleury_base_commands.cpp", 1243, UI)
CUSTOM_DOC("Interactively open a file out of the file system, filtered to files only in the project.")
{
    for(;;)
    {
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = F4_GetFileNameFromUser_Project(app, scratch, SCu8((u8*)("Open (File In Project):"), (u64)(sizeof("Open (File In Project):") - 1)), view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0){
            file_name = result.file_name_in_text_field;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                         (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if(result.is_folder)
        {
            set_hot_directory(app, full_file_name);
            continue;
        }

        if(character_is_slash(file_name.str[file_name.size - 1]))
        {
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if((((attribs.flags)&(FileAttribute_IsDirectory))!=0))
            {
                set_hot_directory(app, full_file_name);
                continue;
            }
            if(string_looks_like_drive_letter(file_name))
            {
                set_hot_directory(app, file_name);
                continue;
            }
            if(query_create_folder(app, file_name))
            {
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_ID buffer = create_buffer(app, full_file_name, 0);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}

static void
F4_SetLineCommentedOnLine(Application_Links *app, Buffer_ID buffer, i64 *cursor_p, i64 *mark_p, b32 commented)
{
    i64 cursor = *cursor_p;
    i64 mark = *mark_p;
    i64 cursor_line = get_line_number_from_pos(app, buffer, cursor);
    i64 mark_line = get_line_number_from_pos(app, buffer, mark);

    if(cursor_line == mark_line)
    {
        i64 line = cursor_line;
        i64 line_start = get_pos_past_lead_whitespace_from_line_number(app, buffer, line);
        b32 already_has_comment = c_line_comment_starts_at_position(app, buffer, line_start);

        if(commented)
        {
            if(!already_has_comment)
            {
                buffer_replace_range(app, buffer, Ii64(line_start), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
                cursor = mark += 2;
            }
        }
        else
        {
            if(already_has_comment)
            {
                buffer_replace_range(app, buffer, Ii64(line_start, line_start + 2), string_u8_empty);
                cursor = mark -= 2;
            }
        }
    }

    *cursor_p = cursor;
    *mark_p = mark;
}

static void
F4_SetBlockCommentedOnRange(Application_Links *app, Buffer_ID buffer, i64 *cursor_p, i64 *mark_p, b32 commented)
{
    Scratch_Block scratch(app);

    i64 cursor = *cursor_p;
    i64 mark = *mark_p;
    Range_i64 range = Ii64(cursor, mark);

    if(commented)
    {
        buffer_replace_range(app, buffer, Ii64(range.max, range.max), SCu8((u8*)("*/"), (u64)(sizeof("*/") - 1)));
        buffer_replace_range(app, buffer, Ii64(range.min, range.min), SCu8((u8*)("/*"), (u64)(sizeof("/*") - 1)));
        if(cursor > mark) { cursor += 4; }
        else { mark += 4; }
    }
    else if(range.max - range.min >= 2)
    {
        String_Const_u8 opener = push_buffer_range(app, scratch, buffer, Ii64(range.min, range.min+2));
        String_Const_u8 closer = push_buffer_range(app, scratch, buffer, Ii64(range.max-2, range.max));
        if(string_match(opener, SCu8((u8*)("/*"), (u64)(sizeof("/*") - 1))) &&
           string_match(closer, SCu8((u8*)("*/"), (u64)(sizeof("*/") - 1))))
        {
            buffer_replace_range(app, buffer, Ii64(range.max-2, range.max), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            buffer_replace_range(app, buffer, Ii64(range.min, range.min+2), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            if(cursor > mark) { cursor -= 4; }
            if(mark > cursor) { mark -= 4; }
        }
    }

    *cursor_p = cursor;
    *mark_p = mark;
}

static b32
F4_CBlockCommentStartsAtPosition(Application_Links *app, Buffer_ID buffer, i64 pos)
{
    b32 alread_has_comment = false;
    u8 check_buffer[2];
    if(buffer_read_range(app, buffer, Ii64(pos, pos + 2), check_buffer))
    {
        if(check_buffer[0] == '/' && check_buffer[1] == '*')
        {
            alread_has_comment = true;
        }
    }
    return(alread_has_comment);
}

static void
F4_SetCommentedOnRange(Application_Links *app, Buffer_ID buffer, i64 *cursor_p, i64 *mark_p, b32 commented)
{
    Scratch_Block scratch(app);

    i64 cursor = *cursor_p;
    i64 mark = *mark_p;
    Range_i64 range = Ii64(cursor, mark);
    Range_i64 line_range = F4_LineRangeFromPosRange(app, buffer, range);
    Token_Array tokens = get_token_array_from_buffer(app, buffer);


    if(range.min == range.max)
    {
        F4_SetLineCommentedOnLine(app, buffer, &cursor, &mark, commented);
    }


    else if(line_range.min == line_range.max)
    {
        Token *min_token = get_token_from_pos(app, &tokens, (u64)range.min);
        Token *max_token = get_token_from_pos(app, &tokens, (u64)range.max);


        if(min_token == max_token && min_token && min_token->kind == TokenBaseKind_Comment)
        {
            (commented ? comment_line : uncomment_line)(app);
        }


        else
        {
            F4_SetBlockCommentedOnRange(app, buffer, &cursor, &mark, commented);
        }
    }


    else if(line_range.min != line_range.max)
    {
        if(commented)
        {
            i64 min_pos = (((cursor)<(mark))?(cursor):(mark));
            i64 line = get_line_number_from_pos(app, buffer, min_pos);
            i64 start_of_line = get_line_start_pos(app, buffer, line);


            if(min_pos == start_of_line)
            {
                for(i64 i = line_range.min; i <= line_range.max; i += 1)
                {
                    i64 cursor2 = get_line_start_pos(app, buffer, i);
                    i64 mark2 = get_line_end_pos(app, buffer, i);
                    F4_SetLineCommentedOnLine(app, buffer, &cursor2, &mark2, commented);
                }
                if(cursor < mark)
                {
                    cursor = get_line_start_pos(app, buffer, line_range.min);
                    mark = get_line_end_pos(app, buffer, line_range.max);
                }
                else
                {
                    mark = get_line_start_pos(app, buffer, line_range.min);
                    cursor = get_line_end_pos(app, buffer, line_range.max);
                }
            }


            else
            {
                F4_SetBlockCommentedOnRange(app, buffer, &cursor, &mark, 1);
            }
        }
        else
        {
            b32 starts_with_block_comment = F4_CBlockCommentStartsAtPosition(app, buffer, range.min);
            if(starts_with_block_comment)
            {
                F4_SetBlockCommentedOnRange(app, buffer, &cursor, &mark, 0);
            }
            else
            {
                for(i64 i = line_range.min; i <= line_range.max; i += 1)
                {
                    i64 cursor2 = get_line_start_pos(app, buffer, i);
                    i64 mark2 = get_line_start_pos(app, buffer, i);
                    F4_SetLineCommentedOnLine(app, buffer, &cursor2, &mark2, 0);
                }
                if(cursor < mark)
                {
                    cursor = get_line_start_pos(app, buffer, line_range.min);
                    mark = get_line_end_pos(app, buffer, line_range.max);
                }
                else
                {
                    mark = get_line_start_pos(app, buffer, line_range.min);
                    cursor = get_line_end_pos(app, buffer, line_range.max);
                }
            }
        }
    }

    *cursor_p = cursor;
    *mark_p = mark;
}

CUSTOM_COMMAND(f4_comment_selection, "4coder_fleury_base_commands.cpp", 1488, Normal)
CUSTOM_DOC("Performs VS-style commenting on the selected range.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 cursor = view_get_cursor_pos(app, view);
    i64 mark = view_get_mark_pos(app, view);

    History_Group group = history_group_begin(app, buffer);
    F4_SetCommentedOnRange(app, buffer, &cursor, &mark, 1);
    view_set_cursor(app, view, seek_pos(cursor));
    view_set_mark(app, view, seek_pos(mark));
    history_group_end(group);
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(f4_uncomment_selection, "4coder_fleury_base_commands.cpp", 1504, Normal)
CUSTOM_DOC("Performs VS-style uncommenting on the selected range.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 cursor = view_get_cursor_pos(app, view);
    i64 mark = view_get_mark_pos(app, view);
    History_Group group = history_group_begin(app, buffer);
    F4_SetCommentedOnRange(app, buffer, &cursor, &mark, 0);
    view_set_cursor(app, view, seek_pos(cursor));
    view_set_mark(app, view, seek_pos(mark));
    history_group_end(group);
    no_mark_snap_to_cursor(app, view);
}

struct F4_LOCInfo
{
    F4_LOCInfo *next;
    String_Const_u8 name;
    i64 lines;
    i64 whitespace_only_lines;
    i64 open_brace_only_lines;
};

static F4_LOCInfo *
F4_LOCInfoFromBuffer(Application_Links *app, Arena *arena, Buffer_ID buffer)
{
    F4_LOCInfo *first = 0;
    F4_LOCInfo *last = 0;

    F4_LOCInfo *file_info = ((F4_LOCInfo*)linalloc_wrap_zero(linalloc_push((arena), sizeof(F4_LOCInfo)*(1), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1534" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1534" ":") - 1)))));
    do{ if((file_info)){if((first)){(last)->next=(file_info);}else{(first)=(file_info);}(last)=(file_info);(last)->next=0;} }while(0);
    file_info->name = {(u8*)("all"), sizeof("all") - 1};
    F4_LOCInfo *active_info = 0;

    i64 line_count = buffer_get_line_count(app, buffer);
    for(i64 line_idx = 0; line_idx < line_count; line_idx += 1)
    {
        Scratch_Block scratch(app, arena);
        String_Const_u8 line = push_buffer_line(app, scratch, buffer, line_idx);
        if(line.size != 0 && line.str[line.size-1] == '\r')
        {
            line.size -= 1;
        }


        if(line.size >= 3 && line.str[0] == '/' && line.str[1] == '/' && line.str[2] == '~')
        {
            active_info = ((F4_LOCInfo*)linalloc_wrap_zero(linalloc_push((arena), sizeof(F4_LOCInfo)*(1), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1552" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1552" ":") - 1)))));
            active_info->name = push_string_copy(arena, string_substring(line, Ii64(3, line.size)));
            do{ if((active_info)){if((first)){(last)->next=(active_info);}else{(first)=(active_info);}(last)=(active_info);(last)->next=0;} }while(0);
        }


        b32 is_only_whitespace = true;
        {
            for(u64 i = 0; i < line.size; i += 1)
            {
                if(!character_is_whitespace(line.str[i]))
                {
                    is_only_whitespace = false;
                    break;
                }
            }
        }


        b32 is_only_open_brace = false;
        if(is_only_whitespace == false)
        {
            for(u64 i = 0; i < line.size; i += 1)
            {
                if(!character_is_whitespace(line.str[i]))
                {
                    is_only_open_brace = line.str[i] == '{';
                    if(!is_only_open_brace)
                    {
                        break;
                    }
                }
            }
        }


        {
            file_info->lines += 1;
            if(active_info != 0)
            {
                active_info->lines += 1;
            }
            if(is_only_whitespace)
            {
                file_info->whitespace_only_lines += 1;
                if(active_info != 0)
                {
                    active_info->whitespace_only_lines += 1;
                }
            }
            if(is_only_open_brace)
            {
                file_info->open_brace_only_lines += 1;
                if(active_info != 0)
                {
                    active_info->open_brace_only_lines += 1;
                }
            }
        }
    }

    return first;
}

static int
F4_LOCInfoCompare(const void *a_void_fuck_cplusplus, const void *b_void_fuck_cplusplus)
{
    F4_LOCInfo *a = (F4_LOCInfo *)a_void_fuck_cplusplus;
    F4_LOCInfo *b = (F4_LOCInfo *)b_void_fuck_cplusplus;
    return ((a->lines < b->lines) ? +1 :
            (a->lines > b->lines) ? -1 :
            0);
}

CUSTOM_COMMAND(f4_loc, "4coder_fleury_base_commands.cpp", 1626, Normal)
CUSTOM_DOC("Counts the lines of code in the current buffer, breaks it down by section, and outputs to the *loc* buffer.")
{
    Scratch_Block scratch(app);
    View_ID view = get_active_view(app, Access_Read);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Read);


    F4_LOCInfo *infos_list = F4_LOCInfoFromBuffer(app, scratch, buffer);


    int info_count = 0;
    F4_LOCInfo *info_array = 0;
    {
        for(F4_LOCInfo *info = infos_list; info; info = info->next, info_count += 1);
        info_array = ((F4_LOCInfo*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(F4_LOCInfo)*(info_count), SCu8((u8*)("4coder_fleury_base_commands.cpp" ":" "1641" ":"), (u64)(sizeof("4coder_fleury_base_commands.cpp" ":" "1641" ":") - 1)))));
        int i = 0;
        for(F4_LOCInfo *info = infos_list; info; info = info->next, i += 1)
        {
            info_array[i] = *info;
        }
    }


    {
        qsort(info_array, info_count, sizeof(F4_LOCInfo), F4_LOCInfoCompare);
    }


    Buffer_ID loc_buffer = get_buffer_by_name(app, {(u8*)("*loc*"), sizeof("*loc*") - 1}, AccessFlag_Write);
    if(loc_buffer != 0)
    {
        clear_buffer(app, loc_buffer);

        for(int i = 0; i < info_count; i += 1)
        {
            F4_LOCInfo *info = info_array + i;

            Scratch_Block scratch2(app, scratch);
            int padding = 25;
            int chrs = (int)info->name.size;
            int spaces = 0;
            if(chrs > padding)
            {
                chrs = padding;
                spaces = 0;
            }
            else
            {
                spaces = padding - chrs;
            }

            if(spaces < 0)
            {
                spaces = 0;
            }

            String_Const_u8 string = push_stringf(scratch2,
                                                  ">>> %.*s%.*s: %6i lines; %6i whitespace; %6i open braces; %6i significant\n",
                                                  chrs, info->name.str,
                                                  spaces, "                                            ",
                                                  (int)info->lines,
                                                  (int)info->whitespace_only_lines,
                                                  (int)info->open_brace_only_lines,
                                                  (int)(info->lines - (info->whitespace_only_lines+info->open_brace_only_lines)));
            b32 write_successful = buffer_replace_range(app, loc_buffer, Ii64(buffer_get_size(app, loc_buffer)), string);
            write_successful = write_successful;
        }
    }
}

CUSTOM_COMMAND(f4_remedy_open_cursor, "4coder_fleury_base_commands.cpp", 1697, Normal)
CUSTOM_DOC("Opens the active panel's file in an actively-running RemedyBG instance, and moves to the cursor's line position.")
{
    Scratch_Block scratch(app);
    View_ID view = get_active_view(app, Access_Read);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Read);
    String8 buffer_name = push_buffer_file_name(app, scratch, buffer);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    String8 hot_directory = push_hot_directory(app, scratch);
    Child_Process_ID child_id = create_child_process(app, hot_directory, push_stringf(scratch, "remedybg.exe open-file %.*s %i", (i32)(buffer_name).size, (char*)(buffer_name).str, (int)line));
    (void)child_id;
}

CUSTOM_COMMAND(f4_bump_to_column, "4coder_fleury_base_commands.cpp", 1711, Normal)
CUSTOM_DOC("Insert the required number of spaces to get to a specified column number.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);

    Query_Bar_Group group(app);
    u8 string_space[256];
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Column Number: "), (u64)(sizeof("Column Number: ") - 1));
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = sizeof(string_space);
    if(query_user_number(app, &bar))
    {
        i64 column_number = (i64)string_to_integer(bar.string, 10);
        i64 cursor = view_get_cursor_pos(app, view);
        i64 cursor_line = get_line_number_from_pos(app, buffer, cursor);
        i64 cursor_column = cursor - get_line_start_pos(app, buffer, cursor_line) + 1;
        i64 spaces_to_insert = column_number - cursor_column;
        History_Group group = history_group_begin(app, buffer);
        for(i64 i = 0; i < spaces_to_insert; i += 1)
        {
            buffer_replace_range(app, buffer, Ii64(cursor, cursor), {(u8*)(" "), sizeof(" ") - 1});
        }
        view_set_cursor(app, view, seek_pos(cursor+spaces_to_insert));
        view_set_mark(app, view, seek_pos(cursor+spaces_to_insert));
        history_group_end(group);
    }
}


CUSTOM_COMMAND(fleury_write_text_input, "4coder_fleury_base_commands.cpp", 1744, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_write_text_input.")
{ f4_write_text_input(app); }
CUSTOM_COMMAND(fleury_write_text_and_auto_indent, "4coder_fleury_base_commands.cpp", 1747, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_write_text_and_auto_indent.")
{f4_write_text_and_auto_indent(app);}
CUSTOM_COMMAND(fleury_write_zero_struct, "4coder_fleury_base_commands.cpp", 1750, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_write_zero_struct.")
{f4_write_zero_struct(app);}
CUSTOM_COMMAND(fleury_home, "4coder_fleury_base_commands.cpp", 1753, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_home.")
{f4_home(app);}
CUSTOM_COMMAND(fleury_toggle_battery_saver, "4coder_fleury_base_commands.cpp", 1756, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_toggle_battery_saver.")
{f4_toggle_battery_saver(app);}
CUSTOM_COMMAND(fleury_toggle_compilation_expand, "4coder_fleury_base_commands.cpp", 1759, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_toggle_compilation_expand.")
{f4_toggle_compilation_expand(app);}
CUSTOM_COMMAND(fleury_go_to_definition, "4coder_fleury_base_commands.cpp", 1762, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_go_to_definition.")
{f4_go_to_definition(app);}
CUSTOM_COMMAND(fleury_go_to_definition_same_panel, "4coder_fleury_base_commands.cpp", 1765, Normal)
CUSTOM_DOC("Deprecated name. Please update to f4_go_to_definition_same_panel.")
{f4_go_to_definition_same_panel(app);}
# 449 "4coder_fleury.cpp" 2



# 1 "4coder_fleury_casey.cpp" 1
Audio_Clip PowerWAV = {};
Audio_Clip HitWAV = {};
Audio_Control PowerWAVControl = {};

CUSTOM_COMMAND(casey_demo_audio, "4coder_fleury_casey.cpp", 5, Normal)
CUSTOM_DOC("He used to cut my grass... he was a very nice boy!")
{
    F4_RequireWAV(app, &PowerWAV, "sounds/hit.wav");
    PowerWAV.channel_volume[0] = 0.5f;
    PowerWAV.channel_volume[1] = 0.25f;
 if(!def_audio_is_playing(&PowerWAVControl))
 {
        def_audio_play_clip(PowerWAV, &PowerWAVControl);
 }
}

CUSTOM_COMMAND(casey_demo_audio_switch_panel, "4coder_fleury_casey.cpp", 17, Normal)
CUSTOM_DOC("The white zone is for loading and unloading only...")
{
    f32 Temp = PowerWAVControl.channel_volume[0];
 PowerWAVControl.channel_volume[0] = PowerWAVControl.channel_volume[1];
    PowerWAVControl.channel_volume[1] = Temp;
 change_active_panel(app);
}

CUSTOM_COMMAND(casey_demo_audio_one_shot, "4coder_fleury_casey.cpp", 26, Normal)
CUSTOM_DOC("... if you gotta load, or if you gotta unload, you go to the white zone...")
{
    F4_RequireWAV(app, &HitWAV, "sounds/hit.wav");
    HitWAV.channel_volume[0] = 0.5f;
    HitWAV.channel_volume[1] = 0.5f;
    def_audio_play_clip(HitWAV, 0);
}

CUSTOM_COMMAND(casey_seek_beginning_of_line_and_tab, "4coder_fleury_casey.cpp", 35, Normal)
CUSTOM_DOC("Goes to the beginning of the line and indents the line with default indenting.")
{
    seek_beginning_of_line(app);
    auto_indent_line_at_cursor(app);
}

CUSTOM_COMMAND(casey_clean_file_and_save, "4coder_fleury_casey.cpp", 42, Normal)
CUSTOM_DOC("Standardizes line endings and tabs, then saves the active buffer.")
{
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
 clean_all_lines_buffer(app, buffer, CleanAllLinesMode_RemoveBlankLines);
    rewrite_lines_to_lf(app, buffer);

    save(app);
}

CUSTOM_COMMAND(casey_switch_to_keybinding_0, "4coder_fleury_casey.cpp", 53, Normal)
CUSTOM_DOC("WENSLEYDALE.")
{
 switch_to_keybinding_0(app);
 global_hide_region_boundary = true;
}

CUSTOM_COMMAND(casey_switch_to_keybinding_1, "4coder_fleury_casey.cpp", 60, Normal)
CUSTOM_DOC("STILTON.")
{
 switch_to_keybinding_1(app);
 global_hide_region_boundary = false;
}

CUSTOM_COMMAND(casey_newline_and_indent, "4coder_fleury_casey.cpp", 67, Normal)
CUSTOM_DOC("Inserts a newline at the cursor position and indent the next line automatically.")
{




 View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    if (buffer_get_access_flags(app, buffer) & Access_Write)
 {
  write_text(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        auto_indent_line_at_cursor(app);
    }
    else
 {
        goto_jump_at_cursor(app);
    }
}

CUSTOM_COMMAND(casey_delete_to_end_of_line, "4coder_fleury_casey.cpp", 88, Normal)
CUSTOM_DOC("Deletes everything from the cursor to the end of the line.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    Range_i64 range = get_line_pos_range(app, buffer, line);
 if(pos == range.end)
 {
  range.end = pos + 1;
  range.start = pos;
 }
 else
 {
  range.start = pos + 1;
 }

    i32 size = (i32)buffer_get_size(app, buffer);
    range.end = (((range.end)<(size))?(range.end):(size));
    if (range_size(range) == 0 ||
        buffer_get_char(app, buffer, range.end - 1) != '\n'){
        range.start -= 1;
        range.first = (((0)>(range.first))?(0):(range.first));
    }
    buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}

CUSTOM_COMMAND(casey_find_matching_file, "4coder_fleury_casey.cpp", 116, Normal)
CUSTOM_DOC("If the current file is a *.cpp or *.h, attempts to open the corresponding *.h or *.cpp file in the same view.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Buffer_ID new_buffer = 0;
    if (get_cpp_matching_file(app, buffer, &new_buffer)){
        view_set_buffer(app, view, new_buffer, 0);
    }
}

CUSTOM_COMMAND(casey_go_to_code_peek, "4coder_fleury_casey.cpp", 127, Normal)
CUSTOM_DOC("Jumps to the most likely thing you'd want to see for the identifier you're on.")
{
    fleury_go_to_definition(app);
}

i32 casey_new_file(Application_Links *app, Buffer_ID buffer_id)
{
 Scratch_Block scratch(app);
 String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer_id);
    String_Const_u8 header_text = push_u8_stringf(scratch,
                                                  "/* ========================================================================\n"
                                                  "   %cFile: %.*s $\n"
                                                  "   %cDate: $\n"
                                                  "   %cRevision: $\n"
                                                  "   %cCreator: Casey Muratori $\n"
                                                  "   %cNotice: (C) Copyright by Molly Rocket, Inc., All Rights Reserved. $\n"
                                                  "   ======================================================================== */\n\n",
                                                  '$', (i32)(file_name).size, (char*)(file_name).str,
                                                  '$', '$', '$', '$');

    buffer_replace_range(app, buffer_id, Ii64(0, 0), header_text);

    return(0);
}
# 453 "4coder_fleury.cpp" 2
# 1 "4coder_fleury_hooks.cpp" 1


static void
F4_RenderBuffer(Application_Links *app, View_ID view_id, Face_ID face_id,
                Buffer_ID buffer, Text_Layout_ID text_layout_id,
                Rect_f32 rect, Frame_Info frame_info)
{
    Scratch_Block scratch(app);
    Profile_Scope_Block profile_block_9 ((app), SCu8((u8*)("[Fleury] Render Buffer"), (u64)(sizeof("[Fleury] Render Buffer") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "9" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "9" ":") - 1)));

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);
    Rect_f32 prev_clip = draw_set_clip(app, rect);


    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if(token_array.tokens != 0)
    {
        F4_SyntaxHighlight(app, text_layout_id, &token_array);


        b32 use_comment_keywords = def_get_config_b32(vars_save_string(SCu8((u8*)("use_comment_keywords"), (u64)(sizeof("use_comment_keywords") - 1))));
        if(use_comment_keywords)
        {
            Comment_Highlight_Pair pairs[] =
            {
                {{(u8*)("NOTE"), sizeof("NOTE") - 1}, finalize_color(defcolor_comment_pop, 0)},
                {{(u8*)("TODO"), sizeof("TODO") - 1}, finalize_color(defcolor_comment_pop, 1)},
                {def_get_config_string(scratch, vars_save_string(SCu8((u8*)("user_name"), (u64)(sizeof("user_name") - 1)))), finalize_color(fleury_color_comment_user_name, 0)},
            };
            draw_comment_highlights(app, buffer, text_layout_id,
                                    &token_array, pairs, ((sizeof(pairs))/(sizeof(*pairs))));
        }
    }
    else
    {
        Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
        paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
    }

    i64 cursor_pos = view_correct_cursor(app, view_id);
    view_correct_mark(app, view_id);


    b32 use_scope_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_scope_highlight"), (u64)(sizeof("use_scope_highlight") - 1))));
    if (use_scope_highlight){
        Color_Array colors = finalize_color_array(defcolor_back_cycle);
        draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }


    {
        Color_Array colors = finalize_color_array(fleury_color_brace_highlight);
        if(colors.count >= 1 && F4_ARGBIsValid(colors.vals[0]))
        {
            F4_Brace_RenderHighlight(app, buffer, text_layout_id, cursor_pos,
                                     colors.vals, colors.count);
        }
    }


    {
        b32 highlight_line_at_cursor = def_get_config_b32(vars_save_string(SCu8((u8*)("highlight_line_at_cursor"), (u64)(sizeof("highlight_line_at_cursor") - 1))));
        String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
        Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
        if(highlight_line_at_cursor && (is_active_view || buffer == compilation_buffer))
        {
            i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
            draw_line_highlight(app, text_layout_id, line_number,
                                fcolor_id(defcolor_highlight_cursor_line));
        }
    }


    {
        b32 use_error_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_error_highlight"), (u64)(sizeof("use_error_highlight") - 1))));
        b32 use_jump_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_jump_highlight"), (u64)(sizeof("use_jump_highlight") - 1))));
        if (use_error_highlight || use_jump_highlight){

            String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
            Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
            if (use_error_highlight){
                draw_jump_highlights(app, buffer, text_layout_id, compilation_buffer,
                                     fcolor_id(defcolor_highlight_junk));
            }


            if (use_jump_highlight){
                Buffer_ID jump_buffer = get_locked_jump_buffer(app);
                if (jump_buffer != compilation_buffer){
                    draw_jump_highlights(app, buffer, text_layout_id, jump_buffer,
                                         fcolor_id(defcolor_highlight_white));
                }
            }
        }
    }


    {
        String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
        Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
        F4_RenderErrorAnnotations(app, buffer, text_layout_id, compilation_buffer);
    }


    if (!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_cursor_token_occurance"), (u64)(sizeof("f4_disable_cursor_token_occurance") - 1)))))
    {
        Profile_Scope_Block profile_block_108 ((app), SCu8((u8*)("[Fleury] Token Occurance Highlight"), (u64)(sizeof("[Fleury] Token Occurance Highlight") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "108" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "108" ":") - 1)));


        Buffer_ID active_cursor_buffer = view_get_buffer(app, active_view, Access_Always);
        i64 active_cursor_pos = view_get_cursor_pos(app, active_view);
        Token_Array active_cursor_buffer_tokens = get_token_array_from_buffer(app, active_cursor_buffer);
        Token_Iterator_Array active_cursor_it = token_iterator_pos(0, &active_cursor_buffer_tokens, active_cursor_pos);
        Token *active_cursor_token = token_it_read(&active_cursor_it);

        String_Const_u8 active_cursor_string = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        if(active_cursor_token)
        {
            active_cursor_string = push_buffer_range(app, scratch, active_cursor_buffer, Ii64(active_cursor_token));


            Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
            i64 first_index = token_index_from_pos(&token_array, visible_range.first);
            Token_Iterator_Array it = token_iterator_index(0, &token_array, first_index);
            for (;;)
            {
                Token *token = token_it_read(&it);
                if(!token || token->pos >= visible_range.one_past_last)
                {
                    break;
                }

                if (token->kind == TokenBaseKind_Identifier)
                {
                    Range_i64 token_range = Ii64(token);
                    String_Const_u8 token_string = push_buffer_range(app, scratch, buffer, token_range);


                    if (range_contains(token_range, view_get_cursor_pos(app, view_id)))
                    {
                        F4_RenderRangeHighlight(app, view_id, text_layout_id,
                                                token_range, F4_RangeHighlightKind_Underline,
                                                fcolor_resolve(fcolor_id(fleury_color_token_highlight)));
                    }

                    else if(active_cursor_token->kind == TokenBaseKind_Identifier &&
                            string_match(token_string, active_cursor_string))
                    {
                        F4_RenderRangeHighlight(app, view_id, text_layout_id,
                                                token_range, F4_RangeHighlightKind_MinorUnderline,
                                                fcolor_resolve(fcolor_id(fleury_color_token_minor_highlight)));

                    }
                }

                if(!token_it_inc_non_whitespace(&it))
                {
                    break;
                }
            }
        }
    }

    else
    {
        Profile_Scope_Block profile_block_167 ((app), SCu8((u8*)("[Fleury] Token Highlight"), (u64)(sizeof("[Fleury] Token Highlight") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "167" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "167" ":") - 1)));

        Token_Iterator_Array it = token_iterator_pos(0, &token_array, cursor_pos);
        Token *token = token_it_read(&it);
        if(token && token->kind == TokenBaseKind_Identifier)
        {
            F4_RenderRangeHighlight(app, view_id, text_layout_id,
                                    Ii64(token->pos, token->pos + token->size),
                                    F4_RangeHighlightKind_Underline,
                                    fcolor_resolve(fcolor_id(fleury_color_token_highlight)));
        }
    }


    {
        F4_RenderFlashes(app, view_id, text_layout_id);
    }


    if(def_get_config_b32(vars_save_string(SCu8((u8*)("use_paren_helper"), (u64)(sizeof("use_paren_helper") - 1)))))
    {
        Color_Array colors = finalize_color_array(defcolor_text_cycle);
        draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }


    {
        F4_RenderDividerComments(app, buffer, view_id, text_layout_id);
    }


    if(is_active_view && fcoder_mode == FCoderMode_Original)
    {
        F4_HighlightCursorMarkRange(app, view_id);
    }


    Face_Metrics metrics = get_face_metrics(app, face_id);
    u64 cursor_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("cursor_roundness"), (u64)(sizeof("cursor_roundness") - 1))));
    f32 cursor_roundness = metrics.normal_advance*cursor_roundness_100*0.01f;
    f32 mark_thickness = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("mark_thickness"), (u64)(sizeof("mark_thickness") - 1))));


    switch (fcoder_mode)
    {
        case FCoderMode_Original:
        {
            F4_Cursor_RenderEmacsStyle(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness, frame_info);
        }break;

        case FCoderMode_NotepadLike:
        {
            F4_Cursor_RenderNotepadStyle(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness,
                                         mark_thickness, frame_info);
            break;
        }
    }


    {
        F4_Brace_RenderCloseBraceAnnotation(app, buffer, text_layout_id, cursor_pos);
    }


    {
        F4_Brace_RenderLines(app, buffer, view_id, text_layout_id, cursor_pos);
    }


    draw_text_layout_default(app, text_layout_id);


    {
        Buffer_ID calc_buffer_id = get_buffer_by_name(app, SCu8((u8*)("*calc*"), (u64)(sizeof("*calc*") - 1)), AccessFlag_Read);
        if(calc_buffer_id == buffer)
        {
            F4_CLC_RenderBuffer(app, buffer, view_id, text_layout_id, frame_info);
        }
    }


    {
        F4_CLC_RenderComments(app, buffer, view_id, text_layout_id, frame_info);
    }

    draw_set_clip(app, prev_clip);


    if(active_view == view_id)
    {

        {
            F4_PosContext_Render(app, view_id, buffer, text_layout_id, cursor_pos);
        }


        {
            Mouse_State mouse = get_mouse_state(app);

            Rect_f32 view_rect = view_get_screen_rect(app, view_id);

            Face_ID tooltip_face_id = global_small_code_face;
            Face_Metrics tooltip_face_metrics = get_face_metrics(app, tooltip_face_id);

            Rect_f32 tooltip_rect =
            {
                (f32)mouse.x + 16,
                (f32)mouse.y + 16,
                (f32)mouse.x + 16,
                (f32)mouse.y + 16 + tooltip_face_metrics.line_height + 8,
            };

            for(int i = 0; i < global_tooltip_count; ++i)
            {
                String_Const_u8 string = global_tooltips[i].string;
                tooltip_rect.x1 = tooltip_rect.x0;
                tooltip_rect.x1 += get_string_advance(app, tooltip_face_id, string) + 4;

                if(tooltip_rect.x1 > view_rect.x1)
                {
                    f32 difference = tooltip_rect.x1 - view_rect.x1;
                    tooltip_rect.x1 = (float)(int)(tooltip_rect.x1 - difference);
                    tooltip_rect.x0 = (float)(int)(tooltip_rect.x0 - difference);
                }

                F4_DrawTooltipRect(app, tooltip_rect);

                draw_string(app, tooltip_face_id, string,
                            V2f32(tooltip_rect.x0 + 4,
                                  tooltip_rect.y0 + 4),
                            global_tooltips[i].color);
            }
        }
    }


    if(is_active_view == 0)
    {
        Rect_f32 view_rect = view_get_screen_rect(app, view_id);
        ARGB_Color color = fcolor_resolve(fcolor_id(fleury_color_inactive_pane_overlay));
        if(F4_ARGBIsValid(color))
        {
            draw_rectangle(app, view_rect, 0.f, color);
        }
    }


    {
        if(!view_get_is_passive(app, view_id) &&
           !is_active_view)
        {
            F4_CodePeek_Render(app, view_id, face_id, buffer, frame_info);
        }
    }


    {
        F4_PowerMode_RenderBuffer(app, view_id, face_id, frame_info);
    }

}



static void
F4_DrawFileBar(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Rect_f32 bar)
{
    Scratch_Block scratch(app);

    draw_rectangle_fcolor(app, bar, 0.f, fcolor_id(defcolor_bar));

    FColor base_color = fcolor_id(defcolor_base);
    FColor pop2_color = fcolor_id(defcolor_pop2);

    i64 cursor_position = view_get_cursor_pos(app, view_id);
    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(cursor_position));

    Fancy_Line list = {};
    String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);
    push_fancy_string(scratch, &list, base_color, unique_name);
    push_fancy_stringf(scratch, &list, base_color, " - Row: %3.lld Col: %3.lld -", cursor.line, cursor.col);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    switch (*eol_setting){
        case LineEndingKind_Binary:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" bin"), (u64)(sizeof(" bin") - 1)));
        }break;

        case LineEndingKind_LF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" lf"), (u64)(sizeof(" lf") - 1)));
        }break;

        case LineEndingKind_CRLF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" crlf"), (u64)(sizeof(" crlf") - 1)));
        }break;
    }

    u8 space[3];
    {
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        String_u8 str = Su8(space, 0, 3);
        if (dirty != 0){
            string_append(&str, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
        }
        if ((((dirty)&(DirtyState_UnsavedChanges))!=0)){
            string_append(&str, SCu8((u8*)("*"), (u64)(sizeof("*") - 1)));
        }
        if ((((dirty)&(DirtyState_UnloadedChanges))!=0)){
            string_append(&str, SCu8((u8*)("!"), (u64)(sizeof("!") - 1)));
        }
        push_fancy_string(scratch, &list, pop2_color, str.string);
    }

    push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" Syntax Mode: "), (u64)(sizeof(" Syntax Mode: ") - 1)));
    push_fancy_string(scratch, &list, base_color, F4_SyntaxOptionString());

    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

    if(!def_get_config_b32(vars_save_string(SCu8((u8*)("f4_disable_progress_bar"), (u64)(sizeof("f4_disable_progress_bar") - 1)))))
    {
        f32 progress = (f32)cursor.line / (f32)buffer_get_line_count(app, buffer);
        Rect_f32 progress_bar_rect =
        {
            bar.x0 + (bar.x1 - bar.x0) * progress,
            bar.y0,
            bar.x1,
            bar.y1,
        };
        ARGB_Color progress_bar_color = fcolor_resolve(fcolor_id(fleury_color_file_progress_bar));
        if(F4_ARGBIsValid(progress_bar_color))
        {
            draw_rectangle(app, progress_bar_rect, 0, progress_bar_color);
        }
    }
}

static void
F4_Render(Application_Links *app, Frame_Info frame_info, View_ID view_id)
{
    F4_RecentFiles_RefreshView(app, view_id);

    Profile_Scope_Block profile_block_414 ((app), SCu8((u8*)("[Fleury] Render"), (u64)(sizeof("[Fleury] Render") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "414" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "414" ":") - 1)));
    Scratch_Block scratch(app);

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    f32 margin_size = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("f4_margin_size"), (u64)(sizeof("f4_margin_size") - 1))));
    Rect_f32 view_rect = view_get_screen_rect(app, view_id);
    Rect_f32 region = rect_inner(view_rect, margin_size);

    Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
    String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer);


    {
        ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_back));
        if(string_match(buffer_name, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1))))
        {
            color = color_blend(color, 0.5f, 0xff000000);
        }

        else if(is_active_view == 0)
        {
            ARGB_Color inactive_bg_color = fcolor_resolve(fcolor_id(fleury_color_inactive_pane_background));
            if(F4_ARGBIsValid(inactive_bg_color))
            {
                color = inactive_bg_color;
            }
        }
        draw_rectangle(app, region, 0.f, color);
        draw_margin(app, view_rect, region, color);
    }


    {
        ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_margin));
        if(def_get_config_b32(vars_save_string(SCu8((u8*)("f4_margin_use_mode_color"), (u64)(sizeof("f4_margin_use_mode_color") - 1)))) &&
           is_active_view)
        {
            color = F4_GetColor(app, ColorCtx_Cursor(power_mode.enabled ? ColorFlag_PowerMode : 0,
                                                     GlobalKeybindingMode));
        }
        draw_margin(app, view_rect, region, color);
    }

    Rect_f32 prev_clip = draw_set_clip(app, region);

    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;
    f32 digit_advance = face_metrics.decimal_digit_advance;


    b64 showing_file_bar = false;
    if(view_get_setting(app, view_id, ViewSetting_ShowFileBar, &showing_file_bar) && showing_file_bar)
    {
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        F4_DrawFileBar(app, view_id, buffer, face_id, pair.min);
        region = pair.max;
    }

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);
    Buffer_Point_Delta_Result delta = delta_apply(app, view_id, frame_info.animation_dt, scroll);

    if(!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position))))
    {
        block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
        view_set_buffer_scroll(app, view_id, scroll, SetBufferScroll_NoCursorChange);
    }

    if(delta.still_animating)
    {
        animate_in_n_milliseconds(app, 0);
    }


    {
        Query_Bar *space[32];
        Query_Bar_Ptr_Array query_bars = {};
        query_bars.ptrs = space;
        if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars))
        {
            for (i32 i = 0; i < query_bars.count; i += 1)
            {
                Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, 1);
                draw_query_bar(app, query_bars.ptrs[i], face_id, pair.min);
                region = pair.max;
            }
        }
    }


    if(show_fps_hud)
    {
        Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
        draw_fps_hud(app, frame_info, face_id, pair.max);
        region = pair.min;
        animate_in_n_milliseconds(app, 1000);
    }


    Rect_f32 line_number_rect = {};
    if(def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1)))))
    {
        Rect_f32_Pair pair = layout_line_number_margin(app, buffer, region, digit_advance);
        line_number_rect = pair.min;
        line_number_rect.x1 += 4;
        region = pair.max;
    }


    Buffer_Point buffer_point = scroll.position;
    if(is_active_view)
    {
        buffer_point.pixel_shift.y += F4_PowerMode_ScreenShake()*1.f;
    }
    Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);


    if(def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1)))))
    {
        draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
    }


    F4_RenderBuffer(app, view_id, face_id, buffer, text_layout_id, region, frame_info);






    text_layout_free(app, text_layout_id);
    draw_set_clip(app, prev_clip);
}



static void
F4_DoFullLex_ASYNC_Inner(Async_Context *actx, Buffer_ID buffer_id)
{
    Application_Links *app = actx->app;
    Profile_Scope_Block profile_block_556 ((app), SCu8((u8*)("[F4] Async Lex"), (u64)(sizeof("[F4] Async Lex") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "556" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "556" ":") - 1)));
    Scratch_Block scratch(app);

    String_Const_u8 contents = {};
    {
        Profile_Block profile_block_561 ((app), SCu8((u8*)("[F4] Async Lex Contents (before mutex)"), (u64)(sizeof("[F4] Async Lex Contents (before mutex)") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "561" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "561" ":") - 1)));
        acquire_global_frame_mutex(app);
        Profile_Block profile_block_563 ((app), SCu8((u8*)("[F4] Async Lex Contents (after mutex)"), (u64)(sizeof("[F4] Async Lex Contents (after mutex)") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "563" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "563" ":") - 1)));
        contents = push_whole_buffer(app, scratch, buffer_id);
        release_global_frame_mutex(app);
    }

    i32 limit_factor = 10000;

    Token_List list = {};
    b32 canceled = false;

    F4_Language *language = F4_LanguageFromBuffer(app, buffer_id);


    if(language == 0)
    {
        language = F4_LanguageFromString(SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1)));
    }

    if(language != 0)
    {
        void *lexing_state = ((u8*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(u8)*(language->lex_state_size), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "583" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "583" ":") - 1)))));
        language->LexInit(lexing_state, contents);
        for(;;)
        {
            Profile_Block profile_block_587 ((app), SCu8((u8*)("[F4] Async Lex Block"), (u64)(sizeof("[F4] Async Lex Block") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "587" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "587" ":") - 1)));
            if(language->LexFullInput(scratch, &list, lexing_state, limit_factor))
            {
                break;
            }
            if(async_check_canceled(actx))
            {
                canceled = true;
                break;
            }
        }
    }

    if(!canceled)
    {
        Profile_Block profile_block_602 ((app), SCu8((u8*)("[F4] Async Lex Save Results (before mutex)"), (u64)(sizeof("[F4] Async Lex Save Results (before mutex)") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "602" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "602" ":") - 1)));
        acquire_global_frame_mutex(app);
        Profile_Block profile_block_604 ((app), SCu8((u8*)("[F4] Async Lex Save Results (after mutex)"), (u64)(sizeof("[F4] Async Lex Save Results (after mutex)") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "604" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "604" ":") - 1)));
        Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
        if(scope != 0)
        {
            Base_Allocator *allocator = managed_scope_allocator(app, scope);
            Token_Array *tokens_ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
            base_free(allocator, tokens_ptr->tokens);
            Token_Array tokens = {};
            tokens.tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(list.total_count), (SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "612" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "612" ":") - 1)))).str);
            tokens.count = list.total_count;
            tokens.max = list.total_count;
            token_fill_memory_from_list(tokens.tokens, &list);
            block_copy((tokens_ptr), (&tokens), sizeof(*(tokens_ptr)));
        }
        buffer_mark_as_modified(buffer_id);
        release_global_frame_mutex(app);
    }
}

static void
F4_DoFullLex_ASYNC(Async_Context *actx, String_Const_u8 data)
{
    if(data.size == sizeof(Buffer_ID))
    {
        Buffer_ID buffer = *(Buffer_ID*)data.str;
        F4_DoFullLex_ASYNC_Inner(actx, buffer);
    }
}

static i32 F4_BeginBuffer(Application_Links *app, Buffer_ID buffer_id)
{
    Profile_Scope_Block profile_block_635 ((app), SCu8((u8*)("[Fleury] Begin Buffer"), (u64)(sizeof("[Fleury] Begin Buffer") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "635" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "635" ":") - 1)));

    Scratch_Block scratch(app);
    b32 treat_as_code = false;
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer_id);
    String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer_id);


    if(treat_as_code == false)
    {
        if(file_name.size > 0)
        {
            String_Const_u8 treat_as_code_string = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
            String_Const_u8_Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code_string);
            String_Const_u8 ext = string_file_extension(file_name);
            for(i32 i = 0; i < extensions.count; ++i)
            {
                if(string_match(ext, extensions.strings[i]))
                {
                    treat_as_code = true;
                    break;
                }
            }
        }
    }


    if(treat_as_code == false)
    {
        if(buffer_name.size > 0)
        {
            if(string_match(buffer_name, SCu8((u8*)("*calc*"), (u64)(sizeof("*calc*") - 1))))
            {
                treat_as_code = true;
            }
            else if(string_match(buffer_name, SCu8((u8*)("*peek*"), (u64)(sizeof("*peek*") - 1))))
            {
                treat_as_code = true;
            }
        }
    }


    if(treat_as_code == false)
    {
        F4_Language *language = F4_LanguageFromBuffer(app, buffer_id);
        if(language)
        {
            treat_as_code = true;
        }
    }

    String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
    String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

    Command_Map_ID map_id = (treat_as_code) ? (code_map_id) : (file_map_id);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
    *map_id_ptr = map_id;

    Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer_id);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
    *eol_setting = setting;


    b32 wrap_lines = true;
    b32 use_lexer = false;
    if(treat_as_code)
    {
        wrap_lines = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_code_wrapping"), (u64)(sizeof("enable_code_wrapping") - 1))));
        use_lexer = true;
    }

    if(string_match(buffer_name, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1))))
    {
        wrap_lines = false;
    }

    if (use_lexer)
    {
        Profile_Block profile_block_715 ((app), SCu8((u8*)("begin buffer kick off lexer"), (u64)(sizeof("begin buffer kick off lexer") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "715" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "715" ":") - 1)));
        Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
        *lex_task_ptr = async_task_no_dep(&global_async_system, F4_DoFullLex_ASYNC, make_data((&buffer_id), sizeof(*(&buffer_id))));
    }

    {
        b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
        *wrap_lines_ptr = wrap_lines;
    }

    if (use_lexer)
    {
        buffer_set_layout(app, buffer_id, layout_virt_indent_index_generic);
    }
    else
    {
        if (treat_as_code)
        {
            buffer_set_layout(app, buffer_id, layout_virt_indent_literal_generic);
        }
        else{
            buffer_set_layout(app, buffer_id, layout_generic);
        }
    }



    return(0);
}




static Layout_Item_List
F4_LayoutInner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Virtual_Indent virt_indent)
{
    Layout_Item_List list = get_empty_item_list(range);

    Scratch_Block scratch(app);
    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    f32 tab_width = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_tab_width"), (u64)(sizeof("default_tab_width") - 1))));
    tab_width = (((1)>(tab_width))?(1):(tab_width));
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, tab_width, width);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
    }
    else{
        b32 skipping_leading_whitespace = (virt_indent == LayoutVirtualIndent_On);
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        for (;ptr < end_ptr;){
            Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));

            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (consume.codepoint){
                case '\t':
                case ' ':
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance(&pos_vars, face, consume.codepoint);
                    if (!skipping_leading_whitespace){
                        lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, consume.codepoint);
                    }
                    else{
                        lr_tb_advance_x_without_item(&pos_vars, advance);
                    }
                }break;

                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                }break;

                case max_u32:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
                }break;
            }

            ptr += consume.inc;
        }

        if (newline_layout_consume_finish(&newline_vars)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
F4_Layout(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width)
{
    return(F4_LayoutInner(app, arena, buffer, range, face, width, LayoutVirtualIndent_Off));
}



static void
F4_Tick(Application_Links *app, Frame_Info frame_info)
{
    linalloc_clear(&global_frame_arena);
    global_tooltip_count = 0;

    F4_TickColors(app, frame_info);
    F4_Index_Tick(app);
    F4_CLC_Tick(frame_info);
    F4_PowerMode_Tick(app, frame_info);
    F4_UpdateFlashes(app, frame_info);


    default_tick(app, frame_info);
}



static void
F4_WholeScreenRender(Application_Links *app, Frame_Info frame_info)
{
    F4_PowerMode_RenderWholeScreen(app, frame_info);
}



static i32 F4_BufferEditRange(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range)
{

    Profile_Scope_Block profile_block_865 ((app), SCu8((u8*)("[F4] Buffer Edit Range"), (u64)(sizeof("[F4] Buffer Edit Range") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "865" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "865" ":") - 1)));

    Range_i64 old_range = Ii64(old_cursor_range.min.pos, old_cursor_range.max.pos);

    buffer_shift_fade_ranges(buffer_id, old_range.max, (new_range.max - old_range.max));

    {
        code_index_lock();
        Code_Index_File *file = code_index_get_file(buffer_id);
        if (file != 0){
            code_index_shift(file, old_range, range_size(new_range));
        }
        code_index_unlock();
    }

    i64 insert_size = range_size(new_range);
    i64 text_shift = replace_range_shift(old_range, insert_size);

    Scratch_Block scratch(app);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));

    Base_Allocator *allocator = managed_scope_allocator(app, scope);
    b32 do_full_relex = false;

    if (async_task_is_running_or_pending(&global_async_system, *lex_task_ptr)){
        async_task_cancel(app, &global_async_system, *lex_task_ptr);
        buffer_unmark_as_modified(buffer_id);
        do_full_relex = true;
        *lex_task_ptr = 0;
    }

    Token_Array *ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (ptr != 0 && ptr->tokens != 0){
        Profile_Block profile_attempt_resync ((app), SCu8((u8*)("attempt resync"), (u64)(sizeof("attempt resync") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "900" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "900" ":") - 1)));

        i64 token_index_first = token_relex_first(ptr, old_range.first, 1);
        i64 token_index_resync_guess =
            token_relex_resync(ptr, old_range.one_past_last, 16);

        if (token_index_resync_guess - token_index_first >= 4000){
            do_full_relex = true;
        }
        else{
            Token *token_first = ptr->tokens + token_index_first;
            Token *token_resync = ptr->tokens + token_index_resync_guess;

            Range_i64 relex_range = Ii64(token_first->pos, token_resync->pos + token_resync->size + text_shift);
            String_Const_u8 partial_text = push_buffer_range(app, scratch, buffer_id, relex_range);


            F4_Language *language = F4_LanguageFromBuffer(app, buffer_id);

            if(language == 0)
            {
                language = F4_LanguageFromString(SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1)));
            }
            Token_List relex_list = F4_Language_LexFullInput_NoBreaks(app, language, scratch, partial_text);


            if (relex_range.one_past_last < buffer_get_size(app, buffer_id)){
                token_drop_eof(&relex_list);
            }

            Token_Relex relex = token_relex(relex_list, relex_range.first - text_shift, ptr->tokens, token_index_first, token_index_resync_guess);

            ((profile_attempt_resync).close_now());

            if (!relex.successful_resync){
                do_full_relex = true;
            }
            else{
                Profile_Block profile_block_938 ((app), SCu8((u8*)("apply resync"), (u64)(sizeof("apply resync") - 1)), SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "938" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "938" ":") - 1)));

                i64 token_index_resync = relex.first_resync_index;

                Range_i64 head = Ii64(0, token_index_first);
                Range_i64 replaced = Ii64(token_index_first, token_index_resync);
                Range_i64 tail = Ii64(token_index_resync, ptr->count);
                i64 resynced_count = (token_index_resync_guess + 1) - token_index_resync;
                i64 relexed_count = relex_list.total_count - resynced_count;
                i64 tail_shift = relexed_count - (token_index_resync - token_index_first);

                i64 new_tokens_count = ptr->count + tail_shift;
                Token *new_tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(new_tokens_count), (SCu8((u8*)("4coder_fleury_hooks.cpp" ":" "950" ":"), (u64)(sizeof("4coder_fleury_hooks.cpp" ":" "950" ":") - 1)))).str);

                Token *old_tokens = ptr->tokens;
                block_copy_array_shift__inner((new_tokens),(old_tokens),sizeof(*(new_tokens)),(head),(0));
                token_fill_memory_from_list(new_tokens + replaced.first, &relex_list, relexed_count);
                for (i64 i = 0, index = replaced.first; i < relexed_count; i += 1, index += 1){
                    new_tokens[index].pos += relex_range.first;
                }
                for (i64 i = tail.first; i < tail.one_past_last; i += 1){
                    old_tokens[i].pos += text_shift;
                }
                block_copy_array_shift__inner((new_tokens),(ptr->tokens),sizeof(*(new_tokens)),(tail),(tail_shift));

                base_free(allocator, ptr->tokens);

                ptr->tokens = new_tokens;
                ptr->count = new_tokens_count;
                ptr->max = new_tokens_count;

                buffer_mark_as_modified(buffer_id);
            }
        }
    }

    if (do_full_relex){
        *lex_task_ptr = async_task_no_dep(&global_async_system, F4_DoFullLex_ASYNC,
                                          make_data((&buffer_id), sizeof(*(&buffer_id))));
    }


    return(0);
}
# 454 "4coder_fleury.cpp" 2


# 1 "4coder_fleury_plots_demo.cpp" 1
# 55 "4coder_fleury_plots_demo.cpp"
static float global_data[] =
{
    -9.108416130192959f, 14.98944384489895f, -10.534840051209034f, -3.614096568530723f,
    15.591337621094421f, -7.739171721170452f, -0.9026170782031733f, -13.149768977154512f,
    -17.219965300059062f, -2.6118783851474427f, 10.222099876380499f, 5.6231067088333635f,
    -5.387046221931645f, -9.347501587691713f, -16.628577856291958f, -3.549878630159417f,
    7.275919813653472f, 13.259019015296275f, -13.719547507312075f, 4.9481447540162184f,
    -0.8746865542576021f, -12.408190318285113f, -9.738643065846126f, -3.8368401053307197f,
    8.324992096614633f, 5.827221620008752f, 2.44537318282724f, 1.7618686011139677f,
    3.2475669947638597f, -1.3107566185213457f, 1.4139056845989626f, 22.335212406970864f,
    -16.628373002086192f, -2.3044147435667854f, -4.98398789678496f, 16.81181581297103f,
    13.820929426683648f, 8.273166954381164f, 4.205658111516642f, 1.3144068522342678f,
    -14.02976653200713f, -10.189462520322799f, -14.996118226598492f, -7.696043181997645f,
    -7.965758359068635f, -25.730179878849828f, 5.989522977751358f, 7.679759952052088f,
    7.137384031660718f, -9.896952786350589f, 2.6808646075560523f, 4.063113446418918f,
    -0.9051192417953401f, 6.667923468460404f, -1.186111757007614f, -1.4881950451626904f,
    4.233309258793588f, 9.784512402515142f, -1.5996194143052291f, -5.95208204626368f,
    6.527238517048863f, -5.96880713775255f, -9.180913523391514f, -3.0983475622391317f,
    -6.380172457884448f, -15.28864581444195f, 3.015771954358115f, -1.1151943462001357f,
    6.076108007434029f, -0.34535881326984036f, -9.886973961522399f, -4.737186858070488f,
    -9.5679105878576f, -12.228251499425696f, 7.250294016267537f, 4.148240878691285f,
    3.874521719638633f, 7.867739374649146f, -1.5275932972524895f, -6.608302297993162f,
    -8.803926488219307f, -1.9995038661551334f, -14.434894611647584f, -0.41132182908862497f,
    -4.349963461481015f, 3.086773296793125f, -7.220092288505216f, 9.370058826931889f,
    -2.995274172084772f, 7.996953684827249f, 8.809179230083636f, -5.218569709558633f,
    -4.590175669522937f, -5.172826845017181f, 0.49860784347011355f, 11.541334216468629f,
    -13.590303633214846f, -7.487766450284603f, -8.242079436281818f, 14.218536525979879f,
};

static float global_data_2[] =
{
    7.577748010344408f, 6.437282062034829f, -11.994330647892166f, 6.343100963328565f,
    -11.035257049206562f, -12.325201833152803f, 10.487078553467546f, -0.302281251571577f,
    6.37167161768581f, -3.029016443166927f, -2.449309813897796f, -1.710311611294908f,
    -8.849582001069985f, -5.096562336080957f, 4.08023422336442f, 13.09503213022921f,
    -4.42215698653707f, 1.4903196541032562f, 18.513375338661536f, 19.836444595990685f,
    -15.657274605334965f, 8.744172984302082f, -0.5128163692963429f, 8.652981818810666f,
    -4.501272431981506f, -5.338077342377595f, -4.516280672130289f, -5.26906827022084f,
    10.368107801542497f, 1.715483332057541f, 0.17745412681264855f, -3.907651876104541f,
    1.1152830110861718f, 8.533965328202594f, -9.569073355235334f, 11.335492351759154f,
    -8.834196801339107f, -7.388475519610194f, -0.9564301924816496f, -2.6200647013161853f,
    -3.4369245883887727f, 7.402555474674301f, 6.488608631449056f, 10.643192111382538f,
    -3.4095312717695365f, 4.244522664423113f, 3.1929321370647608f, 6.7003494689359915f,
    -1.6827069864056388f, 15.962243506800185f, 14.141247706537053f, 2.68132756874319f,
    -2.664309213424854f, 4.574984149324338f, -3.552829528232453f, -7.33980377699842f,
    4.599313341798405f, 3.9387184579833914f, 1.7303574550519154f, -9.013739849292799f,
    -10.096670009002409f, -5.376865969447776f, -8.035341457672533f, 2.827889497039652f,
    -0.9361242397823712f, -0.29467042436082236f, 1.5835137362599832f, -12.921338212205779f,
    -6.017681994641382f, 5.031487952492922f, 7.3365545974315625f, -2.8019359909922477f,
    -4.9170810446626065f, 3.5395114545808015f, 7.894893515517801f, 5.2162370199036365f,
    17.384622111747106f, -5.175019028227791f, 11.10907947411686f, 2.1177241750918325f,
    6.196644993021573f, 3.8114717688791018f, -4.052618724556429f, -2.8131388236006516f,
    3.4225121808116827f, 1.4468017854626773f, 4.936674843542018f, 12.347391841659707f,
    1.481019365327373f, -1.614588595075823f, -16.127418290574937f, 5.8754491693888f,
    5.414944259375581f, -3.9278525762988985f, 1.7713920365071134f, -5.566835799537236f,
    -2.9777849406374193f, 10.340166105177929f, -20.055841888872923f, -8.668248836552227f,
};

static float global_data_3[] =
{
    -8.8146732061949f, -11.859974461710019f, 0.6988238301382752f, 3.8493106728264226f,
    0.9975055447929071f, 2.1263183257518694f, -7.162590910370086f, -4.411404459087052f,
    12.506292741382445f, 6.7696321575984655f, 28.188196774552814f, 9.242340838166736f,
    6.690844009035476f, -12.692668952411303f, 0.1585751887962988f, 16.798063604260854f,
    -15.835398910698641f, 11.929906256712698f, -13.791788282920873f, -7.399384431165447f,
    -1.7316895840446684f, -5.765536364805584f, 0.3037440122496132f, 12.353298081681245f,
    3.381805408397766f, -10.559683278529675f, -8.421745533109155f, -5.799831766680602f,
    -5.4686307234067595f, 0.7753453426415153f, 4.779163543238979f, -7.687415465484914f,
    7.033912303434668f, -5.928271055351296f, -0.19482006115374734f, -16.09737642085842f,
    -8.02191675136603f, 5.408089412341942f, -4.408067132939348f, -5.067414164776771f,
    -4.639986755573686f, -1.3527927911711746f, 7.7525157199153565f, 1.9825121115749949f,
    -0.310969415743857f, -8.79990490996496f, 10.395427187174208f, -7.56478866186992f,
    -3.4315095975926546f, 5.5792985421522046f, -1.6018537884804516f, -18.15718558376568f,
    -9.11806103804825f, 10.945594674460144f, -0.15518187340689968f, 7.215336736037743f,
    9.10913684664322f, -1.2954014201805186f, -3.7655879556053677f, 25.513108679233362f,
    -8.899732575136678f, -8.837793636709254f, 1.4760795169766001f, -4.421912732322799f,
    9.716152080712433f, 2.281876709224348f, -0.29002192867192444f, -12.349466727748691f,
    2.7105026427207326f, -25.042540664548593f, -11.547268733662365f, -8.488266338126234f,
    -5.41217003524133f, 5.053633488587236f, 0.5216637588634313f, -10.918568429065441f,
    -12.718972500410013f, -15.709205357245652f, 6.031754862712157f, 25.62559025419464f,
    4.499488953458418f, 10.114260835136509f, -11.90982864944095f, 8.444006664292425f,
    -2.3658492626073433f, -4.194373837981419f, 14.649583361598292f, -14.041758521108942f,
    -2.2244037251609514f, 10.175103631316116f, -15.747415462670524f, -9.735420666763277f,
    -4.152295098019796f, 11.758217862826264f, -3.8244156666336853f, -1.9656147222257787f,
    13.70739704540151f, 5.396334912138413f, 4.232652499321735f, -19.10558208768004f,
};
# 457 "4coder_fleury.cpp" 2






CUSTOM_ID(colors, defcolor_function);
CUSTOM_ID(colors, defcolor_type);
CUSTOM_ID(colors, defcolor_primitive);
CUSTOM_ID(colors, defcolor_macro);
CUSTOM_ID(colors, defcolor_control);
CUSTOM_ID(colors, defcolor_struct);
CUSTOM_ID(colors, defcolor_non_text);

# 1 "4coder_vimrc.h" 1





enum BYP_Vim_Request{
 BYP_REQUEST_Title,
 BYP_REQUEST_Comment,
 BYP_REQUEST_UnComment,

 BYP_REQUEST_COUNT
};

enum BYP_Vim_Objects{
 BYP_OBJECT_param0,
 BYP_OBJECT_param1,
 BYP_OBJECT_camel0,
 BYP_OBJECT_camel1,

 BYP_OBJECT_COUNT
};
# 472 "4coder_fleury.cpp" 2
# 1 "4coder_vim/4coder_vim_include.h" 1
# 14 "4coder_vim/4coder_vim_include.h"
CUSTOM_ID(colors, defcolor_vim_filebar_pop);
CUSTOM_ID(colors, defcolor_vim_chord_text);
CUSTOM_ID(colors, defcolor_vim_chord_unresolved);
CUSTOM_ID(colors, defcolor_vim_chord_error);
# 75 "4coder_vim/4coder_vim_include.h"
# 1 "4coder_vim/4coder_vim_keycode_lut.h" 1

static char* keycode_lut[2*KeyCode_COUNT];

static void init_keycode_lut(){
    for(i32 i=0; i<2*KeyCode_COUNT; i++){
        keycode_lut[i] = "";
    }
    i32 shift = KeyCode_COUNT;
    char *lowercase_alpha = "a\0b\0c\0d\0e\0f\0g\0h\0i\0j\0k\0l\0m\0n\0o\0p\0q\0r\0s\0t\0u\0v\0w\0x\0y\0z";
    for(i32 i='a'; i<='z'; i++){
        i32 index = i-'a';
        keycode_lut[KeyCode_A+index+shift] = key_code_name[KeyCode_A+index];
        keycode_lut[KeyCode_A+index] = lowercase_alpha + 2*index;
    }
    char *shift_digit = ")\0!\0@\0#\0$\0%\0^\0&\0*\0(";
    for(i32 i=0; i<=9; i++){
        keycode_lut[KeyCode_0+i] = key_code_name[KeyCode_0+i];
        keycode_lut[KeyCode_0+i+shift] = shift_digit + 2*i;;
    }
    char *function_keys = "F1\0F2\0F3\0F4\0F5\0F6\0F7\0F8\0F9\0F10\0F11\0F12";
    for(i32 i=0; i<12; i++){
        keycode_lut[KeyCode_F1+i] = keycode_lut[KeyCode_F1+i+shift] = function_keys + (3*i + (i>9)*(i-9));
    }

    keycode_lut[KeyCode_Space] = keycode_lut[KeyCode_Space+shift] = "Sp";
    keycode_lut[KeyCode_Tab] = keycode_lut[KeyCode_BackwardSlash+shift] = "Tab";
    keycode_lut[KeyCode_Escape] = keycode_lut[KeyCode_Escape+shift] = "ESC";
    keycode_lut[KeyCode_Pause] = keycode_lut[KeyCode_Pause+shift] = key_code_name[KeyCode_Pause];
    keycode_lut[KeyCode_Up] = keycode_lut[KeyCode_Up+shift] = key_code_name[KeyCode_Up];
    keycode_lut[KeyCode_Down] = keycode_lut[KeyCode_Down+shift] = key_code_name[KeyCode_Down];
    keycode_lut[KeyCode_Left] = keycode_lut[KeyCode_Left+shift] = key_code_name[KeyCode_Left];
    keycode_lut[KeyCode_Right] = keycode_lut[KeyCode_Right+shift] = key_code_name[KeyCode_Right];
    keycode_lut[KeyCode_Backspace] = keycode_lut[KeyCode_Backspace+shift] = "BS";
    keycode_lut[KeyCode_Return] = keycode_lut[KeyCode_Escape+shift] = "CR";
    keycode_lut[KeyCode_Delete] = keycode_lut[KeyCode_Delete+shift] = "Del";
    keycode_lut[KeyCode_Insert] = keycode_lut[KeyCode_Insert+shift] = "Ins";
    keycode_lut[KeyCode_Home] = keycode_lut[KeyCode_Home+shift] = "Home";
    keycode_lut[KeyCode_End] = keycode_lut[KeyCode_End+shift] = "End";
    keycode_lut[KeyCode_PageUp] = keycode_lut[KeyCode_PageUp+shift] = "PageUp";
    keycode_lut[KeyCode_PageDown] = keycode_lut[KeyCode_PageDown+shift] = "PageDown";
    keycode_lut[KeyCode_CapsLock] = keycode_lut[KeyCode_CapsLock+shift] = "Caps";
    keycode_lut[KeyCode_NumLock] = keycode_lut[KeyCode_NumLock+shift] = "NumLock";

    keycode_lut[KeyCode_Tick] = "`"; keycode_lut[KeyCode_Tick+shift] = "~";
    keycode_lut[KeyCode_Minus] = "-"; keycode_lut[KeyCode_Minus+shift] = "_";
    keycode_lut[KeyCode_Minus] = "-"; keycode_lut[KeyCode_Minus+shift] = "_";
    keycode_lut[KeyCode_Equal] = "="; keycode_lut[KeyCode_Equal+shift] = "+";
    keycode_lut[KeyCode_LeftBracket] = "["; keycode_lut[KeyCode_LeftBracket+shift] = "{";
    keycode_lut[KeyCode_RightBracket] = "]"; keycode_lut[KeyCode_RightBracket+shift] = "}";
    keycode_lut[KeyCode_Semicolon] = ";"; keycode_lut[KeyCode_Semicolon+shift] = ":";
    keycode_lut[KeyCode_Quote] = "'"; keycode_lut[KeyCode_Quote+shift] = "\"";
    keycode_lut[KeyCode_Comma] = ","; keycode_lut[KeyCode_Comma+shift] = "<";
    keycode_lut[KeyCode_Period] = "."; keycode_lut[KeyCode_Period+shift] = ">";
    keycode_lut[KeyCode_ForwardSlash] = "/"; keycode_lut[KeyCode_ForwardSlash+shift] = "?";
    keycode_lut[KeyCode_BackwardSlash] = "\\"; keycode_lut[KeyCode_BackwardSlash+shift] = "|";
}
# 76 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_base_types.h" 1
# 10 "4coder_vim/4coder_vim_base_types.h"
typedef void Vim_Apply_Request(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range);



typedef Range_i64 Vim_Text_Object_Func(Application_Links *app, Buffer_ID buffer, i64 cursor_pos);




struct Vim_Text_Object{
 u8 character;
 Vim_Text_Object_Func *func;
};


enum Vim_Mode{
 VIM_Normal,
 VIM_Insert,
 VIM_Visual,
 VIM_MODE_COUNT,

 VIM_Visual_Insert,
 VIM_Replace,
};

enum Vim_Sub_Mode{
 SUB_None,
 SUB_G,
 SUB_Z,
 SUB_Leader,

 VIM_SUBMODE_COUNT,
};

typedef u32 Vim_Request_Type;
enum{
 REQUEST_None,
 REQUEST_Yank,
 REQUEST_Delete,
 REQUEST_Change,
 REQUEST_Upper, REQUEST_Lower,
 REQUEST_ToggleCase,
 REQUEST_Replace,
 REQUEST_Indent, REQUEST_Outdent,
 REQUEST_AutoIndent,
 REQUEST_Fold,
 VIM_REQUEST_COUNT
};

enum Vim_Default_Text_Objects{
 TEXT_OBJECT_word,
 TEXT_OBJECT_Word,
 TEXT_OBJECT_para,

 VIM_TEXT_OBJECT_COUNT
};

enum Vim_Edit_Type{
 EDIT_CharWise,
 EDIT_LineWise,
 EDIT_Block,
};

enum Vim_Clusivity{
 VIM_Inclusive,
 VIM_Exclusive,
};

typedef u32 Vim_Register_Flags;
enum{
 REGISTER_ReadOnly = bit_1,
 REGISTER_Append = bit_2,
 REGISTER_Set = bit_3,
 REGISTER_Updated = bit_4,
};

struct Vim_Register{
 Vim_Edit_Type edit_type;
 String_u8 data;
 Vim_Register_Flags flags;
};

struct Vim_Seek_Params{
 u8 character;
 Vim_Clusivity clusivity;
 Scan_Direction direction;
};

struct Vim_Params{
 i32 number;
 i32 count;
 Vim_Request_Type request;
 Vim_Edit_Type edit_type;
 Vim_Clusivity clusivity;
 Vim_Seek_Params seek;
 Vim_Register *selected_reg;
 u8 consume_char;
 b8 do_insert;
 Custom_Command_Function *command;
};

struct Vim_State{
 Vim_Mode mode;
 Vim_Sub_Mode sub_mode;

 Arena arena;
 Heap heap;
 Base_Allocator alloc;

 b8 chord_resolved;
 u8 macro_char;
 u8 prev_macro;

 Buffer_Cursor insert_cursor;
 History_Record_Index insert_index;

 i32 number;
 Vim_Params params;
 Vim_Params prev_params;
 Custom_Command_Function *active_command;
};

union Vim_Registers{
 struct{
  Vim_Register named[26];
  Vim_Register unnamed;
  Vim_Register system;
  Vim_Register expression;
  Vim_Register search;
  union{
   Vim_Register digit[10];
   struct{
    Vim_Register yank;
    Vim_Register cycle[9];
   };
  };
  Vim_Register small_delete;
  Vim_Register insert;
  Vim_Register command;
  Vim_Register file;
 };
 Vim_Register r[44];
};

struct Vim_Prev_Visual{
 i64 cursor_pos, mark_pos;
 Vim_Edit_Type edit_type;
};

struct Vim_Global_Mark{
 Buffer_Identifier buffer_id;
 i64 pos;
};

struct Vim_Jump_List{
 Point_Stack_Slot markers[100 + 1];
 i32 top, bot, index;
};


static const u32 KeyMod_Ctl = bit_32;
static const u32 KeyMod_Sft = bit_31;
static const u32 KeyMod_Alt = bit_30;
static const u32 KeyMod_Cmd = bit_29;
static const u32 KeyMod_Mnu = bit_28;
# 77 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim.h" 1

static Vim_State vim_state;
static Table_u64_u64 vim_maps[VIM_MODE_COUNT*VIM_SUBMODE_COUNT];
static Vim_Registers vim_registers;

static Range_i64 vim_macros[26 + 26];

static Vim_Apply_Request* vim_request_vtable[VIM_REQUEST_COUNT + BYP_REQUEST_COUNT];
static Vim_Text_Object vim_text_object_vtable[VIM_TEXT_OBJECT_COUNT + BYP_OBJECT_COUNT];

static Vim_Global_Mark vim_global_marks[26];

static u8 vim_bot_buffer[256];
static String_u8 vim_bot_text = Su8(vim_bot_buffer, 0, ((sizeof(vim_bot_buffer))/(sizeof(*vim_bot_buffer))));
static bool vim_is_querying_user_key;
static bool vim_is_selecting_register;

static u8 vim_keystroke_buffer[64];
static u64 vim_pre_keystroke_size;
static String_u8 vim_keystroke_text = Su8(vim_keystroke_buffer, 0, ((sizeof(vim_keystroke_buffer))/(sizeof(*vim_keystroke_buffer))));


static History_Group vim_history_group;
static b32 vim_visual_insert_after;
static u32 vim_visual_insert_flags;

static b32 vim_do_full_line = false;
static b32 vim_relative_numbers = true;
static b32 vim_show_block_helper = true;


static b32 vim_use_bottom_cursor;
static u64 vim_cursor_blink;
static Vec2_f32 vim_nxt_cursor_pos;
static Vec2_f32 vim_cur_cursor_pos;

static View_ID vim_lister_view_id;

static f32 vim_nxt_filebar_offset;
static f32 vim_cur_filebar_offset;
static Rect_f32 vim_get_bottom_rect(Application_Links *app){
 Rect_f32 result = global_get_screen_rectangle(app);
 result.y1 -= 2.f*get_face_metrics(app, get_face_id(app, 0)).line_height;
 result.y0 = result.y1 - vim_cur_filebar_offset;
 return result;
}


struct Vim_Buffer_Peek_Entry{
 Buffer_Identifier buffer_id;
 f32 cur_ratio, nxt_ratio;
};

static b32 vim_show_buffer_peek;
static i32 vim_buffer_peek_index;


static Vim_Buffer_Peek_Entry vim_default_peek_list[] = {
 { buffer_identifier(SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1))), 1.f, 1.f },

 { buffer_identifier(SCu8((u8*)("*registers*"), (u64)(sizeof("*registers*") - 1))), 1.f, 1.f },

 { buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1))), 1.f, 1.f },
};

static Vim_Buffer_Peek_Entry vim_buffer_peek_list[((sizeof(vim_default_peek_list))/(sizeof(*vim_default_peek_list))) + 2];


CUSTOM_ID(attachment, vim_buffer_prev_visual);
CUSTOM_ID(attachment, vim_buffer_marks);
CUSTOM_ID(attachment, vim_view_jumps);

static void vim_reset_bottom_text(){ vim_bot_text.size=0; }

static void vim_set_bottom_text(i32 size, char *str){
 block_copy(vim_bot_buffer, str, size);
 vim_bot_text.size = size;
}
static void vim_set_bottom_text(String_Const_u8 msg){ vim_set_bottom_text((i32)((msg)).size, (char*)((msg)).str); }

static i32 vim_consume_number(){
 i32 result = (((1)>(vim_state.number))?(1):(vim_state.number))*(((1)>(vim_state.params.count))?(1):(vim_state.params.count));
 vim_state.params.number = vim_state.number;
 vim_state.number = 0;
 return result;
}

static void vim_default_register(){
 vim_state.params.selected_reg = &vim_registers.unnamed;
}

static void vim_reset_state(){
 vim_state.mode = VIM_Normal;
 vim_state.sub_mode = SUB_None;
 vim_state.number = 0;
 vim_keystroke_text.size = 0;
 Vim_Seek_Params seek = vim_state.params.seek;
 vim_state.params = {};
 vim_state.params.seek = seek;
 vim_default_register();
}


static b32
vim_realloc_string(String_u8 *src, u64 size){
 String_Const_u8 new_data = base_allocate__inner((&vim_state.alloc), (((((u64(128))>(u64(1.5*(size))))?(u64(128)):(u64(1.5*(size)))))), SCu8((u8*)("4coder_vim/4coder_vim.h" ":" "106" ":"), (u64)(sizeof("4coder_vim/4coder_vim.h" ":" "106" ":") - 1)));
 if(new_data.size == 0){ return false; }
 block_copy(new_data.str, src->str, src->size);
 base_free(&vim_state.alloc, src->str);
 src->str = new_data.str;
 src->cap = new_data.size;
 return true;
}

static b32
vim_register_copy(Vim_Register *dst, String_Const_u8 src){
 b32 valid = true;
 if(src.size >= dst->data.cap){ valid = vim_realloc_string(&dst->data, src.size); }
 if(!valid){ return false; }
 block_copy(dst->data.str, src.str, src.size);
 dst->data.size = src.size;
 if(dst->data.size > 0){
  dst->flags |= (REGISTER_Set|REGISTER_Updated);
 }
 return true;
}

static b32
vim_register_copy(Vim_Register *dst, Vim_Register *src){
 b32 valid = vim_register_copy(dst, src->data.string);
 if(!valid){ return false; }
 dst->edit_type = src->edit_type;
 return true;
}

static u8
vim_get_register_char(Vim_Register *reg){
 u8 result = 0;
 Vim_Registers *r = &vim_registers;
 if(0){}
 else if(reg == &r->unnamed){ result = '"'; }
 else if(reg == &r->system){ result = '*'; }
 else if(reg == &r->search){ result = '/'; }
 else if(reg == &r->small_delete){ result = '-'; }
 else if(reg == &r->insert){ result = '.'; }
 else if(reg == &r->command){ result = ':'; }
 else if(reg == &r->file){ result = '%'; }
 else if(reg == &r->expression){ result = '='; }
 else if(((r->named) <= (reg) && (reg) < (r->named + ((sizeof(r->named))/(sizeof(*r->named)))))){
  result = u8(i32('a') + i32(reg - r->named));
 }
 else if(((r->digit) <= (reg) && (reg) < (r->digit + ((sizeof(r->digit))/(sizeof(*r->digit)))))){
  result = u8(i32('0') + i32(reg - r->digit));
 }
 return result;
}
static void vim_update_registers(Application_Links *app);
# 78 "4coder_vim/4coder_vim_include.h" 2

# 1 "4coder_vim/4coder_vim_block.cpp" 1

static Rect_f32
vim_get_rel_block_rect(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range, i64 line){
 Vec2_f32 p0 = view_relative_xy_of_pos(app, view, line, range.min);
 Vec2_f32 p1 = view_relative_xy_of_pos(app, view, line, range.max);
 return Rf32((((p0.x)<(p1.x))?(p0.x):(p1.x)), (((p0.y)<(p1.y))?(p0.y):(p1.y)), (((p0.x)>(p1.x))?(p0.x):(p1.x)), (((p0.y)>(p1.y))?(p0.y):(p1.y)));
}

static Rect_f32
vim_get_abs_block_rect(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id, Range_i64 range){
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

 i64 rel_pos = range.min;
 if(!range_contains(visible_range, rel_pos)){ rel_pos = range.max; }
 if(!range_contains(visible_range, rel_pos)){ rel_pos = scan(app, boundary_alpha_numeric, buffer, Scan_Forward, visible_range.min); }
 if(!range_contains(visible_range, rel_pos)){ return Rect_f32{}; }

 i64 line = get_line_number_from_pos(app, buffer, rel_pos);
 Vec2_f32 rel_p = view_relative_xy_of_pos(app, view, line, rel_pos);
 Rect_f32 rel_rect = text_layout_character_on_screen(app, text_layout_id, rel_pos);
 Vec2_f32 offset0 = rel_p - rel_rect.p0;
 Vec2_f32 offset1 = rel_p - rel_rect.p1;
 Rect_f32 min_rect, max_rect;

 if(range_contains(visible_range, range.min)){
  min_rect = text_layout_character_on_screen(app, text_layout_id, range.min);
 }else{
  Vec2_f32 min_p = view_relative_xy_of_pos(app, view, line, range.min);
  min_rect = Rf32(min_p - offset0, min_p - offset1);
 }

 if(range_contains(visible_range, range.max)){
  max_rect = text_layout_character_on_screen(app, text_layout_id, range.max);
 }else{
  Vec2_f32 max_p = view_relative_xy_of_pos(app, view, line, range.max);
  max_rect = Rf32(max_p - offset0, max_p - offset1);
 }

 return rect_union(min_rect, max_rect);
}

static void
vim_block_copy(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range, Vim_Register *reg){
 if(reg->flags & REGISTER_ReadOnly){
  vim_state.chord_resolved = bitmask_2;
  Scratch_Block scratch(app);
  vim_set_bottom_text(push_stringf(scratch, "Register %c is Read Only", vim_get_register_char(reg)));
  return;
 }
 reg->edit_type = EDIT_Block;
 reg->flags |= (REGISTER_Set|REGISTER_Updated);
 print_message(app, SCu8((u8*)("Block copy\n"), (u64)(sizeof("Block copy\n") - 1)));
 i64 line_min = get_line_number_from_pos(app, buffer, range.min);
 i64 line_max = get_line_number_from_pos(app, buffer, range.max);
 Rect_f32 block_rect = vim_get_rel_block_rect(app, view, buffer, range, line_min);

 f32 line_advance = rect_height(block_rect)/f32((((1)>(line_max-line_min))?(1):(line_max-line_min)));
 f32 wid = rect_width(block_rect);

 u64 size = 0;
 for(i64 i=line_max; i>=line_min; i--){
  Vec2_f32 min_point = block_rect.p0 + V2f32(0, line_advance*(i-line_min));
  Vec2_f32 max_point = min_point + V2f32(wid,0);
  i64 min_pos = view_pos_at_relative_xy(app, view, line_min, min_point);
  i64 max_pos = view_pos_at_relative_xy(app, view, line_min, max_point)+1;
  size += (max_pos - min_pos) + 1;
 }

 b32 valid = true;
 if(size >= reg->data.cap){ valid = vim_realloc_string(&reg->data, size); }
 if(!valid){ return; }
 Scratch_Block scratch(app);

 reg->data.size = 0;
 for(i64 i=line_max; i>=line_min; i--){
  Vec2_f32 min_point = block_rect.p0 + V2f32(0, line_advance*(i-line_min));
  Vec2_f32 max_point = min_point + V2f32(wid,0);
  i64 min_pos = view_pos_at_relative_xy(app, view, line_min, min_point);
  i64 max_pos = view_pos_at_relative_xy(app, view, line_min, max_point)+1;

  Range_i64 line_range = Ii64(min_pos, max_pos);
  buffer_read_range(app, buffer, line_range, reg->data.str + reg->data.size);
  buffer_post_fade(app, buffer, 0.667f, line_range, fcolor_resolve(fcolor_id(defcolor_paste)));
  reg->data.size += (max_pos - min_pos) + 1;
  reg->data.str[reg->data.size-1] = '\n';
 }
}

static void
vim_block_paste(Application_Links *app, View_ID view, Buffer_ID buffer, Vim_Register *reg){
 i64 cursor_pos = view_get_cursor_pos(app, view);

 History_Group group = history_group_begin(app, buffer);

 i64 line_min = get_line_number_from_pos(app, buffer, cursor_pos);
 i64 line_max = line_min-1;
 for(i32 i=0; i<reg->data.size; i++){ line_max += reg->data.str[i] == '\n'; }


 Range_i64 range = Ii64(cursor_pos, buffer_compute_cursor(app, buffer, seek_line_col(line_max, 0)).pos);
 Rect_f32 block_rect = vim_get_rel_block_rect(app, view, buffer, range, line_min);


 f32 line_advance = rect_height(block_rect)/f32((((1)>(line_max-line_min))?(1):(line_max-line_min)));
 f32 wid = rect_width(block_rect);

 Range_i64 substring = {};
 substring.max = -1;
 for(i64 i=line_max; i>=line_min; i--){
  Vec2_f32 point = block_rect.p0 + V2f32(wid, line_advance*(i-line_min));
  i64 pos = view_pos_at_relative_xy(app, view, line_min, point);

  b32 valid=true;
  substring.min = substring.max + 1;
  while(reg->data.str[++substring.max] != '\n'){
   if(substring.max >= i64(reg->data.size)){ valid=false; break; }
  }
  if(!valid){ break; }

  Range_i64 sub = substring;


  buffer_replace_range(app, buffer, Ii64(pos), string_substring(reg->data.string, sub));
  ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
  buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, range_size(sub)), argb);
 }

 history_group_end(group);


 vim_default_register();
}

static void
vim_block_edit(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Vim_Params *params = &vim_state.params;
 if(params->request == REQUEST_Yank ||
    params->request == REQUEST_Change ||
    params->request == REQUEST_Delete)
 {
  if(vim_state.params.selected_reg){
   vim_block_copy(app, view, buffer, range, vim_state.params.selected_reg);
   vim_update_registers(app);
   vim_state.params.selected_reg = 0;
  }
  if(params->request == REQUEST_Yank){ return; }
 }

 History_Group group = history_group_begin(app, buffer);

 i64 line_min = get_line_number_from_pos(app, buffer, range.min);
 i64 line_max = get_line_number_from_pos(app, buffer, range.max);
 Rect_f32 block_rect = vim_get_rel_block_rect(app, view, buffer, range, line_min);

 f32 line_advance = rect_height(block_rect)/f32((((1)>(line_max-line_min))?(1):(line_max-line_min)));
 f32 wid = rect_width(block_rect);
 block_rect = rect_inner(block_rect, -0.1f);

 for(i64 i=line_max; i>=line_min; i--){
  if(line_is_valid_and_blank(app, buffer, i)){ continue; }
  Vec2_f32 min_point = block_rect.p0 + V2f32(0, line_advance*(i-line_min));
  Vec2_f32 max_point = min_point + V2f32(wid,0);
  i64 min_pos = view_pos_at_relative_xy(app, view, line_min, min_point);
  i64 max_pos = view_pos_at_relative_xy(app, view, line_min, max_point);

  Vec2_f32 min_p = view_relative_xy_of_pos(app, view, line_min, min_pos);
  Vec2_f32 max_p = view_relative_xy_of_pos(app, view, line_min, max_pos);
  if(!rect_contains_point(block_rect, min_p) || !rect_contains_point(block_rect, max_p)){ continue; }

  Range_i64 line_range = Ii64(min_pos, max_pos+1);

  vim_request_vtable[params->request](app, view, buffer, line_range);
 }

 history_group_end(group);
}

static void
vim_visual_insert_char(Application_Links *app, View_ID view, Buffer_ID buffer, u8 character){
 History_Group group = history_group_begin(app, buffer);

 Range_i64 range = get_view_range(app, view);
 i64 line_min = get_line_number_from_pos(app, buffer, range.min);
 i64 line_max = get_line_number_from_pos(app, buffer, range.max);
 Rect_f32 block_rect = vim_get_rel_block_rect(app, view, buffer, range, line_min);

 f32 line_advance = rect_height(block_rect)/f32((((1)>(line_max-line_min))?(1):(line_max-line_min)));
 f32 wid = rect_width(block_rect);
 f32 x_off = vim_visual_insert_after*wid;

 for(i64 i=line_max; i>=line_min; i--){
  if(line_is_valid_and_blank(app, buffer, i) && i != line_min && i != line_max){ continue; }
  Vec2_f32 point = block_rect.p0 + V2f32(x_off, line_advance*(i-line_min));
  i64 pos = view_pos_at_relative_xy(app, view, line_min, point);
  buffer_replace_range(app, buffer, Ii64(pos + vim_visual_insert_after), SCu8(&character,1));
 }

 i64 cursor_pos = view_get_cursor_pos(app, view);
 i64 mark_pos = view_get_mark_pos(app, view);

 Vec2_f32 top_point = block_rect.p0 + V2f32(x_off, 0.f);
 Vec2_f32 bot_point = block_rect.p0 + V2f32(x_off, rect_height(block_rect));
 i64 top_pos = view_pos_at_relative_xy(app, view, line_min, top_point);
 i64 bot_pos = view_pos_at_relative_xy(app, view, line_min, bot_point);

 if(cursor_pos == top_pos || cursor_pos == bot_pos){
  view_set_cursor(app, view, seek_pos(cursor_pos+1));
 }
 if(mark_pos == top_pos || mark_pos == bot_pos){
  view_set_mark(app, view, seek_pos(mark_pos+1));
 }

 history_group_end(group);
}
# 80 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_helper.cpp" 1

CUSTOM_COMMAND(no_op, "4coder_vim/4coder_vim_helper.cpp", 2, Normal)
CUSTOM_DOC("no op for binding keybinds to resolve without side effect")
{}


static u8 vim_query_user_key(Application_Links *app, String_Const_u8 message){
 u8 result = 0;

 static u8 vim_bot_temp_buffer[256];
 u64 size = vim_bot_text.size;
 block_copy(vim_bot_temp_buffer, vim_bot_text.str, size);
 vim_set_bottom_text(message);
 vim_is_querying_user_key = true;
 vim_state.chord_resolved = false;

 for(;;){
  User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if(in.abort){ vim_state.params.request = REQUEST_None; break; }
  if(in.event.kind == InputEventKind_TextInsert){
   result = in.event.text.string.str[0];
   string_append_character(&vim_keystroke_text, result);
   break;
  }
  else if(in.event.kind == InputEventKind_KeyStroke){
   in.event.kind = InputEventKind_None;
   leave_current_input_unhandled(app);
  }
  else{
   leave_current_input_unhandled(app);
  }
 }

 vim_set_bottom_text(i32(size), (char *)vim_bot_temp_buffer);
 vim_is_querying_user_key = false;
 vim_state.chord_resolved = true;
 Scratch_Block scratch(app);
 print_message(app, push_stringf(scratch, "User key was '%c' \n", result));
 return result;
}


static void vim_enter_insert_mode(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 vim_state.params.number = vim_consume_number();
 vim_history_group = history_group_begin(app, buffer);
 vim_state.mode = VIM_Insert;
 vim_state.insert_index = buffer_history_get_current_state_index(app, buffer);
 vim_state.insert_cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
}

static void vim_clamp_newline(Application_Links *app, View_ID view, Buffer_ID buffer, i64 cursor_pos){
 u8 c = buffer_get_char(app, buffer, cursor_pos);
 i64 line = get_line_number_from_pos(app, buffer, cursor_pos);
 if(!line_is_valid_and_blank(app, buffer, line) && (c == '\r' || c == '\n')){ move_left(app); }
}

static u8 character_toggle_case(u8 c){
 i32 shift = ((2*character_is_upper(c)-1)*('a'-'A'));
 return (c + u8((character_is_alpha(c) && c != '_')*shift));
}

static Range_i64 get_line_range_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
 return get_line_pos_range(app, buffer, get_line_number_from_pos(app, buffer, pos));
}

static void move_horizontal_lines(Application_Links *app, i32 count){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 Range_i64 line_range = get_line_range_from_pos(app, buffer, pos);
 i64 new_pos = view_set_pos_by_character_delta(app, view, pos, count);
 new_pos = (((line_range.min)>(new_pos))?(line_range.min):(((line_range.max)<(new_pos))?(line_range.max):(new_pos)));
 view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
}

static void seek_one_past_end(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 i64 line = view_compute_cursor(app, view, seek_pos(pos)).line;
 Vec2_f32 p = view_relative_xy_of_pos(app, view, line, pos);
 p.x = max_f32;
 i64 new_pos = view_pos_at_relative_xy(app, view, line, p);
 view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos+1));
}

static void vim_set_prev_visual(Application_Links *app, View_ID view){
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Vim_Prev_Visual *prev_visual = ((Vim_Prev_Visual*)managed_scope_get_attachment((app), (scope), (vim_buffer_prev_visual), sizeof(Vim_Prev_Visual)));

 if(prev_visual){
  prev_visual->cursor_pos = view_get_cursor_pos(app, view);
  prev_visual->mark_pos = view_get_mark_pos(app, view);
  prev_visual->edit_type = vim_state.params.edit_type;
 }
}

static void vim_push_jump(Application_Links *app, View_ID view){
 Managed_Scope scope = view_get_managed_scope(app, view);
 Vim_Jump_List *jump_list = ((Vim_Jump_List*)managed_scope_get_attachment((app), (scope), (vim_view_jumps), sizeof(Vim_Jump_List)));
 if(jump_list){
  jump_list->index = jump_list->top = ((jump_list->index+1) % ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers))));
  if(jump_list->index == jump_list->bot){ jump_list->bot++; }
  Point_Stack_Slot *slot = &jump_list->markers[jump_list->index];
  slot->buffer = view_get_buffer(app, view, Access_ReadVisible);
  slot->object = view_get_cursor_pos(app, view);
 }
}

static void vim_set_jump(Application_Links *app, View_ID view, Vim_Jump_List *jump_list, i32 index){
 jump_list->index = index;
 Point_Stack_Slot *slot = &jump_list->markers[index];
 view_set_buffer(app, view, slot->buffer, 0);
 view_set_cursor_and_preferred_x(app, view, seek_pos(slot->object));
 center_view(app);
}

static void vim_dec_jump(Application_Links *app, View_ID view){
 Managed_Scope scope = view_get_managed_scope(app, view);
 Vim_Jump_List *jump_list = ((Vim_Jump_List*)managed_scope_get_attachment((app), (scope), (vim_view_jumps), sizeof(Vim_Jump_List)));
 if(jump_list){
  if(jump_list->index == jump_list->bot){ return; }
  vim_set_jump(app, view, jump_list, jump_list->index);
  jump_list->index = ((jump_list->index + ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers)))-1) % ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers))));
 }
}

static void vim_inc_jump(Application_Links *app, View_ID view){
 Managed_Scope scope = view_get_managed_scope(app, view);
 Vim_Jump_List *jump_list = ((Vim_Jump_List*)managed_scope_get_attachment((app), (scope), (vim_view_jumps), sizeof(Vim_Jump_List)));
 if(jump_list){
  if(jump_list->index == jump_list->top){ return; }
  vim_set_jump(app, view, jump_list, ((jump_list->index+1) % ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers)))));
 }
}

static void vim_prev_jump(Application_Links *app){ vim_dec_jump(app, get_active_view(app, Access_ReadVisible)); }
static void vim_next_jump(Application_Links *app){ vim_inc_jump(app, get_active_view(app, Access_ReadVisible)); }


struct Vim_Motion_Block{
 Application_Links *app;
 i64 begin_pos, end_pos;
 i64 clamp_end = -1;
 Vim_Edit_Type prev_edit;

 Vim_Motion_Block(Application_Links *a, i64 b) : app(a), begin_pos(b), prev_edit(vim_state.params.edit_type) {}
 Vim_Motion_Block(Application_Links *a) : app(a), prev_edit(vim_state.params.edit_type) {
  View_ID view = get_active_view(app, Access_ReadVisible);
  begin_pos = view_get_cursor_pos(app, view);
 }
 ~Vim_Motion_Block();
};


Vim_Motion_Block::~Vim_Motion_Block(){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Vim_Params *params = &vim_state.params;

 if(params->edit_type == EDIT_Block){
  vim_block_edit(app, view, buffer, get_view_range(app, view));
 }else{
  end_pos = view_get_cursor_pos(app, view);
  i64 buffer_size = buffer_get_size(app, buffer);

  i64 range_begin=begin_pos, range_end=end_pos;
  if(clamp_end > 0){ range_end = (((range_end)<(clamp_end))?(range_end):(clamp_end)); }
  if(params->clusivity == VIM_Exclusive){
   if(begin_pos <= end_pos){ range_end--; }
   else{ range_begin++; }
  }
  Range_i64 range = Ii64(range_begin, range_end);
  range.max = (((range.max+1)<(buffer_size))?(range.max+1):(buffer_size));

  if(params->edit_type == EDIT_LineWise){
   range = range_union(get_line_range_from_pos(app, buffer, begin_pos),
        get_line_range_from_pos(app, buffer, end_pos));
   if(++range.max >= buffer_size){
    range.max = buffer_size;
    range.min = (((0)>(range.min-1))?(0):(range.min-1));
   }
   range.max -= (params->request == REQUEST_Change);
  }

  vim_request_vtable[params->request](app, view, buffer, range);
 }

 if(params->request == REQUEST_Yank || (params->request != REQUEST_None && clamp_end > 0)){
  Vec2_f32 v0 = view_relative_xy_of_pos(app, view, 0, begin_pos);
  Vec2_f32 v1 = view_relative_xy_of_pos(app, view, 0, end_pos);
  vim_nxt_cursor_pos += 2.f*(v1 - v0);
  view_set_cursor_and_preferred_x(app, view, seek_pos(end_pos = begin_pos));
 }

 if(params->request != REQUEST_None && vim_state.mode != VIM_Visual){
  vim_state.params.command = vim_state.active_command;
  vim_state.prev_params = vim_state.params;
 }

 Vim_Seek_Params seek = vim_state.params.seek;
 vim_state.params = {};
 vim_state.params.seek = seek;
 if(vim_state.params.selected_reg){
  vim_state.params.selected_reg->flags &= (~REGISTER_Append);
 }
 vim_default_register();

 vim_state.sub_mode = SUB_None;
 if(vim_state.mode != VIM_Insert && vim_state.mode != VIM_Visual){
  vim_clamp_newline(app, view, buffer, end_pos);
 }
 if(vim_state.mode == VIM_Visual){ vim_state.params.edit_type = prev_edit; }
}

static void
vim_visual_insert_inner(Application_Links *app, View_ID view, Buffer_ID buffer){
 auto_indent_range(app);
 vim_set_prev_visual(app, view);

 vim_visual_insert_after = false;
 vim_history_group = history_group_begin(app, buffer);


 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
 if(wrap_lines_ptr && *wrap_lines_ptr){
  toggle_line_wrap(app);
  vim_visual_insert_flags |= bit_1;
 }
 if(def_enable_virtual_whitespace){
  toggle_virtual_whitespace(app);
  vim_visual_insert_flags |= bit_2;
 }


 vim_state.mode = VIM_Visual_Insert;
}

static void vim_up(Application_Links *app){
 if(vim_state.number >= 10){ vim_push_jump(app, get_active_view(app, Access_ReadVisible)); }
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 move_vertical_lines(app, -vim_consume_number());
}

static void vim_down(Application_Links *app){
 if(vim_state.number >= 10){ vim_push_jump(app, get_active_view(app, Access_ReadVisible)); }
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 move_vertical_lines(app, vim_consume_number());
}

static void vim_left(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 move_horizontal_lines(app, -vim_consume_number());
}

static void vim_right(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 move_horizontal_lines(app, vim_consume_number());
}

static void
vim_make_request(Application_Links *app, Vim_Request_Type request){
 if(vim_state.params.request == request){
  Vim_Motion_Block vim_motion_block(app);
  vim_state.params.edit_type = EDIT_LineWise;
  vim_state.params.edit_type = EDIT_LineWise;
  move_vertical_lines(app, vim_consume_number()-1);
 }else{
  vim_state.params.count = vim_consume_number();
  vim_state.params.request = request;
  if(vim_state.mode == VIM_Visual){
   View_ID view = get_active_view(app, Access_ReadVisible);
   b32 do_visual_insert = (vim_state.params.edit_type == EDIT_Block && request == REQUEST_Change);
   vim_set_prev_visual(app, view);
   vim_state.mode = VIM_Normal;
   {
    Vim_Motion_Block vim_motion_block(app, view_get_mark_pos(app, view));
   }
   if(do_visual_insert){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    vim_visual_insert_inner(app, view, buffer);
   }
  }
  else{ vim_state.chord_resolved = false; }
 }
}

static void vim_page_scroll_inner(Application_Links *app, f32 ratio){
 View_ID view = get_active_view(app, Access_ReadVisible);
 vim_push_jump(app, view);

 f32 scroll_pixels = ratio*get_page_jump(app, view);
 move_vertical_pixels(app, scroll_pixels);

 Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
 scroll.target = view_move_buffer_point(app, view, scroll.target, V2f32(0.f, scroll_pixels));
 view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
}
# 81 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_registers.cpp" 1

# 1 "4coder_vim/calc.hpp" 1





enum Expr_Op{
 CON, NEG,
 SIN, COS, TAN, SQRT, LOG, LN,
 ADD, SUB, MUL, DIV, MOD, EXP,
};

struct Expr_Node{
 Expr_Op type;
 f64 value;
 Expr_Node *A, *B;
};

static f64 EXPR_Evaluate(Expr_Node *node){
 switch(node->type){
  case(CON): return node->value; break;
  case(NEG): return -EXPR_Evaluate(node->A); break;
  case(SIN): return sin(EXPR_Evaluate(node->A)); break;
  case(COS): return cos(EXPR_Evaluate(node->A)); break;
  case(TAN): return tan(EXPR_Evaluate(node->A)); break;
  case(LN): return log(EXPR_Evaluate(node->A)); break;
  case(SQRT): return sqrt(EXPR_Evaluate(node->A)); break;
  case(LOG): return log10(EXPR_Evaluate(node->A)); break;
  case(ADD): return EXPR_Evaluate(node->A) + EXPR_Evaluate(node->B); break;
  case(SUB): return EXPR_Evaluate(node->A) - EXPR_Evaluate(node->B); break;
  case(MUL): return EXPR_Evaluate(node->A) * EXPR_Evaluate(node->B); break;
  case(DIV): return EXPR_Evaluate(node->A) / EXPR_Evaluate(node->B); break;
  case(MOD): return fmod(EXPR_Evaluate(node->A), EXPR_Evaluate(node->B)); break;
  case(EXP): return pow(EXPR_Evaluate(node->A), EXPR_Evaluate(node->B)); break;
 }
 return 
# 35 "4coder_vim/calc.hpp" 3 4
       (__builtin_nanf (""))
# 35 "4coder_vim/calc.hpp"
          ;
}

enum Expr_Token_Type{
 Token_Unknown,
 Token_EndOfStream,
 Token_OpenParen, Token_CloseParen,
 Token_Number,
 Token_Plus, Token_Minus,
 Token_Asterisk, Token_ForwardSlash,
 Token_Caret,
 Token_Percent,
 Token_Sin, Token_Cos, Token_Tan,
 Token_Log, Token_Ln,
 Token_Sqrt,
 Token_PI, Token_TAU, Token_E,
 Token_ANS,
};

struct Expr_Token{
 Expr_Token_Type type;
 const char *text;
 i32 size;
};

struct Expr_Tokenizer{
 const char *At;
 Expr_Token Cur;
};

static i32 EXPR_OpPrec(Expr_Token expr_token){
 switch(expr_token.type){
  case Token_Plus: case Token_Minus: return 1;
  case Token_Asterisk: case Token_ForwardSlash: return 2;
  case Token_Caret: return 3;
  case Token_Percent: return 4;
  default: return 0;
 }
}

static bool EXPR_IsRight(Expr_Token expr_token){ return expr_token.type==Token_Caret; }


static bool EXPR_IsStartAtom(Expr_Token expr_token){
 switch(expr_token.type){
  case Token_OpenParen:
  case Token_Number:
  case Token_TAU:
  case Token_PI:
  case Token_E:
  case Token_Sin:
  case Token_Cos:
  case Token_Tan:
  case Token_Sqrt:
  case Token_Log:
  case Token_Ln:
  return true;
  default:
  return false;
 }
}

static Expr_Op EXPR_GetOp(Expr_Token expr_token){
 switch(expr_token.type){
  case Token_Plus: return ADD;
  case Token_Minus: return SUB;
  case Token_Asterisk: return MUL;
  case Token_ForwardSlash: return DIV;
  case Token_Percent: return MOD;
  case Token_Caret: return EXP;
  case Token_Sin: return SIN;
  case Token_Cos: return COS;
  case Token_Tan: return TAN;
  case Token_Log: return LOG;
  case Token_Ln: return LN;
  case Token_Sqrt: return SQRT;
  default: do{ if (!(false)) { (*((i32*)0) = 0xA11E); } }while(0); return CON;
 }
}

static bool EXPR_IsWhiteSpace(char c){ return (c == ' ' || c == '\r' || c == '\t'); }
static bool EXPR_IsNum(char c){ return ('0' <= c && c <= '9'); }


static bool EXPR_StrMatch_(Expr_Tokenizer *T, const char *Str, const int StrCount){
 for(int i=0; i<StrCount; i++)
  if(T->At[i] == '\0' || T->At[i] != Str[i]){ return false; }
 T->At += StrCount;
 return true;
}
static void EXPR_ConsumeWhiteSpace(Expr_Tokenizer *T){ while(EXPR_IsWhiteSpace(*T->At)){ T->At++; } }

#pragma warning(disable : 4706)

static Expr_Token EXPR_GetToken(Expr_Tokenizer *Tokenizer){
 Expr_Token expr_token = {Token_Unknown, 0, 1};
 EXPR_ConsumeWhiteSpace(Tokenizer);
 char c = *(expr_token.text = Tokenizer->At++);
 switch(c){
  case '\0':
  case '\n':
  case 
# 136 "4coder_vim/calc.hpp" 3 4
      (-1)
# 136 "4coder_vim/calc.hpp"
         :{ expr_token.type = Token_EndOfStream; expr_token.size=0; --Tokenizer->At; } break;
  case '(':{ expr_token.type = Token_OpenParen; } break;
  case ')':{ expr_token.type = Token_CloseParen; } break;
  case '+':{ expr_token.type = Token_Plus; } break;
  case '-':{ expr_token.type = Token_Minus; } break;
  case '*':{ expr_token.type = Token_Asterisk; } break;
  case '/':{ expr_token.type = Token_ForwardSlash; } break;
  case '^':{ expr_token.type = Token_Caret; } break;
  case '%':{ expr_token.type = Token_Percent; } break;
  case 'e':{ expr_token.type = Token_E; } break;
  default:{
   --Tokenizer->At;
   if(EXPR_IsNum(c) || c == '.'){
    expr_token.type = Token_Number;
    bool D = false;
    while(EXPR_IsNum(*Tokenizer->At) || !D && (D |= (*Tokenizer->At=='.'))){ ++Tokenizer->At; }
   }
   else if(EXPR_StrMatch_(Tokenizer, "sin(", sizeof("sin(")-1)) { expr_token.type = Token_Sin; }
   else if(EXPR_StrMatch_(Tokenizer, "cos(", sizeof("cos(")-1)) { expr_token.type = Token_Cos; }
   else if(EXPR_StrMatch_(Tokenizer, "tan(", sizeof("tan(")-1)) { expr_token.type = Token_Tan; }
   else if(EXPR_StrMatch_(Tokenizer, "sqrt(", sizeof("sqrt(")-1)) { expr_token.type = Token_Sqrt; }
   else if(EXPR_StrMatch_(Tokenizer, "log(", sizeof("log(")-1)) { expr_token.type = Token_Log; }
   else if(EXPR_StrMatch_(Tokenizer, "ln(", sizeof("ln(")-1)) { expr_token.type = Token_Ln; }
   else if(EXPR_StrMatch_(Tokenizer, "PI", sizeof("PI")-1)) { expr_token.type = Token_PI; }
   else if(EXPR_StrMatch_(Tokenizer, "TAU", sizeof("TAU")-1)) { expr_token.type = Token_TAU; }
   else if(EXPR_StrMatch_(Tokenizer, "ANS", sizeof("ANS")-1)) { expr_token.type = Token_ANS; }

   else{ expr_token.type = Token_Unknown; }
   expr_token.size = i32(Tokenizer->At - expr_token.text);
  } break;
 }
 return Tokenizer->Cur = expr_token;
}
static Expr_Token EXPR_PeekToken(Expr_Tokenizer *Tokenizer){
 Expr_Tokenizer Temp = *Tokenizer;
 return EXPR_GetToken(&Temp);
}
static void EXPR_ConsumePeeked(Expr_Tokenizer *Tokenizer, Expr_Token Peeked){
 Tokenizer->Cur = Peeked;
 Tokenizer->At = Peeked.text + Peeked.size;
}

static Expr_Node* EXPR_Addnode(Arena *arena, Expr_Op Op, Expr_Node *A=0, Expr_Node *B=0, f64 Value=0.0){
 Expr_Node *node = ((Expr_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Expr_Node)*(1), SCu8((u8*)("4coder_vim/calc.hpp" ":" "179" ":"), (u64)(sizeof("4coder_vim/calc.hpp" ":" "179" ":") - 1)))));
 *node = {Op, Value, A, B};
 return node;
}

static f64 expr_prev_ans;
static Expr_Node* EXPR_ParseExpression(Arena *arena, Expr_Tokenizer *T, Expr_Token_Type EndToken=Token_EndOfStream, Expr_Node *A=nullptr);

static Expr_Node* EXPR_ParseAtom(Arena *arena, Expr_Tokenizer *Tokenizer){
 Expr_Node *node = 0;
 Expr_Token expr_token = EXPR_GetToken(Tokenizer);
 switch(expr_token.type){
  case Token_OpenParen:{ node = EXPR_ParseExpression(arena, Tokenizer, Token_CloseParen); } break;
  case Token_Number:{ node = EXPR_Addnode(arena, CON, 0, 0, atof(expr_token.text)); } break;
  case Token_ANS: { node = EXPR_Addnode(arena, CON, 0, 0, expr_prev_ans); } break;
  case Token_TAU: { node = EXPR_Addnode(arena, CON, 0, 0, 6.28318530717958647692); } break;
  case Token_PI: { node = EXPR_Addnode(arena, CON, 0, 0, 3.14159265358979323846); } break;
  case Token_E: { node = EXPR_Addnode(arena, CON, 0, 0, 2.71828182845904523536); } break;

  case Token_Minus: { node = EXPR_Addnode(arena, NEG, EXPR_ParseAtom(arena, Tokenizer)); } break;

  case Token_Sin:
  case Token_Cos:
  case Token_Tan:
  case Token_Log:
  case Token_Ln:
  case Token_Sqrt:{
   node = EXPR_Addnode(arena, EXPR_GetOp(expr_token), EXPR_ParseExpression(arena, Tokenizer, Token_CloseParen));
  } break;

  default:{ return 0; }
 }

 if(!EXPR_IsWhiteSpace(Tokenizer->At[0]) && EXPR_IsStartAtom(EXPR_PeekToken(Tokenizer))){
  node = EXPR_Addnode(arena, MUL, node, EXPR_ParseAtom(arena, Tokenizer));
 }
 if(node && node->type != CON){
  f64 Val = EXPR_Evaluate(node);
  node = EXPR_Addnode(arena, CON, 0, 0, Val);
 }
 return node;
}

static Expr_Node* EXPR_ParseExpression(Arena *arena, Expr_Tokenizer *Tokenizer, Expr_Token_Type EndTokenType, Expr_Node *PreCalc){
 Expr_Node *A = (PreCalc ? PreCalc : EXPR_ParseAtom(arena, Tokenizer));
 if(A == nullptr){ return 0; }
 while(true){
  Expr_Token expr_token = EXPR_GetToken(Tokenizer);
  if(expr_token.type == EndTokenType){ break; }

  int Precedence1 = EXPR_OpPrec(expr_token);
  if(!Precedence1){ return 0; }

  Expr_Node *B = EXPR_ParseAtom(arena, Tokenizer);
  if(B == nullptr){ return 0; }

  Expr_Token next_token = EXPR_PeekToken(Tokenizer);
  if(next_token.type == EndTokenType){
   EXPR_ConsumePeeked(Tokenizer, next_token);
   return EXPR_Addnode(arena, EXPR_GetOp(expr_token), A, B);
  }

  int Precendence2 = EXPR_OpPrec(next_token);
  if(!Precendence2){ return 0; }

  if(Precedence1 < Precendence2 || (expr_token.type == next_token.type && EXPR_IsRight(expr_token))){
   B = EXPR_ParseExpression(arena, Tokenizer, EndTokenType, B);
   if(Tokenizer->Cur.type == EndTokenType){ Tokenizer->At = Tokenizer->Cur.text; }
  }

  A = EXPR_Addnode(arena, EXPR_GetOp(expr_token), A, B);
 }
 return A;
}

static f64 EXPR_ParseString(Arena *arena, const char *Expression){
 Expr_Tokenizer Tokenizer = {Expression};
 Expr_Token expr_token = EXPR_PeekToken(&Tokenizer);
 if(expr_token.type == Token_EndOfStream){ return 0.0; }

 Expr_Node *A = (EXPR_OpPrec(expr_token) > 0 ? EXPR_Addnode(arena, CON,0,0,expr_prev_ans) : nullptr);
 Expr_Node *node = EXPR_ParseExpression(arena, &Tokenizer, Token_EndOfStream, A);
 if(node){
  expr_prev_ans = EXPR_Evaluate(node);
  if(isnan(expr_prev_ans)){ expr_prev_ans = 0.0; return 
# 263 "4coder_vim/calc.hpp" 3 4
                                                       (__builtin_nanf (""))
# 263 "4coder_vim/calc.hpp"
                                                          ; }
  if(isinf(expr_prev_ans)){ expr_prev_ans = 0.0; return 
# 264 "4coder_vim/calc.hpp" 3 4
                                                       (__builtin_inff ())
# 264 "4coder_vim/calc.hpp"
                                                               ; }
  if(fabs(expr_prev_ans) <= 6.1232339957367660e-17){ expr_prev_ans = 0.0; }

  return expr_prev_ans;
 }
 expr_prev_ans = 0.0;
 return 
# 270 "4coder_vim/calc.hpp" 3 4
       (__builtin_nanf (""))
# 270 "4coder_vim/calc.hpp"
          ;
}
# 3 "4coder_vim/4coder_vim_registers.cpp" 2

static void
vim_update_registers(Application_Links *app){

 Buffer_ID buffer = buffer_identifier_to_id(app, buffer_identifier(SCu8((u8*)("*registers*"), (u64)(sizeof("*registers*") - 1))));
 i64 buffer_size = buffer_get_size(app, buffer);

 f32 advance = get_face_metrics(app, get_face_id(app, buffer)).normal_advance;
 i64 max_line_size = i64(rect_width(global_get_screen_rectangle(app))/advance) - 4;
 max_line_size = (((max_line_size)>(30))?(max_line_size):(30));

 Scratch_Block scratch(app);
 Batch_Edit head = {};
 Batch_Edit *last = &head;

 String_Const_u8 top_text = SCu8((u8*)("Vim Registers\n-+-----------"), (u64)(sizeof("Vim Registers\n-+-----------") - 1));

 head.edit.range = Ii64(0, top_text.size);
 head.edit.text = top_text;

 i64 total_size = top_text.size;
 for(i32 i=0; i<((sizeof(vim_registers.r))/(sizeof(*vim_registers.r))); i++){
  Vim_Register *reg = vim_registers.r + i;
  if(reg->flags & REGISTER_Set){
   u8 reg_char = vim_get_register_char(reg);
   i64 size = (((i64(reg->data.size))<(max_line_size))?(i64(reg->data.size)):(max_line_size));
   size -= (reg->data.str[size-1] == '\n');

   last = (last->next = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("4coder_vim/4coder_vim_registers.cpp" ":" "31" ":"), (u64)(sizeof("4coder_vim/4coder_vim_registers.cpp" ":" "31" ":") - 1))))));
   u8 *str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(4), SCu8((u8*)("4coder_vim/4coder_vim_registers.cpp" ":" "32" ":"), (u64)(sizeof("4coder_vim/4coder_vim_registers.cpp" ":" "32" ":") - 1)))));
   str[0] = '\n';
   str[1] = reg_char;
   str[2] = '|';
   str[3] = ' ';

   last->edit.text = SCu8(str, 4);
   last->edit.range = Ii64_size(total_size, 4);
   total_size += 4;

   last = (last->next = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("4coder_vim/4coder_vim_registers.cpp" ":" "42" ":"), (u64)(sizeof("4coder_vim/4coder_vim_registers.cpp" ":" "42" ":") - 1))))));
   last->edit.text = string_substring(reg->data.string, Ii64(0, size));
   last->edit.range = Ii64_size(total_size, size);
   total_size += size;
   if(reg->flags & REGISTER_Updated){
    reg->flags &= (~REGISTER_Updated);
    buffer_post_fade(app, buffer, 0.667f, last->edit.range, fcolor_resolve(fcolor_id(defcolor_cursor)));
   }
  }
 }
 last->next = 0;
 String_Const_u8 blank_string = SCu8(((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(total_size+1), SCu8((u8*)("4coder_vim/4coder_vim_registers.cpp" ":" "53" ":"), (u64)(sizeof("4coder_vim/4coder_vim_registers.cpp" ":" "53" ":") - 1))))), total_size+1);
 blank_string.str[total_size] = ' ';
 buffer_replace_range(app, buffer, Ii64(0, buffer_size), blank_string);
 buffer_batch_edit(app, buffer, &head);

}

static void vim_eval_register(Application_Links *app, Vim_Register *reg){
 reg->data.str[reg->data.size] = 0;
 Scratch_Block scratch(app);
 vim_register_copy(reg, push_stringf(scratch, "%g", EXPR_ParseString(scratch, (char *)reg->data.str)));
}

static void vim_push_reg_cycle(Application_Links *app){
 Scratch_Block scratch(app);
 for(i32 i=((sizeof(vim_registers.cycle))/(sizeof(*vim_registers.cycle)))-1; i>0; i--){
  if(vim_registers.cycle[i-1].flags & REGISTER_Set){
   vim_register_copy(&vim_registers.cycle[i], &vim_registers.cycle[i-1]);
  }
 }
}

static void
vim_copy(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range, Vim_Register *reg){
 if(reg->flags & REGISTER_ReadOnly){
  vim_state.chord_resolved = bitmask_2;
  Scratch_Block scratch(app);
  vim_set_bottom_text(push_stringf(scratch, "Register %c is Read Only", vim_get_register_char(reg)));
  return;
 }

 u32 append = ((reg->flags & REGISTER_Append) != 0);
 u64 size = u64(range_size(range)) + append*reg->data.size;

 b32 valid = true;
 if(size >= reg->data.cap){ valid = vim_realloc_string(&reg->data, size); }

 if(!valid){ return; }

 buffer_read_range(app, buffer, range, reg->data.str + append*reg->data.size);
 reg->data.size = size;

 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
 reg->flags |= (REGISTER_Set|REGISTER_Updated);

 if(reg != &vim_registers.yank && vim_state.params.request == REQUEST_Yank){
  vim_register_copy(&vim_registers.yank, reg);
 }

 if(0){}
 else if(reg == &vim_registers.system){ clipboard_post(0, reg->data.string); }
 else if(reg == &vim_registers.expression){ vim_eval_register(app, reg); }

 vim_update_registers(app);
}

static void
vim_paste(Application_Links *app, View_ID view, Buffer_ID buffer, Vim_Register *reg){
 if(reg->edit_type == EDIT_Block){ vim_block_paste(app, view, buffer, reg); return; }

 i64 pos = view_get_cursor_pos(app, view);
 if(reg == &vim_registers.system){
  clipboard_update_history_from_system(app, 0);
  clipboard_update_history_from_system(app, 0);
  i32 count = clipboard_count(0);
  if(count > 0){
   Managed_Scope scope = view_get_managed_scope(app, view);
   i32 *paste_index = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
   if(paste_index){
    Scratch_Block scratch(app);
    vim_register_copy(reg, push_clipboard_index(app, scratch, 0, *paste_index=0));
    vim_update_registers(app);
   }
  }
 }
 buffer_replace_range(app, buffer, Ii64(pos), reg->data.string);
 view_set_mark(app, view, seek_pos(pos));
 i64 cursor_pos = pos + ((i32)reg->data.string.size - (vim_state.mode != VIM_Insert));
 view_set_cursor_and_preferred_x(app, view, seek_pos(cursor_pos));

 ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
 buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, reg->data.string.size), argb);

 vim_state.prev_params.selected_reg = vim_state.params.selected_reg;
 vim_default_register();
}


static void vim_select_register(Application_Links *app){
 vim_is_selecting_register = true;
 u8 c = vim_query_user_key(app, SCu8((u8*)("-- SELECT REGISTER --"), (u64)(sizeof("-- SELECT REGISTER --") - 1)));
 vim_is_selecting_register = false;
 if(c == 0){ return; }
 Vim_Register *reg = vim_state.params.selected_reg;
 u32 append = 0;

 if(0){}
 else if(c == '_'){ reg = 0; }
 else if(c == '"'){ reg = &vim_registers.unnamed; }
 else if(c == '/'){ reg = &vim_registers.search; }
 else if(c == '.'){ reg = &vim_registers.insert; }
 else if(c == ':'){ reg = &vim_registers.command; }
 else if(c == '='){ reg = &vim_registers.expression; }
 else if(c == '-'){ reg = &vim_registers.small_delete; }
 else if(c == '%'){ reg = &vim_registers.file; }
 else if(c == '0'){ reg = &vim_registers.yank; }
 else if(c == '*'){ reg = &vim_registers.system; }
 else if(c == '+'){ reg = &vim_registers.system; }
 else if((('1') <= (c) && (c) < ('9'+1))){ reg = &vim_registers.cycle[c-'1']; }
 else if((('a') <= (c) && (c) < ('z'+1))){ reg = &vim_registers.named[c-'a']; }
 else if((('A') <= (c) && (c) < ('Z'+1))){ reg = &vim_registers.named[c-'A']; append = REGISTER_Append; }
 else{ return; }

 vim_state.params.selected_reg = reg;
 if(reg){
  reg->flags &= (~REGISTER_Append);
  reg->flags |= append;
 }

 if(vim_state.mode == VIM_Insert){
  if(reg){
   View_ID view = get_active_view(app, Access_ReadVisible);
   Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
   reg->flags &= (~REGISTER_Append);
   vim_paste(app, view, buffer, reg);
  }
 }else{
  vim_state.chord_resolved = false;
 }
}


static void
vim_process_insert_record(Application_Links *app, Record_Info record, i64 *prev_pos){
 Scratch_Block scratch(app);
 String_u8 *text = &vim_registers.insert.data;
 if(*prev_pos != record.pos_before_edit){
  *prev_pos = record.pos_before_edit;
  text->size = 0;
 }
 *prev_pos = *prev_pos - record.single_string_backward.size + record.single_string_forward.size;
 text->size = (((0)>(i64(text->size) - i64(record.single_string_backward.size)))?(0):(i64(text->size) - i64(record.single_string_backward.size)));
 u64 next_size = u64(text->size + record.single_string_forward.size);
 if(next_size >= text->cap){ vim_realloc_string(text, next_size); }
 string_append(text, record.single_string_forward);
}

static void
vim_set_insert_register(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 vim_registers.insert.data.size = 0;

 Scratch_Block scratch(app);

 History_Record_Index index = vim_state.insert_index;
 History_Record_Index max_index = buffer_history_get_current_state_index(app, buffer);
 i64 prev_pos = vim_state.insert_cursor.pos;
 for(; index <= max_index; index++){
  Record_Info record = buffer_history_get_record_info(app, buffer, index);
  if(record.error != RecordError_NoError){ continue; }
  if(record.kind == RecordKind_Single){
   vim_process_insert_record(app, record, &prev_pos);
  }
  else if(record.kind == RecordKind_Group){
   for(i32 i=0; i<record.group_count; i++){
    Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer, index, i);
    if(sub_record.error != RecordError_NoError){ continue; }
    vim_process_insert_record(app, sub_record, &prev_pos);
   }
  }
 }
 vim_state.prev_params.do_insert = true;
 vim_registers.insert.flags &= (~REGISTER_Append);
 vim_registers.insert.flags |= (REGISTER_Set|REGISTER_Updated);
 vim_update_registers(app);

 history_group_end(vim_history_group);
}
# 82 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_movement.cpp" 1

static void vim_begin_line(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 right_adjust_view(app);
}

static void vim_line_start(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 seek_beginning_of_line(app);
}

static void vim_end_line(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 i64 new_pos = get_line_side_pos_from_pos(app, buffer, pos, Side_Max);
 if(vim_state.params.request == REQUEST_Change){
  new_pos -= (buffer_get_char(app, buffer, new_pos) == '\n');
 }
 view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
}

static void vim_scroll_inner(Application_Links *app, f32 ratio){
 View_ID view = get_active_view(app, Access_ReadVisible);
 vim_push_jump(app, view);
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;



 Rect_f32 region = view_get_buffer_region(app, view);
 i64 pos = view_get_cursor_pos(app, view);
 Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
 f32 view_height = rect_height(region);
 Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
 scroll.target.line_number = cursor.line;
 scroll.target.pixel_shift.y = ratio*view_height;
 view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
 no_mark_snap_to_cursor(app, view);
}

static void vim_file_top(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 goto_beginning_of_file(app);
 move_vertical_lines(app, vim_consume_number()-1);
}


static void vim_goto_line(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 if(vim_state.number == 0){ goto_end_of_file(app); }
 else{
  View_ID view = get_active_view(app, Access_ReadVisible);
  view_set_cursor_and_preferred_x(app, view, seek_line_col(vim_consume_number(), 0));
 }
}

static void vim_goto_column(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 if(vim_state.number == 0){ right_adjust_view(app); }
 else{
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  i64 pos = view_get_cursor_pos(app, view);
  Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));
  view_set_cursor_and_preferred_x(app, view, seek_line_col(cursor.line, vim_consume_number()));
 }
}

static void vim_percent_file(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

 i64 percent = vim_consume_number();
 percent = (((percent)<(100))?(percent):(100));
 i64 target_line = i64(0.01f*percent*buffer_get_line_count(app, buffer));
 view_set_cursor_and_preferred_x(app, view, seek_line_col(target_line, 0));;
}


static void vim_screen_inner(Application_Links *app, f32 ratio, i32 offset){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 vim_push_jump(app, view);
 vim_state.params.edit_type = EDIT_LineWise;
 Buffer_Point buffer_point = view_get_buffer_scroll(app, view).position;


 Rect_f32 region = view_get_buffer_region(app, view);
 Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

 i64 pos = i64(ratio*(range_size(visible_range))) + visible_range.min;
 Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
 cursor = view_compute_cursor(app, view, seek_line_col(cursor.line + offset, 0));
 view_set_cursor_and_preferred_x(app, view, seek_pos(cursor.pos));

 text_layout_free(app, text_layout_id);
}


static Character_Predicate character_predicate_non_word;
static Character_Predicate character_predicate_word;

static void init_vim_boundaries(){
 Character_Predicate character_predicate_non_alpha_num = character_predicate_not(&character_predicate_alpha_numeric_underscore_utf8);
 character_predicate_non_word = character_predicate_and(&character_predicate_non_alpha_num, &character_predicate_non_whitespace);
 character_predicate_word = character_predicate_not(&character_predicate_non_word);
}

static i64
vim_boundary_word(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
 return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore_utf8));
}

static i64
vim_boundary_non_word(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
 return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_non_word));
}

static i64
boundary_whitespace(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
 return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_whitespace));
}



static i64 vim_word_boundary(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos){
 Scratch_Block scratch(app);
 u8 c = buffer_get_char(app, buffer, pos);
 if(direction == Scan_Forward){
  if(character_is_whitespace(c)){
   pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos);
  }else{
   pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, vim_boundary_non_word, boundary_whitespace, 0), buffer, direction, pos);
   if(character_is_whitespace(buffer_get_char(app, buffer, pos))){
    pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos);
   }
  }
 }else{
  if(character_is_whitespace(c)){
   pos = scan(app, push_boundary_list__inner((scratch), boundary_whitespace, 0), buffer, direction, pos+1);
  }
  i64 p1 = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, 0), buffer, direction, pos);
  i64 p2 = scan(app, push_boundary_list__inner((scratch), vim_boundary_non_word, 0), buffer, direction, pos);
  pos = (((p1)>(p2))?(p1):(p2));
  if(character_is_whitespace(buffer_get_char(app, buffer, pos))){
   pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos);
  }
 }
 return pos;
}

static i64 vim_WORD_boundary(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos){
 if(direction == Scan_Forward){
  pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_non_whitespace, direction, pos);
  pos = buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_non_whitespace, direction, pos);
 }else{
  pos = buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_non_whitespace, direction, pos-1);
  pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_non_whitespace, direction, pos);
  pos = buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_non_whitespace, -direction, pos);
 }
 return pos;
}


static i64 vim_end_boundary(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos){
 i64 prev_pos = pos;
 Scratch_Block scratch(app);
 u8 c = buffer_get_char(app, buffer, pos);
 u8 c1 = buffer_get_char(app, buffer, pos+1);
 u8 c2 = buffer_get_char(app, buffer, pos+2);

 if(direction == Scan_Forward){
  if(!character_is_whitespace(c1)){

   b32 c1_w = (((character_predicate_word).b[(c1)/8] & (1 << ((c1)%8))) != 0);
   b32 c2_w = (((character_predicate_word).b[(c2)/8] & (1 << ((c2)%8))) != 0);
   b32 c1_n = (((character_predicate_non_word).b[(c1)/8] & (1 << ((c1)%8))) != 0);
   b32 c2_n = (((character_predicate_non_word).b[(c2)/8] & (1 << ((c2)%8))) != 0);
   if((c1_n && c2_w) || (c1_w && c2_n)){ return pos+1; }
  }

  if(character_is_whitespace(c)){
   pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos);
  }
  pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, vim_boundary_non_word, boundary_whitespace, 0), buffer, direction, pos)-1;
  if(pos == prev_pos){
   pos = vim_end_boundary(app, buffer, direction, pos+1);
  }
 }else{
  if(character_is_whitespace(c)){
   pos = scan(app, push_boundary_list__inner((scratch), boundary_whitespace, 0), buffer, direction, pos+1);
  }


  pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, vim_boundary_non_word, boundary_whitespace, 0), buffer, direction, pos)-1;



  if(character_is_whitespace(buffer_get_char(app, buffer, pos))){
   pos--;


  }
 }
 return pos;

}

static i64 vim_END_boundary(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos){
 i64 prev_pos = pos;
 Scratch_Block scratch(app);

 if(true || direction == Scan_Forward){
  pos = vim_WORD_boundary(app, buffer, direction, pos)-direction;
  if(character_is_whitespace(buffer_get_char(app, buffer, pos))){
   pos = scan(app, push_boundary_list__inner((scratch), boundary_whitespace, 0), buffer, -direction, pos+direction) - direction;
  }
  if(pos == prev_pos){ pos = vim_END_boundary(app, buffer, direction, pos+direction); }
 }else{
  pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_non_whitespace, direction, pos);
  pos = buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_non_whitespace, direction, pos);
 }
 return pos;
}

static i64 vim_scan_word(Application_Links *app, View_ID view, Scan_Direction direction, i64 *prev_pos=0, const i32 N=1){
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 for(i32 i=0; i<N; i++){
  if(prev_pos){ *prev_pos = cursor_pos; }
  cursor_pos = vim_word_boundary(app, buffer, direction, cursor_pos);
 }
 return cursor_pos;
}

static i64 vim_scan_WORD(Application_Links *app, View_ID view, Scan_Direction direction, i64 *prev_pos=0, const i32 N=1){
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 for(i32 i=0; i<N; i++){
  if(prev_pos){ *prev_pos = cursor_pos; }
  cursor_pos = vim_WORD_boundary(app, buffer, direction, cursor_pos);
 }
 return cursor_pos;
}

static i64 vim_scan_end(Application_Links *app, View_ID view, Scan_Direction direction, const i32 N=1){
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 for(i32 i=0; i<N; i++){
  cursor_pos = vim_end_boundary(app, buffer, direction, cursor_pos);
 }
 return cursor_pos;
}

static i64 vim_scan_END(Application_Links *app, View_ID view, Scan_Direction direction, const i32 N=1){
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 for(i32 i=0; i<N; i++){
  cursor_pos = vim_END_boundary(app, buffer, direction, cursor_pos);
 }
 return cursor_pos;
}

static b32 vim_seek_char_inner(Application_Links *app, Scan_Direction Scan){
 Vim_Seek_Params seek = vim_state.params.seek;
 if(seek.character == 0){ return false; }
 i32 direction = Scan*seek.direction;
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 start_pos = view_get_cursor_pos(app, view);
 i64 pos = start_pos;
 pos += direction;
 Range_i64 range = get_line_range_from_pos(app, buffer, pos);
 while(seek.character != buffer_get_char(app, buffer, pos)){
  if(!range_contains(range, pos)){ return false; }
  pos += direction;
 }
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
 return true;
}

static void vim_seek_char(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 b32 valid = true;
 const i32 N = vim_consume_number();
 for(i32 i=0; i<N; i++){ valid &= vim_seek_char_inner(app, Scan_Forward); }
 vim_state.params.request *= valid;
 if(valid && vim_state.params.seek.clusivity == VIM_Exclusive){
  move_horizontal_lines(app, -vim_state.params.seek.direction);
 }
}

static void vim_set_seek_char(Application_Links *app){
 User_Input input = get_current_input(app);
 if(input.event.kind == InputEventKind_KeyStroke){
  vim_state.params.seek.clusivity = (input.event.key.code == KeyCode_T ? VIM_Exclusive : VIM_Inclusive);
  vim_state.params.seek.direction = (has_modifier(&input.event, KeyCode_Shift) ? -1 : 1);

  u8 key = vim_query_user_key(app, SCu8((u8*)("-- SEEK NEXT --"), (u64)(sizeof("-- SEEK NEXT --") - 1)));
  if(key){
   vim_state.params.seek.character = key;
   vim_state.active_command = vim_seek_char;
   vim_seek_char(app);
  }
 }
}

static void vim_seek_char_forward(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 const i32 N = vim_consume_number();
 for(i32 i=0; i<N; i++){ vim_seek_char_inner(app, Scan_Forward); }
 if(vim_state.params.seek.clusivity == VIM_Exclusive){
  move_horizontal_lines(app, -vim_state.params.seek.direction);
 }
}

static void vim_seek_char_backward(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 const i32 N = vim_consume_number();
 for(i32 i=0; i<N; i++){ vim_seek_char_inner(app, Scan_Backward); }
 if(vim_state.params.seek.clusivity == VIM_Exclusive){
  move_horizontal_lines(app, vim_state.params.seek.direction);
 }
}

bool vim_character_can_bounce(u8 c){
 return c == '[' || c == ']' || c == '{' || c == '}' || c == '(' || c == ')';
}

Scan_Direction vim_bounce_direction(u8 c){
 switch(c){
  case '[': case '(': case '{': return Scan_Forward;
  case ']': case ')': case '}': return Scan_Backward;
 }
 return 0;
}

u8 vim_corresponding_bounce(u8 c){
 switch(c){
  case '[': return ']';
  case '(': return ')';
  case '{': return '}';
  case ']': return '[';
  case ')': return '(';
  case '}': return '{';
 }
 return 0;
}

static i64 vim_bounce_pair(Application_Links *app, Buffer_ID buffer, i64 pos, u8 first){
 i32 direction = vim_bounce_direction(first);
 u8 track, close = vim_corresponding_bounce(first);
 i64 max_pos = buffer_get_size(app, buffer);
 i32 stack_count = 0;

 i64 prev_pos = pos;
 pos += direction;
 while(close != (track = buffer_get_char(app, buffer, pos)) || stack_count != 0){
  if(track == first){ stack_count++; }
  if(track == close){ stack_count--; }
  if(pos <= 0 || max_pos <= pos){ return prev_pos; }
  pos += direction;
 }
 return pos;
}

static i64 vim_scan_bounce(Application_Links *app, Buffer_ID buffer, i64 cursor_pos, Scan_Direction direction){
 i64 max_pos = buffer_get_size(app, buffer);
 u8 c = buffer_get_char(app, buffer, cursor_pos);
 i64 pos = cursor_pos - (c == '\n' || c == '\r');
 u8 track;
 while(!vim_character_can_bounce(track = buffer_get_char(app, buffer, pos))){
  pos += direction;
  if(pos <= 0 || max_pos <= pos){ return cursor_pos; }
 }

 return vim_bounce_pair(app, buffer, pos, track);
}

Range_i64 vim_object_none(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){ return Ii64(0,0); }

Range_i64 vim_object_para(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 Range_i64 range = {};
 if(line_is_blank(app, buffer, get_line_number_from_pos(app, buffer, cursor_pos))){
  range.min = range.max = cursor_pos;
 }else{
  range.min = get_pos_of_blank_line_grouped(app, buffer, Scan_Backward, cursor_pos);
  range.max = get_pos_of_blank_line_grouped(app, buffer, Scan_Forward, cursor_pos);
 }
 vim_state.params.edit_type = EDIT_LineWise;
 return range;
}

Range_i64 vim_object_word(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 Range_i64 range = {};
 char c = buffer_get_char(app, buffer, cursor_pos);
 if(character_is_whitespace(c)){
  range.min = scan(app, boundary_whitespace, buffer, Scan_Backward, cursor_pos+1);
  range.max = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, Scan_Forward, cursor_pos)-1;
 }else{
  if(true || vim_state.params.clusivity == VIM_Exclusive){
   u8 c1 = buffer_get_char(app, buffer, cursor_pos-1);
   u8 c2 = buffer_get_char(app, buffer, cursor_pos+1);
   b32 boundary1 = !(((character_predicate_word).b[(c1)/8] & (1 << ((c1)%8))) != 0) || character_is_whitespace(c1);
   b32 boundary2 = !(((character_predicate_word).b[(c2)/8] & (1 << ((c2)%8))) != 0) || character_is_whitespace(c2);
   range.min = boundary1 ? cursor_pos : vim_word_boundary(app, buffer, Scan_Backward, cursor_pos);
   range.max = boundary2 ? cursor_pos : vim_end_boundary(app, buffer, Scan_Forward, cursor_pos);
  }else{
   range.min = vim_end_boundary(app, buffer, Scan_Backward, cursor_pos)+1;
   range.max = vim_word_boundary(app, buffer, Scan_Forward, cursor_pos);
  }
 }
 return range;
}


Range_i64 vim_object_WORD(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 Range_i64 range = {};
 char c = buffer_get_char(app, buffer, cursor_pos);
 if(character_is_whitespace(c)){
  range.min = scan(app, boundary_whitespace, buffer, Scan_Backward, cursor_pos+1);
  range.max = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, Scan_Forward, cursor_pos)-1;
 }else{
  if(true || vim_state.params.clusivity == VIM_Exclusive){
   b32 boundary1 = character_is_whitespace(buffer_get_char(app, buffer, cursor_pos-1));
   b32 boundary2 = character_is_whitespace(buffer_get_char(app, buffer, cursor_pos+1));
   range.min = boundary1 ? cursor_pos : vim_WORD_boundary(app, buffer, Scan_Backward, cursor_pos);
   range.max = boundary2 ? cursor_pos : vim_END_boundary(app, buffer, Scan_Forward, cursor_pos);
  }else{
   range.min = vim_END_boundary(app, buffer, Scan_Backward, cursor_pos)+1;
   range.max = vim_WORD_boundary(app, buffer, Scan_Forward, cursor_pos);
  }
 }
 return range;
}



Range_i64 vim_scan_object_quotes(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 Range_i64 range = {};
 u8 character = vim_state.params.seek.character;
 Range_i64 line_range = get_line_range_from_pos(app, buffer, cursor_pos);
 if(range_size(line_range) >= 2){
  Scratch_Block scratch(app);
  u8 *line_text = push_buffer_range(app, scratch, buffer, line_range).str;
  i64 s = line_range.min;
  b32 inside_string = 0;
  for(i64 i=line_range.min; i<cursor_pos; i++){
   if(character == line_text[i-s]){
    range.min = i;
    inside_string ^= 1;
   }
  }

  if(inside_string){
   for(range.max = cursor_pos; range.max < line_range.max; range.max++){
    if(character == line_text[range.max-s]){ break; }
   }
   if(character != line_text[range.max-s]){ range = {}; }
  }else{
   range.min = 0;
   for(i64 i=cursor_pos; i<line_range.max; i++){
    if(character == line_text[i-s]){
     range.min = i;
     break;
    }
   }
   if(range.min){
    range.max = line_range.max;
    for(i64 i=range.min+1; i<line_range.max; i++){
     if(character == line_text[i-s]){
      range.max = i;
      break;
     }
    }
    if(character != line_text[range.max-s]){ range = {}; }
   }
  }

  if(vim_state.params.clusivity == VIM_Exclusive){
   range.min++;
   range.max--;
   if(range.min >= range.max){ range = {}; }
  }
 }
 return range;
}



static void vim_text_object(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 u8 character = vim_state.params.seek.character;
 Vim_Clusivity object_clusivity = vim_state.params.clusivity;

 Range_i64 range = {};

 b32 did_range = false;
 for(i32 i=0; i<((sizeof(vim_text_object_vtable))/(sizeof(*vim_text_object_vtable))); i++){
  Vim_Text_Object *text_object = vim_text_object_vtable + i;
  if(character == text_object->character){
   range = text_object->func(app, buffer, cursor_pos);
   did_range = true;
   break;
  }
 }

 if(!did_range){


  if(vim_character_can_bounce(character)){
   u8 c = buffer_get_char(app, buffer, cursor_pos);
   u8 b_character = vim_corresponding_bounce(character);
   if(c == character || c == b_character){
    range = Ii64(vim_bounce_pair(app, buffer, cursor_pos, c), cursor_pos);
   }else{
    range = Ii64(vim_bounce_pair(app, buffer, cursor_pos, character),
        vim_bounce_pair(app, buffer, cursor_pos, b_character));
   }
   if(vim_state.params.clusivity == VIM_Exclusive){
    range.min++;
    range.max--;
    if(range.min >= range.max){ range = {}; }
    vim_state.params.clusivity = VIM_Inclusive;
   }
  }


  else if(character == '"' || character == '\''){
   range = vim_scan_object_quotes(app, buffer, cursor_pos);
  }
 }

 if(range.min && range.max){
  vim_push_jump(app, view);
  {
   Vim_Motion_Block vim_motion_block(app, range.max);
   vim_state.params.clusivity = VIM_Inclusive;
   view_set_cursor_and_preferred_x(app, view, seek_pos(range.min));
   view_set_mark(app, view, seek_pos(range.max));
  }
  vim_state.prev_params.clusivity = object_clusivity;
 }else{
  vim_reset_state();
 }
}
# 83 "4coder_vim/4coder_vim_include.h" 2

# 1 "4coder_vim/4coder_vim_lister.cpp" 1


static String_Const_u8
ctrl_backspace_utf8(String_Const_u8 string){
 if(string.size <= 0){ return string; }
 b32 clearing_whitespace = true;
 u64 i = string.size-2;
 for(; i>0; --i){
  if(!clearing_whitespace &&
     (string.str[i] <= 0x7F || string.str[i] >= 0xC0) &&
     (string.str[i] == '_' || !character_is_alpha_numeric(string.str[i])))
  {
   i++;
   break;
  }
  if(clearing_whitespace && !character_is_whitespace(string.str[i])){ clearing_whitespace=false; }
 }
 return SCu8(string.str, i);
}

static void
vim_lister__backspace(Application_Links *app){
 View_ID view = get_this_ctx_view(app, Access_Always);
 Lister *lister = view_get_lister(app, view);
 if(lister){
  User_Input input = get_current_input(app);
  if(has_modifier(&input, KeyCode_Control)){
   if(has_modifier(&input, KeyCode_Shift)){
    lister->text_field.size = 0;
   }else{
    lister->text_field.string = ctrl_backspace_utf8(lister->text_field.string);
   }
  }else{
   lister->text_field.string = backspace_utf8(lister->text_field.string);
  }

  lister_set_key(lister, lister->text_field.string);
  lister->item_index = 0;
  lister_zero_scroll(lister);
  lister_update_filtered_list(app, lister);
 }
}


static void
vim_lister_file__backspace(Application_Links *app){
 View_ID view = get_this_ctx_view(app, Access_Always);
 Lister *lister = view_get_lister(app, view);
 if(lister){
  User_Input input = get_current_input(app);
  if(has_modifier(&input, KeyCode_Control)){
   if(has_modifier(&input, KeyCode_Shift)){
    lister->text_field.size = 0;
    while(!character_is_slash(lister->text_field.str[++lister->text_field.size])){}
    ++lister->text_field.size;
    String_u8 temp = lister->text_field;

    set_hot_directory(app, temp.string);
    lister_call_refresh_handler(app, lister);
    lister->text_field = temp;
   }else{
    String_Const_u8 string = lister->text_field.string;
    if(character_is_slash(string.str[string.size-1])){
     string.size--;
     i64 slash_index = string_find_last_slash(string);
     if(slash_index >= 0){
      string.size = slash_index+1;
      lister->text_field.string = string;
      set_hot_directory(app, string);
      String_u8 temp = lister->text_field;
      lister_call_refresh_handler(app, lister);
      lister->text_field = temp;
     }
    }else{
     lister->text_field.string = ctrl_backspace_utf8(lister->text_field.string);
    }
   }
  }else{
   lister->text_field.string = backspace_utf8(lister->text_field.string);
  }

  String_Const_u8 text_field = lister->text_field.string;
  String_Const_u8 new_key = string_front_of_path(text_field);
  lister_set_key(lister, new_key);

  lister->item_index = 0;
  lister_zero_scroll(lister);
  lister_update_filtered_list(app, lister);
 }
}


static Lister_Activation_Code
vim_lister__write_character__file_path(Application_Links *app){
 Lister_Activation_Code result = ListerActivation_Continue;
 View_ID view = get_this_ctx_view(app, Access_Always);
 Lister *lister = view_get_lister(app, view);
 if(lister != 0){
  User_Input in = get_current_input(app);
  String_Const_u8 string = to_writable(&in);
  if(string.str != 0 && string.size > 0){
   lister_append_text_field(lister, string);
   if(character_is_slash(string.str[0])){
    lister->out.text_field = lister->text_field.string;
                result = ListerActivation_Finished;
   }
   else{
    String_Const_u8 front_name = string_front_of_path(lister->text_field.string);
    lister_set_key(lister, front_name);
   }
   lister->item_index = 0;
   lister_zero_scroll(lister);
   lister_update_filtered_list(app, lister);
  }
 }
 return(result);
}

static void
vim_lister_set_default_handlers(Lister *lister){
 Lister_Handlers handlers = lister_get_default_handlers();
 handlers.backspace = vim_lister__backspace;
 lister_set_handlers(lister, &handlers);
}

static File_Name_Result
vim_convert_lister_result_to_file_name_result(Lister_Result l_result){
 File_Name_Result result = {};
 result.canceled = l_result.canceled;
 if(l_result.canceled){ return result; }
 result.clicked = l_result.activated_by_click;
 if(l_result.user_data != 0){
  String_Const_u8 name = SCu8((u8*)l_result.user_data);
  result.file_name_activated = name;
  result.is_folder = character_is_slash(string_get_character(name, name.size - 1));
 }
 result.file_name_in_text_field = string_front_of_path(l_result.text_field);

 String_Const_u8 path = {};
 if(l_result.user_data && result.file_name_in_text_field.size && l_result.text_field.size > 0){
  result.file_name_in_text_field = string_front_folder_of_path(l_result.text_field);
  path = string_remove_front_folder_of_path(l_result.text_field);
 }else{
  path = string_remove_front_of_path(l_result.text_field);
 }
 if(character_is_slash(string_get_character(path, path.size-1))){
  path = string_chop(path, 1);
 }
 result.path_in_text_field = path;

 return(result);
}


static f32 vim_lister_get_block_height(f32 line_height){ return 1.5f*line_height; }

static void*
vim_lister_user_data_at_p(Application_Links *app, View_ID view, Lister *lister, Vec2_f32 m_p, i32 col_num){
 Rect_f32 region = vim_get_bottom_rect(app);
 f32 line_height = get_face_metrics(app, get_face_id(app, 0)).line_height;
 f32 block_height = vim_lister_get_block_height(line_height);
 f32 block_width = rect_width(region)/col_num;

 if(rect_contains_point(region, m_p)){
  f32 y = m_p.y - region.y0 + lister->scroll.position.y;
  i32 index = i32(m_p.x/block_width) + col_num*i32(y/block_height);
  if(((0) <= (index) && (index) < (lister->filtered.count))){
   return lister->filtered.node_ptrs[index]->user_data;
  }
 }

 return 0;
}


static Vec2_i32
calc_col_row(Application_Links *app, Lister *lister){
 Vec2_f32 dim = rect_dim(global_get_screen_rectangle(app));
 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics metrics = get_face_metrics(app, face_id);
 f32 line_height = metrics.line_height;
 f32 max_advance = metrics.max_advance;
 f32 block_height = vim_lister_get_block_height(line_height);
 f32 max_lister_height = dim.y*0.55f - 2.f*line_height;

 u64 max_name_size = 0;
 Range_i32 lister_range = Ii32(3,5);
 const i32 N = (((lister_range.max*i32(block_height/max_lister_height))<(lister->filtered.count))?(lister_range.max*i32(block_height/max_lister_height)):(lister->filtered.count));
 for(i32 i=0; i<N; i++){
  if(lister->filtered.node_ptrs[i]->string.size > max_name_size){
   max_name_size = lister->filtered.node_ptrs[i]->string.size;
  }
 }

 i32 col_num = i32(dim.x/((max_name_size+7)*max_advance));
 col_num = (((lister_range.min)>(col_num))?(lister_range.min):(((lister_range.max)<(col_num))?(lister_range.max):(col_num)));

 i32 max_row_num = 1 + lister->filtered.count/col_num;
 i32 row_num = i32((dim.y*0.5f - 2.f*line_height)/block_height);
 row_num = (((row_num)<(max_row_num))?(row_num):(max_row_num));

 return Vec2_i32{col_num, row_num};
}


static void
vim_lister_render(Application_Links *app, Frame_Info frame_info, View_ID view){
 Scratch_Block scratch(app);

 Lister *lister = view_get_lister(app, view);
 if(lister == 0){ return; }


 Rect_f32 region = global_get_screen_rectangle(app);
 Rect_f32 prev_clip = draw_set_clip(app, region);

 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics metrics = get_face_metrics(app, face_id);
 f32 line_height = metrics.line_height;
 f32 max_advance = metrics.max_advance;
 f32 block_height = vim_lister_get_block_height(line_height);
 f32 max_lister_height = rect_height(region)*0.55f - 2.f*line_height;

 u64 max_name_size = 0;
 Range_i32 lister_range = Ii32(3,5);
 const i32 N = (((lister_range.max*i32(block_height/max_lister_height))<(lister->filtered.count))?(lister_range.max*i32(block_height/max_lister_height)):(lister->filtered.count));
 for(i32 i=0; i<N; i++){
  if(lister->filtered.node_ptrs[i]->string.size > max_name_size){
   max_name_size = lister->filtered.node_ptrs[i]->string.size;
  }
 }

 i32 col_num = i32(rect_width(region)/((max_name_size+7)*max_advance));

 col_num = (((lister_range.min)>(col_num))?(lister_range.min):(((lister_range.max)<(col_num))?(lister_range.max):(col_num)));

 i32 max_row_num = 1 + (lister->filtered.count-1)/col_num;
 i32 row_num;
 if(lister->filtered.count == 0.f){ row_num = 0; }
 else{ row_num = (((i32(max_lister_height/block_height))<(max_row_num))?(i32(max_lister_height/block_height)):(max_row_num)); }

 lister->visible_count = (((col_num*row_num)<(lister->filtered.count))?(col_num*row_num):(lister->filtered.count));


 region = rect_split_top_bottom_neg(region, (row_num+2)*block_height).b;
 region = rect_split_top_bottom_neg(region, 2.f*line_height).a;
 vim_nxt_filebar_offset = row_num*block_height + 0.1f;



 Render_Caller_Function *render_caller = (Render_Caller_Function *)get_custom_hook(app, HookID_RenderCaller);
 render_caller(app, frame_info, view);
 draw_set_clip(app, region);

 Mouse_State mouse = get_mouse_state(app);
 Vec2_f32 m_p = V2f32(mouse.p);


 f32 scroll_y = lister->scroll.position.y;

 if(lister->set_vertical_focus_to_item){
  lister->set_vertical_focus_to_item = false;
  Range_f32 item_y = If32_size((lister->item_index/col_num)*block_height, block_height);
  f32 view_h = rect_height(region);
  Range_f32 view_y = If32_size(scroll_y, view_h);
  if(view_y.min > item_y.min || item_y.max > view_y.max){
   f32 item_center = (item_y.min + item_y.max)*0.5f;
   f32 view_center = (view_y.min + view_y.max)*0.5f;
   f32 margin = view_h*.3f;
   margin = (((margin)<(block_height*3.f))?(margin):(block_height*3.f));
   if(item_center < view_center){
    lister->scroll.target.y = item_y.min - margin;
   }
   else{
    f32 target_bot = item_y.max + margin;
    lister->scroll.target.y = target_bot - view_h;
   }
  }
 }


 i32 count = lister->filtered.count;

 Range_f32 scroll_range = If32(0.f, (((0.f)>((count/col_num - 1)*block_height))?(0.f):((count/col_num - 1)*block_height)));
 lister->scroll.target.y = clamp_range(scroll_range, lister->scroll.target.y);
 lister->scroll.target.x = 0.f;

 Vec2_f32_Delta_Result delta = delta_apply(app, view, frame_info.animation_dt, lister->scroll);
 lister->scroll.position = delta.p;
 if(delta.still_animating){ animate_in_n_milliseconds(app, 0); }

 lister->scroll.position.y = clamp_range(scroll_range, lister->scroll.position.y);
 lister->scroll.position.x = 0.f;

 scroll_y = lister->scroll.position.y;
 i32 first_index = (i32)(col_num*scroll_y/(block_height));

 f32 x_base = region.x0;
 f32 y_base = region.y1 - vim_cur_filebar_offset;
 f32 block_width = rect_width(region)/col_num;
 Rect_f32 back_rect = region;
 back_rect.y0 = y_base;
 back_rect.y1 = y_base + rect_height(region);
 draw_rectangle_fcolor(app, back_rect, 0.f, fcolor_id(defcolor_back));

 Fancy_Block block = {};
 for(i32 i=first_index; i<count; i++){
  Lister_Node *node = lister->filtered.node_ptrs[i];

  f32 x0 = x_base + block_width*((i-first_index) % col_num);
  f32 y0 = y_base + block_height*((i-first_index) / col_num);
  if(y0 > region.y1){ break; }
  Rect_f32 item_rect = Rf32(x0, y0, x0+block_width, y0+block_height);
  Rect_f32 item_inner = rect_inner(item_rect, 3.f);

  b32 hovered = rect_contains_point(item_rect, m_p);
  if(hovered){
   Fancy_Line *line1 = push_fancy_line(scratch, &block, face_id);
   u64 index = string_find_last(node->status, '\n');

   if(index < node->status.size){
    push_fancy_string(scratch, line1, fcolor_id(defcolor_pop2), string_prefix(node->status, index));
    Fancy_Line *line2 = push_fancy_line(scratch, &block, face_id);
    push_fancy_string(scratch, line2, fcolor_id(defcolor_text_default), string_postfix(node->status, node->status.size-1 - index));
   }else{
    push_fancy_string(scratch, line1, fcolor_id(defcolor_pop2), node->status);
   }
  }
  UI_Highlight_Level highlight = UIHighlight_None;
  if(node == lister->highlighted_node){
   highlight = UIHighlight_Active;
  }else if(node->user_data == lister->hot_user_data){
   highlight = hovered ? UIHighlight_Active : UIHighlight_Hover;
  }else if(hovered){
   highlight = UIHighlight_Hover;
  }

  u64 lister_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("lister_roundness"), (u64)(sizeof("lister_roundness") - 1))));
  f32 roundness = block_height*lister_roundness_100*0.01f;
  draw_rectangle_fcolor(app, item_rect, roundness, get_item_margin_color(highlight));
  draw_rectangle_fcolor(app, item_inner, roundness, get_item_margin_color(highlight, 1));

  Fancy_Line line = {};
  push_fancy_string(scratch, &line, fcolor_id(defcolor_text_default), node->string);
  push_fancy_stringf(scratch, &line, " ");
  u64 index = string_find_last(node->status, '\n');
  push_fancy_string(scratch, &line, fcolor_id(defcolor_pop2), string_prefix(node->status, index));

  Vec2_f32 p = item_inner.p0 + V2f32(3.f, (block_height - line_height)*0.5f);
  draw_fancy_line(app, face_id, fcolor_zero(), &line, p);
 }
 f32 x_padding = metrics.normal_advance;
 f32 x_half_padding = x_padding*0.5f;
 draw_drop_down(app, face_id, &block, m_p, region, x_padding, x_half_padding, fcolor_id(defcolor_margin_hover), fcolor_id(defcolor_back));

 if(lister->visible_count != 0){
  Rect_f32 rect = Rect_f32{region.x0, region.y1 - 4.f, region.x1, region.y1};
  draw_rectangle_fcolor(app, rect, 0.f, get_item_margin_color(UIHighlight_Active));
 }

 draw_set_clip(app, prev_clip);
}

static void vim_change_lister_view_back(Application_Links *app){
 view_set_active(app, vim_lister_view_id);
 vim_lister_view_id = 0;
}

static Lister_Result
vim_run_lister(Application_Links *app, Lister *lister){
 Lister_Result ret;
 View_ID view = get_this_ctx_view(app, Access_Always);
 vim_lister_view_id = view;

 Scratch_Block scratch(app);
 lister->filter_restore_point = begin_temp(lister->arena);
 lister_update_filtered_list(app, lister);

 vim_use_bottom_cursor = true;
 bool do_invalidate = true;
 vim_show_buffer_peek = false;

 View_Context ctx = view_current_context(app, view);
 Rect_f32 global_rect = global_get_screen_rectangle(app);

 ctx.render_caller = vim_lister_render;
 ctx.hides_buffer = false;
 View_Context_Block ctx_block(app, view, &ctx);

 u8 *begin, *dest;
 begin = dest = vim_bot_text.str + vim_bot_text.size;
 u64 base_size, after_size;
 base_size = after_size = vim_bot_text.size;

 User_Input in = {};
 for(;;){
  Vec2_i32 col_row = calc_col_row(app, lister);
  i32 col_num = col_row.x;
  i32 visible_count = col_row.x*col_row.y;
  block_copy(dest, lister->text_field.str, lister->text_field.size);
  vim_bot_text.size = after_size + lister->text_field.size;
  animate_in_n_milliseconds(app, 0);

  Lister_Activation_Code result = ListerActivation_Continue;
  b32 handled = true;

  in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if(in.abort){
   block_zero((&lister->out), sizeof(*(&lister->out)));
   lister->out.canceled = true;
   vim_reset_bottom_text();
   break;
  }

  if(in.event.kind == InputEventKind_KeyStroke){
   if(in.event.key.code == KeyCode_W && has_modifier(&in, KeyCode_Control) && lister->handlers.backspace){
    in.event.key.code = KeyCode_Backspace;
   }
   if(in.event.key.code == KeyCode_U && has_modifier(&in, KeyCode_Control) && lister->handlers.backspace){
    in.event.key.code = KeyCode_Backspace;
    Input_Modifier_Set *set = get_modifiers(&in.event);
    set->mods[set->count++] = KeyCode_Shift;
   }
  }

  switch(in.event.kind){

   case InputEventKind_TextInsert:{
    vim_cursor_blink = 0;
    if(lister->handlers.write_character != 0){
     result = lister->handlers.write_character(app);
    }
   } break;

   case InputEventKind_KeyStroke:{
    vim_cursor_blink = 0;

    switch(in.event.key.code){

     case KeyCode_Tab:{
      i32 delta = (has_modifier(&in.event, KeyCode_Shift) ? -1 : 1);
      if(lister->handlers.navigate != 0){
       lister->handlers.navigate(app, view, lister, delta);
      }else if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;

     case KeyCode_Return:{
      void *user_data = 0;
      if(((0) <= (lister->raw_item_index) && (lister->raw_item_index) < (lister->options.count))){
       user_data = lister_get_user_data(lister, lister->raw_item_index);
       block_copy(dest, lister->highlighted_node->string.str, lister->highlighted_node->string.size);
       vim_bot_text.size = base_size + lister->highlighted_node->string.size;
      }
      lister_activate(app, lister, user_data, false);
      result = ListerActivation_Finished;
     } break;

     case KeyCode_Backspace:{
      if(lister->handlers.backspace != 0){
       lister->handlers.backspace(app);
      }else if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;

     case KeyCode_Down:
     case KeyCode_Up:{
      if(lister->handlers.navigate != 0){
       i32 delta = (in.event.key.code == KeyCode_Up ? -1 : 1);
       lister->handlers.navigate(app, view, lister, delta*col_num);
      }else if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;

     case KeyCode_Right:
     case KeyCode_Left:{
      i32 delta = (in.event.key.code == KeyCode_Left ? -1 : 1);
      if(lister->handlers.navigate != 0){
       lister->handlers.navigate(app, view, lister, delta);
      }else if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;

     case KeyCode_PageDown:
     case KeyCode_PageUp:{
      if(lister->handlers.navigate != 0){
       i32 delta = (in.event.key.code == KeyCode_PageUp ? -1 : 1);
       lister->handlers.navigate(app, view, lister, delta*visible_count);
      }else if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;

     default:{
      if(lister->handlers.key_stroke != 0){
       result = lister->handlers.key_stroke(app);
      }else{ handled = false; }
     } break;
    }
   } break;

   case InputEventKind_MouseWheel:{
    lister->scroll.target.y += get_mouse_state(app).wheel;
    lister_update_filtered_list(app, lister);
   } break;

   case InputEventKind_MouseMove:{ lister_update_filtered_list(app, lister); } break;

   case InputEventKind_Core:{
    switch(in.event.core.code){
     case CoreCode_Animate:{ lister_update_filtered_list(app, lister); } break;

     default:{ handled = false; } break;
    }
   } break;

   default:{ handled = false; } break;
  }


  Mouse_State mouse_state = get_mouse_state(app);
  Vec2_f32 mouse_pos = V2f32(mouse_state.p);
  if(mouse_state.press_l){
   void *clicked = vim_lister_user_data_at_p(app, view, lister, mouse_pos, col_num);
   if(clicked){
    lister_activate(app, lister, clicked, true);
    result = ListerActivation_Finished;
    do_invalidate = false;
    view_enqueue_command_function(app, view, vim_change_lister_view_back);
   }
  }

  if(result == ListerActivation_ContinueAndRefresh){
   lister_call_refresh_handler(app, lister);
  }
  else if(result == ListerActivation_Finished){ break; }

  if(handled){ continue; }
  Fallback_Dispatch_Result disp_result = fallback_command_dispatch(app, lister->mapping, lister->map, &in);
  if(disp_result.code == FallbackDispatch_DelayedUICall){
   call_after_ctx_shutdown(app, view, disp_result.func);
   break;
  }
  if(disp_result.code == FallbackDispatch_Unhandled){ leave_current_input_unhandled(app); }
  else{ lister_call_refresh_handler(app, lister); }
 }

 vim_use_bottom_cursor = false;
 vim_nxt_filebar_offset = 0.f;
 if(do_invalidate){ vim_lister_view_id = 0; }

 if(!in.abort){
  String_Const_u8 command_name = string_substring(vim_bot_text.string, Ii64(base_size,vim_bot_text.size));
  vim_register_copy(&vim_registers.command, command_name);
  vim_update_registers(app);
 }

 ret = lister->out;



 vim_lister_view_id = 0;
 return ret;
}


static Lister_Result
vim_run_lister_with_refresh_handler(Application_Links *app, Arena *arena, String_Const_u8 query, Lister_Handlers handlers){
 Lister_Result result = {};
 if(handlers.refresh != 0){
  Lister_Block lister(app, arena);
  lister_set_query(lister, query);
  lister_set_handlers(lister, &handlers);
  handlers.refresh(app, lister);
  result = vim_run_lister(app, lister);
 }
 else{

  print_message(app, push_u8_stringf(arena, "ERROR: No refresh handler specified for lister (query_string = \"%.*s\")\n", (i32)(query).size, (char*)(query).str));

  result.canceled = true;
 }
 return(result);
}

static File_Name_Result
vim_get_file_name_from_user(Application_Links *app, Arena *arena, String_Const_u8 query, View_ID view){
 Lister_Handlers handlers = lister_get_default_handlers();
 handlers.refresh = generate_hot_directory_file_list;
 handlers.write_character = vim_lister__write_character__file_path;
 handlers.backspace = vim_lister_file__backspace;

 vim_reset_bottom_text();
 Lister_Result l_result = vim_run_lister_with_refresh_handler(app, arena, query, handlers);
 return vim_convert_lister_result_to_file_name_result(l_result);
}
# 85 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_lists.cpp" 1

static void
vim__fill_command_lister(Arena *arena, Lister *lister, i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){
 if(command_ids == 0){ command_id_count = command_one_past_last_id; }

 for(i32 i=0; i<command_id_count; i++){
  i32 j = (command_ids ? command_ids[i] : i);
  j = (((0)>(j))?(0):(((command_one_past_last_id)<(j))?(command_one_past_last_id):(j)));

  Custom_Command_Function *proc = fcoder_metacmd_table[j].proc;

  Command_Trigger_List triggers = map_get_triggers_recursive(arena, status_rule->mapping, status_rule->map_id, proc);

  List_String_Const_u8 list = {};
  if(triggers.first == 0){
   string_list_push(arena, &list, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
  }
  for(Command_Trigger *node=triggers.first; node; node=node->next){
   command_trigger_stringize(arena, &list, node);
   if(node->next){
    string_list_push(arena, &list, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
   }
  }

  String_Const_u8 key_bind = string_list_flatten(arena, list);
  String_Const_u8 description = SCu8(fcoder_metacmd_table[j].description);
  String_Const_u8 status = push_stringf(arena, "%.*s\n%.*s", (i32)(key_bind).size, (char*)(key_bind).str, (i32)(description).size, (char*)(description).str);

  lister_add_item(lister, SCu8(fcoder_metacmd_table[j].name), status, (void*)proc, 0);
 }
}

static Custom_Command_Function*
vim_get_command_from_user(Application_Links *app, i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){

 Scratch_Block scratch(app);
 Lister_Block lister(app, scratch);
 vim_lister_set_default_handlers(lister);
 lister_set_query(lister, SCu8((u8*)("Command:"), (u64)(sizeof("Command:") - 1)));
 vim__fill_command_lister(scratch, lister, command_ids, command_id_count, status_rule);


 vim_reset_bottom_text();
 string_append(&vim_bot_text, SCu8((u8*)(":"), (u64)(sizeof(":") - 1)));

 Lister_Result l_result = vim_run_lister(app, lister);

 return (l_result.canceled ? 0 : (Custom_Command_Function *)l_result.user_data);
}

CUSTOM_COMMAND(vim_command_mode, "4coder_vim/4coder_vim_lists.cpp", 51, UI)
CUSTOM_DOC("Enter Command Mode")
{
 View_ID view = get_this_ctx_view(app, Access_Always);
 if(view == 0){ return; }
 Command_Lister_Status_Rule rule = {};
 Buffer_ID buffer = view_get_buffer(app, view, Access_Visible);
 Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
 Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
 if(map_id_ptr){
  rule = command_lister_status_bindings(&framework_mapping, *map_id_ptr);
 }else{
  rule = command_lister_status_descriptions();
 }

 Custom_Command_Function *func = vim_get_command_from_user(app, 0, 0, &rule);
 if(func != 0){
  view_enqueue_command_function(app, view, func);
 }
}

static void
vim_generate_hot_directory_file_list(Application_Links *app, Lister *lister){
 Scratch_Block scratch(app, lister->arena);

 Temp_Memory temp = begin_temp(lister->arena);
 String_Const_u8 hot = push_hot_directory(app, lister->arena);
 if (!character_is_slash(string_get_character(hot, hot.size - 1))){
  hot = push_u8_stringf(lister->arena, "%.*s/", (i32)(hot).size, (char*)(hot).str);
 }
 lister_set_text_field(lister, hot);
 lister_set_key(lister, string_front_of_path(hot));

 File_List file_list = system_get_file_list(scratch, hot);
 end_temp(temp);

 File_Info **one_past_last = file_list.infos + file_list.count;

 lister_begin_new_item_set(app, lister);

 hot = push_hot_directory(app, lister->arena);
 (linalloc_align((lister->arena), (8)));
 if (hot.str != 0){
  String_Const_u8 empty_string = SCu8((u8*)(""), (u64)(sizeof("") - 1));
  Lister_Prealloced_String empty_string_prealloced = lister_prealloced(empty_string);
  for (File_Info **info = file_list.infos;
    info < one_past_last;
    info += 1){
   if (!((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
   String_Const_u8 file_name = push_u8_stringf(lister->arena, "%.*s/",
              (i32)((**info).file_name).size, (char*)((**info).file_name).str);
   lister_add_item(lister, lister_prealloced(file_name), empty_string_prealloced, file_name.str, 0);
   ;
  }

  for (File_Info **info = file_list.infos;
    info < one_past_last;
    info += 1){
   if (((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
   String_Const_u8 file_name = push_string_copy(lister->arena, (**info).file_name);
   char *is_loaded = "";
   char *status_flag = "";

   Buffer_ID buffer = {};

   {
    Temp_Memory path_temp = begin_temp(lister->arena);
    List_String_Const_u8 list = {};
    string_list_push(lister->arena, &list, hot);
    string_list_push_overlap(lister->arena, &list, '/', (**info).file_name);
    String_Const_u8 full_file_path = string_list_flatten(lister->arena, list);
    buffer = get_buffer_by_file_name(app, full_file_path, Access_Always);
    end_temp(path_temp);
   }

   if (buffer != 0){
    is_loaded = "LOADED";
    Dirty_State dirty = buffer_get_dirty_state(app, buffer);
    switch (dirty){
     case DirtyState_UnsavedChanges: status_flag = " *"; break;
     case DirtyState_UnloadedChanges: status_flag = " !"; break;
     case DirtyState_UnsavedChangesAndUnloadedChanges: status_flag = " *!"; break;
    }
   }
   String_Const_u8 status = push_u8_stringf(lister->arena, "%s%s", is_loaded, status_flag);
   lister_add_item(lister, lister_prealloced(file_name), lister_prealloced(status), file_name.str, 0);
  }
 }
}

static Lister_Choice*
vim_get_choice_from_user(Application_Links *app, String_Const_u8 query, Lister_Choice_List list){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    for(Lister_Choice *choice = list.first; choice; choice = choice->next){
        u64 code_size = sizeof(choice->key_code);
        void *extra = lister_add_item(lister, choice->string, choice->status, choice, code_size);
        block_copy(extra, &choice->key_code, code_size);
    }
    lister_set_query(lister, query);
    Lister_Handlers handlers = {};
    handlers.navigate = lister__navigate__default;
    handlers.key_stroke = lister__key_stroke__choice_list;
    lister_set_handlers(lister, &handlers);

    Lister_Result l_result = vim_run_lister(app, lister);
    Lister_Choice *result = 0;
    if(!l_result.canceled){
        result = (Lister_Choice*)l_result.user_data;
    }
    return result;
}

static b32
vim_query_create_folder(Application_Links *app, String_Const_u8 folder_name){
 Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);

    String_Const_u8 message = push_u8_stringf(scratch, "Create the folder %.*s?", (i32)(folder_name).size, (char*)(folder_name).str);
    Lister_Choice *choice = vim_get_choice_from_user(app, message, list);

 b32 did_create_folder = false;
    if(choice != 0){
        switch(choice->user_data){
            case SureToCreateFolder_No:{} break;

            case SureToCreateFolder_Yes:{
    String_Const_u8 hot = push_hot_directory(app, scratch);
                String_Const_u8 fixed_folder_name = push_string_copy(scratch, folder_name);
                for(i32 i=0; i<fixed_folder_name.size; i++){
     if(fixed_folder_name.str[i] == '/'){ fixed_folder_name.str[i] = '\\'; }
    }
                if(fixed_folder_name.size > 0){
                    String_Const_u8 cmd = push_u8_stringf(scratch, "mkdir %.*s", (i32)(fixed_folder_name).size, (char*)(fixed_folder_name).str);
                    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
                    did_create_folder = true;
    }
            } break;
        }
    }

    return(did_create_folder);
}

CUSTOM_COMMAND(vim_interactive_open_or_new, "4coder_vim/4coder_vim_lists.cpp", 197, UI)
CUSTOM_DOC("Interactively open a file out of the file system.")
{
 for(;;){
  Scratch_Block scratch(app);
  View_ID view = get_this_ctx_view(app, Access_Always);
  File_Name_Result result = vim_get_file_name_from_user(app, scratch, SCu8("Open/New:"), view);
  if(result.canceled || result.path_in_text_field.str == 0){ break; }

  String_Const_u8 file_name = result.file_name_activated;
  if(file_name.size == 0){ file_name = result.file_name_in_text_field; }

  String_Const_u8 path = result.path_in_text_field;
  String_Const_u8 full_file_name =
   push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

  if(result.is_folder){
   set_hot_directory(app, full_file_name);
   continue;
  }

  if(character_is_slash(file_name.str[file_name.size - 1])){
   File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
   if((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
    set_hot_directory(app, full_file_name);
    continue;
   }
   if(string_looks_like_drive_letter(file_name)){
    set_hot_directory(app, file_name);
    continue;
   }
   if(vim_query_create_folder(app, full_file_name)){
    set_hot_directory(app, full_file_name);
    continue;
   }else{
    set_hot_directory(app, result.path_in_text_field);
    continue;
   }
   break;
  }

  Buffer_ID buffer = create_buffer(app, full_file_name, 0);
  if(buffer != 0){ view_set_buffer(app, view, buffer, 0); }
  break;
 }
}


CUSTOM_COMMAND(vim_theme_lister, "4coder_vim/4coder_vim_lists.cpp", 245, UI)
CUSTOM_DOC("Opens an interactive list of all registered themes.")
{
 Color_Table_List *color_table_list = &global_theme_list;

 Scratch_Block scratch(app);
 Lister_Block lister(app, scratch);
 vim_lister_set_default_handlers(lister);
 vim_reset_bottom_text();

 lister_add_item(lister, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)), SCu8((u8*)(""), (u64)(sizeof("") - 1)),
     (void*)&default_color_table, 0);

 for(Color_Table_Node *node = color_table_list->first; node; node = node->next){
  lister_add_item(lister, node->name, SCu8((u8*)(""), (u64)(sizeof("") - 1)), (void*)&node->table, 0);
 }


 string_append(&vim_bot_text, SCu8((u8*)("Theme:"), (u64)(sizeof("Theme:") - 1)));

 Lister_Result l_result = vim_run_lister(app, lister);

 Color_Table *result = 0;
 if(!l_result.canceled){ result = (Color_Table*)l_result.user_data; }

 if(result != 0){ active_color_table = *result; }
}

CUSTOM_COMMAND(vim_switch_lister, "4coder_vim/4coder_vim_lists.cpp", 273, UI)
CUSTOM_DOC("Opens an interactive list of all loaded buffers.")
{
 Lister_Handlers handlers = lister_get_default_handlers();
 handlers.refresh = generate_all_buffers_list;
 handlers.backspace = vim_lister__backspace;
 Scratch_Block scratch(app);

 vim_reset_bottom_text();
 string_append(&vim_bot_text, SCu8((u8*)("Switch:"), (u64)(sizeof("Switch:") - 1)));

 Lister_Result l_result = vim_run_lister_with_refresh_handler(app, scratch, SCu8((u8*)("Switch:"), (u64)(sizeof("Switch:") - 1)), handlers);
 Buffer_ID buffer = 0;
 if (!l_result.canceled){
  buffer = (Buffer_ID)(((u8*)(l_result.user_data) - (u8*)(0)));
 }
 if (buffer != 0){
  View_ID view = get_this_ctx_view(app, Access_Always);
  view_set_buffer(app, view, buffer, 0);
 }
}


static Jump_Lister_Result
vim_get_jump_index_from_user(Application_Links *app, Marker_List *list,
                             String_Const_u8 query){
 Jump_Lister_Result result = {};
 if (list != 0){
  Scratch_Block scratch(app);
  Lister_Block lister(app, scratch);
  lister_set_query(lister, query);
  lister_set_default_handlers(lister);

  Buffer_ID list_buffer = list->buffer_id;

  i32 option_count = list->jump_count;
  Managed_Object stored_jumps = list->jump_array;
  for (i32 i = 0; i < option_count; i += 1){
   Sticky_Jump_Stored stored = {};
   managed_object_load_data(app, stored_jumps, i, 1, &stored);
   String_Const_u8 line = push_buffer_line(app, scratch, list_buffer,
             stored.list_line);
   lister_add_item(lister, line, SCu8(), (void*)(((u8*)0) + i), 0);
  }

  Lister_Result l_result = vim_run_lister(app, lister);
  if (!l_result.canceled){
   result.success = true;
   result.index = (i32)((u8*)(l_result.user_data) - (u8*)(0));
  }
 }

 return(result);
}

static Jump_Lister_Result
vim_get_jump_index_from_user(Application_Links *app, Marker_List *list, char *query){
 return(vim_get_jump_index_from_user(app, list, SCu8(query)));
}


CUSTOM_COMMAND(vim_list_all_functions_current_buffer_lister, "4coder_vim/4coder_vim_lists.cpp", 334, UI)
CUSTOM_DOC("Creates a lister of locations that look like function definitions and declarations in the buffer.")
{
 Heap *heap = &global_heap;
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 if (buffer != 0){
  list_all_functions(app, buffer);
  view = get_active_view(app, Access_Always);
  buffer = view_get_buffer(app, view, Access_Always);
  Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
  if (list != 0){
   Jump_Lister_Result jump = vim_get_jump_index_from_user(app, list, "Function:");
   jump_to_jump_lister_result(app, view, list, &jump);
  }
 }
}

CUSTOM_COMMAND(vim_proj_cmd_lister, "4coder_vim/4coder_vim_lists.cpp", 352, UI)
CUSTOM_DOC("Opens an interactive list of all project commands.")
{
 Variable_Handle prj_var = vars_read_key(vars_get_root(), vars_save_string(SCu8((u8*)("prj_config"), (u64)(sizeof("prj_config") - 1))));

 Scratch_Block scratch(app);
 Lister_Block lister(app, scratch);

 Lister_Handlers handlers = lister_get_default_handlers();
 handlers.backspace = vim_lister__backspace;
 lister_set_handlers(lister, &handlers);

 vim_reset_bottom_text();
 string_append(&vim_bot_text, SCu8((u8*)("Command:"), (u64)(sizeof("Command:") - 1)));

 Variable_Handle cmd_list_var = vars_read_key(prj_var, vars_save_string(SCu8((u8*)("commands"), (u64)(sizeof("commands") - 1))));
 String_ID os_id = vars_save_string(SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));

 i32 i=1;
 for(Variable_Handle cmd=vars_first_child(cmd_list_var); !vars_is_nil(cmd); cmd=vars_next_sibling(cmd), i++){
  Variable_Handle os_cmd = vars_read_key(cmd, os_id);
  if(!vars_is_nil(os_cmd)){
   String8 cmd_name = vars_key_from_var(scratch, cmd);
   String8 os_cmd_str = vars_string_from_var(scratch, os_cmd);
   u8 *f_str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(3), SCu8((u8*)("4coder_vim/4coder_vim_lists.cpp" ":" "376" ":"), (u64)(sizeof("4coder_vim/4coder_vim_lists.cpp" ":" "376" ":") - 1)))));
   f_str[0] = 'F';
   f_str[1] = '0' + u8(i%10);
   f_str[2] = '0' + u8(i/10);

   lister_add_item(lister, cmd_name, SCu8(f_str, 2+(i>9)), cmd.ptr, 0);
  }
 }

 Variable_Handle prj_cmd = vars_get_nil();
 Lister_Result l_result = vim_run_lister(app, lister);
 if(!l_result.canceled && l_result.user_data){
  prj_cmd.ptr = (Variable*)l_result.user_data;
 }
 if(!vars_is_nil(prj_cmd)){
  prj_exec_command(app, prj_cmd);
 }
}

static void vim_jump_navigate(Application_Links *app, View_ID view, Lister *lister, i32 index_delta){
 lister__navigate__default(app, view, lister, index_delta);

 Managed_Scope scope = view_get_managed_scope(app, view);
 Vim_Jump_List *jump_list = ((Vim_Jump_List*)managed_scope_get_attachment((app), (scope), (vim_view_jumps), sizeof(Vim_Jump_List)));
 i32 index = i32(((u8*)(lister_get_user_data(lister, lister->raw_item_index)) - (u8*)(0)));
 if(!((0) <= (index) && (index) < (((sizeof(jump_list->markers))/(sizeof(*jump_list->markers)))))){ return; }
 Point_Stack_Slot *slot = &jump_list->markers[index];
 view_set_buffer(app, view, slot->buffer, SetBuffer_KeepOriginalGUI);
 view_set_cursor_and_preferred_x(app, view, seek_pos(slot->object));
 center_view(app);
}


CUSTOM_COMMAND(vim_jump_lister, "4coder_vim/4coder_vim_lists.cpp", 409, UI)
CUSTOM_DOC("Opens an interactive lists of the views jumps")
{
 Scratch_Block scratch(app);
 Lister_Block lister(app, scratch);
 vim_lister_set_default_handlers(lister);
 lister.lister.current->handlers.navigate = vim_jump_navigate;

 View_ID view = get_active_view(app, Access_ReadVisible);
 Managed_Scope scope = view_get_managed_scope(app, view);
 Vim_Jump_List *jump_list = ((Vim_Jump_List*)managed_scope_get_attachment((app), (scope), (vim_view_jumps), sizeof(Vim_Jump_List)));
 for(i32 i=jump_list->index; i != jump_list->bot; i=((i + ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers)))-1) % ((sizeof(jump_list->markers))/(sizeof(*jump_list->markers))))){
  Point_Stack_Slot *slot = jump_list->markers + i;
  i64 line = get_line_number_from_pos(app, slot->buffer, i64(slot->object));

  String_Const_u8 line_text = push_buffer_line(app, scratch, slot->buffer, line);
  b32 blank = true;
  for(i32 j=0; j<line_text.size; j++){
   if(!character_is_whitespace(line_text.str[j])){ blank = false; break; }
  }
  if(blank){ line_text = SCu8((u8*)("*blank*"), (u64)(sizeof("*blank*") - 1)); }
  line_text.size = (((line_text.size)<(20))?(line_text.size):(20));
  String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, slot->buffer);
  String_Const_u8 text = push_stringf(scratch, "[%.*s]:(%d)", (i32)(unique_name).size, (char*)(unique_name).str, line);
  lister_add_item(lister, text, line_text, (void*)(((u8*)0) + i), 0);
 }
 Lister_Result l_result = vim_run_lister(app, lister);
 i32 index = (!l_result.canceled ? i32(((u8*)(l_result.user_data) - (u8*)(0))) : jump_list->index);
 vim_set_jump(app, view, jump_list, index);
}


static b32
vim_do_buffer_close_user_check(Application_Links *app, Buffer_ID buffer, View_ID view){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
    lister_choice(scratch, &list, "(S)ave", "", KeyCode_S, SureToKill_Save);

    Lister_Choice *choice = vim_get_choice_from_user(app, SCu8((u8*)("There are unsaved changes, close anyway?"), (u64)(sizeof("There are unsaved changes, close anyway?") - 1)), list);

    b32 do_kill = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToKill_No:{} break;

            case SureToKill_Yes:{ do_kill = true; } break;

            case SureToKill_Save:{
                String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
                if(buffer_save(app, buffer, file_name, BufferSave_IgnoreDirtyFlag)){
                    do_kill = true;
                }else{

                    String_Const_u8 str = push_u8_stringf(scratch, "Did not close '%.*s' because it did not successfully save.", (i32)(file_name).size, (char*)(file_name).str);

                    print_message(app, str);
                }
            } break;
        }
    }

    return do_kill;
}

static Buffer_Kill_Result
vim_try_buffer_kill(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Buffer_Kill_Flag flags = 0;
 Buffer_Kill_Result result = buffer_kill(app, buffer, flags);
 if(result == BufferKillResult_Dirty){
  if(vim_do_buffer_close_user_check(app, buffer, view)){
   result = buffer_kill(app, buffer, BufferKill_AlwaysKill);
  }
 }
 return result;
}

static b32
vim_do_4coder_close_user_check(Application_Links *app, View_ID view){
 Scratch_Block scratch(app);
 Lister_Choice_List list = {};
 lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
 lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
 lister_choice(scratch, &list, "(S)ave all and close", "", KeyCode_S, SureToKill_Save);


 Lister_Choice *choice = vim_get_choice_from_user(app, SCu8((u8*)("There are one or more buffers with unsave changes, close anyway?"), (u64)(sizeof("There are one or more buffers with unsave changes, close anyway?") - 1)), list);


 b32 do_exit = false;
 if(choice != 0){
  switch(choice->user_data){
   case SureToKill_No:{} break;

   case SureToKill_Yes:{
    allow_immediate_close_without_checking_for_changes = true;
    do_exit = true;
   } break;

   case SureToKill_Save:{
    save_all_dirty_buffers(app);
    allow_immediate_close_without_checking_for_changes = true;
    do_exit = true;
   } break;
  }
 }

 return do_exit;
}

static void
vim_reload_external_changes_lister(Application_Links *app, Buffer_ID buffer){
 Scratch_Block scratch(app);
 Lister_Choice_List list = {};
 String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer);

 if(buffer_name.size == 0){ return; }
 lister_choice(scratch, &list, buffer_name, "", KeyCode_Q, u64(0));
 lister_choice(scratch, &list, "(L)oad external changes" , "", KeyCode_L, u64(1));
 lister_choice(scratch, &list, "(K)eep current buffer" , "", KeyCode_K, u64(0));


 Lister_Choice *choice = vim_get_choice_from_user(app, SCu8((u8*)("External changes have been detected. Reload buffer from file?"), (u64)(sizeof("External changes have been detected. Reload buffer from file?") - 1)), list);


 if(choice != 0 && choice->user_data){
  buffer_reopen(app, buffer, 0);
 }
}


CUSTOM_COMMAND(vim_file_externally_modified, "4coder_vim/4coder_vim_lists.cpp", 543, Normal){
 User_Input input = get_current_input(app);
 if(match_core_code(&input, CoreCode_FileExternallyModified)){
  print_message(app, input.event.core.string);
  vim_reload_external_changes_lister(app, input.event.core.id);
 }
}
# 86 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_search.cpp" 1

static i64 vim_pattern_inner_v(Application_Links *app, Buffer_Seek_String_Flags seek_flags){
 String_u8 *pattern = &vim_registers.search.data;
 if(pattern->size == 0){ return -1; }
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 i64 new_pos = -1;
 seek_string(app, buffer, pos, 0, 0, pattern->string, &new_pos, seek_flags);
 return new_pos;

}

static void vim_in_pattern_inner(Application_Links *app, Buffer_Seek_String_Flags seek_flags){
 String_u8 *pattern = &vim_registers.search.data;
 i64 new_pos = vim_pattern_inner_v(app, seek_flags);
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 buffer_size = buffer_get_size(app, buffer);
 if(new_pos > 0 && new_pos != buffer_size){
  vim_push_jump(app, view);
  Vim_Motion_Block vim_motion_block(app, new_pos + pattern->size-1);
  view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
 }
}

static void vim_to_pattern_inner(Application_Links *app, Buffer_Seek_String_Flags seek_flags){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 buffer_size = buffer_get_size(app, buffer);
 i64 new_pos = vim_pattern_inner_v(app, seek_flags);
 if(new_pos > 0 && new_pos != buffer_size){
  vim_push_jump(app, view);
  Vim_Motion_Block vim_motion_block(app);
  view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
 }
}


static void
vim_start_search_inner(Application_Links *app, Scan_Direction start_direction){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 if(!buffer_exists(app, buffer)){ return; }

 i64 buffer_size = buffer_get_size(app, buffer);

 Vec2_f32 old_margin = {};
 Vec2_f32 old_push_in = {};
 view_get_camera_bounds(app, view, &old_margin, &old_push_in);

 Vec2_f32 margin = old_margin;
 margin.y = (((200.f)>(margin.y))?(200.f):(margin.y));
 view_set_camera_bounds(app, view, margin, old_push_in);

 Scan_Direction direction = start_direction;
 i64 pos = view_get_cursor_pos(app, view);


 vim_use_bottom_cursor = true;
 String_Const_u8 prefix = (start_direction == Scan_Forward ? SCu8((u8*)("/"), (u64)(sizeof("/") - 1)) : SCu8((u8*)("?"), (u64)(sizeof("?") - 1)));
 vim_set_bottom_text(prefix);
 u8 *dest = vim_bot_text.str + vim_bot_text.size;
 u64 base_size, after_size;
 base_size = after_size = vim_bot_text.size;

 Vim_Register *reg = &vim_registers.search;
 if(reg->data.size < 256){ vim_realloc_string(&reg->data, 0); }
 reg->data.size = 0;
 String_u8 *query = &reg->data;

 f32 prev_offset = vim_nxt_filebar_offset;

 i64 match_size = 0;
 User_Input in = {};
 for(;;){
  if(vim_nxt_filebar_offset == 0.f){ vim_nxt_filebar_offset = 0.1f; }
  animate_in_n_milliseconds(app, 0);
  vim_set_bottom_text(prefix);
  block_copy(dest, query->str, query->size);
  vim_bot_text.size = after_size + query->size;

  in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if(in.abort){ query->size = 0; break; }

  String_Const_u8 string = to_writable(&in);

  b32 string_change = false;
  if(match_key_code(&in, KeyCode_Return)){
   reg->flags |= (REGISTER_Set|REGISTER_Updated);
   break;
  }
  else if(string.str != 0 && string.size > 0){
   string_append(query, string);
   string_change = true;
  }
  else if(match_key_code(&in, KeyCode_Backspace)){
   u64 old_size = query->size;
   if(has_modifier(&in.event.key.modifiers, KeyCode_Control)){
    if(has_modifier(&in.event.key.modifiers, KeyCode_Shift)){
     query->string.size = 0;
    }else{
     query->string = ctrl_backspace_utf8(query->string);
    }
   }else{
    query->string = backspace_utf8(query->string);
   }
   string_change = old_size != query->size;
  }
  else{ leave_current_input_unhandled(app); }

  b32 do_scan_action = false;
  if(string_change){
   reg->flags |= (REGISTER_Set|REGISTER_Updated);
   vim_update_registers(app);
   i64 new_pos = 0;
   switch(direction){
    case Scan_Forward:{

     seek_string_insensitive_forward(app, buffer, pos - 1, 0, query->string, &new_pos);
     if(new_pos < buffer_size){
      pos = new_pos;
      match_size = query->string.size;
     }
    } break;

    case Scan_Backward:{
     seek_string_insensitive_backward(app, buffer, pos + 1, 0, query->string, &new_pos);
     if(new_pos >= 0){
      pos = new_pos;
      match_size = query->string.size;
     }
    } break;
   }
   if(((0) <= (new_pos) && (new_pos) < (buffer_size))){
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    isearch__update_highlight(app, view, Ii64_size(new_pos, match_size));
   }
  }
  else if(do_scan_action){

   switch(direction){
    case Scan_Forward:{
     i64 new_pos = 0;
     seek_string_insensitive_forward(app, buffer, pos, 0, query->string, &new_pos);
     if (new_pos < buffer_size){
      pos = new_pos;
      match_size = query->string.size;
     }
    } break;

    case Scan_Backward:{
     i64 new_pos = 0;
     seek_string_insensitive_backward(app, buffer, pos, 0, query->string, &new_pos);
     if(new_pos >= 0){
      pos = new_pos;
      match_size = query->string.size;
     }
    } break;
   }
  }

 }

 view_disable_highlight_range(app, view);

 vim_reset_bottom_text();
 vim_use_bottom_cursor = false;
 vim_nxt_filebar_offset = prev_offset;
 view_set_camera_bounds(app, view, old_margin, old_push_in);
}

static void vim_clear_search(Application_Links *app){
 vim_registers.search.data.size = 0;
 vim_registers.search.flags &= (~REGISTER_Set);
 vim_update_registers(app);
}

static void vim_start_search_forward(Application_Links *app){ vim_start_search_inner(app, Scan_Forward); }
static void vim_start_search_backward(Application_Links *app){ vim_start_search_inner(app, Scan_Backward); }

static void vim_to_next_pattern(Application_Links *app){ vim_to_pattern_inner(app, 0); }
static void vim_to_prev_pattern(Application_Links *app){ vim_to_pattern_inner(app, BufferSeekString_Backward); }

static void vim_in_next_pattern(Application_Links *app){ vim_in_pattern_inner(app, 0); }
static void vim_in_prev_pattern(Application_Links *app){ vim_in_pattern_inner(app, BufferSeekString_Backward); }

static void vim_search_identifier(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 Range_i64 range = enclose_pos_alpha_numeric_underscore(app, buffer, pos);
 vim_state.params.selected_reg = &vim_registers.search;
 vim_request_vtable[REQUEST_Yank](app, view, buffer, range);
 vim_default_register();
}
# 87 "4coder_vim/4coder_vim_include.h" 2

# 1 "4coder_vim/4coder_folds.hpp" 1
# 22 "4coder_vim/4coder_folds.hpp"
CUSTOM_ID(attachment, buffer_folds);

struct Fold_Params{
 Range_i64 range;
 f32 cur_active;
 b32 active;
};




struct Fold_List{
 Fold_Params *folds;
 i32 fold_count, fold_cap;
};



static void fold_invalidate_buffer(Application_Links *app, Buffer_ID buffer){
 Dirty_State prev_state = buffer_get_dirty_state(app, buffer);
 buffer_replace_range(app, buffer, Ii64(0,0), string_u8_empty);
 undo(app);
 buffer_set_dirty_state(app, buffer, prev_state);
}

static void fold_toggle(Application_Links *app, View_ID view, Buffer_ID buffer, i64 pos){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }

 Range_i64 line_range = Ii64(view_get_cursor_pos(app, view));
 const i32 N = fold_list->fold_count;
 for(i32 i=0; i<N; i++){
  Fold_Params *fold = fold_list->folds + (N-1-i);
  if(range_overlap(fold->range, line_range)){
   fold->active ^= 1;
   if(!1){
    fold->cur_active = f32(fold->active);
    fold_invalidate_buffer(app, buffer);
   }
   view_set_cursor(app, view, seek_pos(fold->range.min));
   break;
  }
 }
}

static void fold_push(Application_Links *app, Buffer_ID buffer, Range_i64 range){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }
 if(fold_list->fold_count+1 == fold_list->fold_cap){
  Base_Allocator *allocator = managed_scope_allocator(app, scope);
  fold_list->fold_cap = i32(1.5*fold_list->fold_cap);
  String_Const_u8 new_data = base_allocate__inner((allocator), (fold_list->fold_cap), SCu8((u8*)("4coder_vim/4coder_folds.hpp" ":" "75" ":"), (u64)(sizeof("4coder_vim/4coder_folds.hpp" ":" "75" ":") - 1)));
  if(new_data.size == 0){ return; }
  block_copy(new_data.str, fold_list->folds, fold_list->fold_count*sizeof(Fold_Params));
  base_free(allocator, fold_list->folds);
  fold_list->folds = (Fold_Params *)new_data.str;
 }

 range.min = get_line_pos_range(app, buffer, get_line_number_from_pos(app, buffer, range.min)).min;
 range.max = get_line_pos_range(app, buffer, get_line_number_from_pos(app, buffer, range.max)).max-1;

 Fold_Params *fold = fold_list->folds;
 i32 i=0;
 for(; i < fold_list->fold_count; i++){
  if(range_contains(range, fold->range.min) && range_contains(range, fold->range.max)){
   break;
  }else if(range_overlap(fold->range, range)){
   fold->range = range_union(fold->range, range);
  }else{
   break;
  }

  fold++;
 }

 block_copy(fold+1, fold, (fold_list->fold_count - i)*sizeof(Fold_Params));
 *fold = Fold_Params{ range, 0.f, 1 };
 fold_list->fold_count++;
 if(!1){
  fold->cur_active = f32(fold->active);
  fold_invalidate_buffer(app, buffer);
 }
}

static void fold_pop_inner(Application_Links *app, Buffer_ID buffer, Fold_List *fold_list, i32 index){
 Fold_Params *fold = fold_list->folds + index;
 u64 size = (fold_list->fold_count - index - 1)*sizeof(Fold_Params);
 block_copy(fold, fold+1, size);
 fold_list->fold_count--;
 fold_invalidate_buffer(app, buffer);
}

static void fold_pop(Application_Links *app, Buffer_ID buffer, i64 pos){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }
 const i32 N = fold_list->fold_count;
 for(i32 i=0; i<N; i++){
  i32 index = N-1-i;
  Fold_Params *fold = fold_list->folds + index;
  if(range_contains(fold->range, pos)){
   fold_pop_inner(app, buffer, fold_list, index);
   break;
  }
 }
}

CUSTOM_COMMAND(fold_clear, "4coder_vim/4coder_folds.hpp", 131, Normal)
CUSTOM_DOC("Clears all folds in buffer")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list){
  fold_list->fold_count = 0;
  fold_invalidate_buffer(app, buffer);
 }
}

CUSTOM_COMMAND(fold_pop_cursor, "4coder_vim/4coder_folds.hpp", 144, Normal)
CUSTOM_DOC("Pops fold at cursor")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 fold_pop(app, buffer, view_get_cursor_pos(app, view));
}

CUSTOM_COMMAND(fold_toggle_cursor, "4coder_vim/4coder_folds.hpp", 152, Normal)
CUSTOM_DOC("Toggles fold at cursor")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 fold_toggle(app, view, buffer, view_get_cursor_pos(app, view));
}

CUSTOM_COMMAND(fold_range, "4coder_vim/4coder_folds.hpp", 160, Normal)
CUSTOM_DOC("Folds cursor mark range")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 fold_push(app, buffer, get_view_range(app, view));
}


static void fold_draw(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }
 Rect_f32 region = text_layout_region(app, text_layout_id);

 for(i32 i=0; i<fold_list->fold_count; i++){
  Fold_Params *fold = fold_list->folds + i;

  Range_i64 range = fold->range;
  i64 line_num = get_line_number_from_pos(app, buffer, range.min);

  if(fold->active){
   ARGB_Color folding_color = fcolor_resolve(fcolor_id(defcolor_text_default));
   ARGB_Color fold_color = argb_color_blend(folding_color, fold->cur_active, folding_color & 0x00FFFFFF);

   Range_i64 line_range = get_line_pos_range(app, buffer, line_num);
   Range_f32 line_range_pixels = text_layout_line_on_screen(app, text_layout_id, line_num);
   if(line_range_pixels.min == line_range_pixels.max){
    line_range = {};
   }else{
    range.min = line_range.max;
   }

   paint_text_color(app, text_layout_id, range, fold_color);
   paint_text_color(app, text_layout_id, line_range, fcolor_resolve(fcolor_id(defcolor_ghost_character)));
# 203 "4coder_vim/4coder_folds.hpp"
  }else{
   i32 nest_level = 1;
   for(i32 j=i-1; j>=0; j--){
    Fold_Params *prev_fold = fold_list->folds + j;
    if(prev_fold->range.min <= fold->range.min && fold->range.max <= prev_fold->range.max){
     nest_level++;
    }
   }
   Rect_f32 rect = rect_split_left_right(region, nest_level*3.f).a;
   Rect_f32 prev_clip = draw_set_clip(app, rect);
   Range_i64 line_nums = Ii64(get_line_number_from_pos(app, buffer, fold->range.min),
            get_line_number_from_pos(app, buffer, fold->range.max));
   draw_line_highlight(app, text_layout_id, line_nums, fcolor_id(defcolor_highlight));
   draw_set_clip(app, prev_clip);
  }

  Range_f32 y = text_layout_line_on_screen(app, text_layout_id, line_num);
  if(range_size(y) > 0.f){
   Range_f32 x = rect_range_x(region);
   x.max *= fold->cur_active;
   draw_rectangle_fcolor(app, Rf32(x, y), 0.f, fcolor_id(defcolor_highlight));
  }
 }
}

static Layout_Item_List fold_items(Application_Links *app, Buffer_ID buffer, Layout_Item_List list){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list_ = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list_ == 0){ return list; }
 Fold_List fold_list = *fold_list_;


 Range_i64 range = list.input_index_range;
 f32 line_height = get_face_metrics(app, get_face_id(app, buffer)).line_height;
 i64 base_line_num = get_line_number_from_pos(app, buffer, range.min);

 for(i32 i=0; i < fold_list.fold_count; i++){
  Fold_Params *fold = fold_list.folds + i;
  if(fold->cur_active > 0.1f && range_overlap(fold->range, range)){
   i64 fold_line_num = get_line_number_from_pos(app, buffer, fold->range.min);

   if(base_line_num == fold_line_num){ break; }
   list.height *= (1.f - fold->cur_active);

   Layout_Item_Block *block = list.first;
   for(;;){
    for(i32 j=0; j < block->item_count; j++){
     block->items[j].rect.x0 -= fold->cur_active*line_height;
     block->items[j].rect.x1 -= fold->cur_active*line_height;


    }

    if(block == list.last || block->next == 0){ break; }
    block = block->next;
   }
   break;
  }
 }

 return list;
}

static void fold_tick(Application_Links *app, Frame_Info frame_info){

 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }
 for(i32 i=0; i < fold_list->fold_count; i++){
  Fold_Params *fold = fold_list->folds + i;
  f32 nxt_active = f32(fold->active);
  f32 diff = (nxt_active - fold->cur_active);
  if(fabs(diff) > 0.01f){
   fold->cur_active += diff*frame_info.animation_dt*30.f;
   fold_invalidate_buffer(app, buffer);
   animate_in_n_milliseconds(app, 0);
  }else{
   fold->cur_active = nxt_active;
  }
 }

}

static void fold_begin_buffer_inner(Application_Links *app, Buffer_ID buffer_id){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
 Base_Allocator *allocator = managed_scope_allocator(app, scope);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }
 String_Const_u8 fold_data = base_allocate__inner((allocator), (10*sizeof(Fold_Params)), SCu8((u8*)("4coder_vim/4coder_folds.hpp" ":" "293" ":"), (u64)(sizeof("4coder_vim/4coder_folds.hpp" ":" "293" ":") - 1)));
 fold_list->folds = (Fold_Params *)fold_data.str;
 fold_list->fold_cap = 10;
 fold_list->fold_count = 0;
}

static void fold_buffer_edit_range_inner(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range){
 Range_i64 old_range = Ii64(old_cursor_range.min.pos, old_cursor_range.max.pos);
 i64 text_shift = replace_range_shift(old_range, range_size(new_range));

 i64 edit_begin = old_cursor_range.min.pos;
 i64 edit_end = old_cursor_range.max.pos;

 Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
 Fold_List *fold_list = ((Fold_List*)managed_scope_get_attachment((app), (scope), (buffer_folds), sizeof(Fold_List)));
 if(fold_list == 0){ return; }

 for(i32 i=0; i<fold_list->fold_count; i++){
  Fold_Params *fold = fold_list->folds + i;
  Range_i64 fold_range = fold->range;

  if(fold_range.max <= edit_begin && fold_range.max <= edit_end){

   continue;
  }else if(edit_begin <= fold_range.min && edit_end <= fold_range.min){

   fold_range.min += text_shift;
   fold_range.max += text_shift;
  }else if(range_contains(fold_range, edit_begin) && range_contains(fold_range, edit_end)){

   fold_range.max += text_shift;
  }else{

   fold_range = {};
  }

  if(fold_range.max <= fold_range.min){
   fold_pop_inner(app, buffer_id, fold_list, i);
   i--;
   continue;
  }

  fold->range.min = get_line_pos_range(app, buffer_id, get_line_number_from_pos(app, buffer_id, fold_range.min)).min;
  fold->range.max = get_line_pos_range(app, buffer_id, get_line_number_from_pos(app, buffer_id, fold_range.max)).max;
 }
}

static Layout_Item_List fold_layout_virt_indent_index_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
 return fold_items(app, buffer, layout_virt_indent_index_generic(app, arena, buffer, range, face, width));
}
static Layout_Item_List fold_layout_virt_indent_literal_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
 return fold_items(app, buffer, layout_virt_indent_literal_generic(app, arena, buffer, range, face, width));
}
static Layout_Item_List fold_layout_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
 return fold_items(app, buffer, layout_generic(app, arena, buffer, range, face, width));
}

static void fold_set_layouts(Application_Links *app, Buffer_ID buffer_id, b32 use_lexer, b32 treat_as_code){
 if(use_lexer){
  buffer_set_layout(app, buffer_id, fold_layout_virt_indent_index_generic);
 }else{
  if(treat_as_code){
   buffer_set_layout(app, buffer_id, fold_layout_virt_indent_literal_generic);
  }
  else{
   buffer_set_layout(app, buffer_id, fold_layout_generic);
  }
 }
}

i32 fold_begin_buffer_hook(Application_Links *app, Buffer_ID buffer_id){

 Profile_Scope_Block profile_block_365 ((app), SCu8((u8*)("fold begin buffer"), (u64)(sizeof("fold begin buffer") - 1)), SCu8((u8*)("4coder_vim/4coder_folds.hpp" ":" "365" ":"), (u64)(sizeof("4coder_vim/4coder_folds.hpp" ":" "365" ":") - 1)));

 Scratch_Block scratch(app);

 b32 treat_as_code = false;
 String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer_id);
 if (file_name.size > 0){
  String_Const_u8 treat_as_code_string = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("treat_as_code"), (u64)(sizeof("treat_as_code") - 1))));
  String_Const_u8_Array extensions = parse_extension_line_to_extension_list(app, scratch, treat_as_code_string);
  String_Const_u8 ext = string_file_extension(file_name);
  for (i32 i = 0; i < extensions.count; ++i){
   if (string_match(ext, extensions.strings[i])){
    if (string_match(ext, SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1))) ||
     string_match(ext, SCu8((u8*)("h"), (u64)(sizeof("h") - 1))) ||
     string_match(ext, SCu8((u8*)("c"), (u64)(sizeof("c") - 1))) ||
     string_match(ext, SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1))) ||
     string_match(ext, SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)))){
     treat_as_code = true;
    }
    break;
   }
  }
 }

 String_ID file_map_id = vars_save_string(SCu8((u8*)("keys_file"), (u64)(sizeof("keys_file") - 1)));
 String_ID code_map_id = vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1)));

 Command_Map_ID map_id = (treat_as_code)?(code_map_id):(file_map_id);
 Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
 Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
 *map_id_ptr = map_id;

 Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer_id);
 Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
 *eol_setting = setting;


 b32 wrap_lines = true;
 b32 use_lexer = false;
 if (treat_as_code){
  wrap_lines = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_code_wrapping"), (u64)(sizeof("enable_code_wrapping") - 1))));
  use_lexer = true;
 }

 String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer_id);
 if (buffer_name.size > 0 && buffer_name.str[0] == '*' && buffer_name.str[buffer_name.size - 1] == '*'){
  wrap_lines = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_output_wrapping"), (u64)(sizeof("enable_output_wrapping") - 1))));
 }

 if (use_lexer){
  Profile_Block profile_block_415 ((app), SCu8((u8*)("begin buffer kick off lexer"), (u64)(sizeof("begin buffer kick off lexer") - 1)), SCu8((u8*)("4coder_vim/4coder_folds.hpp" ":" "415" ":"), (u64)(sizeof("4coder_vim/4coder_folds.hpp" ":" "415" ":") - 1)));
  Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
  *lex_task_ptr = async_task_no_dep(&global_async_system, do_full_lex_async, make_data((&buffer_id), sizeof(*(&buffer_id))));
 }

 {
  b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
  *wrap_lines_ptr = wrap_lines;
 }

 fold_begin_buffer_inner(app, buffer_id);
 fold_set_layouts(app, buffer_id, use_lexer, treat_as_code);


 return(0);
}
# 89 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_commands.cpp" 1


CUSTOM_COMMAND(vim_toggle_relative_line_num, "4coder_vim/4coder_vim_commands.cpp", 3, Normal)
CUSTOM_DOC("Toggles relative line numbers")
{ vim_relative_numbers ^= 1; }

CUSTOM_COMMAND(vim_toggle_show_buffer_peek, "4coder_vim/4coder_vim_commands.cpp", 7, Normal)
CUSTOM_DOC("Toggles buffer peek")
{
 vim_show_buffer_peek ^= 1;
 f32 screen_height = rect_height(global_get_screen_rectangle(app));
 f32 height = (((0.3f)<(0.55f))?(0.3f):(0.55f))*screen_height;
 Input_Event event = get_current_input(app).event;
 if(event.kind == InputEventKind_KeyStroke && has_modifier(&event, KeyCode_Shift)){
  height = 0.55f*screen_height;
 }

 vim_nxt_filebar_offset = vim_show_buffer_peek*height;
}

CUSTOM_COMMAND(vim_inc_buffer_peek, "4coder_vim/4coder_vim_commands.cpp", 21, Normal)
CUSTOM_DOC("Incremenets buffer peek index")
{
 vim_buffer_peek_index = ((vim_buffer_peek_index+1) % ((sizeof(vim_buffer_peek_list))/(sizeof(*vim_buffer_peek_list))));
 vim_show_buffer_peek = 0;
 vim_toggle_show_buffer_peek(app);
}

CUSTOM_COMMAND(vim_dec_buffer_peek, "4coder_vim/4coder_vim_commands.cpp", 29, Normal)
CUSTOM_DOC("Decrements buffer peek index")
{
 vim_buffer_peek_index = ((vim_buffer_peek_index + ((sizeof(vim_buffer_peek_list))/(sizeof(*vim_buffer_peek_list)))-1) % ((sizeof(vim_buffer_peek_list))/(sizeof(*vim_buffer_peek_list))));
 vim_show_buffer_peek = 0;
 vim_toggle_show_buffer_peek(app);
}

static void
vim_scoll_buffer_peek_inner(Application_Links *app, f32 ratio){
 Vim_Buffer_Peek_Entry *entry = vim_buffer_peek_list + vim_buffer_peek_index;
 Buffer_ID buffer = buffer_identifier_to_id(app, entry->buffer_id);
 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics metrics = get_face_metrics(app, face_id);
 f32 line_height = metrics.line_height;
 i64 total_lines = buffer_get_line_count(app, buffer);

 Rect_f32 back_rect = vim_get_bottom_rect(app);
 f32 lines_per_page = rect_height(back_rect) / line_height;
 f32 current_line = entry->nxt_ratio*total_lines;
 entry->nxt_ratio = (current_line + ratio*lines_per_page) / total_lines;
 entry->nxt_ratio = (((f32(lines_per_page / total_lines))>(entry->nxt_ratio))?(f32(lines_per_page / total_lines)):(((1.f)<(entry->nxt_ratio))?(1.f):(entry->nxt_ratio)));
}

CUSTOM_COMMAND(vim_scoll_buffer_peek_up, "4coder_vim/4coder_vim_commands.cpp", 53, Normal)
CUSTOM_DOC("Scrolls buffer peek up")
{ vim_scoll_buffer_peek_inner(app, -0.75f); }

CUSTOM_COMMAND(vim_scoll_buffer_peek_down, "4coder_vim/4coder_vim_commands.cpp", 57, Normal)
CUSTOM_DOC("Scrolls buffer peek down")
{ vim_scoll_buffer_peek_inner(app, 0.75f); }

CUSTOM_COMMAND(right_adjust_view, "4coder_vim/4coder_vim_commands.cpp", 61, Normal)
CUSTOM_DOC("Sets the right size of the view near the x position of the cursor.")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 if(!line_is_valid_and_blank(app, buffer, get_line_number_from_pos(app, buffer, pos))){
  i64 new_pos = get_line_side_pos_from_pos(app, buffer, pos, Side_Min);
  if(character_is_whitespace(buffer_get_char(app, buffer, new_pos))){
   new_pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, Scan_Forward, new_pos);
  }
  view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
 }
 Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
 scroll.target.pixel_shift.x = 0.f;
 view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
}


CUSTOM_COMMAND(reg, "4coder_vim/4coder_vim_commands.cpp", 80, Normal)
CUSTOM_DOC("Vim: Display registers"){
 vim_show_buffer_peek = 0;
 vim_buffer_peek_index = 1;
 view_enqueue_command_function(app, get_active_view(app, Access_ReadVisible), vim_toggle_show_buffer_peek);
}



static void vim_normal_mode(Application_Links *app){
 if(vim_state.mode == VIM_Insert){
  vim_set_insert_register(app);
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  const i32 N = (((0)>(vim_state.params.number-1))?(0):(vim_state.params.number-1));
  for(i32 i=0; i<N; i++){
   vim_paste(app, view, buffer, &vim_registers.insert);
  }
  move_horizontal_lines(app, -1);
 }
 if(vim_state.mode == VIM_Visual){
  vim_set_prev_visual(app, get_active_view(app, Access_ReadVisible));
 }
 vim_reset_state();
}


static void vim_insert_mode_after(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
 if(!line_is_valid_and_blank(app, buffer, line)){
  move_right(app);
 }
 vim_enter_insert_mode(app);
}
static void vim_insert_mode(Application_Links *app){ vim_enter_insert_mode(app); }
static void vim_insert_begin(Application_Links *app){ vim_begin_line(app); vim_enter_insert_mode(app); }
static void vim_insert_end(Application_Links *app){ vim_end_line(app); vim_insert_mode_after(app); }

static void vim_modal_i(Application_Links *app){
 if(vim_state.mode == VIM_Visual || vim_state.params.request != REQUEST_None){
  vim_state.params.clusivity = VIM_Exclusive;
  u8 key = vim_query_user_key(app, SCu8((u8*)("-- TEXT OBJECT --"), (u64)(sizeof("-- TEXT OBJECT --") - 1)));
  if(key){
   vim_state.params.seek.character = key;
   vim_state.active_command = vim_text_object;
   vim_text_object(app);
  }
 }
 else{ vim_insert_mode(app); }
}

static void vim_modal_a(Application_Links *app){
 if(vim_state.mode == VIM_Visual || vim_state.params.request != REQUEST_None){
  vim_state.params.clusivity = VIM_Inclusive;
  u8 key = vim_query_user_key(app, SCu8((u8*)("-- TEXT OBJECT --"), (u64)(sizeof("-- TEXT OBJECT --") - 1)));
  if(key){
   vim_state.params.seek.character = key;
   vim_state.active_command = vim_text_object;
   vim_text_object(app);
  }
 }
 else{ vim_insert_mode_after(app); }
}

static void vim_newline_below(Application_Links *app){
 vim_insert_end(app);
 vim_state.insert_index++;
 write_text(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
}

static void vim_newline_above(Application_Links *app){
 vim_line_start(app);
 vim_enter_insert_mode(app);
 vim_state.insert_index++;
 write_text(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
 move_vertical_lines(app, -1);
}

static void vim_visual_mode(Application_Links *app){
 if(vim_state.mode != VIM_Visual){
  set_mark(app);
  vim_state.mode = VIM_Visual;
 }
 vim_state.params.edit_type = EDIT_CharWise;
 Input_Event event = get_current_input(app).event;
 if(event.kind == InputEventKind_KeyStroke){
  if(0){}
  else if(has_modifier(&event, KeyCode_Shift)){ vim_state.params.edit_type = EDIT_LineWise; }
  else if(has_modifier(&event, KeyCode_Control)){ vim_state.params.edit_type = EDIT_Block; }
 }
}

static void vim_prev_visual(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Managed_Scope scope = buffer_get_managed_scope(app, buffer);

 Vim_Prev_Visual *prev_visual = ((Vim_Prev_Visual*)managed_scope_get_attachment((app), (scope), (vim_buffer_prev_visual), sizeof(Vim_Prev_Visual)));
 if(prev_visual && prev_visual->cursor_pos != 0 && prev_visual->mark_pos != 0){
  view_set_cursor_and_preferred_x(app, view, seek_pos(prev_visual->cursor_pos));
  view_set_mark(app, view, seek_pos(prev_visual->mark_pos));
  vim_state.params.edit_type = prev_visual->edit_type;
  vim_state.mode = VIM_Visual;
 }
}

static void vim_block_swap(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 c = view_get_cursor_pos(app, view);
 i64 m = view_get_mark_pos(app, view);
 i64 line = get_line_number_from_pos(app, buffer, c);
 Vec2_f32 c_p = view_relative_xy_of_pos(app, view, line, c);
 Vec2_f32 m_p = view_relative_xy_of_pos(app, view, line, m);
 do { f32 hidden_temp_196 = c_p.x; c_p.x = m_p.x; m_p.x = hidden_temp_196; } while(0);
 c = view_pos_at_relative_xy(app, view, line, c_p);
 m = view_pos_at_relative_xy(app, view, line, m_p);
 view_set_cursor(app, view, seek_pos(c));
 view_set_mark(app, view, seek_pos(m));
}

static void vim_replace_mode(Application_Links *app){
 vim_state.mode = VIM_Replace;
 set_mark(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 vim_history_group = history_group_begin(app, buffer);
}

static void vim_visual_insert(Application_Links *app){
 if(vim_state.params.edit_type == EDIT_Block){
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

  vim_visual_insert_inner(app, view, buffer);

  i64 cursor_pos = view_get_cursor_pos(app, view);
  if(line_is_valid_and_blank(app, buffer, get_line_number_from_pos(app, buffer, cursor_pos))){
   auto_indent_buffer(app, buffer, Ii64(cursor_pos));
   view_set_cursor(app, view, seek_pos(get_pos_past_lead_whitespace(app, buffer, cursor_pos)));
  }
  i64 mark_pos = view_get_mark_pos(app, view);
  if(line_is_valid_and_blank(app, buffer, get_line_number_from_pos(app, buffer, mark_pos))){
   auto_indent_buffer(app, buffer, Ii64(mark_pos));
   view_set_mark(app, view, seek_pos(get_pos_past_lead_whitespace(app, buffer, mark_pos)));
  }

  User_Input input = get_current_input(app);
  if(input.event.kind == InputEventKind_KeyStroke && input.event.key.code == KeyCode_A){
   vim_visual_insert_after = true;
  }
 }
}


static void vim_submode_g(Application_Links *app){ vim_state.sub_mode = SUB_G; vim_state.chord_resolved = false; }
static void vim_submode_z(Application_Links *app){ vim_state.sub_mode = SUB_Z; vim_state.chord_resolved = false; }
static void vim_submode_leader(Application_Links *app){ vim_state.sub_mode = SUB_Leader; vim_state.chord_resolved = false; }

static void vim_replace_next_char(Application_Links *app){
 u8 key = vim_query_user_key(app, SCu8((u8*)("-- REPLACE NEXT --"), (u64)(sizeof("-- REPLACE NEXT --") - 1)));
 if(key){
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  i64 pos = view_get_cursor_pos(app, view);
  buffer_replace_range(app, buffer, Ii64(pos, pos+1), SCu8(&key, 1));
 }
}


static void vim_replace_range_next(Application_Links *app){
 u8 key = vim_query_user_key(app, SCu8((u8*)("-- RANGE REPLACE NEXT --"), (u64)(sizeof("-- RANGE REPLACE NEXT --") - 1)));
 if(key){
  vim_state.params.seek.character = key;
  vim_make_request(app, REQUEST_Replace);
 }
}

static void vim_request_yank(Application_Links *app){ vim_make_request(app, REQUEST_Yank); }
static void vim_request_delete(Application_Links *app){ vim_make_request(app, REQUEST_Delete); }
static void vim_request_change(Application_Links *app){ vim_make_request(app, REQUEST_Change); }
static void vim_uppercase(Application_Links *app){ vim_make_request(app, REQUEST_Upper); }
static void vim_lowercase(Application_Links *app){ vim_make_request(app, REQUEST_Lower); }
static void vim_toggle_case(Application_Links *app){ vim_make_request(app, REQUEST_ToggleCase); }
static void vim_request_indent(Application_Links *app){ vim_make_request(app, REQUEST_Indent); }
static void vim_request_outdent(Application_Links *app){ vim_make_request(app, REQUEST_Outdent); }
static void vim_request_fold(Application_Links *app){ vim_make_request(app, REQUEST_Fold); }
static void vim_request_auto_indent(Application_Links *app){ vim_make_request(app, REQUEST_AutoIndent); }

static void vim_toggle_char(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 u8 c = buffer_get_char(app, buffer, pos);
 c = character_toggle_case(c);
 buffer_replace_range(app, buffer, Ii64_size(pos, 1), SCu8(&c, 1));
}

static void vim_delete_end(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 i64 line_num = get_line_number_from_pos(app, buffer, pos);
 if(line_is_valid_and_blank(app, buffer, line_num)){ vim_reset_state(); return; }
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.request = REQUEST_Delete;
 vim_state.params.clusivity = VIM_Exclusive;
 seek_end_of_line(app);
}
static void vim_delete_to_begin(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 i64 line_num = get_line_number_from_pos(app, buffer, pos);
 if(line_is_valid_and_blank(app, buffer, line_num)){ vim_reset_state(); return; }
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.request = REQUEST_Delete;
 vim_state.params.clusivity = VIM_Exclusive;
 seek_beginning_of_line(app);
}

static void vim_change_end(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.request = REQUEST_Change;
 vim_state.params.clusivity = VIM_Exclusive;
 seek_end_of_line(app);
}

static void vim_yank_end(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.request = REQUEST_Yank;
 vim_state.params.clusivity = VIM_Exclusive;
 seek_end_of_line(app);
}


static void vim_leader_d(Application_Links *app){ vim_state.params.selected_reg=0; vim_request_delete(app); }
static void vim_leader_D(Application_Links *app){ vim_state.params.selected_reg=0; vim_delete_end(app); }
static void vim_leader_c(Application_Links *app){ vim_state.params.selected_reg=0; vim_request_change(app); }
static void vim_leader_C(Application_Links *app){ vim_state.params.selected_reg=0; vim_change_end(app); }

static void vim_digit(Application_Links *app){
 User_Input input = get_current_input(app);
 if(input.event.kind == InputEventKind_KeyStroke){
  int digit = input.event.key.code - KeyCode_0;
  if(((0) <= (digit) && (digit) < (10))){
   vim_state.number *= 10;
   vim_state.number += digit;
  }
  vim_state.chord_resolved = false;
 }
}

static void vim_digit_del(Application_Links *app){
 if(vim_state.number != 0){
  vim_state.number /= 10;
  vim_keystroke_text.size = vim_pre_keystroke_size-1;
  vim_state.chord_resolved = false;
 }else{
  vim_reset_state();
 }
}

static void vim_modal_0(Application_Links *app){
 if(vim_state.number){ vim_digit(app); }
 else{ vim_begin_line(app); }

}


static void vim_paragraph_up(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 vim_state.params.clusivity = VIM_Exclusive;
 const i32 N = vim_consume_number();
 for(i32 i=0; i<N; i++)
  move_up_to_blank_line_end(app);
}

static void vim_paragraph_down(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.edit_type = EDIT_LineWise;
 vim_state.params.clusivity = VIM_Exclusive;
 const i32 N = vim_consume_number();
 for(i32 i=0; i<N; i++)
  move_down_to_blank_line_end(app);
}

static void vim_whole_page_up(Application_Links *app){ vim_page_scroll_inner(app, -1.0f); }
static void vim_whole_page_down(Application_Links *app){ vim_page_scroll_inner(app, 1.0f); }
static void vim_half_page_up(Application_Links *app){ vim_page_scroll_inner(app, -0.5f); }
static void vim_half_page_down(Application_Links *app){ vim_page_scroll_inner(app, 0.5f); }

static void vim_scroll_screen_top(Application_Links *app){ vim_scroll_inner(app, 0.0f); }
static void vim_scroll_screen_mid(Application_Links *app){ vim_scroll_inner(app, -0.5f); }
static void vim_scroll_screen_bot(Application_Links *app){ vim_scroll_inner(app, -1.0f); }

static void vim_screen_top(Application_Links *app){ vim_screen_inner(app, 0.0f, vim_consume_number()); }
static void vim_screen_mid(Application_Links *app){ vim_screen_inner(app, 0.5f, vim_consume_number()); }
static void vim_screen_bot(Application_Links *app){ vim_screen_inner(app, 1.0f, -vim_consume_number()); }

static void vim_line_up(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 f32 line_height = get_face_metrics(app, get_face_id(app, 0)).line_height;
 Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
 scroll.target = view_move_buffer_point(app, view, scroll.target, V2f32(0.f, line_height));
 view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
}

static void vim_line_down(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 f32 line_height = get_face_metrics(app, get_face_id(app, 0)).line_height;
 Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
 scroll.target = view_move_buffer_point(app, view, scroll.target, V2f32(0.f, -line_height));
 view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
}


static void vim_forward_word(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.clusivity = VIM_Exclusive;
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 prev_pos = -1;
 i64 pos = vim_scan_word(app, view, Scan_Forward, &prev_pos, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
 if(prev_pos != pos){
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  i64 line0 = get_line_number_from_pos(app, buffer, prev_pos);
  i64 line1 = get_line_number_from_pos(app, buffer, pos);
  if(line0 != line1){
   vim_motion_block.clamp_end = get_line_side_pos(app, buffer, line0, Side_Max);
  }
 }
}

static void vim_backward_word(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = vim_scan_word(app, view, Scan_Backward, 0, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_forward_WORD(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 vim_state.params.clusivity = VIM_Exclusive;
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 prev_pos = -1;
 i64 pos = vim_scan_WORD(app, view, Scan_Forward, &prev_pos, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
 if(prev_pos != pos){
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  i64 line0 = get_line_number_from_pos(app, buffer, prev_pos);
  i64 line1 = get_line_number_from_pos(app, buffer, pos);
  if(line0 != line1){
   vim_motion_block.clamp_end = get_line_side_pos(app, buffer, line0, Side_Max);
  }
 }
}

static void vim_backward_WORD(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 cursor_pos = view_get_cursor_pos(app, view);
 Vim_Motion_Block vim_motion_block(app, cursor_pos-1);
 i64 pos = vim_scan_WORD(app, view, Scan_Backward, 0, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_forward_end(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = vim_scan_end(app, view, Scan_Forward, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_backward_end(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = vim_scan_end(app, view, Scan_Backward, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_forward_END(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = vim_scan_END(app, view, Scan_Forward, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_backward_END(Application_Links *app){
 Vim_Motion_Block vim_motion_block(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 i64 pos = vim_scan_END(app, view, Scan_Backward, vim_consume_number());
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_bounce(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 Vim_Motion_Block vim_motion_block(app);
 Scan_Direction direction = Scan_Forward;
 Input_Event event = get_current_input(app).event;
 if(event.kind == InputEventKind_KeyStroke && has_modifier(&event, KeyCode_Control)){ direction=Scan_Backward; }
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 pos = vim_scan_bounce(app, buffer, pos, direction);
 view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void vim_modal_percent(Application_Links *app){
 if(vim_state.number){ vim_percent_file(app); }
 else{ vim_bounce(app); }
}

static void vim_paste_after(Application_Links *app){
 if(vim_state.params.selected_reg){
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  if(vim_state.params.selected_reg->edit_type == EDIT_LineWise){
   seek_end_of_line(app);
   move_right(app);
   vim_paste(app, view, buffer, vim_state.params.selected_reg);
   move_up(app);
  }else{
   move_right(app);
   vim_paste(app, view, buffer, vim_state.params.selected_reg);
  }

  Vim_Register *reg = vim_state.prev_params.selected_reg;
  vim_state.params.command = vim_paste_after;
  vim_state.prev_params = vim_state.params;
  vim_state.prev_params.selected_reg = reg;
 }
}

static void vim_paste_before(Application_Links *app){
 if(vim_state.params.selected_reg){
  if(vim_state.params.selected_reg->edit_type == EDIT_LineWise){
   seek_beginning_of_line(app);
  }
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  vim_paste(app, view, buffer, vim_state.params.selected_reg);

  Vim_Register *reg = vim_state.prev_params.selected_reg;
  vim_state.params.command = vim_paste_before;
  vim_state.prev_params = vim_state.params;
  vim_state.prev_params.selected_reg = reg;
 }
}


static void vim_backspace_char_inner(Application_Links *app, i32 offset){
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 if(!if_view_has_highlighted_range_delete_range(app, view)){
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
  i64 pos = view_get_cursor_pos(app, view);
  i64 buffer_size = buffer_get_size(app, buffer);
  if(((0) <= (pos) && (pos) < (buffer_size))){
   Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
   i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
   i64 start = view_pos_from_relative_character(app, view, cursor.line, character + offset);
   u8 c = buffer_get_char(app, buffer, start);
   vim_register_copy(&vim_registers.small_delete, SCu8(&c, 1));
   vim_registers.small_delete.edit_type = EDIT_CharWise;
   vim_update_registers(app);
   buffer_replace_range(app, buffer, Ii64(start, pos), string_u8_empty);
  }
 }
}

static void vim_backspace_char(Application_Links *app){ vim_backspace_char_inner(app, -1); }
static void vim_delete_char(Application_Links *app){ vim_backspace_char_inner(app, 1); }

static void vim_last_command(Application_Links *app){
 const i32 N = vim_consume_number();
 Custom_Command_Function *command = vim_state.prev_params.command;
 if(command){
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
  History_Group history_group = history_group_begin(app, buffer);
  for(i32 i=0; i<N; i++){
   vim_state.params = vim_state.prev_params;
   vim_state.active_command = command;
   vim_state.number = vim_state.params.number;
   b32 do_insert = vim_state.params.do_insert;

   if((command == vim_paste_before || command == vim_paste_after) &&
      ((0) <= ((vim_state.params.selected_reg - vim_registers.cycle)) && ((vim_state.params.selected_reg - vim_registers.cycle)) < (8)))
   {
    vim_state.params.selected_reg++;
   }

   command(app);

   if(do_insert){
    vim_paste(app, view, buffer, &vim_registers.insert);
    vim_state.mode = VIM_Normal;
   }
  }
  history_group_end(history_group);
 }
}

static b32
vim_combine_line_inner(Application_Links *app, View_ID view, Buffer_ID buffer, i64 line_num){
 if(!is_valid_line(app, buffer, line_num+1)){ return true; }
 i64 pos = get_line_end_pos(app, buffer, line_num);
 Range_i64 range = {};
 range.min = pos;

 i64 new_pos = pos + 1;
 String_Const_u8 delimiter = (vim_state.sub_mode == SUB_G ? string_u8_empty : SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
 if(!line_is_valid_and_blank(app, buffer, line_num+1)){
  if(character_is_whitespace(buffer_get_char(app, buffer, new_pos))){
   new_pos = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, Scan_Forward, new_pos);
  }
 }else{
  new_pos = get_line_end_pos(app, buffer, line_num+1);
  delimiter.size = 0;
 }
 i64 end_pos = get_line_side_pos_from_pos(app, buffer, pos, Side_Max);
 view_set_cursor_and_preferred_x(app, view, seek_pos(end_pos));
 move_right(app);

 range.max = new_pos;

 buffer_replace_range(app, buffer, range, delimiter);

 return false;
}

static void vim_combine_line(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
 if(buffer == 0){ return; }
 i64 pos = view_get_cursor_pos(app, view);
 i64 line = buffer_compute_cursor(app, buffer, seek_pos(pos)).line;

 i32 N = vim_consume_number();
 if(vim_state.mode == VIM_Visual){
  Range_i64 range = get_view_range(app, view);
  i64 line_min = get_line_number_from_pos(app, buffer, range.min);
  i64 line_max = get_line_number_from_pos(app, buffer, range.max);
  N = (((1)>(i32(line_max-line_min)))?(1):(i32(line_max-line_min)));
  view_set_cursor_and_preferred_x(app, view, seek_pos(range.min));
  view_set_mark(app, view, seek_pos(range.max));
  line = line_min;
 }

 History_Group history_group = history_group_begin(app, buffer);
 for(i32 i=0; i<N; i++){
  if(vim_combine_line_inner(app, view, buffer, line)){
   break;
  }
 }
 if(N > 1){ history_group_end(history_group); }
}


static void vim_set_mark(Application_Links *app){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 Scratch_Block scratch(app);
 u8 character = vim_query_user_key(app, SCu8((u8*)("-- SET MARK NEXT --"), (u64)(sizeof("-- SET MARK NEXT --") - 1)));
 if((('a') <= (character) && (character) < ('z'+1))){
  Managed_Scope scope = buffer_get_managed_scope(app, buffer);
  i64 *marks = (i64 *)managed_scope_get_attachment(app, scope, vim_buffer_marks, 26*sizeof(i64));
  if(marks){
   marks[character-'a'] = pos;
   vim_set_bottom_text(push_stringf(scratch, "Mark %c set", character));
  }
 }
 else if((('A') <= (character) && (character) < ('Z'+1))){
  vim_global_marks[character-'A'] = {buffer_identifier(buffer), pos};
  vim_set_bottom_text(push_stringf(scratch, "Global mark %c set", character));
 }
}

static void vim_goto_mark(Application_Links *app){
 User_Input input = get_current_input(app);
 if(input.event.kind == InputEventKind_KeyStroke){
  if(input.event.key.code == KeyCode_Tick){
   vim_state.params.edit_type = EDIT_LineWise;
  }
 }
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 u8 c = vim_query_user_key(app, SCu8((u8*)("-- GOTO MARK NEXT --"), (u64)(sizeof("-- GOTO MARK NEXT --") - 1)));
 if((('a') <= (c) && (c) < ('z'+1))){
  Managed_Scope scope = buffer_get_managed_scope(app, buffer);
  i64 *marks = (i64 *)managed_scope_get_attachment(app, scope, vim_buffer_marks, 26*sizeof(i64));
  if(marks){
   i64 pos = marks[c-'a'];
   if(pos > 0){
    vim_push_jump(app, view);
    Vim_Motion_Block vim_motion_block(app);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
   }else{
    Scratch_Block scratch(app);
    vim_set_bottom_text(push_stringf(scratch, "Mark %c not set", c));
   }
  }
 }
 else if((('A') <= (c) && (c) < ('Z'+1))){
  vim_push_jump(app, view);
  Vim_Global_Mark mark = vim_global_marks[c-'A'];
  if(mark.buffer_id.id){
   vim_push_jump(app, view);
   view_set_buffer(app, view, mark.buffer_id.id, 0);
   view_set_cursor_and_preferred_x(app, view, seek_pos(mark.pos));
  }else{
   Scratch_Block scratch(app);
   vim_set_bottom_text(push_stringf(scratch, "Mark %c not set", c));
  }
 }
 else{

  i64 pos = -1;
  switch(c){
   case '\'':{} break;
   case '.': {} break;
   case '`': {} break;
   case '[': {} break;
   case ']': {} break;
   case '<': {} break;
   case '>': {} break;

  }
  if(pos > 0){
   ;
  }
 }
}


static void vim_open_file_in_quotes(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 if(buffer_exists(app, buffer)){
  Scratch_Block scratch(app);

  i64 pos = view_get_cursor_pos(app, view);

  vim_state.params.consume_char = '"';
  vim_state.params.clusivity = VIM_Inclusive;
  Range_i64 range = vim_scan_object_quotes(app, buffer, pos);
  range.min++;
  String_Const_u8 quoted_name = push_buffer_range(app, scratch, buffer, range);

  String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
  String_Const_u8 path = string_remove_last_folder(file_name);

  if(character_is_slash(string_get_character(path, path.size-1))){
   path = string_chop(path, 1);
  }

  String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(quoted_name).size, (char*)(quoted_name).str);

  vim_push_jump(app, view);
  view = get_next_view_looped_primary_panels(app, view, Access_Always);
  if(view && view_open_file(app, view, new_file_name, true)){
   view_set_active(app, view);
  }
 }
}

static void vim_goto_definition(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 jump_to_definition_at_cursor(app);
}
static void vim_next_4coder_jump(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 goto_next_jump(app);
}
static void vim_prev_4coder_jump(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 goto_prev_jump(app);
}
static void vim_first_4coder_jump(Application_Links *app){
 vim_push_jump(app, get_active_view(app, Access_ReadVisible));
 goto_first_jump(app);
}

static void vim_move_selection(Application_Links *app, Scan_Direction direction){
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

 Scratch_Block scratch(app);
 const i64 N = vim_consume_number();
 const b32 forward = direction == Scan_Forward;

 i64 cursor_pos = view_get_cursor_pos(app, view);
 i64 mark_pos = view_get_mark_pos(app, view);
 Range_i64 range = Ii64(cursor_pos, mark_pos);
 i64 min_line = get_line_number_from_pos(app, buffer, range.min);
 i64 max_line = get_line_number_from_pos(app, buffer, range.max);
 i64 line_count = buffer_get_line_count(app, buffer);

 Range_i64 copy_range = range_union(get_line_pos_range(app, buffer, min_line),
            get_line_pos_range(app, buffer, max_line));
 copy_range.max += buffer_get_char(app, buffer, copy_range.max) == '\r';
 copy_range.max += 1;

 i64 paste_pos = (forward ?
      get_line_pos_range(app, buffer, (((max_line + N)<(line_count))?(max_line + N):(line_count))).max + 1 :
      get_line_pos_range(app, buffer, min_line - N).min);
 i64 buff_size = buffer_get_size(app, buffer);
 paste_pos = (((paste_pos)<(buff_size))?(paste_pos):(buff_size));

 String_Const_u8 copy_string = push_buffer_range(app, scratch, buffer, copy_range);

 i64 cursor_offset = cursor_pos - copy_range.min;
 i64 mark_offset = mark_pos - copy_range.min;

 History_Group group = history_group_begin(app, buffer);
 if(forward){
  buffer_replace_range(app, buffer, Ii64(paste_pos), copy_string);

  view_set_cursor(app, view, seek_pos(paste_pos + cursor_offset));
  view_set_mark(app, view, seek_pos(paste_pos + mark_offset));

  buffer_replace_range(app, buffer, copy_range, string_u8_empty);
 }else{
  buffer_replace_range(app, buffer, copy_range, string_u8_empty);
  buffer_replace_range(app, buffer, Ii64(paste_pos), copy_string);

  view_set_cursor(app, view, seek_pos(paste_pos + cursor_offset));
  view_set_mark(app, view, seek_pos(paste_pos + mark_offset));
 }

 history_group_end(group);
}

static void vim_move_selection_up(Application_Links *app){ vim_move_selection(app, Scan_Backward); }
static void vim_move_selection_down(Application_Links *app){ vim_move_selection(app, Scan_Forward); }


static i32 vim_macro_index(u8 c){
 return((character_to_lower(c) - 'a') + 26*(('A') <= (c) && (c) < ('Z'+1)));
}

static void vim_toggle_macro(Application_Links *app){
 if(vim_state.macro_char){
  Buffer_ID buffer = get_keyboard_log_buffer(app);
  i64 end = buffer_get_size(app, buffer);
  Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(end));
  Buffer_Cursor back_cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line - 1, 1));
  vim_macros[vim_macro_index(vim_state.macro_char)].max = back_cursor.pos;
  vim_state.macro_char = 0;
 }else{
  if(vim_state.macro_char){ return; }
  u8 c = vim_query_user_key(app, SCu8((u8*)("-- SELECT MACRO TO RECORD --"), (u64)(sizeof("-- SELECT MACRO TO RECORD --") - 1)));
  if((('a') <= (c) && (c) < ('z'+1)) || (('A') <= (c) && (c) < ('Z'+1))){
   vim_state.macro_char = c;
   i32 index = vim_macro_index(c);
   vim_macros[index].min = buffer_get_size(app, get_keyboard_log_buffer(app));
  }
 }
}

static void vim_play_macro(Application_Links *app){
 u8 c = vim_query_user_key(app, SCu8((u8*)("-- SELECT MACRO TO PLAY --"), (u64)(sizeof("-- SELECT MACRO TO PLAY --") - 1)));
 if(c == '@'){ c = vim_state.prev_macro; }
 if((('a') <= (c) && (c) < ('z'+1)) || (('A') <= (c) && (c) < ('Z'+1))){
  i32 index = vim_macro_index(c);
  Range_i64 range = vim_macros[index];
  if(range.min == 0 || range.max == 0){ return; }
  vim_state.prev_macro = c;

  Buffer_ID key_buffer = get_keyboard_log_buffer(app);
  Scratch_Block scratch(app);
  String_Const_u8 macro = push_buffer_range(app, scratch, key_buffer, range);
  keyboard_macro_play(app, macro);
 }
}

static void vim_insert_command(Application_Links *app);




CUSTOM_COMMAND(w, "4coder_vim/4coder_vim_commands.cpp", 867, Normal)
CUSTOM_DOC("Vim: Saves the buffer") { save(app); }

CUSTOM_COMMAND(wq, "4coder_vim/4coder_vim_commands.cpp", 870, Normal)
CUSTOM_DOC("Vim: Saves and quits the buffer") { save(app); close_panel(app); }

CUSTOM_COMMAND(wqa, "4coder_vim/4coder_vim_commands.cpp", 873, Normal)
CUSTOM_DOC("Vim: Saves and quits all buffers") { save_all_dirty_buffers(app); exit_4coder(app); }

CUSTOM_COMMAND(q, "4coder_vim/4coder_vim_commands.cpp", 876, Normal)
CUSTOM_DOC("Vim: Close panel") { close_panel(app); }

CUSTOM_COMMAND(qk, "4coder_vim/4coder_vim_commands.cpp", 879, Normal)
CUSTOM_DOC("Vim: Attempt to kill buffer and close panel") { vim_try_buffer_kill(app); close_panel(app); }

CUSTOM_COMMAND(qa, "4coder_vim/4coder_vim_commands.cpp", 882, Normal)
CUSTOM_DOC("Vim: Attempt to exit") { exit_4coder(app); }

CUSTOM_COMMAND(e, "4coder_vim/4coder_vim_commands.cpp", 885, Normal)
CUSTOM_DOC("Vim: Open file") { vim_interactive_open_or_new(app); }

CUSTOM_COMMAND(b, "4coder_vim/4coder_vim_commands.cpp", 888, Normal)
CUSTOM_DOC("Vim: Open file") { vim_interactive_open_or_new(app); }

CUSTOM_COMMAND(vs, "4coder_vim/4coder_vim_commands.cpp", 891, Normal)
CUSTOM_DOC("Vim: Vertical split") { open_panel_vsplit(app); }

CUSTOM_COMMAND(sp, "4coder_vim/4coder_vim_commands.cpp", 894, Normal)
CUSTOM_DOC("Vim: Horizontal split") { open_panel_hsplit(app); }

CUSTOM_COMMAND(s, "4coder_vim/4coder_vim_commands.cpp", 897, Normal)
CUSTOM_DOC("Vim: Substitute"){ replace_in_buffer(app); }

CUSTOM_COMMAND(jumps, "4coder_vim/4coder_vim_commands.cpp", 900, Normal)
CUSTOM_DOC("Vim: Interactive jump stack lister"){ vim_jump_lister(app); }
# 90 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_bindings.cpp" 1


static void vim_map_set_binding(u32 mode, u32 sub_mode, void *func, u64 key){
 if((mode & bitmask_3) == 0){
  mode |= bitmask_3;
  for(i32 s=0; s<VIM_SUBMODE_COUNT; s++){ vim_map_set_binding(mode, s, func, key); }
 }
 if(mode & bit_1){ table_insert(vim_maps + 0 + sub_mode*VIM_MODE_COUNT, key, ((u8*)(func) - (u8*)(0))); }
 if(mode & bit_2){ table_insert(vim_maps + 1 + sub_mode*VIM_MODE_COUNT, key, ((u8*)(func) - (u8*)(0))); }
 if(mode & bit_3){ table_insert(vim_maps + 2 + sub_mode*VIM_MODE_COUNT, key, ((u8*)(func) - (u8*)(0))); }
}
static void VimBind(u32 mode, Custom_Command_Function *custom, Vim_Sub_Mode sub_mode, u64 key){
 vim_map_set_binding(mode, sub_mode, (void *)custom, key);
}
static void VimBind(u32 mode, Custom_Command_Function *custom, u64 key){
 vim_map_set_binding(mode, SUB_None, (void *)custom, key);
}


static void vim_default_bindings(Application_Links *app, Key_Code leader){







 u32 Ctl = KeyMod_Ctl;
 u32 Sft = KeyMod_Sft;
 u32 Alt = KeyMod_Alt;

 VimBind(0, vim_normal_mode, KeyCode_Escape);
 VimBind(0, vim_inc_buffer_peek, (Ctl|KeyCode_RightBracket));
 VimBind(0, vim_dec_buffer_peek, (Ctl|KeyCode_LeftBracket));
 VimBind(0, vim_toggle_show_buffer_peek, (Ctl|KeyCode_Return));
 VimBind(0, vim_toggle_show_buffer_peek, (Ctl|Sft|KeyCode_Return));
 VimBind(0, vim_scoll_buffer_peek_up, (Ctl|Sft|KeyCode_U));
 VimBind(0, vim_scoll_buffer_peek_down, (Ctl|Sft|KeyCode_D));


 VimBind(bit_1|0, undo, KeyCode_U);
 VimBind(bit_1|0, undo, (Ctl|KeyCode_Z));
 VimBind(bit_1|0, redo, (Ctl|KeyCode_R));
 VimBind(bit_1|bit_3|0, set_mark, (Ctl|KeyCode_Space));
 VimBind(bit_1|0, save, (Ctl|KeyCode_S));
 VimBind(bit_1|0, vim_open_file_in_quotes, SUB_G, KeyCode_F);
 VimBind(bit_1|0, vim_interactive_open_or_new, (Ctl|Sft|KeyCode_O));
 VimBind(bit_1|0, quick_swap_buffer, (Sft|Ctl|KeyCode_6));
 VimBind(bit_1|0, vim_goto_definition, (Ctl|KeyCode_W));
 VimBind(bit_1|0, vim_next_4coder_jump, (Alt|KeyCode_N));
 VimBind(bit_1|0, vim_prev_4coder_jump, (Sft|Alt|KeyCode_N));
 VimBind(bit_1|0, vim_first_4coder_jump, (Sft|Alt|KeyCode_M));
 VimBind(bit_1|bit_2|0, view_buffer_other_panel, (Ctl|KeyCode_1));
 VimBind(bit_1|bit_2|0, swap_panels, (Ctl|KeyCode_2));
 VimBind(bit_2|0, word_complete_drop_down, (Ctl|KeyCode_N));



 VimBind(bit_1|bit_3|0, vim_modal_i, KeyCode_I);
 VimBind(bit_1|bit_3|0, vim_modal_a, KeyCode_A);
 VimBind(bit_1|bit_3|0, vim_command_mode, (Sft|KeyCode_Semicolon));
 VimBind(bit_1|0, vim_insert_begin, (Sft|KeyCode_I));
 VimBind(bit_1|0, vim_insert_end, (Sft|KeyCode_A));
 VimBind(bit_1|0, vim_replace_mode, (Sft|KeyCode_R));
 VimBind(bit_1|bit_3|0, vim_visual_mode, KeyCode_V);
 VimBind(bit_1|bit_3|0, vim_visual_mode, (Sft|KeyCode_V));
 VimBind(bit_1|bit_3|0, vim_visual_mode, (Ctl|KeyCode_V));
 VimBind(bit_1|0, vim_prev_visual, SUB_G, KeyCode_V);
 VimBind(bit_1|0, vim_newline_below, KeyCode_O);
 VimBind(bit_1|0, vim_newline_above, (Sft|KeyCode_O));
 VimBind(bit_3|0, vim_visual_insert, (Sft|KeyCode_A));
 VimBind(bit_3|0, vim_visual_insert, (Sft|KeyCode_I));
 VimBind(bit_2|0, vim_insert_command, (Ctl|Sft|KeyCode_O));


 VimBind(bit_1|bit_3|0, vim_submode_g, KeyCode_G);
 VimBind(bit_1|bit_3|0, vim_submode_z, KeyCode_Z);
 VimBind(bit_1|bit_3|0, vim_submode_leader, leader);


 VimBind(bit_1|bit_3|0, vim_request_yank, KeyCode_Y);
 VimBind(bit_1|bit_3|0, vim_request_delete, KeyCode_D);
 VimBind(bit_1|bit_3|0, vim_request_change, KeyCode_C);
 VimBind(bit_1|bit_3|0, vim_delete_end, (Sft|KeyCode_D));
 VimBind(bit_1|bit_3|0, vim_change_end, (Sft|KeyCode_C));
 VimBind(bit_1|bit_3|0, vim_yank_end, (Sft|KeyCode_Y));
 VimBind(bit_1|bit_3|0, vim_request_auto_indent, KeyCode_Equal);
 VimBind(bit_1|bit_3|0, vim_lowercase, SUB_G, KeyCode_U);
 VimBind(bit_1|bit_3|0, vim_uppercase, SUB_G, (Sft|KeyCode_U));
 VimBind(bit_1|bit_3|0, vim_toggle_case, SUB_G, (Sft|KeyCode_Tick));
 VimBind(bit_1|bit_3|0, vim_request_indent, (Sft|KeyCode_Period));
 VimBind(bit_1|bit_3|0, vim_request_outdent, (Sft|KeyCode_Comma));
 VimBind(bit_1|bit_3|0, vim_request_fold, SUB_Z, KeyCode_F);
 VimBind(bit_1|bit_3|0, fold_toggle_cursor, SUB_Z, KeyCode_A);
 VimBind(bit_1|bit_3|0, fold_pop_cursor, SUB_Z, KeyCode_D);
 VimBind(bit_3|0, vim_toggle_case, (Sft|KeyCode_Tick));
 VimBind(bit_3|0, vim_lowercase, KeyCode_U);
 VimBind(bit_3|0, vim_uppercase, (Sft|KeyCode_U));
 VimBind(bit_3|0, vim_replace_range_next, KeyCode_R);


 VimBind(bit_1|0, vim_paste_before, (Sft|KeyCode_P));
 VimBind(bit_1|0, vim_paste_after, KeyCode_P);
 VimBind(bit_1|0, vim_backspace_char, (Sft|KeyCode_X));
 VimBind(bit_1|0, vim_delete_char, KeyCode_X);
 VimBind(bit_1|0, vim_replace_next_char, KeyCode_R);
 VimBind(bit_1|bit_3|0, vim_combine_line, (Sft|KeyCode_J));
 VimBind(bit_1|bit_3|0, vim_combine_line, SUB_G, (Sft|KeyCode_J));
 VimBind(bit_1|0, vim_last_command, KeyCode_Period);
 VimBind(bit_1|bit_3|0, vim_select_register, (Sft|KeyCode_Quote));
 VimBind(bit_1|0, vim_toggle_char, (Sft|KeyCode_Tick));
 VimBind(bit_2|0, vim_select_register, (Ctl|KeyCode_R));
 VimBind(bit_2|0, vim_delete_to_begin, (Ctl|KeyCode_U));
 VimBind(bit_3|0, vim_move_selection_up, (Alt|KeyCode_K));
 VimBind(bit_3|0, vim_move_selection_down, (Alt|KeyCode_J));


 VimBind(bit_1|bit_3|0, vim_modal_0, KeyCode_0);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_1);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_2);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_3);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_4);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_5);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_6);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_7);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_8);
 VimBind(bit_1|bit_3|0, vim_digit, KeyCode_9);
 VimBind(bit_1|bit_3|0, vim_digit_del, KeyCode_Backspace);
 VimBind(bit_1|bit_3|0, vim_digit_del, KeyCode_Delete);


 VimBind(bit_1|bit_3|0, vim_left, KeyCode_H);
 VimBind(bit_1|bit_3|0, vim_down, KeyCode_J);
 VimBind(bit_1|bit_3|0, vim_up, KeyCode_K);
 VimBind(bit_1|bit_3|0, vim_right, KeyCode_L);
 VimBind(bit_1|bit_3|0, vim_end_line, (Sft|KeyCode_4));
 VimBind(bit_1|bit_3|0, vim_begin_line, (Sft|KeyCode_6));
 VimBind(bit_1|bit_3|0, vim_forward_word, KeyCode_W);
 VimBind(bit_1|bit_3|0, vim_forward_WORD, (Sft|KeyCode_W));
 VimBind(bit_1|bit_3|0, vim_backward_word, KeyCode_B);
 VimBind(bit_1|bit_3|0, vim_backward_WORD, (Sft|KeyCode_B));
 VimBind(bit_1|bit_3|0, vim_forward_end, KeyCode_E);
 VimBind(bit_1|bit_3|0, vim_forward_END, (Sft|KeyCode_E));
 VimBind(bit_1|bit_3|0, vim_backward_end, SUB_G, KeyCode_E);
 VimBind(bit_1|bit_3|0, vim_backward_END, SUB_G, (Sft|KeyCode_E));

 VimBind(bit_1|bit_3|0, vim_file_top, SUB_G, KeyCode_G);
 VimBind(bit_1|bit_3|0, vim_goto_line, (Sft|KeyCode_G));
 VimBind(bit_1|bit_3|0, vim_goto_column, (Sft|KeyCode_BackwardSlash));
 VimBind(bit_1|bit_3|0, vim_modal_percent, (Sft|KeyCode_5));
 VimBind(bit_1|bit_3|0, vim_bounce, (Ctl|KeyCode_5));
 VimBind(bit_1|bit_3|0, vim_set_seek_char, KeyCode_F);
 VimBind(bit_1|bit_3|0, vim_set_seek_char, KeyCode_T);
 VimBind(bit_1|bit_3|0, vim_set_seek_char, (Sft|KeyCode_F));
 VimBind(bit_1|bit_3|0, vim_set_seek_char, (Sft|KeyCode_T));
 VimBind(bit_1|bit_3|0, vim_seek_char_forward, KeyCode_Semicolon);
 VimBind(bit_1|bit_3|0, vim_seek_char_backward, KeyCode_Comma);
 VimBind(bit_1|bit_3|0, vim_paragraph_up, (Sft|KeyCode_LeftBracket));
 VimBind(bit_1|bit_3|0, vim_paragraph_down, (Sft|KeyCode_RightBracket));
 VimBind(bit_1|bit_3|0, vim_screen_top, (Sft|KeyCode_H));
 VimBind(bit_1|bit_3|0, vim_screen_bot, (Sft|KeyCode_L));
 VimBind(bit_1|bit_3|0, vim_screen_mid, (Sft|KeyCode_M));
 VimBind(bit_3|0, cursor_mark_swap, KeyCode_O);
 VimBind(bit_3|0, vim_block_swap, (Sft|KeyCode_O));

 VimBind(bit_1|0, vim_search_identifier, (Ctl|Sft|KeyCode_8));
 VimBind(bit_1|0, vim_search_identifier, (Sft|KeyCode_8));
 VimBind(bit_1|0, vim_clear_search, SUB_Leader, KeyCode_Space);
 VimBind(bit_1|0, vim_start_search_forward, KeyCode_ForwardSlash);
 VimBind(bit_1|0, vim_start_search_backward, (Sft|KeyCode_ForwardSlash));
 VimBind(bit_1|0, vim_to_next_pattern, KeyCode_N);
 VimBind(bit_1|0, vim_to_prev_pattern, (Sft|KeyCode_N));
 VimBind(bit_1|0, vim_in_next_pattern, SUB_G, KeyCode_N);
 VimBind(bit_1|0, vim_in_prev_pattern, SUB_G, (Sft|KeyCode_N));

 VimBind(bit_1|0, vim_prev_jump, (Ctl|KeyCode_O));
 VimBind(bit_1|0, vim_next_jump, (Ctl|KeyCode_I));
 VimBind(bit_1|0, vim_next_jump, (Sft|KeyCode_I));



 VimBind(bit_1|bit_3|0, vim_half_page_up, (Ctl|KeyCode_U));
 VimBind(bit_1|bit_3|0, vim_half_page_down, (Ctl|KeyCode_D));
 VimBind(bit_1|bit_3|0, vim_whole_page_up, (Ctl|KeyCode_B));
 VimBind(bit_1|bit_3|0, vim_whole_page_down, (Ctl|KeyCode_F));
 VimBind(bit_1|bit_3|0, vim_line_down, (Ctl|Sft|KeyCode_Y));
 VimBind(bit_1|bit_3|0, vim_line_down, (Ctl|KeyCode_Y));
 VimBind(bit_1|bit_3|0, vim_line_up, (Ctl|Sft|KeyCode_E));
 VimBind(bit_1|bit_3|0, vim_line_up, (Ctl|KeyCode_E));
 VimBind(bit_1|bit_3|0, vim_scroll_screen_top, SUB_Z, KeyCode_T);
 VimBind(bit_1|bit_3|0, vim_scroll_screen_mid, SUB_Z, KeyCode_Z);
 VimBind(bit_1|bit_3|0, vim_scroll_screen_bot, SUB_Z, KeyCode_B);


 VimBind(bit_1|bit_3|0, vim_set_mark, KeyCode_M);
 VimBind(bit_1|bit_3|0, vim_goto_mark, KeyCode_Tick);
 VimBind(bit_1|bit_3|0, vim_goto_mark, KeyCode_Quote);
 VimBind(bit_1|bit_3|0, vim_toggle_macro, KeyCode_Q);
 VimBind(bit_1|bit_3|0, vim_play_macro, (Sft|KeyCode_2));


 VimBind(bit_1|0, change_active_panel_backwards, (Ctl|KeyCode_H));
 VimBind(bit_1|0, change_active_panel_backwards, (Ctl|KeyCode_J));
 VimBind(bit_1|0, change_active_panel, (Ctl|KeyCode_K));
 VimBind(bit_1|0, change_active_panel, (Ctl|KeyCode_L));






}
# 91 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim.cpp" 1

void vim_apply_none(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){}
void vim_apply_yank(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 if(vim_state.params.selected_reg){
  vim_state.params.selected_reg->edit_type = vim_state.params.edit_type;
  vim_copy(app, view, buffer, range, vim_state.params.selected_reg);
 }
}

void vim_apply_delete(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 vim_apply_yank(app, view, buffer, range);
 if(vim_state.params.edit_type != EDIT_Block && vim_state.params.selected_reg){
  Vim_Register *dst = &vim_registers.small_delete;
  if(vim_state.params.edit_type != EDIT_CharWise){
   dst = vim_registers.cycle;
   vim_push_reg_cycle(app);
  }
  vim_register_copy(dst, vim_state.params.selected_reg);
  vim_update_registers(app);
 }
 buffer_replace_range(app, buffer, range, string_u8_empty);
 if(vim_state.params.edit_type == EDIT_LineWise){
  i64 pos = get_line_side_pos_from_pos(app, buffer, view_get_cursor_pos(app, view), Side_Min);
  view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
 }
}

void vim_apply_change(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 vim_enter_insert_mode(app);
 vim_apply_delete(app, view, buffer, range);
}

void vim_apply_upper(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Scratch_Block scratch(app);
 String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
 string = string_mod_upper(string);
 buffer_replace_range(app, buffer, range, string);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}

void vim_apply_lower(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Scratch_Block scratch(app);
 String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
 string = string_mod_lower(string);
 buffer_replace_range(app, buffer, range, string);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}

void vim_apply_replace(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Scratch_Block scratch(app);
 String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
 for(i32 i=0; i<range_size(range); i++){
  if(string.str[i] != '\n'){ string.str[i] = vim_state.params.seek.character; }
 }
 buffer_replace_range(app, buffer, range, string);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}

void vim_apply_indent(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 i64 line0 = get_line_number_from_pos(app, buffer, range.min);
 i64 line1 = get_line_number_from_pos(app, buffer, range.max);
 line1 += (line0 == line1);
 History_Group history_group = history_group_begin(app, buffer);
 for(i64 l=line0; l<line1; l++){
  i64 pos = get_line_start_pos(app, buffer, l);
  buffer_replace_range(app, buffer, Ii64(pos), SCu8((u8*)("\t"), (u64)(sizeof("\t") - 1)));
 }
 history_group_end(history_group);
}

void vim_apply_outdent(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 i64 line0 = get_line_number_from_pos(app, buffer, range.min);
 i64 line1 = get_line_number_from_pos(app, buffer, range.max);
 line1 += (line0 == line1);
 History_Group history_group = history_group_begin(app, buffer);
 for(i64 l=line0; l<line1; l++){
  i64 pos = get_line_start_pos(app, buffer, l);
  Range_i64 tab_range = Ii64(pos, pos + (buffer_get_char(app, buffer, pos) == '\t'));
  buffer_replace_range(app, buffer, tab_range, string_u8_empty);
 }
 history_group_end(history_group);
}

void vim_apply_auto_indent(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 auto_indent_buffer(app, buffer, range);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}


void vim_apply_toggle_case(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Scratch_Block scratch(app);
 String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
 for(i32 i=0; i<string.size; i++){
  string.str[i] = character_toggle_case(string.str[i]);
 }
 buffer_replace_range(app, buffer, range, string);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}

void vim_apply_fold(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 fold_push(app, buffer, range);
}

static void
vim_init(Application_Links *app){
 init_keycode_lut();
 init_vim_boundaries();
 vim_reset_bottom_text();
 vim_reset_state();

    {
  default_color_table.arrays[defcolor_vim_filebar_pop] = default_color_table.arrays[defcolor_mark];
  default_color_table.arrays[defcolor_vim_chord_text] = default_color_table.arrays[defcolor_text_default];
  default_color_table.arrays[defcolor_vim_chord_unresolved] = default_color_table.arrays[defcolor_mark];
  default_color_table.arrays[defcolor_vim_chord_error] = default_color_table.arrays[defcolor_special_character];
 }


 Buffer_ID reg_buffer = create_buffer(app, SCu8((u8*)("*registers*"), (u64)(sizeof("*registers*") - 1)),
           BufferCreate_NeverAttachToFile|BufferCreate_AlwaysNew);
 buffer_set_setting(app, reg_buffer, BufferSetting_ReadOnly, true);
 buffer_set_setting(app, reg_buffer, BufferSetting_Unkillable, true);
 buffer_set_setting(app, reg_buffer, BufferSetting_Unimportant, true);


 vim_state.arena = make_arena_system();
 heap_init(&vim_state.heap, &vim_state.arena);
 vim_state.alloc = base_allocator_on_heap(&vim_state.heap);

 vim_request_vtable[REQUEST_None] = vim_apply_none;
 vim_request_vtable[REQUEST_Yank] = vim_apply_yank;
 vim_request_vtable[REQUEST_Delete] = vim_apply_delete;
 vim_request_vtable[REQUEST_Change] = vim_apply_change;
 vim_request_vtable[REQUEST_Upper] = vim_apply_upper;
 vim_request_vtable[REQUEST_Lower] = vim_apply_lower;
 vim_request_vtable[REQUEST_Replace] = vim_apply_replace;
 vim_request_vtable[REQUEST_ToggleCase] = vim_apply_toggle_case;
 vim_request_vtable[REQUEST_Indent] = vim_apply_indent;
 vim_request_vtable[REQUEST_Outdent] = vim_apply_outdent;
 vim_request_vtable[REQUEST_AutoIndent] = vim_apply_auto_indent;
 vim_request_vtable[REQUEST_Fold] = vim_apply_fold;

 vim_text_object_vtable[TEXT_OBJECT_para] = {'p', (Vim_Text_Object_Func *)vim_object_para};
 vim_text_object_vtable[TEXT_OBJECT_word] = {'w', (Vim_Text_Object_Func *)vim_object_word};
 vim_text_object_vtable[TEXT_OBJECT_Word] = {'W', (Vim_Text_Object_Func *)vim_object_WORD};

 for(i32 i=0; i<((sizeof(vim_request_vtable))/(sizeof(*vim_request_vtable))); i++){

  if(vim_request_vtable[i] == 0){ do{ if (!(false)) { (*((i32*)0) = 0xA11E); } }while(0); }



 }

 for(i32 i=0; i<((sizeof(vim_text_object_vtable))/(sizeof(*vim_text_object_vtable))); i++){

  if(vim_text_object_vtable[i].func == 0){ do{ if (!(false)) { (*((i32*)0) = 0xA11E); } }while(0); }





 }

 for(i32 i=0; i<((sizeof(vim_default_peek_list))/(sizeof(*vim_default_peek_list))); i++){
  vim_buffer_peek_list[i] = vim_default_peek_list[i];
 }
 for(i32 i=0; i<((sizeof(vim_buffer_peek_list))/(sizeof(*vim_buffer_peek_list))); i++){
  do{ if (!(vim_buffer_peek_list[i].buffer_id.name != 0)) { (*((i32*)0) = 0xA11E); } }while(0);
 }

 vim_register_copy(&vim_registers.small_delete, string_u8_empty);
 vim_register_copy(&vim_registers.insert, string_u8_empty);
 for(i32 i=i32(vim_registers.digit - vim_registers.r); i<((sizeof(vim_registers.r))/(sizeof(*vim_registers.r))); i++){
  vim_registers.r[i].flags |= REGISTER_ReadOnly;
 }

 Base_Allocator *base = get_base_allocator_system();
 for(i32 i=0; i<((sizeof(vim_maps))/(sizeof(*vim_maps))); i++){
  vim_maps[i] = make_table_u64_u64__inner((base),(100),SCu8((u8*)("4coder_vim/4coder_vim.cpp" ":" "180" ":"), (u64)(sizeof("4coder_vim/4coder_vim.cpp" ":" "180" ":") - 1)));
 }
}




static b32
vim_handle_visual_insert_mode(Application_Links *app, Input_Event *event){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

 static i32 count=0;

 if(event->kind == InputEventKind_KeyStroke){

  if(event->key.code == KeyCode_Escape || event->key.code == KeyCode_Return){
   vim_normal_mode(app);
   history_group_end(vim_history_group);
   if(vim_visual_insert_flags & bit_1){ toggle_line_wrap(app); }
   if(vim_visual_insert_flags & bit_2){ toggle_virtual_whitespace(app); }
   vim_visual_insert_flags = 0;
   count = 0;
   return true;
  }

  if(event->key.code == KeyCode_Backspace){
   if(count > 0){ undo(app); count--; }
   if(has_modifier(event, KeyCode_Control)){

    b32 clearing_whitespace = true;
    while(count > 0){
     Range_i64 range = get_view_range(app, view);
     i64 line_min = get_line_number_from_pos(app, buffer, range.min);
     Rect_f32 block_rect = vim_get_rel_block_rect(app, view, buffer, range, line_min);

     f32 x_off = vim_visual_insert_after*rect_width(block_rect);
     Vec2_f32 point = block_rect.p0 + V2f32(x_off, 0.f);
     i64 pos = view_pos_at_relative_xy(app, view, line_min, point) + vim_visual_insert_after;

     u8 c = buffer_get_char(app, buffer, pos-1);
     if(!clearing_whitespace && character_is_whitespace(c)){ break; }
     if(clearing_whitespace && !character_is_whitespace(c)){ clearing_whitespace = false; }

     undo(app); count--;
    }

   }
   return true;
  }


  b32 result = has_modifier(event, KeyCode_Control);
  event->kind = InputEventKind_None;
  return result;
 }

 if(event->kind == InputEventKind_TextInsert){
  vim_visual_insert_char(app, view, buffer, event->text.string.str[0]);
  count++;
  return true;
 }

 event->kind = InputEventKind_None;
 return false;
}

static b32
vim_handle_replace_mode(Application_Links *app, Input_Event *event){
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 if(event->kind == InputEventKind_KeyStroke){
  if(event->key.code == KeyCode_Escape){
   vim_normal_mode(app);
   history_group_end(vim_history_group);
   return true;
  }
  if(event->key.code == KeyCode_Backspace){
   if(has_modifier(event, KeyCode_Control)){
    i64 cursor_pos = view_get_cursor_pos(app, view);
    while(cursor_pos != view_get_mark_pos(app, view) &&
       !character_is_whitespace(buffer_get_char(app, buffer, cursor_pos-1)))
    {
     undo(app);
     cursor_pos = view_get_cursor_pos(app, view);
    }
    undo(app);
    return true;
   }else{
    if(view_get_cursor_pos(app, view) != view_get_mark_pos(app, view)){
     undo(app);
     return true;
    }
   }
  }


  b32 result = has_modifier(event, KeyCode_Control);
  event->kind = InputEventKind_None;
  return result;
 }

 if(event->kind == InputEventKind_TextInsert){
  i64 pos = view_get_cursor_pos(app, view);
  Range_i64 range = Ii64(pos, pos + (buffer_get_char(app, buffer, pos) != '\n'));
  buffer_replace_range(app, buffer, range, event->text.string);
  move_right(app);
 }

 return true;
}


static void vim_append_keycode(Key_Code code){
# 308 "4coder_vim/4coder_vim.cpp"
 if(code & KeyMod_Ctl){ string_append_character(&vim_keystroke_text, '^'); }
 if(code & KeyMod_Alt){ string_append_character(&vim_keystroke_text, '~'); }
 i32 index = (code & bitmask_8) + ((code & KeyMod_Sft) != 0)*KeyCode_COUNT;
 string_append(&vim_keystroke_text, SCu8(keycode_lut[index]));

}


static b32
vim_handle_input(Application_Links *app, Input_Event *event){
 switch(vim_state.mode){
  case VIM_Replace: return vim_handle_replace_mode(app, event);
  case VIM_Visual_Insert: return vim_handle_visual_insert_mode(app, event);
 }


 bool result = false;
 if(event->kind == InputEventKind_KeyStroke){


  Key_Code code = event->key.code;
  if(code != KeyCode_Control && code != KeyCode_Shift && code != KeyCode_Alt && code != KeyCode_Command && code != KeyCode_Menu){
   if(vim_state.chord_resolved){ vim_keystroke_text.size=0; vim_state.chord_resolved=false; }
   for(i32 i=0; i<event->key.modifiers.count; i++){
    Key_Code mod = event->key.modifiers.mods[i];
    if(0){}
    else if(mod == KeyCode_Control){ code |= KeyMod_Ctl; }
    else if(mod == KeyCode_Shift){ code |= KeyMod_Sft; }
    else if(mod == KeyCode_Alt){ code |= KeyMod_Alt; }
    else if(mod == KeyCode_Command){ code |= KeyMod_Cmd; }
    else if(mod == KeyCode_Menu){ code |= KeyMod_Mnu; }
   }
  }else{
   return true;
  }

  b32 was_in_sub_mode = (vim_state.sub_mode != SUB_None);
  u64 function_data=0;
  if(table_read(vim_maps + vim_state.mode + vim_state.sub_mode*VIM_MODE_COUNT, code, &function_data)){
   Custom_Command_Function *vim_func = (Custom_Command_Function *)(void*)(((u8*)0) + function_data);
   if(vim_func){

    View_ID view = get_active_view(app, Access_ReadVisible);
    Managed_Scope scope = view_get_managed_scope(app, view);
    default_pre_command(app, scope);
    vim_pre_keystroke_size = vim_keystroke_text.size;
    vim_append_keycode(code);
    vim_state.active_command = vim_func;
    vim_state.chord_resolved = true;
    if(vim_func == no_op){ vim_state.chord_resolved = bitmask_2; }

    vim_func(app);


    default_post_command(app, scope);
    vim_state.active_command = 0;

    result = true;
   }
  }else{
   if(vim_state.mode != VIM_Insert){
    String_ID map_id = vars_save_string(SCu8((u8*)("keys_global"), (u64)(sizeof("keys_global") - 1)));
    Command_Binding command_binding = map_get_binding_non_recursive(&framework_mapping, map_id, event);
    if(command_binding.custom){
     vim_reset_state();
     command_binding.custom(app);
     vim_keystroke_text.size = 0;
    }else{
     vim_append_keycode(code);
     vim_state.chord_resolved = bitmask_2;
    }
    result = true;
   }
  }
  if(was_in_sub_mode){ vim_state.sub_mode = SUB_None; }

  if(vim_keystroke_text.size >= vim_keystroke_text.cap){ vim_keystroke_text.size = 0; }

  return result;
 }

 return false;
}

static String_Const_u8 vim_get_bot_string(){
 String_Const_u8 result = vim_bot_text.string;

 if(vim_is_querying_user_key){ return result; }

 switch(vim_state.mode){
  case VIM_Insert: result = SCu8((u8*)("-- INSERT --"), (u64)(sizeof("-- INSERT --") - 1)); break;
  case VIM_Replace: result = SCu8((u8*)("-- REPLACE --"), (u64)(sizeof("-- REPLACE --") - 1)); break;
  case VIM_Visual_Insert: result = SCu8((u8*)("-- VISUAL INSERT --"), (u64)(sizeof("-- VISUAL INSERT --") - 1)); break;
  case VIM_Visual:{
   switch(vim_state.params.edit_type){
    case EDIT_CharWise: result = SCu8((u8*)("-- VISUAL --"), (u64)(sizeof("-- VISUAL --") - 1)); break;
    case EDIT_LineWise: result = SCu8((u8*)("-- VISUAL LINE --"), (u64)(sizeof("-- VISUAL LINE --") - 1)); break;
    case EDIT_Block: result = SCu8((u8*)("-- VISUAL BLOCK --"), (u64)(sizeof("-- VISUAL BLOCK --") - 1)); break;
   }
  } break;
 }

 if(vim_state.macro_char){
  static u8 macro_string_buffer[] = "-- RECORDING   --";
  macro_string_buffer[13] = vim_state.macro_char;
  result = SCu8(macro_string_buffer, ((sizeof(macro_string_buffer))/(sizeof(*macro_string_buffer)))-1);
 }

 return result;
}
# 92 "4coder_vim/4coder_vim_include.h" 2

# 1 "4coder_vim/4coder_vim_draw.cpp" 1

static void
vim_draw_visual_mode(Application_Links *app, View_ID view, Buffer_ID buffer, Face_ID face_id, Text_Layout_ID text_layout_id){
 Range_i64 range = get_view_range(app, view);

 ARGB_Color text_color = fcolor_resolve(fcolor_id(defcolor_at_highlight));
 switch(vim_state.params.edit_type){
  case EDIT_Block:{
   Rect_f32 block_rect = vim_get_abs_block_rect(app, view, buffer, text_layout_id, range);
   draw_rectangle_fcolor(app, block_rect, 5.f, fcolor_id(defcolor_highlight));

   i64 line_min = get_line_number_from_pos(app, buffer, range.min);
   i64 line_max = get_line_number_from_pos(app, buffer, range.max);
   f32 line_advance = rect_height(block_rect)/f32((((1)>(line_max-line_min))?(1):(line_max-line_min)));
   f32 wid = rect_width(block_rect);

   Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
   Range_i64 test_range = range_intersect(visible_range, range);
   i64 test_line_min = get_line_number_from_pos(app, buffer, test_range.min);
   i64 test_line_max = get_line_number_from_pos(app, buffer, test_range.max);

   ARGB_Color helper_color = fcolor_resolve(fcolor_id(defcolor_mark));
   for(i64 i=test_line_min; i<=test_line_max; i++){
    if(line_is_valid_and_blank(app, buffer, i) && i != line_min && i != line_max){ continue; }
    Vec2_f32 min_point = block_rect.p0 + V2f32(0, line_advance*(i-line_min));
    Vec2_f32 max_point = min_point + V2f32(wid,0);
    i64 min_pos = view_pos_from_xy(app, view, min_point);
    i64 max_pos = view_pos_from_xy(app, view, max_point);
    paint_text_color(app, text_layout_id, Ii64(min_pos, max_pos), text_color);

    if(!vim_show_block_helper || min_pos == max_pos){ continue; }
    Rect_f32 min_rect = text_layout_character_on_screen(app, text_layout_id, min_pos);
    Rect_f32 max_rect = text_layout_character_on_screen(app, text_layout_id, max_pos-1);
    draw_rectangle(app, rect_split_top_bottom_neg(min_rect, 3.f).b, 3.0f, helper_color);
    draw_rectangle(app, rect_split_top_bottom(max_rect, 3.f).a, 3.0f, helper_color);
    draw_rectangle(app, rect_split_left_right(min_rect, 3.f).a, 3.0f, helper_color);
    draw_rectangle(app, rect_split_left_right_neg(max_rect, 3.f).b, 3.0f, helper_color);
   }
  } break;

  case EDIT_LineWise:{
   range.min = get_line_side_pos_from_pos(app, buffer, range.min, Side_Min);
   range.max = get_line_side_pos_from_pos(app, buffer, range.max, Side_Max) + 1;

   if(vim_do_full_line){
    Range_i64 line_range = Ii64(get_line_number_from_pos(app, buffer, range.min),
           get_line_number_from_pos(app, buffer, range.max)-1);
    draw_line_highlight(app, text_layout_id, line_range, fcolor_id(defcolor_highlight));
    paint_text_color(app, text_layout_id, range, text_color);
    break;
   }



   Managed_Scope scope = buffer_get_managed_scope(app, buffer);
   Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
   b32 is_code = *map_id_ptr == i64(vars_save_string(SCu8((u8*)("keys_code"), (u64)(sizeof("keys_code") - 1))));
   b32 virtual_enabled = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
   if((virtual_enabled && is_code) && character_is_whitespace(buffer_get_char(app, buffer, range.min))){

    i64 line_end = get_line_end_pos(app, buffer, get_line_number_from_pos(app, buffer, range.min));
    line_end -= (line_end > 0 && buffer_get_char(app, buffer, line_end) == '\n' && buffer_get_char(app, buffer, line_end-1) == '\r');
    i64 non_ws = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, Scan_Forward, range.min);
    range.min = (((line_end)<(non_ws))?(line_end):(non_ws));
   }

  }

  case EDIT_CharWise:{
   if(vim_state.params.edit_type != EDIT_LineWise){ range.max++; }
   draw_character_block(app, text_layout_id, range, 5.f, fcolor_id(defcolor_highlight));
   paint_text_color(app, text_layout_id, range, text_color);
  } break;
 }
}

static void
vim_draw_filebar(Application_Links *app, View_ID view_id, Buffer_ID buffer, Frame_Info frame_info, Face_ID face_id, Rect_f32 bar){
 Scratch_Block scratch(app);
 String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);

 draw_rectangle_fcolor(app, bar, 0.f, fcolor_id(defcolor_bar));

 f32 char_wid = get_face_metrics(app, face_id).normal_advance;
 Rect_f32 title_rect = bar;
 title_rect.x1 = bar.x0 + char_wid*unique_name.size;
 draw_rectangle_fcolor(app, title_rect, 0.f, fcolor_id(defcolor_vim_filebar_pop));

 Rect_f32 triangle_rect = title_rect;
 f32 radius_fudge = 5.f;
 triangle_rect.x0 = title_rect.x1 - radius_fudge*char_wid;
 triangle_rect.x1 = title_rect.x1 + radius_fudge*char_wid;
 draw_rectangle_fcolor(app, triangle_rect, radius_fudge*char_wid, fcolor_id(defcolor_vim_filebar_pop));

 FColor base_color = fcolor_id(defcolor_base);
 FColor pop2_color = fcolor_id(defcolor_pop2);

 i64 cursor_position = view_get_cursor_pos(app, view_id);
 Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(cursor_position));

 u8 space[5];
 String_u8 str = Su8(space, 0, 4);

 Managed_Scope scope = buffer_get_managed_scope(app, buffer);
 Line_Ending_Kind *eol_kind = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
 switch(*eol_kind){
  case LineEndingKind_Binary:{ string_append(&str, SCu8((u8*)("bin"), (u64)(sizeof("bin") - 1))); } break;
  case LineEndingKind_LF: { string_append(&str, SCu8((u8*)("lf"), (u64)(sizeof("lf") - 1))); } break;
  case LineEndingKind_CRLF: { string_append(&str, SCu8((u8*)("crlf"), (u64)(sizeof("crlf") - 1))); } break;
 }


 Vec2_f32 p = V2f32(title_rect.x1 + 4.5f*char_wid, bar.y0 + 3.f);
 p = draw_string(app, face_id, str.string, p, base_color);

 str = Su8(space, 0, 5);
 Dirty_State dirty = buffer_get_dirty_state(app, buffer);
 if(dirty != 0){
  string_append(&str, SCu8((u8*)(" ["), (u64)(sizeof(" [") - 1)));
  if((((dirty)&(DirtyState_UnsavedChanges))!=0))
   string_append(&str, SCu8((u8*)("+"), (u64)(sizeof("+") - 1)));
  if((((dirty)&(DirtyState_UnloadedChanges))!=0))
   string_append(&str, SCu8((u8*)("!"), (u64)(sizeof("!") - 1)));
  string_append(&str, SCu8((u8*)("]"), (u64)(sizeof("]") - 1)));
  draw_string(app, face_id, str.string, p, pop2_color);
 }

 p.x = (((p.x + 5.f*char_wid)>(bar.x1 - char_wid*15.f))?(p.x + 5.f*char_wid):(bar.x1 - char_wid*15.f));
 draw_string(app, face_id, push_stringf(scratch, "%d,%d", cursor.line, cursor.col), p, base_color);

 p.x = bar.x0 + 2.f;
 draw_string(app, face_id, unique_name, p, base_color);

 p.x = bar.x1 - char_wid*3.5f;
 i64 buffer_size = buffer_get_size(app, buffer);
 String_Const_u8 PosText;
 if(cursor_position == 0){
  PosText = SCu8((u8*)("Top"), (u64)(sizeof("Top") - 1));
 }else if(cursor_position == buffer_size){
  PosText = SCu8((u8*)("Bot"), (u64)(sizeof("Bot") - 1));
 }else{
  PosText = push_stringf(scratch, "%d%%", i64(100.f*cursor_position/(buffer_size)));
 }
 draw_string(app, face_id, PosText, p, base_color);
}

static void
vim_draw_search_highlight(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id, f32 roundness){
 String_u8 *pattern = &vim_registers.search.data;
 if(pattern->size == 0){ return; }
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
 i64 buffer_size = buffer_get_size(app, buffer);
 i64 cur_pos = visible_range.min;
 while(cur_pos < visible_range.max){
  i64 new_pos = 0;
  seek_string_forward(app, buffer, cur_pos, 0, pattern->string, &new_pos);
  if(new_pos == 0 || new_pos == buffer_size){ break; }
  else{
   cur_pos = new_pos;
   Rect_f32 rect = text_layout_character_on_screen(app, text_layout_id, cur_pos);
   rect.x1 = rect.x0 + pattern->size*(rect_width(rect));
   draw_rectangle_fcolor(app, rect, roundness, fcolor_id(defcolor_highlight));
  }
 }
}

static void
vim_draw_cursor(Application_Links *app, View_ID view, b32 is_active_view, Buffer_ID buffer, Text_Layout_ID text_layout_id, f32 roundness, f32 thickness){

 if(is_active_view && vim_state.mode == VIM_Visual_Insert){
  animate_in_n_milliseconds(app, 0);

  if((!(((vim_cursor_blink) / 20) & 0x1))){
   Range_i64 range = get_view_range(app, view);
   Rect_f32 block_rect = vim_get_abs_block_rect(app, view, buffer, text_layout_id, range);


   if(vim_visual_insert_after){
    block_rect.x0 = block_rect.x1 - 2.f;
   }else{
    block_rect.x1 = block_rect.x0 + 2.f;
   }
   draw_rectangle_fcolor(app, block_rect, 1.f, fcolor_id(defcolor_cursor));
  }
  return;
 }

 b32 has_highlight_range = draw_highlight_range(app, view, buffer, text_layout_id, roundness);
 if(!has_highlight_range){
  i32 cursor_sub_id = default_cursor_sub_id();

  i64 cursor_pos = view_get_cursor_pos(app, view);
  i64 mark_pos = view_get_mark_pos(app, view);
  if(is_active_view && vim_lister_view_id == 0){
   animate_in_n_milliseconds(app, 0);

   Rect_f32 rect = text_layout_character_on_screen(app, text_layout_id, cursor_pos);

   if((!(((vim_cursor_blink) / 20) & 0x1)) && !vim_is_selecting_register){
    if(vim_state.mode == VIM_Insert){ rect = rect_split_top_bottom_neg(rect, 5.f).b; }

    if(rect.p1 != V2f32(0,0)){
     vim_nxt_cursor_pos = rect.p1;
    }

    Rect_f32 cursor_rect = Rf32_xy_wh(vim_cur_cursor_pos - rect_dim(rect), rect_dim(rect));
    draw_rectangle_fcolor(app, cursor_rect, roundness, fcolor_id(defcolor_cursor, cursor_sub_id));






    if(vim_state.mode != VIM_Insert){
     paint_text_color_pos(app, text_layout_id, cursor_pos, fcolor_id(defcolor_at_cursor));
    }
   }
   if(vim_state.mode == VIM_Insert){
    draw_character_wire_frame(app, text_layout_id, mark_pos,roundness, thickness, fcolor_id(defcolor_mark));
   }
  }else{
   draw_character_wire_frame(app, text_layout_id, cursor_pos, roundness, thickness, fcolor_id(defcolor_cursor, cursor_sub_id));
   if(vim_state.mode == VIM_Insert){
    draw_character_wire_frame(app, text_layout_id, mark_pos, roundness, thickness, fcolor_id(defcolor_mark));
   }
  }
 }
}

static void
vim_draw_after_text(Application_Links *app, View_ID view, b32 is_active_view, Buffer_ID buffer, Text_Layout_ID text_layout_id, f32 cursor_roundness, f32 mark_thickness){
 if(is_active_view && vim_is_selecting_register && vim_state.mode == VIM_Insert){
  i64 cursor_pos = view_get_cursor_pos(app, view);
  Rect_f32 cursor_rect = text_layout_character_on_screen(app, text_layout_id, cursor_pos);
  draw_rectangle_fcolor(app, cursor_rect, 0.f, fcolor_id(defcolor_back));
  if(!def_get_config_b32(vars_save_string(SCu8((u8*)("highlight_line_at_cursor"), (u64)(sizeof("highlight_line_at_cursor") - 1))))){
   draw_rectangle_fcolor(app, cursor_rect, 0.f, fcolor_id(defcolor_highlight_cursor_line));
  }
  vim_draw_cursor(app, view, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness);
  draw_string(app, get_face_id(app, 0), SCu8((u8*)("\""), (u64)(sizeof("\"") - 1)), cursor_rect.p0, fcolor_id(defcolor_text_default));
 }
}

static Rect_f32
vim_draw_query_bars(Application_Links *app, Rect_f32 region, View_ID view_id, Face_ID face_id){
 Face_Metrics face_metrics = get_face_metrics(app, face_id);
 f32 line_height = face_metrics.line_height;

 Query_Bar *space[32];
 Query_Bar_Ptr_Array query_bars = {};
 query_bars.ptrs = space;
 if(get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
  for(i32 i=0; i<query_bars.count; i++){
   Rect_f32_Pair pair = layout_query_bar_on_bot(region, line_height, 1);
   draw_rectangle_fcolor(app, pair.max, 0.f, fcolor_id(defcolor_back));
   draw_query_bar(app, query_bars.ptrs[i], face_id, pair.max);
   region = pair.min;
  }
 }
 return region;
}

static Rect_f32_Pair
vim_line_number_margin(Application_Links *app, Buffer_ID buffer, Rect_f32 rect, f32 digit_advance){
 i64 line_count = buffer_get_line_count(app, buffer);
 i64 digit_count = digit_count_from_integer(line_count, 10) + i64(vim_relative_numbers != 0);

 f32 margin_width = (f32)digit_count*digit_advance + 6.f;
 Rect_f32_Pair pair = rect_split_left_right(rect, margin_width);
 pair.a = rect_split_left_right(pair.a, 6.f).b;
 pair.b = rect_split_left_right(pair.b, 4.f).b;
 return pair;
}


static void
vim_draw_rel_line_number_margin(Application_Links *app, View_ID view, Buffer_ID buffer, Face_ID face, Text_Layout_ID text_layout_id, Rect_f32 margin){
 Rect_f32 prev_clip = draw_set_clip(app, margin);
 draw_rectangle_fcolor(app, margin, 0.f, fcolor_id(defcolor_line_numbers_back));

 const i64 cur_line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
 const i64 line_count = buffer_get_line_count(app, buffer);

 i64 cur_line_digit_count = digit_count_from_integer(cur_line, 10);
 i64 bot_line_digit_count = digit_count_from_integer(line_count, 10);
 i64 digit_count = (((cur_line_digit_count+1)>(bot_line_digit_count))?(cur_line_digit_count+1):(bot_line_digit_count));

 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
 Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(visible_range.first));
 Buffer_Cursor cursor_end = view_compute_cursor(app, view, seek_pos(visible_range.end));
 const i64 first_line_num = cursor.line;
 const i64 one_past_last = cursor_end.line;

 Scratch_Block scratch(app);
 u8 *digit_buffer = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(digit_count), SCu8((u8*)("4coder_vim/4coder_vim_draw.cpp" ":" "295" ":"), (u64)(sizeof("4coder_vim/4coder_vim_draw.cpp" ":" "295" ":") - 1)))));
 String_Const_u8 digit_string = SCu8(digit_buffer, digit_count);
 for(i32 i=0; i<digit_count; i++){ digit_buffer[i] = ' '; }

 u8 *small_digit = digit_buffer + (digit_count-1) - 1;
 u8 *ptr = small_digit;
 if(cur_line == 0){ *ptr = '0'; }
 else{
  for(u64 X=cur_line; X>0; X/=10){
   *ptr-- = '0' + (X%10);
  }
 }
 small_digit++;

 Range_f32 line_y = text_layout_line_on_screen(app, text_layout_id, cur_line);
 Vec2_f32 p = V2f32(margin.x0, line_y.min);


 FColor text_color = fcolor_id(defcolor_line_numbers_text);
 FColor contrast_color = fcolor_blend(text_color, 0.4f, f_white);

 draw_string(app, face, digit_string, p, fcolor_resolve(contrast_color));

 i32 rel_num = 1;
 for(i32 i=0; i<digit_count-1; i++){ digit_buffer[i] = ' '; }
 digit_buffer[digit_count-1] = '1';

 for(;;){
  i64 bot_line = cur_line+rel_num;
  if(bot_line > one_past_last){ break; }

  for(;;){
   line_y = text_layout_line_on_screen(app, text_layout_id, cur_line+rel_num);
   if(line_y.min != line_y.max){ break; }
   rel_num++;
  }
  p = V2f32(margin.x0, line_y.min);
  draw_string(app, face, digit_string, p, fcolor_resolve(text_color));

  rel_num++;
  ptr = small_digit;
  while(ptr >= digit_buffer){
   if(*ptr == ' '){ *ptr = '0'; }
   if(*ptr == '9'){ *ptr-- = '0'; }
   else{ (*ptr)++; break; }
  }
 }

 rel_num = 1;
 for(i32 i=0; i<digit_count-1; i++){ digit_buffer[i] = ' '; }
 digit_buffer[digit_count-1] = '1';

 for(;;){
  i64 top_line = cur_line-rel_num;
  if(top_line < first_line_num){ break; }

  for(;;){
   line_y = text_layout_line_on_screen(app, text_layout_id, cur_line-rel_num);
   if(line_y.min != line_y.max){ break; }
   rel_num++;
  }
  p = V2f32(margin.x0, line_y.min);
  draw_string(app, face, digit_string, p, fcolor_resolve(text_color));

  rel_num++;
  ptr = small_digit;
  while(ptr >= digit_buffer){
   if(*ptr == ' '){ *ptr = '0'; }
   if(*ptr == '9'){ *ptr-- = '0'; }
   else{ (*ptr)++; break; }
  }
 }
 draw_set_clip(app, prev_clip);
}

static void
vim_draw_line_number_margin(Application_Links *app, View_ID view, Buffer_ID buffer, Face_ID face, Text_Layout_ID text_layout_id, Rect_f32 margin){

 Scratch_Block scratch(app);
 Rect_f32 prev_clip = draw_set_clip(app, margin);
 draw_rectangle_fcolor(app, margin, 0.f, fcolor_id(defcolor_line_numbers_back));

 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 digit_count = digit_count_from_integer(line_count, 10);

 u8 *digit_buffer = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(digit_count), SCu8((u8*)("4coder_vim/4coder_vim_draw.cpp" ":" "381" ":"), (u64)(sizeof("4coder_vim/4coder_vim_draw.cpp" ":" "381" ":") - 1)))));
 String_Const_u8 digit_string = SCu8(digit_buffer, digit_count);
 for(i32 i=0; i<digit_count; i++){ digit_buffer[i] = ' '; }

 i64 cur_line = view_compute_cursor(app, view, seek_pos(visible_range.min)).line;
 i64 end_line = view_compute_cursor(app, view, seek_pos(visible_range.max)).line+1;

 u8 *small_digit = digit_buffer + (digit_count-1) - 1;
 u8 *ptr = small_digit;
 if(cur_line == 0){ *ptr = '0'; }
 else{
  for(u64 X=cur_line; X>0; X/=10){
   *ptr-- = '0' + (X%10);
  }
 }

 Range_f32 line_y = text_layout_line_on_screen(app, text_layout_id, cur_line);
 Vec2_f32 p = V2f32(margin.x0, line_y.min);


 FColor text_color = fcolor_id(defcolor_line_numbers_text);
 FColor contrast_color = fcolor_blend(text_color, 0.4f, f_white);

 draw_string(app, face, digit_string, p, fcolor_resolve(contrast_color));

 for(;;){
  if(cur_line > end_line){ break; }

  line_y = text_layout_line_on_screen(app, text_layout_id, cur_line);
  if(line_y.min != line_y.max){
   p = V2f32(margin.x0, line_y.min);
   draw_string(app, face, digit_string, p, fcolor_resolve(text_color));
  }

  cur_line++;
  ptr = small_digit;
  while(ptr >= digit_buffer){
   if(*ptr == ' '){ *ptr = '0'; }
   if(*ptr == '9'){ *ptr-- = '0'; }
   else{ (*ptr)++; break; }
  }
 }

 draw_set_clip(app, prev_clip);
}

static void
vim_draw_whole_screen(Application_Links *app, Frame_Info frame_info){
 Rect_f32 region = global_get_screen_rectangle(app);
 Vec2_f32 center = rect_center(region);
 draw_set_clip(app, region);

 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics metrics = get_face_metrics(app, face_id);
 f32 line_height = metrics.line_height;
 f32 char_wid = metrics.normal_advance;


 if(vim_cur_cursor_pos != vim_nxt_cursor_pos){
  Vec2_f32 cursor_dim = V2f32(9.f, (vim_state.mode == VIM_Insert ? 4.f : 18.f));
  Rect_f32 cursor_rect = Rf32_xy_wh(vim_cur_cursor_pos - cursor_dim, cursor_dim);
  u64 cursor_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("cursor_roundness"), (u64)(sizeof("cursor_roundness") - 1))));
  f32 roundness = char_wid*cursor_roundness_100*0.01f;
  draw_rectangle_fcolor(app, cursor_rect, roundness, fcolor_id(defcolor_cursor, default_cursor_sub_id()));
 }

 ARGB_Color back_color = fcolor_resolve(fcolor_id(defcolor_back));


 Rect_f32 back_rect = vim_get_bottom_rect(app);
 if(vim_cur_filebar_offset > vim_nxt_filebar_offset){
  draw_rectangle(app, back_rect, 0.f, back_color);
  draw_rectangle_fcolor(app, rect_split_top_bottom_neg(back_rect, 4.f).b, 0.f, get_item_margin_color(UIHighlight_Active));
 }

 draw_rectangle(app, rect_split_top_bottom_neg(region, 2.f*line_height).b, 0.f, back_color);

 Vec2_f32 bot_left = {region.x0 + 4.f, region.y1 - 1.5f*line_height};
 String_Const_u8 bot_string = vim_get_bot_string();

 if(vim_use_bottom_cursor){
  Vec2_f32 p = draw_string(app, face_id, vim_bot_text.string, bot_left, finalize_color(defcolor_text_default, 0));
  if((!(((vim_cursor_blink) / 20) & 0x1))){
   p.x -= 0.37f*(p.x - bot_left.x)/vim_bot_text.size;
   draw_string(app, face_id, SCu8((u8*)("|"), (u64)(sizeof("|") - 1)), p, finalize_color(defcolor_text_default, 0));
  }
 }else{
  draw_string(app, face_id, bot_string, bot_left, finalize_color(defcolor_text_default, 0));
 }

 if(vim_lister_view_id == 0){

  if(vim_show_buffer_peek && rect_height(back_rect) > 0.f){
   Vim_Buffer_Peek_Entry *entry = vim_buffer_peek_list + vim_buffer_peek_index;
   Buffer_Identifier buffer_iden = entry->buffer_id;
   Buffer_ID buffer = buffer_identifier_to_id(app, buffer_iden);
   vim_set_bottom_text(SCu8((u8 *)buffer_iden.name, buffer_iden.name_len));

   f32 ratio_diff = entry->nxt_ratio - entry->cur_ratio;
   entry->cur_ratio += ratio_diff*frame_info.animation_dt*20.f;

   Buffer_Point buffer_point = {};
   i64 line_count = buffer_get_line_count(app, buffer);

   buffer_point.pixel_shift.y = line_height*entry->cur_ratio*(line_count+1) - rect_height(back_rect);

   FColor peek_back_color = fcolor_id(defcolor_back);
   draw_rectangle_fcolor(app, back_rect, 0.f, peek_back_color);
   Rect_f32_Pair pair = rect_split_top_bottom_neg(back_rect, 4.f);
   draw_rectangle_fcolor(app, pair.b, 0.f, get_item_margin_color(UIHighlight_Active));
   back_rect = rect_split_left_right(pair.a, 4.f).b;
   Rect_f32 prev_clip = draw_set_clip(app, back_rect);

   Text_Layout_ID text_layout_id = text_layout_create(app, buffer, back_rect, buffer_point);
   Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

   paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
   paint_fade_ranges(app, text_layout_id, buffer);
   draw_text_layout_default(app, text_layout_id);

   text_layout_free(app, text_layout_id);
   draw_set_clip(app, prev_clip);
  }
 }

 Vec2_f32 bot_right = {region.x1 - 4.f - char_wid*vim_keystroke_text.size, bot_left.y};
 FColor chord_color = fcolor_id(defcolor_vim_chord_unresolved);
 if(vim_state.chord_resolved){
  chord_color = (vim_state.chord_resolved & bit_2 ? fcolor_id(defcolor_vim_chord_error) : fcolor_id(defcolor_vim_chord_text));
 }
 draw_string(app, face_id, vim_keystroke_text.string, bot_right, chord_color);
}
# 94 "4coder_vim/4coder_vim_include.h" 2
# 1 "4coder_vim/4coder_vim_hooks.cpp" 1

CUSTOM_COMMAND(vim_view_input_handler, "4coder_vim/4coder_vim_hooks.cpp", 2, Normal)
CUSTOM_DOC("Input consumption loop for vim behavior")
{
 Scratch_Block scratch(app);
 default_input_handler_init(app, scratch);

 View_ID view = get_this_ctx_view(app, Access_Always);
 Managed_Scope scope = view_get_managed_scope(app, view);

 for(;;){
  User_Input input = get_next_input(app, EventPropertyGroup_Any, 0);
  if(input.abort){ break; }



  if(vim_lister_view_id != 0 && view != vim_lister_view_id){
   view_set_active(app, vim_lister_view_id);
   leave_current_input_unhandled(app);
   continue;
  }


  Profile_Scope_Block view_input_profile ((app), SCu8((u8*)("before view input"), (u64)(sizeof("before view input") - 1)), SCu8((u8*)("4coder_vim/4coder_vim_hooks.cpp" ":" "24" ":"), (u64)(sizeof("4coder_vim/4coder_vim_hooks.cpp" ":" "24" ":") - 1)));


  Event_Property event_properties = get_event_properties(&input.event);
  if((suppressing_mouse && (event_properties & EventPropertyGroup_AnyMouseEvent) != 0)){
   continue;
  }

  if(vim_handle_input(app, &input.event)){
   vim_cursor_blink = 0;
   continue;
  }


  if(implicit_map_function == 0){
   implicit_map_function = default_implicit_map;
  }
  Implicit_Map_Result map_result = implicit_map_function(app, 0, 0, &input.event);
  if(map_result.command == 0){
   leave_current_input_unhandled(app);
   continue;
  }

  if(!(event_properties & EventPropertyGroup_AnyMouseEvent) && input.event.kind != InputEventKind_None){
   vim_keystroke_text.size = 0;
   vim_cursor_blink = 0;
  }


  default_pre_command(app, scope);
  ((view_input_profile).close_now());

  map_result.command(app);

  Profile_Scope_Block profile_block_58 ((app), SCu8((u8*)("after view input"), (u64)(sizeof("after view input") - 1)), SCu8((u8*)("4coder_vim/4coder_vim_hooks.cpp" ":" "58" ":"), (u64)(sizeof("4coder_vim/4coder_vim_hooks.cpp" ":" "58" ":") - 1)));
  default_post_command(app, scope);
 }
}


static void vim_insert_command(Application_Links *app){
 vim_state.mode = VIM_Normal;
 vim_state.chord_resolved = false;

 Scratch_Block scratch(app);
 default_input_handler_init(app, scratch);

 View_ID view = get_this_ctx_view(app, Access_Always);
 Managed_Scope scope = view_get_managed_scope(app, view);

 while(!vim_state.chord_resolved){
  vim_set_bottom_text(SCu8((u8*)("-- INSERT NORMAL --"), (u64)(sizeof("-- INSERT NORMAL --") - 1)));


  User_Input input = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if(input.abort){ break; }

  Event_Property event_properties = get_event_properties(&input.event);
  if((suppressing_mouse && (event_properties & EventPropertyGroup_AnyMouseEvent) != 0)){
   continue;
  }

  if(vim_handle_input(app, &input.event)){
   vim_cursor_blink = 0;
   continue;
  }

  if(implicit_map_function == 0){
   implicit_map_function = default_implicit_map;
  }
  Implicit_Map_Result map_result = implicit_map_function(app, 0, 0, &input.event);
  if(map_result.command == 0){
   leave_current_input_unhandled(app);
   continue;
  }

  if(!(event_properties & EventPropertyGroup_AnyMouseEvent) && input.event.kind != InputEventKind_None){
   vim_keystroke_text.size = 0;
   vim_cursor_blink = 0;
  }

  default_pre_command(app, scope);
  map_result.command(app);
  default_post_command(app, scope);
 }

 vim_reset_bottom_text();
 vim_state.mode = VIM_Insert;
}

static void
vim_file_save(Application_Links *app, Buffer_ID buffer_id){
 Scratch_Block scratch(app);
 String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer_id);
 i64 line_count = buffer_get_line_count(app, buffer_id);
 i64 bytes = buffer_get_size(app, buffer_id);
 String_Const_u8 msg = push_stringf(scratch, "\"%.*s\"  %dL, %dC written", (i32)(unique_name).size, (char*)(unique_name).str, line_count, bytes);
 vim_set_bottom_text(msg);
}

i32 vim_file_save_hook(Application_Links *app, Buffer_ID buffer_id){
 default_file_save(app, buffer_id);
 vim_file_save(app, buffer_id);
 return 0;
}

static void vim_set_file_register(Application_Links *app, Buffer_ID buffer){
 Scratch_Block scratch(app);
 String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);
 Vim_Register *reg = &vim_registers.file;
 b32 valid = vim_register_copy(reg, unique_name);
 if(!valid){ return; }
 vim_update_registers(app);
}

static void
vim_view_change_buffer(Application_Links *app, View_ID view_id, Buffer_ID old_buffer_id, Buffer_ID new_buffer_id){
 vim_set_file_register(app, new_buffer_id);
}

static void
vim_begin_buffer_inner(Application_Links *app, Buffer_ID buffer_id){
 Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
 Vim_Prev_Visual *prev_visual = ((Vim_Prev_Visual*)managed_scope_get_attachment((app), (scope), (vim_buffer_prev_visual), sizeof(Vim_Prev_Visual)));
 prev_visual->cursor_pos = prev_visual->mark_pos = 0;

 i64 *marks = (i64 *)managed_scope_get_attachment(app, scope, vim_buffer_marks, 26*sizeof(i64));
 block_fill_u64(marks, 26*sizeof(i64), max_u64);

 b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
 *wrap_lines_ptr = false;
}

i32 vim_begin_buffer(Application_Links *app, Buffer_ID buffer_id){

 fold_begin_buffer_hook(app, buffer_id);
 vim_begin_buffer_inner(app, buffer_id);
 return 0;
}

static void
vim_animate_filebar(Application_Links *app, Frame_Info frame_info){

 f32 diff = vim_nxt_filebar_offset - vim_cur_filebar_offset;
 if(fabs(diff) > 1.0f){
  vim_cur_filebar_offset += diff*frame_info.animation_dt*25.0f;
  animate_in_n_milliseconds(app, 0);
 }else{
  vim_cur_filebar_offset = vim_nxt_filebar_offset;
 }



}


static void
vim_animate_cursor(Application_Links *app, Frame_Info frame_info){

 Vec2_f32 diff = vim_nxt_cursor_pos - vim_cur_cursor_pos;
 if(fabs(diff.x) > 1.f){
  vim_cur_cursor_pos.x += diff.x*frame_info.animation_dt*30.f;
  animate_in_n_milliseconds(app, 0);
 }else{
  vim_cur_cursor_pos.x = vim_nxt_cursor_pos.x;
 }
 if(fabs(diff.y) > 1.f){
  vim_cur_cursor_pos.y += diff.y*frame_info.animation_dt*30.f;
  animate_in_n_milliseconds(app, 0);
 }else{
  vim_cur_cursor_pos.y = vim_nxt_cursor_pos.y;
 }



}

i32 vim_buffer_edit_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range){
 default_buffer_edit_range(app, buffer_id, new_range, old_cursor_range);
 fold_buffer_edit_range_inner(app, buffer_id, new_range, old_cursor_range);

 return 0;
}

static void
vim_tick(Application_Links *app, Frame_Info frame_info){
 code_index_update_tick(app);
 if(tick_all_fade_ranges(app, frame_info.animation_dt)){
  animate_in_n_milliseconds(app, 0);
 }

 vim_animate_filebar(app, frame_info);
 vim_animate_cursor(app, frame_info);

 vim_cursor_blink++;


 fold_tick(app, frame_info);

 b32 enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
 if(enable_virtual_whitespace != def_enable_virtual_whitespace){
  def_enable_virtual_whitespace = enable_virtual_whitespace;
  clear_all_layouts(app);
 }
}

CUSTOM_COMMAND(vim_try_exit, "4coder_vim/4coder_vim_hooks.cpp", 230, Normal)
CUSTOM_DOC("Vim command for responding to a try-exit event")
{
 User_Input input = get_current_input(app);
 if(match_core_code(&input, CoreCode_TryExit)){
  b32 do_exit = true;
  if(!allow_immediate_close_without_checking_for_changes){
   b32 has_unsaved_changes = false;
   for(Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
    buffer;
    buffer = get_buffer_next(app, buffer, Access_Always))
   {
    Dirty_State dirty = buffer_get_dirty_state(app, buffer);
    if((((dirty)&(DirtyState_UnsavedChanges))!=0)){
     has_unsaved_changes = true;
     break;
    }
   }
   if(has_unsaved_changes){
    View_ID view = get_active_view(app, Access_Always);
    do_exit = vim_do_4coder_close_user_check(app, view);
   }
  }
  if(do_exit){
   hard_exit(app);
  }
 }
}
# 95 "4coder_vim/4coder_vim_include.h" 2
# 473 "4coder_fleury.cpp" 2

# 1 "4coder_byp_helper.h" 1




static b32
string_ends_with(String_Const_u8 string, String_Const_u8 pred){
 return block_match(string.str+string.size-pred.size, pred.str, pred.size);
}

static void
draw_circle_outline(Application_Links *app, Vec2_f32 center, f32 radius, ARGB_Color color){
 Rect_f32 rect = Rect_f32{center.x-radius, center.y-radius, center.x+radius, center.y+radius};
 draw_rectangle(app, rect, radius, color);
}

static void
draw_circle(Application_Links *app, Vec2_f32 center, f32 radius, ARGB_Color color){
 Rect_f32 rect = Rect_f32{center.x-radius, center.y-radius, center.x+radius, center.y+radius};
 draw_rectangle(app, rect, radius, color);
}

static void
draw_circle_fcolor(Application_Links *app, Vec2_f32 center, f32 radius, FColor color){
 Rect_f32 rect = Rect_f32{center.x-radius, center.y-radius, center.x+radius, center.y+radius};
 draw_rectangle_fcolor(app, rect, radius, color);
}

static void
draw_circle_outline_fcolor(Application_Links *app, Vec2_f32 center, f32 radius, f32 thickness, FColor color){
 Rect_f32 rect = Rect_f32{center.x-radius, center.y-radius, center.x+radius, center.y+radius};
 draw_rectangle_outline_fcolor(app, rect, radius, thickness, color);
}

static void
draw_circle_gradient(Application_Links *app, Vec2_f32 center, f32 radius, ARGB_Color c1, ARGB_Color c2){
 Rect_f32 rect = Rf32(center - radius*V2f32(1,1), center + radius*V2f32(1,1));
 for(f32 y=rect.y0; y<=rect.y1; y+=1.f){
  ARGB_Color color = argb_color_blend(c1, (y-rect.y0)/(rect.y1-rect.y0), c2);
  draw_set_clip(app, Rf32(rect.x0, y, rect.x1, y+1.f));
  draw_rectangle(app, rect, radius, color);
 }
}

static Audio_Clip
load_wav(Arena *arena, char *file_name){
 Audio_Clip result = {};
 FILE *file = def_search_normal_fopen(arena, file_name, "rb");
 if(file != 0){
  result = audio_clip_from_wav_FILE(&global_permanent_arena, file);
  fclose(file);
 }
 return result;
}
# 63 "4coder_byp_helper.h"
static u32 pcg_rand(){
 static u64 state = time(
# 64 "4coder_byp_helper.h" 3 4
                   __null
# 64 "4coder_byp_helper.h"
                   );
 state = state * 6364136223846793005ULL + (1|1);



 u64 xsh = (state ^ (state >> 18)) >> 27;
 i32 r_bits = i32(state >> 59);
 return u32((xsh >> r_bits) | (xsh << ((-r_bits) & 31)));

}

static f32 rand01(){ return pcg_rand()/f32(max_u32); }
# 475 "4coder_fleury.cpp" 2

# 1 "4coder_byp_token.h" 1




enum{
    byp_TokenKind_Primitive = 16,
    byp_TokenKind_ControlFlow = 17,
    byp_TokenKind_Struct = 18,
};
# 477 "4coder_fleury.cpp" 2
# 1 "4coder_byp_token.cpp" 1

static b32
byp_highlight_token(Token_Base_Kind kind){
 switch(kind){
  case TokenBaseKind_Keyword:

  case TokenBaseKind_Identifier:
  case byp_TokenKind_Primitive:
  case byp_TokenKind_ControlFlow:
  case byp_TokenKind_Struct:
  return true;
 }
 return false;
}


static ARGB_Color
byp_get_token_color_cpp(Token token){
 Managed_ID color = defcolor_text_default;
 switch (token.kind){
  case TokenBaseKind_Preprocessor:{ color = defcolor_preproc; }break;
  case TokenBaseKind_Keyword:{ color = defcolor_keyword; }break;
  case TokenBaseKind_Comment:{ color = defcolor_comment; }break;
  case TokenBaseKind_LiteralString:{ color = defcolor_str_constant; }break;
  case TokenBaseKind_LiteralInteger:{ color = defcolor_int_constant; }break;
  case TokenBaseKind_LiteralFloat:{ color = defcolor_float_constant; }break;

  case TokenBaseKind_Operator:
  case TokenBaseKind_ScopeOpen:
  case TokenBaseKind_ScopeClose:
  case TokenBaseKind_ParentheticalOpen:
  case TokenBaseKind_ParentheticalClose:
  case TokenBaseKind_StatementClose:{ color = defcolor_non_text; } break;

  case byp_TokenKind_ControlFlow:{ color = defcolor_control; }break;
  case byp_TokenKind_Primitive:{ color = defcolor_primitive; }break;
  case byp_TokenKind_Struct:{ color = defcolor_struct; }break;
 }

 switch (token.sub_kind){
  case TokenCppKind_LiteralTrue:
  case TokenCppKind_LiteralFalse:
  { color = defcolor_bool_constant; }break;

  case TokenCppKind_LiteralCharacter:
  case TokenCppKind_LiteralCharacterWide:
  case TokenCppKind_LiteralCharacterUTF8:
  case TokenCppKind_LiteralCharacterUTF16:
  case TokenCppKind_LiteralCharacterUTF32:
  { color = defcolor_char_constant; }break;

  case TokenCppKind_PPIncludeFile:
  { color = defcolor_include; }break;
 }
 return fcolor_resolve(fcolor_id(color));
}

static void
byp_draw_cpp_token_colors(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array){
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
 i64 first_index = token_index_from_pos(array, visible_range.first);
 Token_Iterator_Array it = token_iterator_index(0, array, first_index);
 for(;;){
  Token *token = token_it_read(&it);
  if(token->pos >= visible_range.one_past_last){ break; }
  ARGB_Color argb = byp_get_token_color_cpp(*token);
  paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), argb);
  if(!token_it_inc_all(&it)){ break; }
 }
}

static void byp_draw_token_colors(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id){
 Token_Array token_array = get_token_array_from_buffer(app, buffer);
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

 Scratch_Block scratch(app);
 byp_draw_cpp_token_colors(app, text_layout_id, &token_array);

 i64 cursor_index = token_index_from_pos(&token_array, view_get_cursor_pos(app, view));
 Token_Iterator_Array it = token_iterator_index(0, token_array.tokens, token_array.count, cursor_index);
 Token *cursor_token = token_it_read(&it);
 b32 do_cursor_tok_highlight = byp_highlight_token(cursor_token->kind);

 String_Const_u8 token_string = {};
 Rect_f32 cursor_tok_rect = {};
 Vec2_f32 tok_rect_dim = {};

 if(do_cursor_tok_highlight){
  token_string = push_token_lexeme(app, scratch, buffer, cursor_token);
  cursor_tok_rect = text_layout_character_on_screen(app, text_layout_id, cursor_token->pos);
  tok_rect_dim = V2f32(cursor_token->size*rect_width(cursor_tok_rect), 2.f);
  cursor_tok_rect = Rf32_xy_wh(V2f32(cursor_tok_rect.x0, cursor_tok_rect.y1 - 2.f), tok_rect_dim);
 }

 ARGB_Color function_color = fcolor_resolve(fcolor_id(defcolor_function));
 ARGB_Color type_color = fcolor_resolve(fcolor_id(defcolor_type));
 ARGB_Color macro_color = fcolor_resolve(fcolor_id(defcolor_macro));
 ARGB_Color back_color = fcolor_resolve(fcolor_id(defcolor_back));
 ARGB_Color cursor_tok_color = byp_get_token_color_cpp(*cursor_token);

 if(cursor_token->kind == TokenBaseKind_Identifier){
  String_Const_u8 lexeme = push_token_lexeme(app, scratch, buffer, cursor_token);
  Code_Index_Note *note = code_index_note_from_string(lexeme);

  if(note != 0){
   switch(note->note_kind){
    case CodeIndexNote_Function: cursor_tok_color = function_color; break;
    case CodeIndexNote_Type: cursor_tok_color = type_color; break;
    case CodeIndexNote_Macro: cursor_tok_color = macro_color; break;
   }
  }
 }


 {
  i64 first_index = token_index_from_pos(&token_array, visible_range.first);
  Token_Iterator_Array comment_it = token_iterator_index(buffer, &token_array, first_index);
  for(;;){
   Token *token = token_it_read(&comment_it);
   if(token->pos >= visible_range.max){ break; }
   String_Const_u8 tail = {};
   if(token_it_check_and_get_lexeme(app, scratch, &comment_it, TokenBaseKind_Comment, &tail)){
    for(i32 i=0; i<token->size; i++){
     if(tail.str[i] == '@'){
      Range_i64 annot_range = Ii64(i);
      i32 j=i+1;
      for(; j<token->size; j++){
       if(character_is_whitespace(tail.str[j]) || !character_is_alpha_numeric(tail.str[j])){
        break;
       }
      }
      annot_range.max = j;
      if(annot_range.min != annot_range.max-1){
       annot_range += token->pos;
       paint_text_color(app, text_layout_id, annot_range, 0xFFFF0000);
      }
     }
    }
   }
   if(!token_it_inc_non_whitespace(&comment_it)){ break; }
  }
 }


 b32 use_comment_keyword = def_get_config_b32(vars_save_string(SCu8((u8*)("use_comment_keyword"), (u64)(sizeof("use_comment_keyword") - 1))));
 if(use_comment_keyword){
  Comment_Highlight_Pair pairs[] = {
   {SCu8((u8*)("NOTE"), (u64)(sizeof("NOTE") - 1)), finalize_color(defcolor_comment_pop, 0)},
   {SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), finalize_color(defcolor_comment_pop, 1)},
  };
  draw_comment_highlights(app, buffer, text_layout_id, &token_array, pairs, ((sizeof(pairs))/(sizeof(*pairs))));
 }

 it = token_iterator_pos(0, &token_array, (((0)>(visible_range.first-1))?(0):(visible_range.first-1)));
 for(;;){
  Token *token = token_it_read(&it);
  if(token->pos > visible_range.max){ break; }
  String_Const_u8 lexeme = push_token_lexeme(app, scratch, buffer, token);
  Code_Index_Note *note = code_index_note_from_string(lexeme);

  if(do_cursor_tok_highlight){
   if(data_match(lexeme, token_string)){
    Rect_f32 cur_tok_rect = text_layout_character_on_screen(app, text_layout_id, token->pos);
    cur_tok_rect = Rf32_xy_wh(V2f32(cur_tok_rect.x0, cur_tok_rect.y1 - 2.f), tok_rect_dim);
    draw_rectangle(app, cur_tok_rect, 5.f, argb_color_blend(cursor_tok_color, 0.7f, back_color));
   }
  }

  if(!token_it_inc_non_whitespace(&it)){ break; }
  if(note == 0){ continue; }
  switch(note->note_kind){
   case CodeIndexNote_Function:
   paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), function_color); break;
   case CodeIndexNote_Type:
   paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), type_color); break;
   case CodeIndexNote_Macro:
   paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), macro_color); break;
  }

 }
 if(do_cursor_tok_highlight){ draw_rectangle(app, cursor_tok_rect, 5.f, cursor_tok_color); }

}
# 478 "4coder_fleury.cpp" 2

# 1 "4coder_byp_build.cpp" 1

static void
byp_prj_exec_command(Application_Links *app, Variable_Handle cmd_var){
 Scratch_Block scratch(app);

 String_ID os_id = vars_save_string(SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));

 String8 cmd = vars_string_from_var(scratch, vars_read_key(cmd_var, os_id));
 if (cmd.size > 0){
  String_ID out_id = vars_save_string(SCu8((u8*)("out"), (u64)(sizeof("out") - 1)));
  String_ID footer_panel_id = vars_save_string(SCu8((u8*)("footer_panel"), (u64)(sizeof("footer_panel") - 1)));
  String_ID save_dirty_files_id = vars_save_string(SCu8((u8*)("save_dirty_files"), (u64)(sizeof("save_dirty_files") - 1)));
  String_ID cursor_at_end_id = vars_save_string(SCu8((u8*)("cursor_at_end"), (u64)(sizeof("cursor_at_end") - 1)));

  b32 save_dirty_files = vars_b32_from_var(vars_read_key(cmd_var, save_dirty_files_id));
  if (save_dirty_files){
   save_all_dirty_buffers(app);
  }

  u32 flags = CLI_OverlapWithConflict|CLI_SendEndSignal;
  b32 cursor_at_end = vars_b32_from_var(vars_read_key(cmd_var, cursor_at_end_id));
  if (cursor_at_end){
   flags |= CLI_CursorAtEnd;
  }

  View_ID view = 0;
  Buffer_Identifier buffer_id = {};
  b32 set_fancy_font = false;
  String8 out = vars_string_from_var(scratch, vars_read_key(cmd_var, out_id));
  if(out.size > 0){
   buffer_id = buffer_identifier(out);

   b32 footer_panel = vars_b32_from_var(vars_read_key(cmd_var, footer_panel_id));
   if(footer_panel){
    set_fancy_font = true;
    vim_show_buffer_peek = false;
    vim_toggle_show_buffer_peek(app);
    vim_buffer_peek_index = 0;
    buffer_id = vim_buffer_peek_list[0].buffer_id;
                vim_buffer_peek_list[0] = {buffer_id, 1.f, 1.f};

    View_Context ctx = view_current_context(app, build_footer_panel_view_id);
    view_set_split_pixel_size(app, build_footer_panel_view_id, 0);
    ctx.render_caller = 0;
    view_alter_context(app, build_footer_panel_view_id, &ctx);
   }
   else{
    Buffer_ID buffer = buffer_identifier_to_id(app, buffer_id);
    view = get_first_view_with_buffer(app, buffer);
    if (view == 0){
     view = get_active_view(app, Access_Always);
    }
   }

   block_zero((&prev_location), sizeof(*(&prev_location)));
   lock_jump_buffer(app, out);
  }
  else{

   buffer_id = buffer_identifier(SCu8((u8*)("*dump*"), (u64)(sizeof("*dump*") - 1)));
  }

  Variable_Handle command_list_var = vars_parent(cmd_var);
  Variable_Handle prj_var = vars_parent(command_list_var);
  String8 prj_dir = prj_path_from_project(scratch, prj_var);
  exec_system_command(app, view, buffer_id, prj_dir, cmd, flags);

 }
}

static void
byp_prj_exec_command_fkey_index(Application_Links *app, i32 fkey_index){

 Scratch_Block scratch(app);
 String8 fkey_index_str = push_stringf(scratch, "F%d", fkey_index + 1);
 String_ID fkey_index_id = vars_save_string(fkey_index_str);


 Variable_Handle cmd_name_var = vars_get_nil();


 {
  Variable_Handle fkey_override = def_get_config_var(vars_save_string(SCu8((u8*)("fkey_command_override"), (u64)(sizeof("fkey_command_override") - 1))));
  if(!vars_is_nil(fkey_override)){
   String_Const_u8 name = def_get_config_string(scratch, vars_save_string(SCu8((u8*)("user_name"), (u64)(sizeof("user_name") - 1))));
   String_ID user_name_id = vars_save_string(name);
   Variable_Handle user_var = vars_read_key(fkey_override, user_name_id);
   cmd_name_var = vars_read_key(user_var, fkey_index_id);
  }
 }


 if(vars_is_nil(cmd_name_var)){
  Variable_Handle fkeys = def_get_config_var(vars_save_string(SCu8((u8*)("fkey_command"), (u64)(sizeof("fkey_command") - 1))));
  cmd_name_var = vars_read_key(fkeys, fkey_index_id);
 }

 String_ID cmd_id = vars_save_string(vars_string_from_var(scratch, cmd_name_var));
 Variable_Handle cmd_list = def_get_config_var(vars_save_string(SCu8((u8*)("commands"), (u64)(sizeof("commands") - 1))));
 Variable_Handle cmd = vars_read_key(cmd_list, cmd_id);
 byp_prj_exec_command(app, cmd);
}


CUSTOM_COMMAND(byp_project_fkey_command, "4coder_byp_build.cpp", 105, Normal)
CUSTOM_DOC("Runs project commands but uses proper footer build panel")
{
 Profile_Scope_Block profile_block_108 ((app), SCu8((u8*)("project fkey command"), (u64)(sizeof("project fkey command") - 1)), SCu8((u8*)("4coder_byp_build.cpp" ":" "108" ":"), (u64)(sizeof("4coder_byp_build.cpp" ":" "108" ":") - 1)));
 User_Input input = get_current_input(app);
 b32 got_ind = false;
 i32 ind = 0;
 if(input.event.kind == InputEventKind_KeyStroke){
  if(KeyCode_F1 <= input.event.key.code && input.event.key.code <= KeyCode_F16){
   ind = (input.event.key.code - KeyCode_F1);
   got_ind = true;
  }
  else if(KeyCode_1 <= input.event.key.code && input.event.key.code <= KeyCode_9){
   ind = (input.event.key.code - '1');
   got_ind = true;
  }
  else if(input.event.key.code == KeyCode_0){
   ind = 9;
   got_ind = true;
  }
  if(got_ind){
   byp_prj_exec_command_fkey_index(app, ind);
  }
 }
}

CUSTOM_COMMAND(byp_build_project, "4coder_byp_build.cpp", 131, Normal)
CUSTOM_DOC("Compiles project")
{
 View_ID view = get_active_view(app, Access_Always);
 Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

 View_ID build_view = get_or_open_build_panel(app);
 standard_search_and_build(app, build_view, buffer);

 vim_show_buffer_peek = false;
 vim_toggle_show_buffer_peek(app);
 vim_buffer_peek_index = 0;
 vim_buffer_peek_list[0] = {buffer_identifier(SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1))), 1.f, 1.f};

 View_Context ctx = view_current_context(app, build_footer_panel_view_id);
 view_set_split_pixel_size(app, build_footer_panel_view_id, 0);
 ctx.render_caller = 0;
 view_alter_context(app, build_footer_panel_view_id, &ctx);

 block_zero((&prev_location), sizeof(*(&prev_location)));
 lock_jump_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));

}
# 480 "4coder_fleury.cpp" 2
# 1 "4coder_byp_colors.cpp" 1

static Color_Table target_color_table = {};
static Color_Table cached_color_table = {};


static Color_Table
byp_init_color_table(Application_Links *app){
 Color_Table result = make_color_table(app, &global_permanent_arena);
 for(i32 i=0; i<result.count; i++){
  result.arrays[i].vals = ((u32*)linalloc_wrap_unintialized(linalloc_push((&global_permanent_arena), sizeof(u32)*(14), SCu8((u8*)("4coder_byp_colors.cpp" ":" "10" ":"), (u64)(sizeof("4coder_byp_colors.cpp" ":" "10" ":") - 1)))));
  result.arrays[i].count = 14;
 }
 return result;
}

static void
byp_copy_color_table(Color_Table *dst, Color_Table table){
 for(i32 i=0; i<table.count; i++){
  Color_Array *nxt_array = &dst->arrays[i];
  Color_Array *array = &table.arrays[i];
  for(i32 j=0; j<array->count; j++){
   nxt_array->vals[j] = array->vals[j];
  }
 }
}

static void
byp_tick_colors(Application_Links *app, Frame_Info frame_info){

 if(active_color_table.arrays != cached_color_table.arrays){
  if(active_color_table.arrays && active_color_table.arrays->vals && active_color_table.arrays->count > 0){
   byp_copy_color_table(&target_color_table, active_color_table);
   active_color_table = cached_color_table;
  }
 }
 b32 needs_animate = false;
 for(i32 i=0; i<active_color_table.count; i++){
  Color_Array *nxt_array = &target_color_table.arrays[i];
  Color_Array *cur_array = &active_color_table.arrays[i];
  for(i32 j=0; j<cur_array->count; j++){
   Vec4_f32 nxt_v = unpack_color(nxt_array->vals[j]);
   Vec4_f32 cur_v = unpack_color(cur_array->vals[j]);
   Vec4_f32 diff = nxt_v - cur_v;
   cur_v += diff*frame_info.animation_dt*10.f;
   cur_array->vals[j] = pack_color(cur_v);

   needs_animate |= (!near_zero(diff, 0.001f));
  }
 }
 if(needs_animate){ animate_in_n_milliseconds(app, 0); }
}

static void
byp_theme_navigate(Application_Links *app, View_ID view, Lister *lister, i32 index_delta){
 lister__navigate__default(app, view, lister, index_delta);
 Color_Table *result = (Color_Table *)lister_get_user_data(lister, lister->raw_item_index);
 if(result){ byp_copy_color_table(&target_color_table, *result); }
}


CUSTOM_COMMAND(byp_theme_lister, "4coder_byp_colors.cpp", 61, UI)
CUSTOM_DOC("Opens an interactive list of all registered themes.")
{
 Color_Table_List *color_table_list = &global_theme_list;

 Scratch_Block scratch(app);
 Lister_Block lister(app, scratch);
 vim_lister_set_default_handlers(lister);
 vim_reset_bottom_text();
 string_append(&vim_bot_text, SCu8((u8*)("Theme:"), (u64)(sizeof("Theme:") - 1)));

 lister_add_item(lister, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)), SCu8((u8*)(""), (u64)(sizeof("") - 1)),
     (void*)&default_color_table, 0);

 if(color_table_list->first){
  byp_copy_color_table(&target_color_table, color_table_list->first->table);
 }
 for(Color_Table_Node *node = color_table_list->first; node; node = node->next){
  lister_add_item(lister, node->name, SCu8((u8*)(""), (u64)(sizeof("") - 1)), (void*)&node->table, 0);
 }

 lister.lister.current->handlers.navigate = byp_theme_navigate;
 Lister_Result l_result = vim_run_lister(app, lister);

 Color_Table *result = 0;
 if(!l_result.canceled){ result = (Color_Table*)l_result.user_data; }

 if(result != 0){ byp_copy_color_table(&target_color_table, *result); }
}
# 481 "4coder_fleury.cpp" 2
# 1 "4coder_byp_commands.cpp" 1

static Face_ID byp_small_italic_face;
static Face_ID byp_minimal_face;


static b32 byp_show_hex_colors;
static b32 byp_relative_numbers;
static b32 byp_show_scrollbars;
static b32 byp_drop_shadow;

CUSTOM_COMMAND(byp_toggle_show_hex_colors, "4coder_byp_commands.cpp", 11, Normal)
CUSTOM_DOC("Toggles value for `show_hex_colors`")
{ byp_show_hex_colors ^= 1; }

CUSTOM_COMMAND(byp_toggle_relative_numbers, "4coder_byp_commands.cpp", 15, Normal)
CUSTOM_DOC("Toggles value for `relative_numbers`")
{ byp_relative_numbers ^= 1; }

CUSTOM_COMMAND(byp_toggle_show_scrollbars, "4coder_byp_commands.cpp", 19, Normal)
CUSTOM_DOC("Toggles value for `show_scrollbars`")
{ byp_show_scrollbars ^= 1; }

CUSTOM_COMMAND(byp_toggle_drop_shadow, "4coder_byp_commands.cpp", 23, Normal)
CUSTOM_DOC("Toggles value for `drop_shadow`")
{ byp_drop_shadow ^= 1; }


CUSTOM_COMMAND(byp_test, "4coder_byp_commands.cpp", 28, Normal)
CUSTOM_DOC("Just bound to the key I spam to execute whatever test code I'm working on")
{
 Scratch_Block scratch(app);
 View_ID view = get_active_view(app, Access_ReadVisible);

 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 i64 pos = view_get_cursor_pos(app, view);
 Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));

 print_message(app, push_stringf(scratch, "Buffer[%d] = '%c'\n", pos, buffer_get_char(app, buffer, pos)));
 print_message(app, push_stringf(scratch, "Line %d Col: %d\n", cursor.line, cursor.col));

 Face_ID face = get_face_id(app, buffer);
 Face_Description desc = get_face_description(app, face);
 print_message(app, push_stringf(scratch, "Face Size: %d \n", desc.parameters.pt_size));
}

CUSTOM_COMMAND(byp_reset_face_size, "4coder_byp_commands.cpp", 46, Normal)
CUSTOM_DOC("Resets face size to default")
{
 View_ID view = get_active_view(app, Access_Always);
 Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
 Face_ID face_id = get_face_id(app, buffer);
 Face_Description description = get_face_description(app, face_id);
 description.parameters.pt_size = (i32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("default_font_size"), (u64)(sizeof("default_font_size") - 1))));
 try_modify_face(app, face_id, &description);
}



static Buffer_Cursor byp_col_cursor;

CUSTOM_COMMAND(byp_toggle_set_col_ruler, "4coder_byp_commands.cpp", 61, Normal)
CUSTOM_DOC("Toggles the column ruler. Set to cursor column when on.")
{
 View_ID view = get_active_view(app, Access_ReadVisible);
 byp_col_cursor = (byp_col_cursor.pos != 0 ?
       Buffer_Cursor{} :
       view_compute_cursor(app, view, seek_pos(view_get_cursor_pos(app, view))));
}

CUSTOM_COMMAND(byp_space, "4coder_byp_commands.cpp", 70, Normal)
CUSTOM_DOC("When column ruler is set, spaces towards that, else just inserts one space")
{
 Scratch_Block scratch(app);
 if(byp_col_cursor.pos > 0){
  View_ID view = get_active_view(app, Access_ReadVisible);
  Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

  byp_col_cursor = buffer_compute_cursor(app, buffer, seek_line_col(byp_col_cursor.line, byp_col_cursor.col));

  i64 pos = view_get_cursor_pos(app, view);
  i64 line = get_line_number_from_pos(app, buffer, pos);
  f32 col_x = view_relative_xy_of_pos(app, view, line, byp_col_cursor.pos).x;
  f32 cur_x = view_relative_xy_of_pos(app, view, line, pos).x;
  Face_ID face = get_face_id(app, buffer);
  f32 space_advance = get_face_metrics(app, face).space_advance;

  i64 N = i64((col_x - cur_x) / space_advance);
  if(N < 0){ N = 1; }
  for(i32 i=0; i<N; i++){ write_space(app); }
 }else{ write_space(app); }
}


static b32 byp_bracket_opened;

CUSTOM_COMMAND(byp_write_text_input, "4coder_byp_commands.cpp", 96, Normal)
CUSTOM_DOC("Inserts whatever text was used to trigger this command.")
{
 User_Input in = get_current_input(app);
 String_Const_u8 insert = to_writable(&in);
 byp_bracket_opened = insert.str[insert.size-1] == '{';
 write_text(app, insert);
}

CUSTOM_COMMAND(byp_auto_complete_bracket, "4coder_byp_commands.cpp", 105, Normal)
CUSTOM_DOC("Sets the right size of the view near the x position of the cursor.")
{
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 i64 pos = view_get_character_legal_pos_from_pos(app, view, view_get_cursor_pos(app, view));
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
 Token_Array token_array = get_token_array_from_buffer(app, buffer);
 do{
  if(token_array.tokens == 0){
   if(byp_bracket_opened){
    write_text(app, SCu8((u8*)("\n\n}"), (u64)(sizeof("\n\n}") - 1)));
    move_up(app);
    byp_bracket_opened = 0;
    return;
   }else{
    break;
   }
  }

  i64 first_index = token_index_from_pos(&token_array, pos);
  Token_Iterator_Array it = token_iterator_index(0, token_array.tokens, token_array.count, first_index);
  if(!token_it_dec(&it)){ break; }

  Token *token = token_it_read(&it);
  if(token && byp_bracket_opened && buffer_get_char(app, buffer, token->pos) == '{'){
   token_it_dec(&it);
   token = token_it_read(&it);
   if(token->kind == TokenBaseKind_Identifier){
    if(!token_it_dec(&it)){ break; }
    token = token_it_read(&it);
   }
   String_Const_u8 insert = SCu8((u8*)("\n\n};"), (u64)(sizeof("\n\n};") - 1));
   insert.size -= (token->kind != byp_TokenKind_Struct);
   write_text(app, insert);
   move_up(app);
   byp_bracket_opened = 0;
   return;
  }
 }while(0);

 write_text(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
 byp_bracket_opened = 0;
}

CUSTOM_COMMAND(explorer, "4coder_byp_commands.cpp", 149, Normal)
CUSTOM_DOC("Opens file explorer in hot directory")
{
 Scratch_Block scratch(app);
 String_Const_u8 hot = push_hot_directory(app, scratch);
 exec_system_command(app, 0, buffer_identifier(0), hot, SCu8((u8*)("explorer ."), (u64)(sizeof("explorer .") - 1)), 0);
}

static void
byp_load_theme(String_Const_u8 theme_name){
 Color_Table *table_ptr = get_color_table_by_name(theme_name);
 if(table_ptr){ byp_copy_color_table(&target_color_table, *table_ptr); }
}

static Vim_Buffer_Peek_Entry BYP_peek_list[2] = {
 { buffer_identifier(SCu8((u8*)("*scratch*"), (u64)(sizeof("*scratch*") - 1))), 1.f, 1.f },
 { buffer_identifier(SCu8((u8*)("todo.txt"), (u64)(sizeof("todo.txt") - 1))), 1.f, 1.f },
};

CUSTOM_COMMAND(byp_list_all_locations_selection, "4coder_byp_commands.cpp", 168, Normal)
CUSTOM_DOC("Lists locations of selection range")
{
 vim_normal_mode(app);
 View_ID view = get_active_view(app, Access_ReadVisible);
 Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
 Range_i64 range = get_view_range(app, view);
 range.max++;

 Scratch_Block scratch(app);
 String_Const_u8 range_string = push_buffer_range(app, scratch, buffer, range);
 list_all_locations__generic(app, range_string, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(byp_open_current_peek, "4coder_byp_commands.cpp", 182, Normal)
CUSTOM_DOC("Sets the active view to the current peeked buffer")
{
 View_ID view = get_active_view(app, Access_ReadWriteVisible);
 Buffer_ID buffer = buffer_identifier_to_id(app, vim_buffer_peek_list[vim_buffer_peek_index].buffer_id);
 view_set_buffer(app, view, buffer, SetBuffer_KeepOriginalGUI);
 vim_show_buffer_peek = 1;
 vim_toggle_show_buffer_peek(app);
}

Range_i64 byp_object_param(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 u8 c = buffer_get_char(app, buffer, cursor_pos);
 Range_i64 range = Ii64(cursor_pos + (c == ',' || c == ';'));

 for(; range.min>0; range.min--){
  c = buffer_get_char(app, buffer, range.min);
  if(c == ',' || c == ';'){ break; }
  Scan_Direction bounce = vim_bounce_direction(c);
  if(bounce == Scan_Forward){ break; }
  if(bounce == Scan_Backward){
   range.min = vim_bounce_pair(app, buffer, range.min, c)-1;
   continue;
  }
 }

 i64 buffer_size = buffer_get_size(app, buffer);
 for(; range.max < buffer_size; range.max++){
  c = buffer_get_char(app, buffer, range.max);
  if(c == ',' || c == ';'){ break; }
  Scan_Direction bounce = vim_bounce_direction(c);
  if(bounce == Scan_Backward){ break; }
  if(bounce == Scan_Forward){
   range.max = vim_bounce_pair(app, buffer, range.max, c);
   continue;
  }
 }
 range.min++; range.max--;
 if(range.min >= range.max){ range = {}; }

 return range;
}

Range_i64 byp_object_camel(Application_Links *app, Buffer_ID buffer, i64 cursor_pos){
 Range_i64 range = {};
 Scratch_Block scratch(app);
 Range_i64 line_range = get_line_range_from_pos(app, buffer, cursor_pos);
 i64 s = line_range.min;
 u8 *line_text = push_buffer_range(app, scratch, buffer, line_range).str;
 u8 c = line_text[cursor_pos-s];
 if(!character_is_alpha_numeric(c)){ return {}; }
 cursor_pos += line_text[cursor_pos-s] == '_';
 range.min = range.max = cursor_pos;

 b32 valid=false;
 for(; range.min>0; range.min--){
  c = line_text[range.min-s];
  if(!character_is_alpha_numeric(c) || c == '_'){ valid = true; break; }
 }
 if(!valid){ return {}; }

 valid=false;
 for(; range.max>0; range.max++){
  c = line_text[range.max-s];
  if(!character_is_alpha_numeric(c) || c == '_'){ valid = true; break; }
 }
 if(!valid){ return {}; }

 range.min += (vim_state.params.clusivity != VIM_Inclusive || line_text[range.min-s] != '_');
 range.max -= (vim_state.params.clusivity != VIM_Inclusive || line_text[range.max-s] != '_');
 if(range.min >= range.max){ range = {}; }

 return range;
}

static void byp_make_vim_request(Application_Links *app, BYP_Vim_Request request){
 vim_make_request(app, Vim_Request_Type(VIM_REQUEST_COUNT + request));
}

void byp_apply_title(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 Scratch_Block scratch(app);
 String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);
 u8 prev = buffer_get_char(app, buffer, range.min-1);
 for(i32 i=0; i<text.size; i++){
  text.str[i] += u8(i32('A' - 'a')*((!character_is_alpha(prev) || prev == '_') &&
            character_is_lower(text.str[i])));
  prev = text.str[i];
 }
 buffer_replace_range(app, buffer, range, text);
 buffer_post_fade(app, buffer, 0.667f, range, fcolor_resolve(fcolor_id(defcolor_paste)));
}

void byp_apply_comment(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 i64 line0 = get_line_number_from_pos(app, buffer, range.min);
 i64 line1 = get_line_number_from_pos(app, buffer, range.max);
 line1 += (line0 == line1);
 History_Group history_group = history_group_begin(app, buffer);
 for(i64 l=line0; l<line1; l++){
  i64 line_start = get_pos_past_lead_whitespace_from_line_number(app, buffer, l);
  b32 has_comment = c_line_comment_starts_at_position(app, buffer, line_start);
  if(!has_comment){
   buffer_replace_range(app, buffer, Ii64(line_start), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
   buffer_post_fade(app, buffer, 0.667f, Ii64_size(line_start,2), fcolor_resolve(fcolor_id(defcolor_paste)));
  }
 }
 history_group_end(history_group);
}

void byp_apply_uncomment(Application_Links *app, View_ID view, Buffer_ID buffer, Range_i64 range){
 i64 line0 = get_line_number_from_pos(app, buffer, range.min);
 i64 line1 = get_line_number_from_pos(app, buffer, range.max);
 line1 += (line0 == line1);
 History_Group history_group = history_group_begin(app, buffer);
 for(i64 l=line0; l<line1; l++){
  i64 line_start = get_pos_past_lead_whitespace_from_line_number(app, buffer, l);
  b32 has_comment = c_line_comment_starts_at_position(app, buffer, line_start);
  if(has_comment){
   buffer_replace_range(app, buffer, Ii64_size(line_start,2), string_u8_empty);
  }
 }
 history_group_end(history_group);
}

static void byp_request_title(Application_Links *app){ byp_make_vim_request(app, BYP_REQUEST_Title); }
static void byp_request_comment(Application_Links *app){ byp_make_vim_request(app, BYP_REQUEST_Comment); }
static void byp_request_uncomment(Application_Links *app){ byp_make_vim_request(app, BYP_REQUEST_UnComment); }
static void byp_visual_comment(Application_Links *app){
 if(vim_state.mode == VIM_Visual){
  Vim_Edit_Type edit = vim_state.params.edit_type;
  byp_request_comment(app);
  vim_state.mode = VIM_Visual;
  vim_state.params.edit_type = edit;
 }
}
static void byp_visual_uncomment(Application_Links *app){
 if(vim_state.mode == VIM_Visual){
  Vim_Edit_Type edit = vim_state.params.edit_type;
  byp_request_uncomment(app);
  vim_state.mode = VIM_Visual;
  vim_state.params.edit_type = edit;
 }
}
# 482 "4coder_fleury.cpp" 2

# 1 "4coder_byp_draw.cpp" 1


static void
byp_draw_function_preview_inner(Application_Links *app, Buffer_ID buffer, Range_f32 x_range, Range_i64 range, i64 pos, i32 count){
 Scratch_Block scratch(app);
 String_Const_u8 query = push_token_or_word_under_pos(app, scratch, buffer, range.min-1);

 Buffer_ID target_buffer = -1;
 Range_i64 target_range = Ii64(-1);

 code_index_lock();
 for(Buffer_ID b = get_buffer_next(app, 0, Access_Always);
        b != 0;
        b = get_buffer_next(app, b, Access_Always))
 {
  Code_Index_File *file = code_index_get_file(b);
  if(file != 0){
   for(i32 i=0; i<file->note_array.count; i++){
    Code_Index_Note *note = file->note_array.ptrs[i];
    if((note->note_kind == CodeIndexNote_Function || note->note_kind == CodeIndexNote_Macro) &&
       string_match(note->text, query))
    {
     target_buffer = b;
     target_range = note->pos;
     goto done;
    }
   }
  }
 }
 done:;
 code_index_unlock();

 if(target_buffer < 0){ return; }


 target_range.max = vim_scan_bounce(app, target_buffer, target_range.max, Scan_Forward) + 1;
# 59 "4coder_byp_draw.cpp"
 Range_i64 sig_underline = target_range;



 String_Const_u8 sig = push_buffer_range(app, scratch, target_buffer, target_range);
 sig = string_condense_whitespace(scratch, sig);

 Face_Metrics metrics = get_face_metrics(app, byp_small_italic_face);
 f32 wid = 2.f;
 f32 pad = 2.f;
 Rect_f32 rect = {};
 rect.p0 = vim_cur_cursor_pos + V2f32(0, 2.f + count*(metrics.line_height + pad + 2.f*wid));
 rect.p1 = rect.p0 + V2f32(sig.size*metrics.max_advance, metrics.line_height);
 f32 x_offset = ((rect.x1 > x_range.max)*(rect.x1 - x_range.max) -
     (rect.x0 < x_range.min)*(rect.x0 - x_range.max));
 rect.x0 -= x_offset;
 rect.x1 -= x_offset;

 Rect_f32 underline = rect;
 underline.x0 += metrics.max_advance*(sig_underline.min - target_range.min);
 underline.x1 = underline.x0 + metrics.max_advance*(range_size(sig_underline));
 underline.y1 -= 1.f;
 underline.y0 = underline.y1 - 1.f;

 rect = rect_inner(rect, -pad);
 draw_rectangle_fcolor(app, rect, 3.f, fcolor_id(defcolor_back));
 rect.x0 -= pad;
 rect.x1 += pad;
 draw_rectangle_outline_fcolor(app, rect, 3.f, wid, fcolor_id(defcolor_ghost_character));

 draw_string(app, byp_small_italic_face, sig, rect.p0 + (pad + wid)*V2f32(1,1), fcolor_id(defcolor_ghost_character));
}

static void
byp_draw_function_preview(Application_Links *app, Buffer_ID buffer, Range_f32 x_range, i64 pos){

 Token_Array token_array = get_token_array_from_buffer(app, buffer);
 if(token_array.tokens == 0){ return; }
 Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
 Token *token = token_it_read(&it);

 if(token->kind == TokenBaseKind_ParentheticalOpen){ pos = token->pos + token->size; }
 else if(token_it_dec_all(&it)){
  token = token_it_read(&it);
  if(token->kind == TokenBaseKind_ParentheticalClose && pos == token->pos + token->size){
   pos = token->pos;
  }
 }

 Scratch_Block scratch(app);
 Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, FindNest_Paren);
 i32 count = 0;
 for(i32 i=0; i<ranges.count; i++){
  Token_Iterator_Array cur_it = token_iterator_pos(0, &token_array, ranges.ranges[i].min-1);
  token = token_it_read(&cur_it);
  if(token->kind == TokenBaseKind_Identifier){
   byp_draw_function_preview_inner(app, buffer, x_range, ranges.ranges[i], pos, count++);
  }
 }
}

static void
byp_hex_color_preview(Application_Links *app, Buffer_ID buffer_id, Text_Layout_ID text_layout_id){
 Scratch_Block scratch(app);
 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
 u8 *text = push_buffer_range(app, scratch, buffer_id, visible_range).str;
 for(i32 i=0; i<range_size(visible_range)-9; i++){
  byp_hex_scan:
  if(text[i] != '0' || text[i+1] != 'x'){ continue; }
  for(i32 j=0; j<8; j++){
   char c = text[i+2+j];
   if(!('0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F')){
    i+=9; goto byp_hex_scan;
   }
  }
  Range_i64 hex_range = Ii64_size(i+visible_range.min, 10);
  u32 c = u32(string_to_integer(SCu8(text+i+2, 8), 16));
  f32 avg = (((c >> 16) & 0xFF) + ((c >> 8) & 0xFF) + (c & 0xFF))/3.f;

  u32 contrast = 0xFF000000 | (i32(avg > 110.f)-1);
  paint_text_color(app, text_layout_id, hex_range, contrast);
  Rect_f32 rect_left = text_layout_character_on_screen(app, text_layout_id, hex_range.min);
  Rect_f32 rect_right = text_layout_character_on_screen(app, text_layout_id, hex_range.max-1);
  Rect_f32 rect = rect_union(rect_left, rect_right);
  rect = rect_inner(rect, -1.f);
  draw_rectangle(app, rect, 8.f, c);
  draw_rectangle_outline(app, rect_inner(rect, -2.f), 8.f, 2.1f, contrast);
 }
}

static Rect_f32_Pair
byp_layout_scrollbars(Rect_f32 region, f32 digit_advance){ return rect_split_left_right_neg(region, 1.25f*digit_advance); }

static void
byp_draw_scrollbars(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id, Rect_f32 region){
 Rect_f32 prev_clip = draw_set_clip(app, region);
 f32 region_height = rect_height(region);
 u64 cursor_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("cursor_roundness"), (u64)(sizeof("cursor_roundness") - 1))));
 f32 roundness = rect_width(region)*cursor_roundness_100*0.0075f;

 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
 i64 line_count = buffer_get_line_count(app, buffer);
 f32 line_diff_y = (((5.f)>(region_height*(1.f/line_count)))?(5.f):(((10.f)<(region_height*(1.f/line_count)))?(10.f):(region_height*(1.f/line_count))));

 i64 top_line = get_line_number_from_pos(app, buffer, visible_range.min)-1;
 i64 bot_line = get_line_number_from_pos(app, buffer, visible_range.max)-1;
 i64 cursor_line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view))-1;
 i64 mark_line = get_line_number_from_pos(app, buffer, view_get_mark_pos(app, view))-1;

 draw_rectangle_fcolor(app, region, 0.f, fcolor_id(defcolor_highlight_cursor_line));
 {
  f32 top_y = region_height*(f32(top_line)/(line_count));
  f32 bot_y = region_height*(f32(bot_line)/(line_count));
  Rect_f32 rect = Rf32(region.x0, top_y, region.x1, bot_y);
  draw_rectangle_fcolor(app, rect, roundness, fcolor_id(defcolor_line_numbers_text));
 }

 {
  f32 top_y = region_height*(f32(cursor_line)/(line_count));
  f32 bot_y = top_y + 3.f*line_diff_y;
  Rect_f32 rect = Rf32(region.x0, top_y, region.x1, bot_y);
  draw_rectangle_fcolor(app, rect, roundness, fcolor_id(defcolor_cursor));
 }

 {
  f32 top_y = region_height*(f32(mark_line)/(line_count));
  f32 bot_y = top_y + 3.f*line_diff_y;
  Rect_f32 rect = Rf32(region.x0, top_y, region.x1, bot_y);
  draw_rectangle_fcolor(app, rect, roundness, fcolor_id(defcolor_mark));
 }
 draw_set_clip(app, prev_clip);
}

static void
draw_scope_range(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id, Range_i64 range, f32 x_off, f32 wid, FColor color){
 range.max -= 1;

 u8 c0 = buffer_get_char(app, buffer, range.min);
 u8 c1 = buffer_get_char(app, buffer, range.max);
 if((c0 != '{' && c0 != '(') || (c1 != '}' && c1 != ')')){ return; }
 paint_text_color_pos(app, text_layout_id, range.min, color);
 paint_text_color_pos(app, text_layout_id, range.max, color);

 i64 line0 = get_line_number_from_pos(app, buffer, range.min);
 i64 line1 = get_line_number_from_pos(app, buffer, range.max);
 if(line0 == line1){ return; }

 Rect_f32 line_rect = vim_get_abs_block_rect(app, view, buffer, text_layout_id, range);
 line_rect.p0 -= V2f32(3.f, 4.f);
 Rect_f32 region = line_rect;
 region.x1 = region.x0 + x_off;

 Rect_f32 prev_clip = draw_set_clip(app, region);
 draw_set_clip(app, rect_intersect(region, prev_clip));

 draw_rectangle_outline_fcolor(app, line_rect, 1.5f*wid, wid, color);

 draw_set_clip(app, prev_clip);
}

static void
byp_draw_scope_brackets(Application_Links *app, View_ID view, Buffer_ID buffer, Text_Layout_ID text_layout_id, Rect_f32 region, i64 pos){

 Token_Array token_array = get_token_array_from_buffer(app, buffer);
 if(token_array.tokens == 0){ return; }
 {
  Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
  Token *token = token_it_read(&it);

  if(token->kind == TokenBaseKind_ScopeOpen){ pos = token->pos + token->size; }
  else if(token_it_dec_all(&it)){
   token = token_it_read(&it);
   if(token->kind == TokenBaseKind_ScopeClose && pos == token->pos + token->size){
    pos = token->pos;
   }
  }
 }

 Scratch_Block scratch(app);
 Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, FindNest_Scope);


 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

 region.x0 -= 3.f;
 Rect_f32 prev_clip = draw_set_clip(app, region);

 f32 wid = 2.f;
 f32 x_off = rect_width(text_layout_character_on_screen(app, text_layout_id, pos)) + 1.f;
 draw_scope_range(app, view, buffer, text_layout_id, ranges.ranges[0], x_off, wid, fcolor_id(defcolor_preproc));
 for(i32 i=1; i<ranges.count; i++){
  Range_i64 range = ranges.ranges[i];
  draw_scope_range(app, view, buffer, text_layout_id, range, x_off, wid, fcolor_id(defcolor_ghost_character));
 }
 draw_set_clip(app, prev_clip);



 for(i32 i=ranges.count-1; i >= 0; --i){
  Range_i64 range = ranges.ranges[i];

  i64 start_line_num = get_line_number_from_pos(app, buffer, range.start);
  i64 end_line_num = get_line_number_from_pos(app, buffer, range.end);
  if(start_line_num == end_line_num || range.end >= visible_range.end){ continue; }

  Token *start_token = 0;
  Token_Iterator_Array it = token_iterator_pos(0, &token_array, range.start-1);
  i32 token_count=0, paren_level=0;

  for(;;){
   Token *token = token_it_read(&it);
   if(token == 0){ break; }
   ++token_count;

   if(0){}
   else if(token->kind == TokenBaseKind_ParentheticalClose){ ++paren_level; }
   else if(token->kind == TokenBaseKind_ParentheticalOpen){ --paren_level; }

   if(paren_level == 0){
    if(token->kind == TokenBaseKind_ScopeClose ||
       (token->kind == TokenBaseKind_StatementClose && token->sub_kind != TokenCppKind_Colon))
    {
     break;
    }
    else if(token->kind == TokenBaseKind_Identifier ||
      token->kind == TokenBaseKind_Keyword ||
      token->kind == TokenBaseKind_Comment ||
      token->kind == byp_TokenKind_ControlFlow)
    {
     start_token = token;
     break;
    }
   }

   if(!token_it_dec_non_whitespace(&it)){ break; }
  }

  if(start_token){
   start_line_num = get_line_number_from_pos(app, buffer, start_token->pos);
   String_Const_u8 start_line_text = push_buffer_line(app, scratch, buffer, start_line_num);

   u64 whitespace_count = 0;
   for(i32 j=0; j<start_line_text.size; j++){
    if(start_line_text.str[j] > 32){ break; }
    ++whitespace_count;
   }
   start_line_text.str += whitespace_count;
   start_line_text.size -= whitespace_count;
   start_line_text.size -= (start_line_text.str[start_line_text.size - 1] == 13);

   i64 last_char = get_line_end_pos(app, buffer, end_line_num)-1;
   Rect_f32 last_char_rect = text_layout_character_on_screen(app, text_layout_id, last_char);
   Vec2_f32 string_pos = V2f32(last_char_rect.x1, last_char_rect.y0);
   string_pos += V2f32(2, 4);

   draw_string(app, byp_small_italic_face, start_line_text, string_pos, fcolor_id(defcolor_ghost_character));
  }
 }
}


static void
byp_render_buffer(Application_Links *app, View_ID view_id, Face_ID face_id, Buffer_ID buffer, Text_Layout_ID text_layout_id, Rect_f32 rect){
 Profile_Scope_Block profile_block_322 ((app), SCu8((u8*)("render buffer"), (u64)(sizeof("render buffer") - 1)), SCu8((u8*)("4coder_byp_draw.cpp" ":" "322" ":"), (u64)(sizeof("4coder_byp_draw.cpp" ":" "322" ":") - 1)));
 b32 is_active_view = view_id == get_active_view(app, Access_Always);
 Rect_f32 prev_clip = draw_set_clip(app, rect);

 Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

 Face_Metrics metrics = get_face_metrics(app, face_id);
 u64 cursor_roundness_100 = def_get_config_u64(app, vars_save_string(SCu8((u8*)("cursor_roundness"), (u64)(sizeof("cursor_roundness") - 1))));
 f32 cursor_roundness = metrics.normal_advance*cursor_roundness_100*0.01f;
 f32 mark_thickness = (f32)def_get_config_u64(app, vars_save_string(SCu8((u8*)("mark_thickness"), (u64)(sizeof("mark_thickness") - 1))));

 i64 cursor_pos = view_correct_cursor(app, view_id);
 view_correct_mark(app, view_id);

 b32 use_scope_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_scope_highlight"), (u64)(sizeof("use_scope_highlight") - 1))));
 if(use_scope_highlight){
  Color_Array colors = finalize_color_array(defcolor_back_cycle);
  draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
 }

 b32 highlight_line_at_cursor = def_get_config_b32(vars_save_string(SCu8((u8*)("highlight_line_at_cursor"), (u64)(sizeof("highlight_line_at_cursor") - 1))));
 if(highlight_line_at_cursor && is_active_view){
  i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
  draw_line_highlight(app, text_layout_id, line_number, fcolor_id(defcolor_highlight_cursor_line));
 }

 if(is_active_view && byp_col_cursor.pos > 0){
  byp_col_cursor = buffer_compute_cursor(app, buffer, seek_line_col(byp_col_cursor.line, byp_col_cursor.col));

  i64 rel_pos = cursor_pos;
  Rect_f32 rel_rect = text_layout_character_on_screen(app, text_layout_id, rel_pos);

  i64 line = get_line_number_from_pos(app, buffer, rel_pos);
  Vec2_f32 col_rel = view_relative_xy_of_pos(app, view_id, line, byp_col_cursor.pos);
  Vec2_f32 rel_point = view_relative_xy_of_pos(app, view_id, line, rel_pos);
  Rect_f32 col_highlight_rect = {};
  col_highlight_rect.p0 = (rel_rect.p0 - rel_point) + col_rel;
  col_highlight_rect.p1 = (rel_rect.p1 - rel_point) + col_rel;
  col_highlight_rect.y0 = rect.y0;
  col_highlight_rect.y1 = rect.y1;

  draw_rectangle_fcolor(app, col_highlight_rect, 0.f, fcolor_id(defcolor_highlight_cursor_line));
 }

 Token_Array token_array = get_token_array_from_buffer(app, buffer);
 if(token_array.tokens == 0){
  paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
 }else{
  byp_draw_token_colors(app, view_id, buffer, text_layout_id);
 }

 b32 use_error_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_error_highlight"), (u64)(sizeof("use_error_highlight") - 1))));
 b32 use_jump_highlight = def_get_config_b32(vars_save_string(SCu8((u8*)("use_jump_highlight"), (u64)(sizeof("use_jump_highlight") - 1))));
 if(use_error_highlight || use_jump_highlight){
  Buffer_ID comp_buffer = get_buffer_by_name(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)), Access_Always);
  if(use_error_highlight){
   draw_jump_highlights(app, buffer, text_layout_id, comp_buffer, fcolor_id(defcolor_highlight_junk));

  }

  if(use_jump_highlight){
   Buffer_ID jump_buffer = get_locked_jump_buffer(app);
   if(jump_buffer != comp_buffer){
    draw_jump_highlights(app, buffer, text_layout_id, jump_buffer, fcolor_id(defcolor_highlight_white));
   }
  }
 }

 b32 use_paren_helper = def_get_config_b32(vars_save_string(SCu8((u8*)("use_paren_helper"), (u64)(sizeof("use_paren_helper") - 1))));
 if(use_paren_helper){
  Color_Array colors = finalize_color_array(defcolor_text_cycle);
  draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
 }

 byp_draw_scope_brackets(app, view_id, buffer, text_layout_id, rect, cursor_pos);

 b64 show_whitespace = false;
 view_get_setting(app, view_id, ViewSetting_ShowWhitespace, &show_whitespace);
 if(show_whitespace){
  if(token_array.tokens == 0){
   draw_whitespace_highlight(app, buffer, text_layout_id, cursor_roundness);
  }else{
   draw_whitespace_highlight(app, text_layout_id, &token_array, cursor_roundness);
  }
 }

 if(byp_show_hex_colors){
  byp_hex_color_preview(app, buffer, text_layout_id);
 }

 if(is_active_view && vim_state.mode == VIM_Visual){
  vim_draw_visual_mode(app, view_id, buffer, face_id, text_layout_id);
 }

 fold_draw(app, buffer, text_layout_id);

 vim_draw_search_highlight(app, view_id, buffer, text_layout_id, cursor_roundness);

 switch(fcoder_mode){
  case FCoderMode_Original:
  vim_draw_cursor(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness); break;
  case FCoderMode_NotepadLike:
  draw_notepad_style_cursor_highlight(app, view_id, buffer, text_layout_id, cursor_roundness); break;
 }


 paint_fade_ranges(app, text_layout_id, buffer);
 draw_text_layout_default(app, text_layout_id);

 vim_draw_after_text(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness);
 if(is_active_view){
  byp_draw_function_preview(app, buffer, If32(rect.x0, rect.x1), cursor_pos);
 }

 draw_set_clip(app, prev_clip);
}
# 484 "4coder_fleury.cpp" 2
# 1 "4coder_byp_game.cpp" 1

struct Game_State{
   b32 buttonA;
   b32 buttonD;
   b32 buttonSpace;
   i32 Frame;
   Vec2_f32 Pos;
   Vec2_f32 Dim;
   Vec2_f32 b_p;
   Vec2_f32 b_v;
   Vec2_f32 trail[10];
   i32 trail_index;
   void render_game_byp(Application_Links*, Frame_Info, Face_ID);
   void bounce_rect(f32 r, f32 step, Rect_f32 rect);
};

static b32 byp_game_is_running;
static Game_State byp_game_state;

static f32 bounce_angle_out(){ return pi_f32*0.8f*(pcg_rand() / f32(max_u32)) + pi_f32*0.1f; }
static Vec2_f32 bounce_u(){ f32 a = bounce_angle_out(); return {cosf(a), -sinf(a)}; }
static Vec2_f32 bounce_d(){ f32 a = bounce_angle_out(); return {cosf(a), sinf(a)}; }
static Vec2_f32 bounce_l(){ f32 a = bounce_angle_out(); return {-sinf(a), cosf(a)}; }
static Vec2_f32 bounce_r(){ f32 a = bounce_angle_out(); return { sinf(a), cosf(a)}; }


static void normalize(Vec2_f32 &v){
 if(v.x != 0.f && v.y != 0.f){ v *= 1.f/sqrtf(v.x*v.x + v.y*v.y); }
}

void Game_State::bounce_rect(f32 r, f32 step, Rect_f32 rect){
 rect = rect_inner(rect, -r);
 Vec2_f32 new_p = b_p;
 new_p.x += b_v.x*step;
 if(rect_contains_point(rect, new_p)){
  b_v.x *= -1.0f;

 }
 new_p = b_p;
 new_p.y += b_v.y*step;
 if(rect_contains_point(rect, new_p)){
  b_v.y *= -1.0f;

  if(buttonA){ b_v.x = -fabsf(b_v.x); }
  if(buttonD){ b_v.x = fabsf(b_v.x); }
 }

}

void Game_State::render_game_byp(Application_Links *app, Frame_Info frame_info, Face_ID face_id){
 Rect_f32 global_rect = global_get_screen_rectangle(app);
 Rect_f32 prev_rect = draw_set_clip(app, global_rect);
 f32 max_x = global_rect.x1;
 f32 max_y = global_rect.y1;

 f32 delta = frame_info.animation_dt;

 if(buttonA){ Pos.x -= delta*625.0f; }
 if(buttonD){ Pos.x += delta*625.0f; }
 Pos.x = (((global_rect.x0)>(Pos.x))?(global_rect.x0):(((global_rect.x1-Dim.x)<(Pos.x))?(global_rect.x1-Dim.x):(Pos.x)));

 f32 b_r = 20.0f;
 f32 scale = delta*880.0f;
 Vec2_f32 new_p = b_p + scale*b_v;
# 75 "4coder_byp_game.cpp"
 if(new_p.x - b_r < 0.0f){ b_v = (b_v.x*=-1.0f, lerp(b_v, 0.3f, bounce_r())); }
 else if(new_p.x + b_r > max_x){ b_v = (b_v.x*=-1.0f, lerp(b_v, 0.3f, bounce_l())); }
 if(new_p.y - b_r < 0.0f){ b_v = (b_v.y*=-1.0f, lerp(b_v, 0.3f, bounce_d())); }
 else if(new_p.y + b_r > max_y){ byp_game_is_running=false; }



 bounce_rect(b_r, scale, Rf32_xy_wh(Pos, Dim));




 normalize(b_v);

 b_p = b_p + scale*b_v;

 const i32 count = ((sizeof(trail))/(sizeof(*trail)));
 for(i32 i=0; i<count; i++){
  i32 index = trail_index-i + count;
  f32 percent = (index/f32(trail_index+count));
  FColor color = fcolor_change_alpha(f_white, 0.5f*percent);
  draw_circle_fcolor(app, trail[index%count], b_r*(percent*percent), color);
 }

 draw_rectangle(app, Rf32_xy_wh(Pos+V2f32(5.0f, 5.0f), Dim), 0.f, 0xAA000000);
 draw_rectangle_fcolor(app, Rf32_xy_wh(Pos, Dim), 0.f, f_red);
 if(buttonSpace){
  draw_circle_fcolor(app, b_p, b_r, f_blue);
 }else{
  draw_circle_gradient(app, b_p, b_r, fcolor_resolve(f_pink), 0xFF8E2DE2);
 }


 trail_index = (trail_index+1) % count;
 trail[trail_index] = b_p;

 draw_set_clip(app, prev_rect);
}


CUSTOM_COMMAND(byp_start_game_loop, "4coder_byp_game.cpp", 115, Normal)
CUSTOM_DOC("Starts game loop")
{
 View_ID view = get_this_ctx_view(app, Access_Always);
 View_Context ctx = view_current_context(app, view);
 ctx.hides_buffer = true;
 View_Context_Block ctx_block(app, view, &ctx);


 Rect_f32 global_rect = global_get_screen_rectangle(app);

 byp_game_is_running = 1;
 byp_game_state = {};
 byp_game_state.b_p = {rect_center(global_rect).x, global_rect.y0+20.0f};
 byp_game_state.b_v = bounce_d();
 byp_game_state.Dim = {400.0f, 30.0f};
 byp_game_state.Pos.x = byp_game_state.b_p.x;
 byp_game_state.Pos.y = global_rect.y1 -= 90.0f;

 for(i32 i=0; i<((sizeof(byp_game_state.trail))/(sizeof(*byp_game_state.trail))); i++){
  byp_game_state.trail[i] = byp_game_state.b_p;
 }

 while(byp_game_is_running){
  byp_game_state.Frame++;
  animate_in_n_milliseconds(app, 0);

  User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
  if(in.abort){ break; }

  switch(in.event.kind){
   case InputEventKind_KeyRelease:
   case InputEventKind_KeyStroke:{
    b32 IsDown = in.event.kind == InputEventKind_KeyStroke;
    switch(in.event.key.code){
     case KeyCode_A:{ byp_game_state.buttonA = IsDown; } break;
     case KeyCode_D:{ byp_game_state.buttonD = IsDown; } break;
     case KeyCode_Space:{ byp_game_state.buttonSpace = IsDown; } break;
    } break;
   }

   default:{}
  }
 }
 byp_game_is_running = 0;
 vim_reset_bottom_text();
}
# 485 "4coder_fleury.cpp" 2

# 1 "4coder_byp_bindings.cpp" 1

static void
byp_essential_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
 Mapping *m = 0; Command_Map *map = 0;
 m = (mapping);

 map = mapping_get_or_make_map(m, (global_id));
 map_set_binding_l(m, map, byp_startup, InputEventKind_Core, (CoreCode_Startup), 0);
 map_set_binding_l(m, map, vim_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
 map_set_binding_l(m, map, clipboard_record_clip, InputEventKind_Core, (CoreCode_NewClipboardContents), 0);
 map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
 map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);


 map = mapping_get_or_make_map(m, (file_id));
 map_set_parent(m, map, (global_id));
 map_set_binding_text_input(map, byp_write_text_input);
 map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
 map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
 map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
 map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

 map = mapping_get_or_make_map(m, (code_id));
 map_set_parent(m, map, (file_id));
}

static void
byp_vim_bindings(Application_Links *app){





 u32 Ctl = KeyMod_Ctl;
 u32 Sft = KeyMod_Sft;
 u32 Alt = KeyMod_Alt;

 VimBind(bit_1|0, redo, (Ctl|KeyCode_Y));
 VimBind(bit_1|0, redo, (Ctl|Sft|KeyCode_Z));
 VimBind(bit_1|0, save, (Ctl|KeyCode_S));
 VimBind(bit_1|0, vim_line_start, (Sft|KeyCode_0));
 VimBind(bit_1|0, byp_space, KeyCode_Space);
 VimBind(bit_1|0, move_line_up, (Alt|KeyCode_K));
 VimBind(bit_1|0, move_line_down, (Alt|KeyCode_J));
 VimBind(bit_1|0, change_active_panel_backwards, (Ctl|KeyCode_H));
 VimBind(bit_1|0, change_active_panel, (Ctl|KeyCode_L));
 VimBind(bit_1|0, goto_next_jump, (Alt|KeyCode_N));
 VimBind(bit_1|0, goto_prev_jump, (Alt|Sft|KeyCode_N));
 VimBind(bit_1|0, vim_switch_lister, (Ctl|Sft|KeyCode_I));

 VimBind(bit_1|bit_3|0, vim_bounce, (Ctl|KeyCode_5));
 VimBind(bit_1|bit_3|0, byp_open_current_peek, (Alt|KeyCode_Return));

 VimBind(bit_1|bit_3|0, byp_request_title, SUB_Leader, (Sft|KeyCode_U));
 VimBind(bit_1|0, byp_request_comment, SUB_G, KeyCode_ForwardSlash);
 VimBind(bit_1|0, byp_request_uncomment, SUB_G, (Sft|KeyCode_ForwardSlash));
 VimBind(bit_3|0, byp_visual_comment, KeyCode_ForwardSlash);
 VimBind(bit_3|0, byp_visual_uncomment, (Sft|KeyCode_ForwardSlash));

 VimBind(bit_1|bit_3|0, vim_leader_d, SUB_Leader, KeyCode_D);
 VimBind(bit_1|bit_3|0, vim_leader_c, SUB_Leader, KeyCode_C);
 VimBind(bit_1|bit_3|0, vim_leader_D, SUB_Leader, (Sft|KeyCode_D));
 VimBind(bit_1|bit_3|0, vim_leader_C, SUB_Leader, (Sft|KeyCode_C));

 VimBind(bit_2|0, byp_auto_complete_bracket, KeyCode_Return);
 VimBind(bit_2|0, byp_auto_complete_bracket, (Sft|KeyCode_Return));
 VimBind(bit_1|0, goto_jump_at_cursor, KeyCode_Return);
 VimBind(bit_1|0, goto_jump_at_cursor_same_panel, (Sft|KeyCode_Return));
 VimBind(bit_3|0, byp_list_all_locations_selection, (Ctl|Sft|KeyCode_F));
 VimBind(bit_1|0, list_all_locations_of_identifier, (Ctl|Sft|KeyCode_F));





}


static void
byp_default_bindings(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
 Mapping *m = 0; Command_Map *map = 0;
 m = (mapping);

 map = mapping_get_or_make_map(m, (global_id));

 map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
 map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, byp_build_project, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);
 map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
 map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
 map_set_binding_l(m, map, quick_swap_buffer, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Alt, 0);
 map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);

 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
 map_set_binding_l(m, map, byp_project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
 map_set_binding_l(m, map, toggle_fullscreen, InputEventKind_KeyStroke, (KeyCode_F11), 0);

 map_set_binding_l(m, map, vim_interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
 map_set_binding_l(m, map, byp_test, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Control, 0);
 map_set_binding_l(m, map, increase_face_size, InputEventKind_KeyStroke, (KeyCode_Equal), KeyCode_Control, 0);
 map_set_binding_l(m, map, decrease_face_size, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Control, 0);
 map_set_binding_l(m, map, byp_reset_face_size, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);
 map_set_binding_l(m, map, vim_proj_cmd_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
 map_set_binding_l(m, map, byp_toggle_set_col_ruler, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Control, KeyCode_Shift, 0);


 map = mapping_get_or_make_map(m, (file_id));
 map_set_parent(m, map, (global_id));

 map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
 map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
 map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
 map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
 map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
 map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
 map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
 map_set_binding_l(m, map, right_adjust_view, InputEventKind_KeyStroke, (KeyCode_Home), 0);
 map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
 map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
 map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
 map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
 map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
 map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
 map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
 map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
 map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
 map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Alt, 0);
 map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, snippet_lister, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Control, 0);
 map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Control, 0);
 map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
 map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
 map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Alt, 0);
 map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, 0);
 map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
 map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
 map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
 map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
 map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
 map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
 map_set_binding_l(m, map, goto_jump_at_cursor, InputEventKind_KeyStroke, (KeyCode_Return), 0);
 map_set_binding_l(m, map, goto_jump_at_cursor_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
 map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);

 map = mapping_get_or_make_map(m, (code_id));
 map_set_parent(m, map, (file_id));

 map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
 map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
 map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
 map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);
}
# 487 "4coder_fleury.cpp" 2
# 1 "4coder_byp_hooks.cpp" 1

CUSTOM_COMMAND(byp_startup, "4coder_byp_hooks.cpp", 2, Normal)
CUSTOM_DOC("Responding to a startup event")
{
 Profile_Scope_Block profile_block_5 ((app), SCu8((u8*)("byp startup"), (u64)(sizeof("byp startup") - 1)), SCu8((u8*)("4coder_byp_hooks.cpp" ":" "5" ":"), (u64)(sizeof("4coder_byp_hooks.cpp" ":" "5" ":") - 1)));
 User_Input input = get_current_input(app);
 if(match_core_code(&input, CoreCode_Startup)){
  String_Const_u8_Array file_names = input.event.core.file_names;
  load_themes_default_folder(app);
  default_4coder_initialize(app, file_names);







  Buffer_Identifier left = buffer_identifier(SCu8((u8*)("*scratch*"), (u64)(sizeof("*scratch*") - 1)));
  if(file_names.count > 0){
   left = buffer_identifier(file_names.vals[0]);
  }
  Buffer_ID left_id = buffer_identifier_to_id(app, left);


  View_ID view = get_active_view(app, Access_Always);
  new_view_settings(app, view);


  View_ID left_view = get_active_view(app, Access_Always);
  view_set_buffer(app, view, left_id, 0);


  view_set_active(app, left_view);
  vim_set_file_register(app, left_id);


  View_Context ctx = view_current_context(app, build_footer_panel_view_id);
  view_set_split_pixel_size(app, build_footer_panel_view_id, 0);
  ctx.render_caller = 0;
  view_alter_context(app, build_footer_panel_view_id, &ctx);

  if(def_get_config_b32(vars_save_string(SCu8((u8*)("automatically_load_project"), (u64)(sizeof("automatically_load_project") - 1))))){
   load_project(app);
  }

 }

 def_audio_init();

 def_enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));



 Face_Description desc = get_global_face_description(app);
 desc.parameters.pt_size -= 2;
 desc.parameters.bold = 1;
 desc.parameters.italic = 1;
 desc.parameters.hinting = 0;
 byp_small_italic_face = try_create_new_face(app, &desc);

 desc.parameters.pt_size = 0;
 desc.parameters.bold = 0;
 byp_minimal_face = try_create_new_face(app, &desc);

 system_set_fullscreen(false);
 set_window_title(app, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)));

 byp_relative_numbers = 1;
 byp_show_hex_colors = 1;
 byp_show_scrollbars = 0;

 {
  Arena *arena = &global_theme_arena;
  default_color_table.arrays[defcolor_function] = make_colors(arena, 0xFF0030B0);
  default_color_table.arrays[defcolor_type] = make_colors(arena, 0xFFA00000);
  default_color_table.arrays[defcolor_macro] = make_colors(arena, 0xFF579EA8);
  default_color_table.arrays[defcolor_control] = make_colors(arena, 0xFF00A000);
  default_color_table.arrays[defcolor_control] = default_color_table.arrays[defcolor_keyword];
  default_color_table.arrays[defcolor_non_text] = default_color_table.arrays[defcolor_text_default];
 }
 Color_Table *table = get_color_table_by_name(SCu8((u8*)("theme-byp"), (u64)(sizeof("theme-byp") - 1)));
 if(table == 0){ table = &default_color_table; }
 target_color_table = byp_init_color_table(app);
 cached_color_table = byp_init_color_table(app);
 byp_copy_color_table(&target_color_table, *table);
 byp_copy_color_table(&cached_color_table, *table);
 active_color_table = cached_color_table;
}

static void
byp_tick(Application_Links *app, Frame_Info frame_info){
 code_index_update_tick(app);
 if(tick_all_fade_ranges(app, frame_info.animation_dt)){
  animate_in_n_milliseconds(app, 0);
 }

 vim_animate_filebar(app, frame_info);
 vim_animate_cursor(app, frame_info);
 fold_tick(app, frame_info);
 byp_tick_colors(app, frame_info);

 vim_cursor_blink++;

 b32 enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
 if(enable_virtual_whitespace != def_enable_virtual_whitespace){
  def_enable_virtual_whitespace = enable_virtual_whitespace;
  clear_all_layouts(app);
 }
}


static void
byp_render_caller(Application_Links *app, Frame_Info frame_info, View_ID view_id){
 Profile_Scope_Block profile_block_114 ((app), SCu8((u8*)("default render caller"), (u64)(sizeof("default render caller") - 1)), SCu8((u8*)("4coder_byp_hooks.cpp" ":" "114" ":"), (u64)(sizeof("4coder_byp_hooks.cpp" ":" "114" ":") - 1)));

 Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);

 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics face_metrics = get_face_metrics(app, face_id);
 f32 line_height = face_metrics.line_height;
 f32 digit_advance = face_metrics.decimal_digit_advance;

 Rect_f32 region = view_get_screen_rect(app, view_id);
 Rect_f32 prev_clip = draw_set_clip(app, region);

 Rect_f32 global_rect = global_get_screen_rectangle(app);
 f32 filebar_y = global_rect.y1 - 2.f*line_height - vim_cur_filebar_offset;
 if(region.y1 >= filebar_y){ region.y1 = filebar_y; }

 draw_rectangle_fcolor(app, region, 0.f, fcolor_id(defcolor_back));

 region = vim_draw_query_bars(app, region, view_id, face_id);

 {
  Rect_f32_Pair pair = layout_file_bar_on_bot(region, line_height);
  pair.b = rect_split_top_bottom(pair.b, line_height).a;
  vim_draw_filebar(app, view_id, buffer, frame_info, face_id, pair.b);
  region = pair.a;
 }

 Rect_f32_Pair scrollbar_pair = byp_layout_scrollbars(region, digit_advance);
 i64 show_scrollbar = false;
 view_get_setting(app, view_id, ViewSetting_ShowScrollbar, &show_scrollbar);
 show_scrollbar &= byp_show_scrollbars;
 if(show_scrollbar){
  region = scrollbar_pair.a;
 }
 draw_set_clip(app, region);


 if(region.x0 > global_rect.x0){
  Rect_f32_Pair border_pair = rect_split_left_right(region, 2.f);
  draw_rectangle_fcolor(app, border_pair.a, 0.f, fcolor_id(defcolor_margin));
  region = border_pair.b;
 }
 if(region.x1 < global_rect.x1){
  Rect_f32_Pair border_pair = rect_split_left_right_neg(region, 2.f);
  draw_rectangle_fcolor(app, border_pair.b, 0.f, fcolor_id(defcolor_margin));
  region = border_pair.a;
 }
 region.y0 += 3.f;


 if(show_fps_hud){
  Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
  draw_fps_hud(app, frame_info, face_id, pair.max);
  region = pair.min;
  animate_in_n_milliseconds(app, 1000);
 }


 b32 show_line_number_margins = def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1))));
 Rect_f32_Pair pair = (show_line_number_margins ?
        (byp_relative_numbers ?
         vim_line_number_margin(app, buffer, region, digit_advance) :
         layout_line_number_margin(app, buffer, region, digit_advance)) :
        rect_split_left_right(region, 1.5f*digit_advance));
 Rect_f32 line_number_rect = pair.min;
 region = pair.max;

 Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);
 Buffer_Point_Delta_Result delta = delta_apply(app, view_id, frame_info.animation_dt, scroll);
 if(!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position)))){
  block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
  view_set_buffer_scroll(app, view_id, scroll, SetBufferScroll_NoCursorChange);
 }
 if(delta.still_animating){ animate_in_n_milliseconds(app, 0); }
 Buffer_Point buffer_point = scroll.position;
 Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);

 if(show_line_number_margins){
  if(byp_relative_numbers)
   vim_draw_rel_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
  else
   vim_draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
 }else{
  draw_rectangle_fcolor(app, line_number_rect, 0.f, fcolor_id(defcolor_back));
 }

 if(show_scrollbar){
  byp_draw_scrollbars(app, view_id, buffer, text_layout_id, scrollbar_pair.b);
 }

 if(byp_drop_shadow){
  Buffer_Point shadow_point = buffer_point;
  Face_Description desc = get_face_description(app, face_id);
  shadow_point.pixel_shift -= ((((f32(desc.parameters.pt_size) / 8))>(1.f))?((f32(desc.parameters.pt_size) / 8)):(1.f))*V2f32(1.f, 1.f);
  Text_Layout_ID shadow_layout_id = text_layout_create(app, buffer, region, shadow_point);
  paint_text_color(app, shadow_layout_id, text_layout_get_visible_range(app, text_layout_id), 0xBB000000);
  draw_text_layout_default(app, shadow_layout_id);
  text_layout_free(app, shadow_layout_id);
 }

 byp_render_buffer(app, view_id, face_id, buffer, text_layout_id, region);


 if(false){
  Buffer_Point point = {};
  Rect_f32 prev_region = rect_split_left_right_neg(region, 190.f).b;
  prev_region.x1 -= 10.f;
  Face_ID prev_face = get_face_id(app, buffer);
  buffer_set_face(app, buffer, byp_minimal_face);
  Text_Layout_ID layout_id = text_layout_create(app, buffer, prev_region, point);

  draw_rectangle(app, rect_inner(prev_region, -10.f), 5.f, 0x44000000);

  i32 prev_mode = fcoder_mode;
  fcoder_mode = 20;
  byp_render_buffer(app, view_id, byp_minimal_face, buffer, layout_id, prev_region);
  fcoder_mode = prev_mode;

  buffer_set_face(app, buffer, prev_face);
  text_layout_free(app, layout_id);
 }


 text_layout_free(app, text_layout_id);
 draw_set_clip(app, prev_clip);
}

static Rect_f32
byp_buffer_region(Application_Links *app, View_ID view_id, Rect_f32 region){

 Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
 Face_ID face_id = get_face_id(app, 0);
 Face_Metrics metrics = get_face_metrics(app, face_id);
 f32 line_height = metrics.line_height;
 f32 digit_advance = metrics.decimal_digit_advance;

 Rect_f32 global_rect = global_get_screen_rectangle(app);
 f32 filebar_y = global_rect.y1 - 2.f*line_height - vim_cur_filebar_offset;
 if(region.y1 >= filebar_y){
  region.y1 = filebar_y;
 }

 Query_Bar *space[32];
 Query_Bar_Ptr_Array query_bars = {};
 query_bars.ptrs = space;
 if(get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
  region = layout_query_bar_on_bot(region, line_height, query_bars.count).min;
 }

 region = layout_file_bar_on_bot(region, line_height).min;

 i64 show_scrollbar = false;
 view_get_setting(app, view_id, ViewSetting_ShowScrollbar, &show_scrollbar);
 if(byp_show_scrollbars && show_scrollbar){
  region = byp_layout_scrollbars(region, digit_advance).a;
 }

 if(region.x0 > global_rect.x0){
  region = rect_split_left_right(region, 2.f).b;
 }
 if(region.x1 < global_rect.x1){
  region = rect_split_left_right_neg(region, 2.f).a;
 }
 region.y0 += 3.f;

 if(show_fps_hud){
  region = layout_fps_hud_on_bottom(region, line_height).min;
 }

 b32 show_line_number_margins = def_get_config_b32(vars_save_string(SCu8((u8*)("show_line_number_margins"), (u64)(sizeof("show_line_number_margins") - 1))));
 region = (show_line_number_margins ?
     (byp_relative_numbers ?
      vim_line_number_margin(app, buffer, region, digit_advance) :
      layout_line_number_margin(app, buffer, region, digit_advance)) :
     rect_split_left_right(region, 1.5f*digit_advance)).max;

 return region;
}

static void
byp_whole_screen_render_caller(Application_Links *app, Frame_Info frame_info){
 vim_draw_whole_screen(app, frame_info);
 if(byp_game_is_running){ byp_game_state.render_game_byp(app, frame_info, get_face_id(app, 0)); }
}

i32 byp_file_save(Application_Links *app, Buffer_ID buffer_id){
 default_file_save(app, buffer_id);
 vim_file_save(app, buffer_id);
 auto_indent_buffer(app, buffer_id, buffer_range(app, buffer_id));
 clean_all_lines_buffer(app, buffer_id, CleanAllLinesMode_RemoveBlankLines);

 Scratch_Block scratch(app);
 String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer_id);
 String_Const_u8 postfix = SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1));

 if(string_match(string_postfix(unique_name, postfix.size), postfix)){
  String_Const_u8 theme_name = string_chop(unique_name, postfix.size);
  for(Color_Table_Node *node = global_theme_list.first; node; node=node->next){
   if(string_match(node->name, theme_name)){
    Color_Table color_table = make_color_table(app, scratch);
    Config *config = theme_parse__buffer(app, scratch, buffer_id, scratch, &color_table);
    String_Const_u8 error_text = config_stringize_errors(app, scratch, config);
    print_message(app, error_text);

    u64 problem_score = 0;
    if(color_table.count < defcolor_line_numbers_text){
     problem_score = defcolor_line_numbers_text - color_table.count;
    }
    for(i32 i=0; i<color_table.count; i++){
     problem_score += (color_table.arrays[i].count == 0);
    }

    if(0 < error_text.size || 10 <= problem_score){
     String_Const_u8 string = push_u8_stringf(scratch, "There appears to be a problem parsing %.*s; no theme change applied\n", (i32)(theme_name).size, (char*)(theme_name).str);
     print_message(app, string);
    }else{
     print_message(app, SCu8((u8*)("Copied color theme\n"), (u64)(sizeof("Copied color theme\n") - 1)));
     byp_copy_color_table(&node->table, color_table);
     byp_copy_color_table(&target_color_table, color_table);
    }

    break;
   }
  }
 }
 return 0;
}

i32 byp_new_file(Application_Links *app, Buffer_ID buffer_id){
 Scratch_Block scratch(app);
 String_Const_u8 file_name = push_buffer_base_name(app, scratch, buffer_id);
 if(string_match(string_postfix(file_name, 4), SCu8((u8*)(".bat"), (u64)(sizeof(".bat") - 1)))){
  Buffer_Insertion insert = begin_buffer_insertion_at_buffered(app, buffer_id, 0, scratch, ((16) << 10));
  insertf(&insert, "@echo off" "\n");
  end_buffer_insertion(&insert);
  return 0;
 }

 return 0;
}
# 488 "4coder_fleury.cpp" 2



void custom_layer_init(Application_Links *app)
{
    default_framework_init(app);
    global_frame_arena = make_arena(get_base_allocator_system());
    permanent_arena = make_arena(get_base_allocator_system());


    {
        set_all_default_hooks(app);

        set_custom_hook((app),(HookID_Tick),(Void_Func*)(F4_Tick));
        set_custom_hook((app),(HookID_RenderCaller),(Void_Func*)(F4_Render));
        set_custom_hook((app),(HookID_BeginBuffer),(Void_Func*)(F4_BeginBuffer));
        set_custom_hook((app),(HookID_Layout),(Void_Func*)(F4_Layout));
        set_custom_hook((app),(HookID_WholeScreenRenderCaller),(Void_Func*)(F4_WholeScreenRender));
        set_custom_hook((app),(HookID_DeltaRule),(Void_Func*)(F4_DeltaRule));
        set_custom_hook((app),(HookID_BufferEditRange),(Void_Func*)(F4_BufferEditRange));
        set_custom_hook_memory_size(app, HookID_DeltaRule, delta_ctx_size(sizeof(Vec2_f32)));

     vim_buffer_peek_list[((sizeof(vim_default_peek_list))/(sizeof(*vim_default_peek_list))) + 0] = BYP_peek_list[0];
  vim_buffer_peek_list[((sizeof(vim_default_peek_list))/(sizeof(*vim_default_peek_list))) + 1] = BYP_peek_list[1];
  vim_request_vtable[VIM_REQUEST_COUNT + BYP_REQUEST_Title] = byp_apply_title;
  vim_request_vtable[VIM_REQUEST_COUNT + BYP_REQUEST_Comment] = byp_apply_comment;
  vim_request_vtable[VIM_REQUEST_COUNT + BYP_REQUEST_UnComment] = byp_apply_uncomment;

  vim_text_object_vtable[VIM_TEXT_OBJECT_COUNT + BYP_OBJECT_param0] = {',', (Vim_Text_Object_Func *)byp_object_param};
  vim_text_object_vtable[VIM_TEXT_OBJECT_COUNT + BYP_OBJECT_param1] = {';', (Vim_Text_Object_Func *)byp_object_param};
  vim_text_object_vtable[VIM_TEXT_OBJECT_COUNT + BYP_OBJECT_camel0] = {'_', (Vim_Text_Object_Func *)byp_object_camel};
  vim_text_object_vtable[VIM_TEXT_OBJECT_COUNT + BYP_OBJECT_camel1] = {'-', (Vim_Text_Object_Func *)byp_object_camel};
  vim_init(app);
 }


    {
        Thread_Context *tctx = get_thread_context(app);
        mapping_init(tctx, &framework_mapping);
        String_Const_u8 bindings_file = SCu8((u8*)("bindings.4coder"), (u64)(sizeof("bindings.4coder") - 1));
        F4_SetAbsolutelyNecessaryBindings(&framework_mapping);
  byp_essential_mapping(&framework_mapping, global_map_id, file_map_id, code_map_id);
  byp_default_bindings(&framework_mapping, global_map_id, file_map_id, code_map_id);

  vim_default_bindings(app, KeyCode_BackwardSlash);
  byp_vim_bindings(app);
  if(!dynamic_binding_load_from_file(app, &framework_mapping, bindings_file))
        {
            F4_SetDefaultBindings(&framework_mapping);
        }

    }


    {
        F4_Index_Initialize();
    }


    {
        F4_RegisterLanguages();
    }
}







static b32
IsFileReadable(String_Const_u8 path)
{
    b32 result = 0;
    FILE *file = fopen((char *)path.str, "r");
    if(file)
    {
        result = 1;
        fclose(file);
    }
    return result;
}

CUSTOM_COMMAND(fleury_startup, "4coder_fleury.cpp", 571, Normal)
CUSTOM_DOC("Fleury startup event")
{
    Profile_Scope_Block profile_block_574 ((app), SCu8((u8*)("default startup"), (u64)(sizeof("default startup") - 1)), SCu8((u8*)("4coder_fleury.cpp" ":" "574" ":"), (u64)(sizeof("4coder_fleury.cpp" ":" "574" ":") - 1)));

    User_Input input = get_current_input(app);
    if(!match_core_code(&input, CoreCode_Startup))
    {
        return;
    }


    String_Const_u8_Array file_names = input.event.core.file_names;
    load_themes_default_folder(app);
    default_4coder_initialize(app, file_names);


    {

        {
            Buffer_ID buffer = create_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)),
                                             BufferCreate_NeverAttachToFile |
                                             BufferCreate_AlwaysNew);
            buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);
            buffer_set_setting(app, buffer, BufferSetting_ReadOnly, true);
        }


        {
            Buffer_ID buffer = create_buffer(app, SCu8((u8*)("*lego*"), (u64)(sizeof("*lego*") - 1)),
                                             BufferCreate_NeverAttachToFile |
                                             BufferCreate_AlwaysNew);
            buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);
            buffer_set_setting(app, buffer, BufferSetting_ReadOnly, true);
        }


        {
            Buffer_ID buffer = create_buffer(app, SCu8((u8*)("*calc*"), (u64)(sizeof("*calc*") - 1)),
                                             BufferCreate_NeverAttachToFile |
                                             BufferCreate_AlwaysNew);
            buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);
        }


        {
            Buffer_ID buffer = create_buffer(app, SCu8((u8*)("*peek*"), (u64)(sizeof("*peek*") - 1)),
                                             BufferCreate_NeverAttachToFile |
                                             BufferCreate_AlwaysNew);
            buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);
        }


        {
            Buffer_ID buffer = create_buffer(app, SCu8((u8*)("*loc*"), (u64)(sizeof("*loc*") - 1)),
                                             BufferCreate_NeverAttachToFile |
                                             BufferCreate_AlwaysNew);
            buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);
        }
    }


    {
        Buffer_Identifier comp = buffer_identifier(SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));
        Buffer_Identifier left = buffer_identifier(SCu8((u8*)("*calc*"), (u64)(sizeof("*calc*") - 1)));
        Buffer_Identifier right = buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1)));
        Buffer_ID comp_id = buffer_identifier_to_id(app, comp);
        Buffer_ID left_id = buffer_identifier_to_id(app, left);
        Buffer_ID right_id = buffer_identifier_to_id(app, right);


        View_ID view = get_active_view(app, Access_Always);
        new_view_settings(app, view);
        view_set_buffer(app, view, left_id, 0);


        View_ID compilation_view = 0;
        {
            compilation_view = open_view(app, view, ViewSplit_Bottom);
            new_view_settings(app, compilation_view);
            Buffer_ID buffer = view_get_buffer(app, compilation_view, Access_Always);
            Face_ID face_id = get_face_id(app, buffer);
            Face_Metrics metrics = get_face_metrics(app, face_id);
            view_set_split_pixel_size(app, compilation_view, (i32)(metrics.line_height*4.f));
            view_set_passive(app, compilation_view, true);
            global_compilation_view = compilation_view;
            view_set_buffer(app, compilation_view, comp_id, 0);
        }

        view_set_active(app, view);


        open_panel_vsplit(app);

        View_ID right_view = get_active_view(app, Access_Always);
        view_set_buffer(app, right_view, right_id, 0);


        view_set_active(app, view);
    }


    {
        b32 auto_load = def_get_config_b32(vars_save_string(SCu8((u8*)("automatically_load_project"), (u64)(sizeof("automatically_load_project") - 1))));
        if (auto_load)
        {
            load_project(app);
        }
    }


    {
        global_battery_saver = def_get_config_b32(vars_save_string(SCu8((u8*)("f4_battery_saver"), (u64)(sizeof("f4_battery_saver") - 1))));
    }


    {
        def_audio_init();
    }


    {
        Scratch_Block scratch(app);
        String_Const_u8 bin_path = system_get_path(scratch, SystemPath_Binary);


        Face_ID face_that_should_totally_be_there = get_face_id(app, 0);


        {
            Face_Description desc = {0};
            {
                desc.font.file_name = push_u8_stringf(scratch, "%.*sfonts/RobotoCondensed-Regular.ttf", (i32)(bin_path).size, (char*)(bin_path).str);
                desc.parameters.pt_size = 18;
                desc.parameters.bold = 0;
                desc.parameters.italic = 0;
                desc.parameters.hinting = 0;
            }

            if(IsFileReadable(desc.font.file_name))
            {
                global_styled_title_face = try_create_new_face(app, &desc);
            }
            else
            {
                global_styled_title_face = face_that_should_totally_be_there;
            }
        }


        {
            Face_Description desc = {0};
            {
                desc.font.file_name = push_u8_stringf(scratch, "%.*sfonts/RobotoCondensed-Regular.ttf", (i32)(bin_path).size, (char*)(bin_path).str);
                desc.parameters.pt_size = 10;
                desc.parameters.bold = 1;
                desc.parameters.italic = 1;
                desc.parameters.hinting = 0;
            }

            if(IsFileReadable(desc.font.file_name))
            {
                global_styled_label_face = try_create_new_face(app, &desc);
            }
            else
            {
                global_styled_label_face = face_that_should_totally_be_there;
            }
        }


        {
            Face_Description normal_code_desc = get_face_description(app, get_face_id(app, 0));

            Face_Description desc = {0};
            {
                desc.font.file_name = push_u8_stringf(scratch, "%.*sfonts/Inconsolata-Regular.ttf", (i32)(bin_path).size, (char*)(bin_path).str);
                desc.parameters.pt_size = normal_code_desc.parameters.pt_size - 1;
                desc.parameters.bold = 1;
                desc.parameters.italic = 1;
                desc.parameters.hinting = 0;
            }

            if(IsFileReadable(desc.font.file_name))
            {
                global_small_code_face = try_create_new_face(app, &desc);
            }
            else
            {
                global_small_code_face = face_that_should_totally_be_there;
            }
        }
    }


    {
        def_enable_virtual_whitespace = def_get_config_b32(vars_save_string(SCu8((u8*)("enable_virtual_whitespace"), (u64)(sizeof("enable_virtual_whitespace") - 1))));
        clear_all_layouts(app);
    }
}
